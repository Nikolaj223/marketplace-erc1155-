/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_pages-dir-browser_node_modules_metamask_sdk_dist_browser_es_metamask-sdk_js"],{

/***/ "(pages-dir-browser)/./emptyModule.js":
/*!************************!*\
  !*** ./emptyModule.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\nmodule.exports = {};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL2VtcHR5TW9kdWxlLmpzIiwibWFwcGluZ3MiOiI7QUFBQUEsT0FBT0MsT0FBTyxHQUFHLENBQUMiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxlbXB0eU1vZHVsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHt9OyAiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./emptyModule.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@metamask/sdk-analytics/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@metamask/sdk-analytics/dist/index.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/process/browser.js\");\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.ts\nvar index_exports = {};\n__export(index_exports, {\n  analytics: () => analytics\n});\nmodule.exports = __toCommonJS(index_exports);\n\n// src/analytics.ts\nvar import_openapi_fetch = __toESM(__webpack_require__(/*! openapi-fetch */ \"(pages-dir-browser)/./node_modules/openapi-fetch/dist/cjs/index.cjs\"));\n\n// src/sender.ts\nvar Sender = class {\n  constructor(options) {\n    this.batch = [];\n    this.maxTimeoutMs = 3e4;\n    this.timeoutId = null;\n    this.isSending = false;\n    this.batchSize = options.batchSize;\n    this.baseTimeoutMs = options.baseTimeoutMs;\n    this.currentTimeoutMs = options.baseTimeoutMs;\n    this.sendFn = options.sendFn;\n  }\n  enqueue(item) {\n    this.batch.push(item);\n    this.schedule();\n  }\n  schedule() {\n    if (this.batch.length > 0 && !this.timeoutId) {\n      this.timeoutId = setTimeout(() => {\n        this.timeoutId = null;\n        this.flush();\n      }, this.currentTimeoutMs);\n    }\n  }\n  async flush() {\n    if (this.isSending || this.batch.length === 0) {\n      return;\n    }\n    this.isSending = true;\n    const current = [...this.batch.slice(0, this.batchSize)];\n    this.batch = this.batch.slice(this.batchSize);\n    try {\n      await this.sendFn(current);\n      this.currentTimeoutMs = this.baseTimeoutMs;\n    } catch (error) {\n      console.error(\"Sender: Failed to send batch\", error);\n      this.batch = [...current, ...this.batch];\n      this.currentTimeoutMs = Math.min(\n        this.currentTimeoutMs * 2,\n        this.maxTimeoutMs\n      );\n    } finally {\n      this.isSending = false;\n      this.schedule();\n    }\n  }\n};\nvar sender_default = Sender;\n\n// src/analytics.ts\nvar Analytics = class {\n  constructor(baseUrl) {\n    this.enabled = false;\n    this.properties = {};\n    const client2 = (0, import_openapi_fetch.default)({ baseUrl });\n    const sendFn = async (batch) => {\n      const res = await client2.POST(\"/v1/events\", { body: batch });\n      if (res.response.status !== 200) {\n        throw new Error(res.error);\n      }\n    };\n    this.sender = new sender_default({ batchSize: 100, baseTimeoutMs: 200, sendFn });\n  }\n  enable() {\n    this.enabled = true;\n  }\n  setGlobalProperty(key, value) {\n    this.properties[key] = value;\n  }\n  track(name, properties) {\n    if (!this.enabled) {\n      return;\n    }\n    const event = {\n      name,\n      ...this.properties,\n      ...properties\n    };\n    this.sender.enqueue(event);\n  }\n};\nvar analytics_default = Analytics;\n\n// src/index.ts\nvar endpoint;\nvar _a;\nif (typeof process !== \"undefined\" && process.env) {\n  endpoint = (_a = process.env.METAMASK_ANALYTICS_ENDPOINT) != null ? _a : process.env.NEXT_PUBLIC_METAMASK_ANALYTICS_ENDPOINT;\n}\nvar METAMASK_ANALYTICS_ENDPOINT = endpoint != null ? endpoint : \"https://mm-sdk-analytics.api.cx.metamask.io/\";\nvar client = new analytics_default(METAMASK_ANALYTICS_ENDPOINT);\nvar analytics = client;\n// Annotate the CommonJS export names for ESM import in node:\n0 && (0);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc2RrLWFuYWx5dGljcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQSxtQ0FBbUMsbUJBQU8sQ0FBQywwRkFBZTs7QUFFMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsU0FBUztBQUNqRTtBQUNBLHFEQUFxRCxhQUFhO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDRDQUE0QztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTyxvQkFBb0IsT0FBTztBQUM3QyxtQkFBbUIsT0FBTyxpREFBaUQsT0FBTztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxDQUVMIiwic291cmNlcyI6WyJDOlxcc2hvcF9oYXJkaGF0XFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxAbWV0YW1hc2tcXHNkay1hbmFseXRpY3NcXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2dldFByb3RvT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL2luZGV4LnRzXG52YXIgaW5kZXhfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaW5kZXhfZXhwb3J0cywge1xuICBhbmFseXRpY3M6ICgpID0+IGFuYWx5dGljc1xufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhpbmRleF9leHBvcnRzKTtcblxuLy8gc3JjL2FuYWx5dGljcy50c1xudmFyIGltcG9ydF9vcGVuYXBpX2ZldGNoID0gX190b0VTTShyZXF1aXJlKFwib3BlbmFwaS1mZXRjaFwiKSk7XG5cbi8vIHNyYy9zZW5kZXIudHNcbnZhciBTZW5kZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLmJhdGNoID0gW107XG4gICAgdGhpcy5tYXhUaW1lb3V0TXMgPSAzZTQ7XG4gICAgdGhpcy50aW1lb3V0SWQgPSBudWxsO1xuICAgIHRoaXMuaXNTZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5iYXRjaFNpemUgPSBvcHRpb25zLmJhdGNoU2l6ZTtcbiAgICB0aGlzLmJhc2VUaW1lb3V0TXMgPSBvcHRpb25zLmJhc2VUaW1lb3V0TXM7XG4gICAgdGhpcy5jdXJyZW50VGltZW91dE1zID0gb3B0aW9ucy5iYXNlVGltZW91dE1zO1xuICAgIHRoaXMuc2VuZEZuID0gb3B0aW9ucy5zZW5kRm47XG4gIH1cbiAgZW5xdWV1ZShpdGVtKSB7XG4gICAgdGhpcy5iYXRjaC5wdXNoKGl0ZW0pO1xuICAgIHRoaXMuc2NoZWR1bGUoKTtcbiAgfVxuICBzY2hlZHVsZSgpIHtcbiAgICBpZiAodGhpcy5iYXRjaC5sZW5ndGggPiAwICYmICF0aGlzLnRpbWVvdXRJZCkge1xuICAgICAgdGhpcy50aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSBudWxsO1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICB9LCB0aGlzLmN1cnJlbnRUaW1lb3V0TXMpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmbHVzaCgpIHtcbiAgICBpZiAodGhpcy5pc1NlbmRpbmcgfHwgdGhpcy5iYXRjaC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5pc1NlbmRpbmcgPSB0cnVlO1xuICAgIGNvbnN0IGN1cnJlbnQgPSBbLi4udGhpcy5iYXRjaC5zbGljZSgwLCB0aGlzLmJhdGNoU2l6ZSldO1xuICAgIHRoaXMuYmF0Y2ggPSB0aGlzLmJhdGNoLnNsaWNlKHRoaXMuYmF0Y2hTaXplKTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5zZW5kRm4oY3VycmVudCk7XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lb3V0TXMgPSB0aGlzLmJhc2VUaW1lb3V0TXM7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJTZW5kZXI6IEZhaWxlZCB0byBzZW5kIGJhdGNoXCIsIGVycm9yKTtcbiAgICAgIHRoaXMuYmF0Y2ggPSBbLi4uY3VycmVudCwgLi4udGhpcy5iYXRjaF07XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lb3V0TXMgPSBNYXRoLm1pbihcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZW91dE1zICogMixcbiAgICAgICAgdGhpcy5tYXhUaW1lb3V0TXNcbiAgICAgICk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuaXNTZW5kaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnNjaGVkdWxlKCk7XG4gICAgfVxuICB9XG59O1xudmFyIHNlbmRlcl9kZWZhdWx0ID0gU2VuZGVyO1xuXG4vLyBzcmMvYW5hbHl0aWNzLnRzXG52YXIgQW5hbHl0aWNzID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihiYXNlVXJsKSB7XG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0ge307XG4gICAgY29uc3QgY2xpZW50MiA9ICgwLCBpbXBvcnRfb3BlbmFwaV9mZXRjaC5kZWZhdWx0KSh7IGJhc2VVcmwgfSk7XG4gICAgY29uc3Qgc2VuZEZuID0gYXN5bmMgKGJhdGNoKSA9PiB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBjbGllbnQyLlBPU1QoXCIvdjEvZXZlbnRzXCIsIHsgYm9keTogYmF0Y2ggfSk7XG4gICAgICBpZiAocmVzLnJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXMuZXJyb3IpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5zZW5kZXIgPSBuZXcgc2VuZGVyX2RlZmF1bHQoeyBiYXRjaFNpemU6IDEwMCwgYmFzZVRpbWVvdXRNczogMjAwLCBzZW5kRm4gfSk7XG4gIH1cbiAgZW5hYmxlKCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cbiAgc2V0R2xvYmFsUHJvcGVydHkoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMucHJvcGVydGllc1trZXldID0gdmFsdWU7XG4gIH1cbiAgdHJhY2sobmFtZSwgcHJvcGVydGllcykge1xuICAgIGlmICghdGhpcy5lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgbmFtZSxcbiAgICAgIC4uLnRoaXMucHJvcGVydGllcyxcbiAgICAgIC4uLnByb3BlcnRpZXNcbiAgICB9O1xuICAgIHRoaXMuc2VuZGVyLmVucXVldWUoZXZlbnQpO1xuICB9XG59O1xudmFyIGFuYWx5dGljc19kZWZhdWx0ID0gQW5hbHl0aWNzO1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBlbmRwb2ludDtcbnZhciBfYTtcbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudikge1xuICBlbmRwb2ludCA9IChfYSA9IHByb2Nlc3MuZW52Lk1FVEFNQVNLX0FOQUxZVElDU19FTkRQT0lOVCkgIT0gbnVsbCA/IF9hIDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTUVUQU1BU0tfQU5BTFlUSUNTX0VORFBPSU5UO1xufVxudmFyIE1FVEFNQVNLX0FOQUxZVElDU19FTkRQT0lOVCA9IGVuZHBvaW50ICE9IG51bGwgPyBlbmRwb2ludCA6IFwiaHR0cHM6Ly9tbS1zZGstYW5hbHl0aWNzLmFwaS5jeC5tZXRhbWFzay5pby9cIjtcbnZhciBjbGllbnQgPSBuZXcgYW5hbHl0aWNzX2RlZmF1bHQoTUVUQU1BU0tfQU5BTFlUSUNTX0VORFBPSU5UKTtcbnZhciBhbmFseXRpY3MgPSBjbGllbnQ7XG4vLyBBbm5vdGF0ZSB0aGUgQ29tbW9uSlMgZXhwb3J0IG5hbWVzIGZvciBFU00gaW1wb3J0IGluIG5vZGU6XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgYW5hbHl0aWNzXG59KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@metamask/sdk-analytics/dist/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@metamask/sdk/dist/browser/es/metamask-sdk.js":
/*!********************************************************************!*\
  !*** ./node_modules/@metamask/sdk/dist/browser/es/metamask-sdk.js ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommunicationLayerPreference: () => (/* binding */ jo),\n/* harmony export */   ConnectionStatus: () => (/* binding */ Eo),\n/* harmony export */   DEFAULT_SERVER_URL: () => (/* binding */ fo),\n/* harmony export */   EventType: () => (/* binding */ So),\n/* harmony export */   MessageType: () => (/* binding */ ko),\n/* harmony export */   MetaMaskSDK: () => (/* binding */ rf),\n/* harmony export */   MetaMaskSDKEvent: () => (/* binding */ zu),\n/* harmony export */   PROVIDER_UPDATE_TYPE: () => (/* binding */ hh),\n/* harmony export */   PlatformType: () => (/* binding */ Uo),\n/* harmony export */   SDKProvider: () => (/* binding */ Gu),\n/* harmony export */   \"default\": () => (/* binding */ rf)\n/* harmony export */ });\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cross-fetch */ \"(pages-dir-browser)/./node_modules/cross-fetch/dist/browser-ponyfill.js\");\n/* harmony import */ var cross_fetch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cross_fetch__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! debug */ \"(pages-dir-browser)/./node_modules/@metamask/sdk/node_modules/debug/src/browser.js\");\n/* harmony import */ var debug__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(debug__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @metamask/sdk-analytics */ \"(pages-dir-browser)/./node_modules/@metamask/sdk-analytics/dist/index.js\");\n/* harmony import */ var _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var eventemitter2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! eventemitter2 */ \"(pages-dir-browser)/./node_modules/eventemitter2/lib/eventemitter2.js\");\n/* harmony import */ var eventemitter2__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(eventemitter2__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! uuid */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/index.js\");\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! socket.io-client */ \"(pages-dir-browser)/./node_modules/socket.io-client/build/esm/index.js\");\n\n\n\n\n\n\nfunction c(e, t, n, r) {\n    return new (n || (n = Promise))(function(i, o) {\n        function s(e) {\n            try {\n                c(r.next(e));\n            } catch (e) {\n                o(e);\n            }\n        }\n        function a(e) {\n            try {\n                c(r.throw(e));\n            } catch (e) {\n                o(e);\n            }\n        }\n        function c(e) {\n            var t;\n            e.done ? i(e.value) : (t = e.value, t instanceof n ? t : new n(function(e) {\n                e(t);\n            })).then(s, a);\n        }\n        c((r = r.apply(e, t || [])).next());\n    });\n}\n\"function\" == typeof SuppressedError && SuppressedError;\nvar l = \"undefined\" != typeof __webpack_require__.g ? __webpack_require__.g : \"undefined\" != typeof self ? self :  true ? window : 0, d = [], u = [], h = \"undefined\" != typeof Uint8Array ? Uint8Array : Array, f = !1;\nfunction p() {\n    f = !0;\n    for(var e = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", t = 0; t < 64; ++t)d[t] = e[t], u[e.charCodeAt(t)] = t;\n    u[\"-\".charCodeAt(0)] = 62, u[\"_\".charCodeAt(0)] = 63;\n}\nfunction g(e, t, n) {\n    for(var r, i, o = [], s = t; s < n; s += 3)r = (e[s] << 16) + (e[s + 1] << 8) + e[s + 2], o.push(d[(i = r) >> 18 & 63] + d[i >> 12 & 63] + d[i >> 6 & 63] + d[63 & i]);\n    return o.join(\"\");\n}\nfunction m(e) {\n    var t;\n    f || p();\n    for(var n = e.length, r = n % 3, i = \"\", o = [], s = 16383, a = 0, c = n - r; a < c; a += s)o.push(g(e, a, a + s > c ? c : a + s));\n    return 1 === r ? (t = e[n - 1], i += d[t >> 2], i += d[t << 4 & 63], i += \"==\") : 2 === r && (t = (e[n - 2] << 8) + e[n - 1], i += d[t >> 10], i += d[t >> 4 & 63], i += d[t << 2 & 63], i += \"=\"), o.push(i), o.join(\"\");\n}\nfunction y(e, t, n, r, i) {\n    var o, s, a = 8 * i - r - 1, c = (1 << a) - 1, l = c >> 1, d = -7, u = n ? i - 1 : 0, h = n ? -1 : 1, f = e[t + u];\n    for(u += h, o = f & (1 << -d) - 1, f >>= -d, d += a; d > 0; o = 256 * o + e[t + u], u += h, d -= 8);\n    for(s = o & (1 << -d) - 1, o >>= -d, d += r; d > 0; s = 256 * s + e[t + u], u += h, d -= 8);\n    if (0 === o) o = 1 - l;\n    else {\n        if (o === c) return s ? NaN : 1 / 0 * (f ? -1 : 1);\n        s += Math.pow(2, r), o -= l;\n    }\n    return (f ? -1 : 1) * s * Math.pow(2, o - r);\n}\nfunction v(e, t, n, r, i, o) {\n    var s, a, c, l = 8 * o - i - 1, d = (1 << l) - 1, u = d >> 1, h = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = r ? 0 : o - 1, p = r ? 1 : -1, g = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;\n    for(t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (a = isNaN(t) ? 1 : 0, s = d) : (s = Math.floor(Math.log(t) / Math.LN2), t * (c = Math.pow(2, -s)) < 1 && (s--, c *= 2), (t += s + u >= 1 ? h / c : h * Math.pow(2, 1 - u)) * c >= 2 && (s++, c /= 2), s + u >= d ? (a = 0, s = d) : s + u >= 1 ? (a = (t * c - 1) * Math.pow(2, i), s += u) : (a = t * Math.pow(2, u - 1) * Math.pow(2, i), s = 0)); i >= 8; e[n + f] = 255 & a, f += p, a /= 256, i -= 8);\n    for(s = s << i | a, l += i; l > 0; e[n + f] = 255 & s, f += p, s /= 256, l -= 8);\n    e[n + f - p] |= 128 * g;\n}\nvar b = {}.toString, w = Array.isArray || function(e) {\n    return \"[object Array]\" == b.call(e);\n};\nC.TYPED_ARRAY_SUPPORT = void 0 === l.TYPED_ARRAY_SUPPORT || l.TYPED_ARRAY_SUPPORT;\nvar E = S();\nfunction S() {\n    return C.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;\n}\n_c1 = S;\nfunction _(e, t) {\n    if (S() < t) throw new RangeError(\"Invalid typed array length\");\n    return C.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t)).__proto__ = C.prototype : (null === e && (e = new C(t)), e.length = t), e;\n}\nfunction C(e, t, n) {\n    if (!(C.TYPED_ARRAY_SUPPORT || this instanceof C)) return new C(e, t, n);\n    if (\"number\" == typeof e) {\n        if (\"string\" == typeof t) throw new Error(\"If encoding is specified then the first argument must be a string\");\n        return x(this, e);\n    }\n    return k(this, e, t, n);\n}\n_c2 = C;\nfunction k(e, t, n, r) {\n    if (\"number\" == typeof t) throw new TypeError('\"value\" argument must not be a number');\n    return \"undefined\" != typeof ArrayBuffer && t instanceof ArrayBuffer ? function(e, t, n, r) {\n        if (t.byteLength, n < 0 || t.byteLength < n) throw new RangeError(\"'offset' is out of bounds\");\n        if (t.byteLength < n + (r || 0)) throw new RangeError(\"'length' is out of bounds\");\n        t = void 0 === n && void 0 === r ? new Uint8Array(t) : void 0 === r ? new Uint8Array(t, n) : new Uint8Array(t, n, r);\n        C.TYPED_ARRAY_SUPPORT ? (e = t).__proto__ = C.prototype : e = M(e, t);\n        return e;\n    }(e, t, n, r) : \"string\" == typeof t ? function(e, t, n) {\n        \"string\" == typeof n && \"\" !== n || (n = \"utf8\");\n        if (!C.isEncoding(n)) throw new TypeError('\"encoding\" must be a valid string encoding');\n        var r = 0 | R(t, n);\n        e = _(e, r);\n        var i = e.write(t, n);\n        i !== r && (e = e.slice(0, i));\n        return e;\n    }(e, t, n) : function(e, t) {\n        if (T(t)) {\n            var n = 0 | I(t.length);\n            return 0 === (e = _(e, n)).length || t.copy(e, 0, 0, n), e;\n        }\n        if (t) {\n            if (\"undefined\" != typeof ArrayBuffer && t.buffer instanceof ArrayBuffer || \"length\" in t) return \"number\" != typeof t.length || (r = t.length) != r ? _(e, 0) : M(e, t);\n            if (\"Buffer\" === t.type && w(t.data)) return M(e, t.data);\n        }\n        var r;\n        throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\");\n    }(e, t);\n}\nfunction A(e) {\n    if (\"number\" != typeof e) throw new TypeError('\"size\" argument must be a number');\n    if (e < 0) throw new RangeError('\"size\" argument must not be negative');\n}\n_c3 = A;\nfunction x(e, t) {\n    if (A(t), e = _(e, t < 0 ? 0 : 0 | I(t)), !C.TYPED_ARRAY_SUPPORT) for(var n = 0; n < t; ++n)e[n] = 0;\n    return e;\n}\nfunction M(e, t) {\n    var n = t.length < 0 ? 0 : 0 | I(t.length);\n    e = _(e, n);\n    for(var r = 0; r < n; r += 1)e[r] = 255 & t[r];\n    return e;\n}\n_c4 = M;\nfunction I(e) {\n    if (e >= S()) throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + S().toString(16) + \" bytes\");\n    return 0 | e;\n}\n_c5 = I;\nfunction T(e) {\n    return !(null == e || !e._isBuffer);\n}\n_c6 = T;\nfunction R(e, t) {\n    if (T(e)) return e.length;\n    if (\"undefined\" != typeof ArrayBuffer && \"function\" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer)) return e.byteLength;\n    \"string\" != typeof e && (e = \"\" + e);\n    var n = e.length;\n    if (0 === n) return 0;\n    for(var r = !1;;)switch(t){\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n            return n;\n        case \"utf8\":\n        case \"utf-8\":\n        case void 0:\n            return ie(e).length;\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return 2 * n;\n        case \"hex\":\n            return n >>> 1;\n        case \"base64\":\n            return oe(e).length;\n        default:\n            if (r) return ie(e).length;\n            t = (\"\" + t).toLowerCase(), r = !0;\n    }\n}\n_c7 = R;\nfunction P(e, t, n) {\n    var r = !1;\n    if ((void 0 === t || t < 0) && (t = 0), t > this.length) return \"\";\n    if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return \"\";\n    if ((n >>>= 0) <= (t >>>= 0)) return \"\";\n    for(e || (e = \"utf8\");;)switch(e){\n        case \"hex\":\n            return V(this, t, n);\n        case \"utf8\":\n        case \"utf-8\":\n            return F(this, t, n);\n        case \"ascii\":\n            return q(this, t, n);\n        case \"latin1\":\n        case \"binary\":\n            return W(this, t, n);\n        case \"base64\":\n            return H(this, t, n);\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return G(this, t, n);\n        default:\n            if (r) throw new TypeError(\"Unknown encoding: \" + e);\n            e = (e + \"\").toLowerCase(), r = !0;\n    }\n}\n_c8 = P;\nfunction O(e, t, n) {\n    var r = e[t];\n    e[t] = e[n], e[n] = r;\n}\n_c9 = O;\nfunction N(e, t, n, r, i) {\n    if (0 === e.length) return -1;\n    if (\"string\" == typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, isNaN(n) && (n = i ? 0 : e.length - 1), n < 0 && (n = e.length + n), n >= e.length) {\n        if (i) return -1;\n        n = e.length - 1;\n    } else if (n < 0) {\n        if (!i) return -1;\n        n = 0;\n    }\n    if (\"string\" == typeof t && (t = C.from(t, r)), T(t)) return 0 === t.length ? -1 : L(e, t, n, r, i);\n    if (\"number\" == typeof t) return t &= 255, C.TYPED_ARRAY_SUPPORT && \"function\" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(e, t, n) : Uint8Array.prototype.lastIndexOf.call(e, t, n) : L(e, [\n        t\n    ], n, r, i);\n    throw new TypeError(\"val must be string, number or Buffer\");\n}\n_c10 = N;\nfunction L(e, t, n, r, i) {\n    var o, s = 1, a = e.length, c = t.length;\n    if (void 0 !== r && (\"ucs2\" === (r = String(r).toLowerCase()) || \"ucs-2\" === r || \"utf16le\" === r || \"utf-16le\" === r)) {\n        if (e.length < 2 || t.length < 2) return -1;\n        s = 2, a /= 2, c /= 2, n /= 2;\n    }\n    function l(e, t) {\n        return 1 === s ? e[t] : e.readUInt16BE(t * s);\n    }\n    if (i) {\n        var d = -1;\n        for(o = n; o < a; o++)if (l(e, o) === l(t, -1 === d ? 0 : o - d)) {\n            if (-1 === d && (d = o), o - d + 1 === c) return d * s;\n        } else -1 !== d && (o -= o - d), d = -1;\n    } else for(n + c > a && (n = a - c), o = n; o >= 0; o--){\n        for(var u = !0, h = 0; h < c; h++)if (l(e, o + h) !== l(t, h)) {\n            u = !1;\n            break;\n        }\n        if (u) return o;\n    }\n    return -1;\n}\n_c11 = L;\nfunction D(e, t, n, r) {\n    n = Number(n) || 0;\n    var i = e.length - n;\n    r ? (r = Number(r)) > i && (r = i) : r = i;\n    var o = t.length;\n    if (o % 2 != 0) throw new TypeError(\"Invalid hex string\");\n    r > o / 2 && (r = o / 2);\n    for(var s = 0; s < r; ++s){\n        var a = parseInt(t.substr(2 * s, 2), 16);\n        if (isNaN(a)) return s;\n        e[n + s] = a;\n    }\n    return s;\n}\n_c12 = D;\nfunction $(e, t, n, r) {\n    return se(ie(t, e.length - n), e, n, r);\n}\nfunction B(e, t, n, r) {\n    return se(function(e) {\n        for(var t = [], n = 0; n < e.length; ++n)t.push(255 & e.charCodeAt(n));\n        return t;\n    }(t), e, n, r);\n}\n_c13 = B;\nfunction K(e, t, n, r) {\n    return B(e, t, n, r);\n}\n_c14 = K;\nfunction j(e, t, n, r) {\n    return se(oe(t), e, n, r);\n}\nfunction U(e, t, n, r) {\n    return se(function(e, t) {\n        for(var n, r, i, o = [], s = 0; s < e.length && !((t -= 2) < 0); ++s)r = (n = e.charCodeAt(s)) >> 8, i = n % 256, o.push(i), o.push(r);\n        return o;\n    }(t, e.length - n), e, n, r);\n}\n_c15 = U;\nfunction H(e, t, n) {\n    return 0 === t && n === e.length ? m(e) : m(e.slice(t, n));\n}\n_c16 = H;\nfunction F(e, t, n) {\n    n = Math.min(e.length, n);\n    for(var r = [], i = t; i < n;){\n        var o, s, a, c, l = e[i], d = null, u = l > 239 ? 4 : l > 223 ? 3 : l > 191 ? 2 : 1;\n        if (i + u <= n) switch(u){\n            case 1:\n                l < 128 && (d = l);\n                break;\n            case 2:\n                128 == (192 & (o = e[i + 1])) && (c = (31 & l) << 6 | 63 & o) > 127 && (d = c);\n                break;\n            case 3:\n                o = e[i + 1], s = e[i + 2], 128 == (192 & o) && 128 == (192 & s) && (c = (15 & l) << 12 | (63 & o) << 6 | 63 & s) > 2047 && (c < 55296 || c > 57343) && (d = c);\n                break;\n            case 4:\n                o = e[i + 1], s = e[i + 2], a = e[i + 3], 128 == (192 & o) && 128 == (192 & s) && 128 == (192 & a) && (c = (15 & l) << 18 | (63 & o) << 12 | (63 & s) << 6 | 63 & a) > 65535 && c < 1114112 && (d = c);\n        }\n        null === d ? (d = 65533, u = 1) : d > 65535 && (d -= 65536, r.push(d >>> 10 & 1023 | 55296), d = 56320 | 1023 & d), r.push(d), i += u;\n    }\n    return function(e) {\n        var t = e.length;\n        if (t <= z) return String.fromCharCode.apply(String, e);\n        var n = \"\", r = 0;\n        for(; r < t;)n += String.fromCharCode.apply(String, e.slice(r, r += z));\n        return n;\n    }(r);\n}\n_c17 = F;\nC.poolSize = 8192, C._augment = function(e) {\n    return e.__proto__ = C.prototype, e;\n}, C.from = function(e, t, n) {\n    return k(null, e, t, n);\n}, C.TYPED_ARRAY_SUPPORT && (C.prototype.__proto__ = Uint8Array.prototype, C.__proto__ = Uint8Array, \"undefined\" != typeof Symbol && Symbol.species && C[Symbol.species]), C.alloc = function(e, t, n) {\n    return function(e, t, n, r) {\n        return A(t), t <= 0 ? _(e, t) : void 0 !== n ? \"string\" == typeof r ? _(e, t).fill(n, r) : _(e, t).fill(n) : _(e, t);\n    }(null, e, t, n);\n}, C.allocUnsafe = function(e) {\n    return x(null, e);\n}, C.allocUnsafeSlow = function(e) {\n    return x(null, e);\n}, C.isBuffer = ae, C.compare = function(e, t) {\n    if (!T(e) || !T(t)) throw new TypeError(\"Arguments must be Buffers\");\n    if (e === t) return 0;\n    for(var n = e.length, r = t.length, i = 0, o = Math.min(n, r); i < o; ++i)if (e[i] !== t[i]) {\n        n = e[i], r = t[i];\n        break;\n    }\n    return n < r ? -1 : r < n ? 1 : 0;\n}, C.isEncoding = function(e) {\n    switch(String(e).toLowerCase()){\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return !0;\n        default:\n            return !1;\n    }\n}, C.concat = function(e, t) {\n    if (!w(e)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n    if (0 === e.length) return C.alloc(0);\n    var n;\n    if (void 0 === t) for(t = 0, n = 0; n < e.length; ++n)t += e[n].length;\n    var r = C.allocUnsafe(t), i = 0;\n    for(n = 0; n < e.length; ++n){\n        var o = e[n];\n        if (!T(o)) throw new TypeError('\"list\" argument must be an Array of Buffers');\n        o.copy(r, i), i += o.length;\n    }\n    return r;\n}, C.byteLength = R, C.prototype._isBuffer = !0, C.prototype.swap16 = function() {\n    var e = this.length;\n    if (e % 2 != 0) throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n    for(var t = 0; t < e; t += 2)O(this, t, t + 1);\n    return this;\n}, C.prototype.swap32 = function() {\n    var e = this.length;\n    if (e % 4 != 0) throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n    for(var t = 0; t < e; t += 4)O(this, t, t + 3), O(this, t + 1, t + 2);\n    return this;\n}, C.prototype.swap64 = function() {\n    var e = this.length;\n    if (e % 8 != 0) throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n    for(var t = 0; t < e; t += 8)O(this, t, t + 7), O(this, t + 1, t + 6), O(this, t + 2, t + 5), O(this, t + 3, t + 4);\n    return this;\n}, C.prototype.toString = function() {\n    var e = 0 | this.length;\n    return 0 === e ? \"\" : 0 === arguments.length ? F(this, 0, e) : P.apply(this, arguments);\n}, C.prototype.equals = function(e) {\n    if (!T(e)) throw new TypeError(\"Argument must be a Buffer\");\n    return this === e || 0 === C.compare(this, e);\n}, C.prototype.inspect = function() {\n    var e = \"\";\n    return this.length > 0 && (e = this.toString(\"hex\", 0, 50).match(/.{2}/g).join(\" \"), this.length > 50 && (e += \" ... \")), \"<Buffer \" + e + \">\";\n}, C.prototype.compare = function(e, t, n, r, i) {\n    if (!T(e)) throw new TypeError(\"Argument must be a Buffer\");\n    if (void 0 === t && (t = 0), void 0 === n && (n = e ? e.length : 0), void 0 === r && (r = 0), void 0 === i && (i = this.length), t < 0 || n > e.length || r < 0 || i > this.length) throw new RangeError(\"out of range index\");\n    if (r >= i && t >= n) return 0;\n    if (r >= i) return -1;\n    if (t >= n) return 1;\n    if (this === e) return 0;\n    for(var o = (i >>>= 0) - (r >>>= 0), s = (n >>>= 0) - (t >>>= 0), a = Math.min(o, s), c = this.slice(r, i), l = e.slice(t, n), d = 0; d < a; ++d)if (c[d] !== l[d]) {\n        o = c[d], s = l[d];\n        break;\n    }\n    return o < s ? -1 : s < o ? 1 : 0;\n}, C.prototype.includes = function(e, t, n) {\n    return -1 !== this.indexOf(e, t, n);\n}, C.prototype.indexOf = function(e, t, n) {\n    return N(this, e, t, n, !0);\n}, C.prototype.lastIndexOf = function(e, t, n) {\n    return N(this, e, t, n, !1);\n}, C.prototype.write = function(e, t, n, r) {\n    if (void 0 === t) r = \"utf8\", n = this.length, t = 0;\n    else if (void 0 === n && \"string\" == typeof t) r = t, n = this.length, t = 0;\n    else {\n        if (!isFinite(t)) throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n        t |= 0, isFinite(n) ? (n |= 0, void 0 === r && (r = \"utf8\")) : (r = n, n = void 0);\n    }\n    var i = this.length - t;\n    if ((void 0 === n || n > i) && (n = i), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError(\"Attempt to write outside buffer bounds\");\n    r || (r = \"utf8\");\n    for(var o = !1;;)switch(r){\n        case \"hex\":\n            return D(this, e, t, n);\n        case \"utf8\":\n        case \"utf-8\":\n            return $(this, e, t, n);\n        case \"ascii\":\n            return B(this, e, t, n);\n        case \"latin1\":\n        case \"binary\":\n            return K(this, e, t, n);\n        case \"base64\":\n            return j(this, e, t, n);\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n            return U(this, e, t, n);\n        default:\n            if (o) throw new TypeError(\"Unknown encoding: \" + r);\n            r = (\"\" + r).toLowerCase(), o = !0;\n    }\n}, C.prototype.toJSON = function() {\n    return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n    };\n};\nvar z = 4096;\nfunction q(e, t, n) {\n    var r = \"\";\n    n = Math.min(e.length, n);\n    for(var i = t; i < n; ++i)r += String.fromCharCode(127 & e[i]);\n    return r;\n}\nfunction W(e, t, n) {\n    var r = \"\";\n    n = Math.min(e.length, n);\n    for(var i = t; i < n; ++i)r += String.fromCharCode(e[i]);\n    return r;\n}\n_c18 = W;\nfunction V(e, t, n) {\n    var r = e.length;\n    (!t || t < 0) && (t = 0), (!n || n < 0 || n > r) && (n = r);\n    for(var i = \"\", o = t; o < n; ++o)i += re(e[o]);\n    return i;\n}\n_c19 = V;\nfunction G(e, t, n) {\n    for(var r = e.slice(t, n), i = \"\", o = 0; o < r.length; o += 2)i += String.fromCharCode(r[o] + 256 * r[o + 1]);\n    return i;\n}\n_c20 = G;\nfunction Y(e, t, n) {\n    if (e % 1 != 0 || e < 0) throw new RangeError(\"offset is not uint\");\n    if (e + t > n) throw new RangeError(\"Trying to access beyond buffer length\");\n}\n_c21 = Y;\nfunction Z(e, t, n, r, i, o) {\n    if (!T(e)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n    if (t > i || t < o) throw new RangeError('\"value\" argument is out of bounds');\n    if (n + r > e.length) throw new RangeError(\"Index out of range\");\n}\n_c22 = Z;\nfunction J(e, t, n, r) {\n    t < 0 && (t = 65535 + t + 1);\n    for(var i = 0, o = Math.min(e.length - n, 2); i < o; ++i)e[n + i] = (t & 255 << 8 * (r ? i : 1 - i)) >>> 8 * (r ? i : 1 - i);\n}\n_c23 = J;\nfunction Q(e, t, n, r) {\n    t < 0 && (t = 4294967295 + t + 1);\n    for(var i = 0, o = Math.min(e.length - n, 4); i < o; ++i)e[n + i] = t >>> 8 * (r ? i : 3 - i) & 255;\n}\n_c24 = Q;\nfunction X(e, t, n, r, i, o) {\n    if (n + r > e.length) throw new RangeError(\"Index out of range\");\n    if (n < 0) throw new RangeError(\"Index out of range\");\n}\n_c25 = X;\nfunction ee(e, t, n, r, i) {\n    return i || X(e, 0, n, 4), v(e, t, n, r, 23, 4), n + 4;\n}\nfunction te(e, t, n, r, i) {\n    return i || X(e, 0, n, 8), v(e, t, n, r, 52, 8), n + 8;\n}\nC.prototype.slice = function(e, t) {\n    var n, r = this.length;\n    if ((e = ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), (t = void 0 === t ? r : ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), t < e && (t = e), C.TYPED_ARRAY_SUPPORT) (n = this.subarray(e, t)).__proto__ = C.prototype;\n    else {\n        var i = t - e;\n        n = new C(i, void 0);\n        for(var o = 0; o < i; ++o)n[o] = this[o + e];\n    }\n    return n;\n}, C.prototype.readUIntLE = function(e, t, n) {\n    e |= 0, t |= 0, n || Y(e, t, this.length);\n    for(var r = this[e], i = 1, o = 0; ++o < t && (i *= 256);)r += this[e + o] * i;\n    return r;\n}, C.prototype.readUIntBE = function(e, t, n) {\n    e |= 0, t |= 0, n || Y(e, t, this.length);\n    for(var r = this[e + --t], i = 1; t > 0 && (i *= 256);)r += this[e + --t] * i;\n    return r;\n}, C.prototype.readUInt8 = function(e, t) {\n    return t || Y(e, 1, this.length), this[e];\n}, C.prototype.readUInt16LE = function(e, t) {\n    return t || Y(e, 2, this.length), this[e] | this[e + 1] << 8;\n}, C.prototype.readUInt16BE = function(e, t) {\n    return t || Y(e, 2, this.length), this[e] << 8 | this[e + 1];\n}, C.prototype.readUInt32LE = function(e, t) {\n    return t || Y(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3];\n}, C.prototype.readUInt32BE = function(e, t) {\n    return t || Y(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);\n}, C.prototype.readIntLE = function(e, t, n) {\n    e |= 0, t |= 0, n || Y(e, t, this.length);\n    for(var r = this[e], i = 1, o = 0; ++o < t && (i *= 256);)r += this[e + o] * i;\n    return r >= (i *= 128) && (r -= Math.pow(2, 8 * t)), r;\n}, C.prototype.readIntBE = function(e, t, n) {\n    e |= 0, t |= 0, n || Y(e, t, this.length);\n    for(var r = t, i = 1, o = this[e + --r]; r > 0 && (i *= 256);)o += this[e + --r] * i;\n    return o >= (i *= 128) && (o -= Math.pow(2, 8 * t)), o;\n}, C.prototype.readInt8 = function(e, t) {\n    return t || Y(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e];\n}, C.prototype.readInt16LE = function(e, t) {\n    t || Y(e, 2, this.length);\n    var n = this[e] | this[e + 1] << 8;\n    return 32768 & n ? 4294901760 | n : n;\n}, C.prototype.readInt16BE = function(e, t) {\n    t || Y(e, 2, this.length);\n    var n = this[e + 1] | this[e] << 8;\n    return 32768 & n ? 4294901760 | n : n;\n}, C.prototype.readInt32LE = function(e, t) {\n    return t || Y(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;\n}, C.prototype.readInt32BE = function(e, t) {\n    return t || Y(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];\n}, C.prototype.readFloatLE = function(e, t) {\n    return t || Y(e, 4, this.length), y(this, e, !0, 23, 4);\n}, C.prototype.readFloatBE = function(e, t) {\n    return t || Y(e, 4, this.length), y(this, e, !1, 23, 4);\n}, C.prototype.readDoubleLE = function(e, t) {\n    return t || Y(e, 8, this.length), y(this, e, !0, 52, 8);\n}, C.prototype.readDoubleBE = function(e, t) {\n    return t || Y(e, 8, this.length), y(this, e, !1, 52, 8);\n}, C.prototype.writeUIntLE = function(e, t, n, r) {\n    (e = +e, t |= 0, n |= 0, r) || Z(this, e, t, n, Math.pow(2, 8 * n) - 1, 0);\n    var i = 1, o = 0;\n    for(this[t] = 255 & e; ++o < n && (i *= 256);)this[t + o] = e / i & 255;\n    return t + n;\n}, C.prototype.writeUIntBE = function(e, t, n, r) {\n    (e = +e, t |= 0, n |= 0, r) || Z(this, e, t, n, Math.pow(2, 8 * n) - 1, 0);\n    var i = n - 1, o = 1;\n    for(this[t + i] = 255 & e; --i >= 0 && (o *= 256);)this[t + i] = e / o & 255;\n    return t + n;\n}, C.prototype.writeUInt8 = function(e, t, n) {\n    return e = +e, t |= 0, n || Z(this, e, t, 1, 255, 0), C.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = 255 & e, t + 1;\n}, C.prototype.writeUInt16LE = function(e, t, n) {\n    return e = +e, t |= 0, n || Z(this, e, t, 2, 65535, 0), C.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : J(this, e, t, !0), t + 2;\n}, C.prototype.writeUInt16BE = function(e, t, n) {\n    return e = +e, t |= 0, n || Z(this, e, t, 2, 65535, 0), C.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : J(this, e, t, !1), t + 2;\n}, C.prototype.writeUInt32LE = function(e, t, n) {\n    return e = +e, t |= 0, n || Z(this, e, t, 4, 4294967295, 0), C.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e) : Q(this, e, t, !0), t + 4;\n}, C.prototype.writeUInt32BE = function(e, t, n) {\n    return e = +e, t |= 0, n || Z(this, e, t, 4, 4294967295, 0), C.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : Q(this, e, t, !1), t + 4;\n}, C.prototype.writeIntLE = function(e, t, n, r) {\n    if (e = +e, t |= 0, !r) {\n        var i = Math.pow(2, 8 * n - 1);\n        Z(this, e, t, n, i - 1, -i);\n    }\n    var o = 0, s = 1, a = 0;\n    for(this[t] = 255 & e; ++o < n && (s *= 256);)e < 0 && 0 === a && 0 !== this[t + o - 1] && (a = 1), this[t + o] = (e / s >> 0) - a & 255;\n    return t + n;\n}, C.prototype.writeIntBE = function(e, t, n, r) {\n    if (e = +e, t |= 0, !r) {\n        var i = Math.pow(2, 8 * n - 1);\n        Z(this, e, t, n, i - 1, -i);\n    }\n    var o = n - 1, s = 1, a = 0;\n    for(this[t + o] = 255 & e; --o >= 0 && (s *= 256);)e < 0 && 0 === a && 0 !== this[t + o + 1] && (a = 1), this[t + o] = (e / s >> 0) - a & 255;\n    return t + n;\n}, C.prototype.writeInt8 = function(e, t, n) {\n    return e = +e, t |= 0, n || Z(this, e, t, 1, 127, -128), C.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1;\n}, C.prototype.writeInt16LE = function(e, t, n) {\n    return e = +e, t |= 0, n || Z(this, e, t, 2, 32767, -32768), C.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : J(this, e, t, !0), t + 2;\n}, C.prototype.writeInt16BE = function(e, t, n) {\n    return e = +e, t |= 0, n || Z(this, e, t, 2, 32767, -32768), C.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : J(this, e, t, !1), t + 2;\n}, C.prototype.writeInt32LE = function(e, t, n) {\n    return e = +e, t |= 0, n || Z(this, e, t, 4, 2147483647, -2147483648), C.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : Q(this, e, t, !0), t + 4;\n}, C.prototype.writeInt32BE = function(e, t, n) {\n    return e = +e, t |= 0, n || Z(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), C.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : Q(this, e, t, !1), t + 4;\n}, C.prototype.writeFloatLE = function(e, t, n) {\n    return ee(this, e, t, !0, n);\n}, C.prototype.writeFloatBE = function(e, t, n) {\n    return ee(this, e, t, !1, n);\n}, C.prototype.writeDoubleLE = function(e, t, n) {\n    return te(this, e, t, !0, n);\n}, C.prototype.writeDoubleBE = function(e, t, n) {\n    return te(this, e, t, !1, n);\n}, C.prototype.copy = function(e, t, n, r) {\n    if (n || (n = 0), r || 0 === r || (r = this.length), t >= e.length && (t = e.length), t || (t = 0), r > 0 && r < n && (r = n), r === n) return 0;\n    if (0 === e.length || 0 === this.length) return 0;\n    if (t < 0) throw new RangeError(\"targetStart out of bounds\");\n    if (n < 0 || n >= this.length) throw new RangeError(\"sourceStart out of bounds\");\n    if (r < 0) throw new RangeError(\"sourceEnd out of bounds\");\n    r > this.length && (r = this.length), e.length - t < r - n && (r = e.length - t + n);\n    var i, o = r - n;\n    if (this === e && n < t && t < r) for(i = o - 1; i >= 0; --i)e[i + t] = this[i + n];\n    else if (o < 1e3 || !C.TYPED_ARRAY_SUPPORT) for(i = 0; i < o; ++i)e[i + t] = this[i + n];\n    else Uint8Array.prototype.set.call(e, this.subarray(n, n + o), t);\n    return o;\n}, C.prototype.fill = function(e, t, n, r) {\n    if (\"string\" == typeof e) {\n        if (\"string\" == typeof t ? (r = t, t = 0, n = this.length) : \"string\" == typeof n && (r = n, n = this.length), 1 === e.length) {\n            var i = e.charCodeAt(0);\n            i < 256 && (e = i);\n        }\n        if (void 0 !== r && \"string\" != typeof r) throw new TypeError(\"encoding must be a string\");\n        if (\"string\" == typeof r && !C.isEncoding(r)) throw new TypeError(\"Unknown encoding: \" + r);\n    } else \"number\" == typeof e && (e &= 255);\n    if (t < 0 || this.length < t || this.length < n) throw new RangeError(\"Out of range index\");\n    if (n <= t) return this;\n    var o;\n    if (t >>>= 0, n = void 0 === n ? this.length : n >>> 0, e || (e = 0), \"number\" == typeof e) for(o = t; o < n; ++o)this[o] = e;\n    else {\n        var s = T(e) ? e : ie(new C(e, r).toString()), a = s.length;\n        for(o = 0; o < n - t; ++o)this[o + t] = s[o % a];\n    }\n    return this;\n};\nvar ne = /[^+\\/0-9A-Za-z-_]/g;\nfunction re(e) {\n    return e < 16 ? \"0\" + e.toString(16) : e.toString(16);\n}\nfunction ie(e, t) {\n    var n;\n    t = t || 1 / 0;\n    for(var r = e.length, i = null, o = [], s = 0; s < r; ++s){\n        if ((n = e.charCodeAt(s)) > 55295 && n < 57344) {\n            if (!i) {\n                if (n > 56319) {\n                    (t -= 3) > -1 && o.push(239, 191, 189);\n                    continue;\n                }\n                if (s + 1 === r) {\n                    (t -= 3) > -1 && o.push(239, 191, 189);\n                    continue;\n                }\n                i = n;\n                continue;\n            }\n            if (n < 56320) {\n                (t -= 3) > -1 && o.push(239, 191, 189), i = n;\n                continue;\n            }\n            n = 65536 + (i - 55296 << 10 | n - 56320);\n        } else i && (t -= 3) > -1 && o.push(239, 191, 189);\n        if (i = null, n < 128) {\n            if ((t -= 1) < 0) break;\n            o.push(n);\n        } else if (n < 2048) {\n            if ((t -= 2) < 0) break;\n            o.push(n >> 6 | 192, 63 & n | 128);\n        } else if (n < 65536) {\n            if ((t -= 3) < 0) break;\n            o.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128);\n        } else {\n            if (!(n < 1114112)) throw new Error(\"Invalid code point\");\n            if ((t -= 4) < 0) break;\n            o.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128);\n        }\n    }\n    return o;\n}\nfunction oe(e) {\n    return function(e) {\n        var t, n, r, i, o, s;\n        f || p();\n        var a = e.length;\n        if (a % 4 > 0) throw new Error(\"Invalid string. Length must be a multiple of 4\");\n        o = \"=\" === e[a - 2] ? 2 : \"=\" === e[a - 1] ? 1 : 0, s = new h(3 * a / 4 - o), r = o > 0 ? a - 4 : a;\n        var c = 0;\n        for(t = 0, n = 0; t < r; t += 4, n += 3)i = u[e.charCodeAt(t)] << 18 | u[e.charCodeAt(t + 1)] << 12 | u[e.charCodeAt(t + 2)] << 6 | u[e.charCodeAt(t + 3)], s[c++] = i >> 16 & 255, s[c++] = i >> 8 & 255, s[c++] = 255 & i;\n        return 2 === o ? (i = u[e.charCodeAt(t)] << 2 | u[e.charCodeAt(t + 1)] >> 4, s[c++] = 255 & i) : 1 === o && (i = u[e.charCodeAt(t)] << 10 | u[e.charCodeAt(t + 1)] << 4 | u[e.charCodeAt(t + 2)] >> 2, s[c++] = i >> 8 & 255, s[c++] = 255 & i), s;\n    }(function(e) {\n        if ((e = (function(e) {\n            return e.trim ? e.trim() : e.replace(/^\\s+|\\s+$/g, \"\");\n        })(e).replace(ne, \"\")).length < 2) return \"\";\n        for(; e.length % 4 != 0;)e += \"=\";\n        return e;\n    }(e));\n}\nfunction se(e, t, n, r) {\n    for(var i = 0; i < r && !(i + n >= t.length || i >= e.length); ++i)t[i + n] = e[i];\n    return i;\n}\nfunction ae(e) {\n    return null != e && (!!e._isBuffer || ce(e) || function(e) {\n        return \"function\" == typeof e.readFloatLE && \"function\" == typeof e.slice && ce(e.slice(0, 0));\n    }(e));\n}\nfunction ce(e) {\n    return !!e.constructor && \"function\" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e);\n}\nvar le = Object.freeze({\n    __proto__: null,\n    Buffer: C,\n    INSPECT_MAX_BYTES: 50,\n    SlowBuffer: function(e) {\n        return +e != e && (e = 0), C.alloc(+e);\n    },\n    isBuffer: ae,\n    kMaxLength: E\n}), de = \"undefined\" != typeof globalThis ? globalThis :  true ? window : 0;\nfunction ue(e) {\n    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n}\nfunction he(e) {\n    if (e.__esModule) return e;\n    var t = e.default;\n    if (\"function\" == typeof t) {\n        var n = function e() {\n            return this instanceof e ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);\n        };\n        n.prototype = t.prototype;\n    } else n = {};\n    return Object.defineProperty(n, \"__esModule\", {\n        value: !0\n    }), Object.keys(e).forEach(function(t) {\n        var r = Object.getOwnPropertyDescriptor(e, t);\n        Object.defineProperty(n, t, r.get ? r : {\n            enumerable: !0,\n            get: function() {\n                return e[t];\n            }\n        });\n    }), n;\n}\nvar fe = {}, pe = {}, ge = {};\nfunction me(e) {\n    if (!Number.isSafeInteger(e) || e < 0) throw new Error(\"positive integer expected, not \".concat(e));\n}\nfunction ye(e) {\n    if (\"boolean\" != typeof e) throw new Error(\"boolean expected, not \".concat(e));\n}\nfunction ve(e) {\n    return e instanceof Uint8Array || null != e && \"object\" == typeof e && \"Uint8Array\" === e.constructor.name;\n}\nfunction be(e) {\n    for(var _len = arguments.length, t = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        t[_key - 1] = arguments[_key];\n    }\n    if (!ve(e)) throw new Error(\"Uint8Array expected\");\n    if (t.length > 0 && !t.includes(e.length)) throw new Error(\"Uint8Array expected of length \".concat(t, \", not of length=\").concat(e.length));\n}\nfunction we(e) {\n    if (\"function\" != typeof e || \"function\" != typeof e.create) throw new Error(\"hash must be wrapped by utils.wrapConstructor\");\n    me(e.outputLen), me(e.blockLen);\n}\nfunction Ee(e) {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;\n    if (e.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (t && e.finished) throw new Error(\"Hash#digest() has already been called\");\n}\n_c26 = Ee;\nfunction Se(e, t) {\n    be(e);\n    const n = t.outputLen;\n    if (e.length < n) throw new Error(\"digestInto() expects output buffer of length at least \".concat(n));\n}\n_c27 = Se;\nObject.defineProperty(ge, \"__esModule\", {\n    value: !0\n}), ge.isBytes = ve, ge.number = me, ge.bool = ye, ge.bytes = be, ge.hash = we, ge.exists = Ee, ge.output = Se;\nconst _e = {\n    number: me,\n    bool: ye,\n    bytes: be,\n    hash: we,\n    exists: Ee,\n    output: Se\n};\nge.default = _e, function(e) {\n    Object.defineProperty(e, \"__esModule\", {\n        value: !0\n    }), e.wrapCipher = e.Hash = e.nextTick = e.isLE = e.createView = e.u32 = e.u16 = e.u8 = void 0, e.bytesToHex = r, e.hexToBytes = s, e.hexToNumber = a, e.bytesToNumberBE = function(e) {\n        return a(r(e));\n    }, e.numberToBytesBE = function(e, t) {\n        return s(e.toString(16).padStart(2 * t, \"0\"));\n    }, e.asyncLoop = async function(t, n, r) {\n        let i = Date.now();\n        for(let o = 0; o < t; o++){\n            r(o);\n            const t = Date.now() - i;\n            t >= 0 && t < n || (await (0, e.nextTick)(), i += t);\n        }\n    }, e.utf8ToBytes = c, e.bytesToUtf8 = function(e) {\n        return (new TextDecoder).decode(e);\n    }, e.toBytes = function(e) {\n        if (\"string\" == typeof e) e = c(e);\n        else {\n            if (!(0, t.isBytes)(e)) throw new Error(\"Uint8Array expected, got \" + typeof e);\n            e = d(e);\n        }\n        return e;\n    }, e.concatBytes = function() {\n        for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n            e[_key] = arguments[_key];\n        }\n        let n = 0;\n        for(let r = 0; r < e.length; r++){\n            const i = e[r];\n            (0, t.bytes)(i), n += i.length;\n        }\n        const r = new Uint8Array(n);\n        for(let t = 0, n = 0; t < e.length; t++){\n            const i = e[t];\n            r.set(i, n), n += i.length;\n        }\n        return r;\n    }, e.checkOpts = function(e, t) {\n        if (null == t || \"object\" != typeof t) throw new Error(\"options must be defined\");\n        return Object.assign(e, t);\n    }, e.equalBytes = function(e, t) {\n        if (e.length !== t.length) return !1;\n        let n = 0;\n        for(let r = 0; r < e.length; r++)n |= e[r] ^ t[r];\n        return 0 === n;\n    }, e.setBigUint64 = l, e.u64Lengths = function(t, n) {\n        const r = new Uint8Array(16), i = (0, e.createView)(r);\n        return l(i, 0, BigInt(n ? n.length : 0), !0), l(i, 8, BigInt(t.length), !0), r;\n    }, e.isAligned32 = function(e) {\n        return e.byteOffset % 4 == 0;\n    }, e.copyBytes = d, e.clean = function() {\n        for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n            e[_key] = arguments[_key];\n        }\n        for(let t = 0; t < e.length; t++)e[t].fill(0);\n    };\n    const t = ge;\n    e.u8 = (e)=>new Uint8Array(e.buffer, e.byteOffset, e.byteLength);\n    e.u16 = (e)=>new Uint16Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 2));\n    e.u32 = (e)=>new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));\n    if (e.createView = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength), e.isLE = 68 === new Uint8Array(new Uint32Array([\n        287454020\n    ]).buffer)[0], !e.isLE) throw new Error(\"Non little-endian hardware is not supported\");\n    const n = Array.from({\n        length: 256\n    }, (e, t)=>t.toString(16).padStart(2, \"0\"));\n    function r(e) {\n        (0, t.bytes)(e);\n        let r = \"\";\n        for(let t = 0; t < e.length; t++)r += n[e[t]];\n        return r;\n    }\n    const i = {\n        _0: 48,\n        _9: 57,\n        _A: 65,\n        _F: 70,\n        _a: 97,\n        _f: 102\n    };\n    function o(e) {\n        return e >= i._0 && e <= i._9 ? e - i._0 : e >= i._A && e <= i._F ? e - (i._A - 10) : e >= i._a && e <= i._f ? e - (i._a - 10) : void 0;\n    }\n    function s(e) {\n        if (\"string\" != typeof e) throw new Error(\"hex string expected, got \" + typeof e);\n        const t = e.length, n = t / 2;\n        if (t % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + t);\n        const r = new Uint8Array(n);\n        for(let t = 0, i = 0; t < n; t++, i += 2){\n            const n = o(e.charCodeAt(i)), s = o(e.charCodeAt(i + 1));\n            if (void 0 === n || void 0 === s) {\n                const t = e[i] + e[i + 1];\n                throw new Error('hex string expected, got non-hex character \"' + t + '\" at index ' + i);\n            }\n            r[t] = 16 * n + s;\n        }\n        return r;\n    }\n    function a(e) {\n        if (\"string\" != typeof e) throw new Error(\"hex string expected, got \" + typeof e);\n        return BigInt(\"\" === e ? \"0\" : \"0x\".concat(e));\n    }\n    function c(e) {\n        if (\"string\" != typeof e) throw new Error(\"string expected, got \" + typeof e);\n        return new Uint8Array((new TextEncoder).encode(e));\n    }\n    e.nextTick = async ()=>{};\n    e.Hash = class {\n    };\n    function l(e, t, n, r) {\n        if (\"function\" == typeof e.setBigUint64) return e.setBigUint64(t, n, r);\n        const i = BigInt(32), o = BigInt(4294967295), s = Number(n >> i & o), a = Number(n & o), c = r ? 4 : 0, l = r ? 0 : 4;\n        e.setUint32(t + c, s, r), e.setUint32(t + l, a, r);\n    }\n    function d(e) {\n        return Uint8Array.from(e);\n    }\n    e.wrapCipher = (e, t)=>(Object.assign(t, e), t);\n}(pe);\nvar Ce = {}, ke = {};\nObject.defineProperty(ke, \"__esModule\", {\n    value: !0\n}), ke.AEAD_TAG_LENGTH = ke.XCHACHA20_NONCE_LENGTH = ke.CURVE25519_PUBLIC_KEY_SIZE = ke.ETH_PUBLIC_KEY_SIZE = ke.UNCOMPRESSED_PUBLIC_KEY_SIZE = ke.COMPRESSED_PUBLIC_KEY_SIZE = ke.SECRET_KEY_LENGTH = void 0, ke.SECRET_KEY_LENGTH = 32, ke.COMPRESSED_PUBLIC_KEY_SIZE = 33, ke.UNCOMPRESSED_PUBLIC_KEY_SIZE = 65, ke.ETH_PUBLIC_KEY_SIZE = 64, ke.CURVE25519_PUBLIC_KEY_SIZE = 32, ke.XCHACHA20_NONCE_LENGTH = 24, ke.AEAD_TAG_LENGTH = 16, function(e) {\n    Object.defineProperty(e, \"__esModule\", {\n        value: !0\n    }), e.ephemeralKeySize = e.symmetricNonceLength = e.symmetricAlgorithm = e.isHkdfKeyCompressed = e.isEphemeralKeyCompressed = e.ellipticCurve = e.ECIES_CONFIG = void 0;\n    var t = ke, n = function() {\n        this.ellipticCurve = \"secp256k1\", this.isEphemeralKeyCompressed = !1, this.isHkdfKeyCompressed = !1, this.symmetricAlgorithm = \"aes-256-gcm\", this.symmetricNonceLength = 16;\n    };\n    e.ECIES_CONFIG = new n;\n    e.ellipticCurve = function() {\n        return e.ECIES_CONFIG.ellipticCurve;\n    };\n    e.isEphemeralKeyCompressed = function() {\n        return e.ECIES_CONFIG.isEphemeralKeyCompressed;\n    };\n    e.isHkdfKeyCompressed = function() {\n        return e.ECIES_CONFIG.isHkdfKeyCompressed;\n    };\n    e.symmetricAlgorithm = function() {\n        return e.ECIES_CONFIG.symmetricAlgorithm;\n    };\n    e.symmetricNonceLength = function() {\n        return e.ECIES_CONFIG.symmetricNonceLength;\n    };\n    e.ephemeralKeySize = function() {\n        var n = {\n            secp256k1: e.ECIES_CONFIG.isEphemeralKeyCompressed ? t.COMPRESSED_PUBLIC_KEY_SIZE : t.UNCOMPRESSED_PUBLIC_KEY_SIZE,\n            x25519: t.CURVE25519_PUBLIC_KEY_SIZE,\n            ed25519: t.CURVE25519_PUBLIC_KEY_SIZE\n        };\n        if (e.ECIES_CONFIG.ellipticCurve in n) return n[e.ECIES_CONFIG.ellipticCurve];\n        throw new Error(\"Not implemented\");\n    };\n}(Ce);\nvar Ae = {}, xe = {}, Me = {}, Ie = {}, Te = {}, Re = {};\nObject.defineProperty(Re, \"__esModule\", {\n    value: !0\n}), Re.crypto = void 0, Re.crypto = \"object\" == typeof globalThis && \"crypto\" in globalThis ? globalThis.crypto : void 0, function(e) {\n    Object.defineProperty(e, \"__esModule\", {\n        value: !0\n    }), e.gcm = e.ctr = e.cbc = e.utils = void 0, e.randomBytes = i, e.getWebcryptoSubtle = o, e.managedNonce = function(e) {\n        return (0, n.number)(e.nonceLength), function(t) {\n            for(var _len = arguments.length, n = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                n[_key - 1] = arguments[_key];\n            }\n            return {\n                encrypt (o) {\n                    for(var _len = arguments.length, s = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        s[_key - 1] = arguments[_key];\n                    }\n                    const { nonceLength: a } = e, c = i(a), l = e(t, c, ...n).encrypt(o, ...s), d = (0, r.concatBytes)(c, l);\n                    return l.fill(0), d;\n                },\n                decrypt (r) {\n                    for(var _len = arguments.length, i = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        i[_key - 1] = arguments[_key];\n                    }\n                    const { nonceLength: o } = e, s = r.subarray(0, o), a = r.subarray(o);\n                    return e(t, s, ...n).decrypt(a, ...i);\n                }\n            };\n        };\n    };\n    const t = Re, n = ge, r = pe;\n    function i() {\n        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 32;\n        if (t.crypto && \"function\" == typeof t.crypto.getRandomValues) return t.crypto.getRandomValues(new Uint8Array(e));\n        if (t.crypto && \"function\" == typeof t.crypto.randomBytes) return t.crypto.randomBytes(e);\n        throw new Error(\"crypto.getRandomValues must be defined\");\n    }\n    function o() {\n        if (t.crypto && \"object\" == typeof t.crypto.subtle && null != t.crypto.subtle) return t.crypto.subtle;\n        throw new Error(\"crypto.subtle must be defined\");\n    }\n    e.utils = {\n        async encrypt (e, t, n, r) {\n            const i = o(), s = await i.importKey(\"raw\", e, t, !0, [\n                \"encrypt\"\n            ]), a = await i.encrypt(n, s, r);\n            return new Uint8Array(a);\n        },\n        async decrypt (e, t, n, r) {\n            const i = o(), s = await i.importKey(\"raw\", e, t, !0, [\n                \"decrypt\"\n            ]), a = await i.decrypt(n, s, r);\n            return new Uint8Array(a);\n        }\n    };\n    const s = {\n        CBC: \"AES-CBC\",\n        CTR: \"AES-CTR\",\n        GCM: \"AES-GCM\"\n    };\n    function a(t) {\n        return (r, i, o)=>{\n            (0, n.bytes)(r), (0, n.bytes)(i);\n            const a = {\n                name: t,\n                length: 8 * r.length\n            }, c = function(e, t, n) {\n                if (e === s.CBC) return {\n                    name: s.CBC,\n                    iv: t\n                };\n                if (e === s.CTR) return {\n                    name: s.CTR,\n                    counter: t,\n                    length: 64\n                };\n                if (e === s.GCM) return n ? {\n                    name: s.GCM,\n                    iv: t,\n                    additionalData: n\n                } : {\n                    name: s.GCM,\n                    iv: t\n                };\n                throw new Error(\"unknown aes block mode\");\n            }(t, i, o);\n            return {\n                encrypt: (t)=>((0, n.bytes)(t), e.utils.encrypt(r, a, c, t)),\n                decrypt: (t)=>((0, n.bytes)(t), e.utils.decrypt(r, a, c, t))\n            };\n        };\n    }\n    e.cbc = a(s.CBC), e.ctr = a(s.CTR), e.gcm = a(s.GCM);\n}(Te);\nvar Pe = {}, Oe = {}, Ne = {}, Le = {};\nfunction De(e) {\n    if (!Number.isSafeInteger(e) || e < 0) throw new Error(\"positive integer expected, not \".concat(e));\n}\n_c28 = De;\nfunction $e(e) {\n    if (\"boolean\" != typeof e) throw new Error(\"boolean expected, not \".concat(e));\n}\nfunction Be(e) {\n    return e instanceof Uint8Array || null != e && \"object\" == typeof e && \"Uint8Array\" === e.constructor.name;\n}\n_c29 = Be;\nfunction Ke(e) {\n    for(var _len = arguments.length, t = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        t[_key - 1] = arguments[_key];\n    }\n    if (!Be(e)) throw new Error(\"Uint8Array expected\");\n    if (t.length > 0 && !t.includes(e.length)) throw new Error(\"Uint8Array expected of length \".concat(t, \", not of length=\").concat(e.length));\n}\n_c30 = Ke;\nfunction je(e) {\n    if (\"function\" != typeof e || \"function\" != typeof e.create) throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n    De(e.outputLen), De(e.blockLen);\n}\nfunction Ue(e) {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;\n    if (e.destroyed) throw new Error(\"Hash instance has been destroyed\");\n    if (t && e.finished) throw new Error(\"Hash#digest() has already been called\");\n}\n_c31 = Ue;\nfunction He(e, t) {\n    Ke(e);\n    const n = t.outputLen;\n    if (e.length < n) throw new Error(\"digestInto() expects output buffer of length at least \".concat(n));\n}\n_c32 = He;\nObject.defineProperty(Le, \"__esModule\", {\n    value: !0\n}), Le.isBytes = Be, Le.number = De, Le.bool = $e, Le.bytes = Ke, Le.hash = je, Le.exists = Ue, Le.output = He;\nconst Fe = {\n    number: De,\n    bool: $e,\n    bytes: Ke,\n    hash: je,\n    exists: Ue,\n    output: He\n};\nLe.default = Fe;\nvar ze = {}, qe = {};\nObject.defineProperty(qe, \"__esModule\", {\n    value: !0\n}), qe.crypto = void 0, qe.crypto = \"object\" == typeof globalThis && \"crypto\" in globalThis ? globalThis.crypto : void 0, function(e) {\n    Object.defineProperty(e, \"__esModule\", {\n        value: !0\n    }), e.Hash = e.nextTick = e.byteSwapIfBE = e.byteSwap = e.isLE = e.rotl = e.rotr = e.createView = e.u32 = e.u8 = void 0, e.isBytes = function(e) {\n        return e instanceof Uint8Array || null != e && \"object\" == typeof e && \"Uint8Array\" === e.constructor.name;\n    }, e.byteSwap32 = function(t) {\n        for(let n = 0; n < t.length; n++)t[n] = (0, e.byteSwap)(t[n]);\n    }, e.bytesToHex = function(e) {\n        (0, n.bytes)(e);\n        let t = \"\";\n        for(let n = 0; n < e.length; n++)t += r[e[n]];\n        return t;\n    }, e.hexToBytes = function(e) {\n        if (\"string\" != typeof e) throw new Error(\"hex string expected, got \" + typeof e);\n        const t = e.length, n = t / 2;\n        if (t % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + t);\n        const r = new Uint8Array(n);\n        for(let t = 0, i = 0; t < n; t++, i += 2){\n            const n = o(e.charCodeAt(i)), s = o(e.charCodeAt(i + 1));\n            if (void 0 === n || void 0 === s) {\n                const t = e[i] + e[i + 1];\n                throw new Error('hex string expected, got non-hex character \"' + t + '\" at index ' + i);\n            }\n            r[t] = 16 * n + s;\n        }\n        return r;\n    }, e.asyncLoop = async function(t, n, r) {\n        let i = Date.now();\n        for(let o = 0; o < t; o++){\n            r(o);\n            const t = Date.now() - i;\n            t >= 0 && t < n || (await (0, e.nextTick)(), i += t);\n        }\n    }, e.utf8ToBytes = s, e.toBytes = a, e.concatBytes = function() {\n        for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n            e[_key] = arguments[_key];\n        }\n        let t = 0;\n        for(let r = 0; r < e.length; r++){\n            const i = e[r];\n            (0, n.bytes)(i), t += i.length;\n        }\n        const r = new Uint8Array(t);\n        for(let t = 0, n = 0; t < e.length; t++){\n            const i = e[t];\n            r.set(i, n), n += i.length;\n        }\n        return r;\n    }, e.checkOpts = function(e, t) {\n        if (void 0 !== t && \"[object Object]\" !== c.call(t)) throw new Error(\"Options should be object or undefined\");\n        return Object.assign(e, t);\n    }, e.wrapConstructor = function(e) {\n        const t = (t)=>e().update(a(t)).digest(), n = e();\n        return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = ()=>e(), t;\n    }, e.wrapConstructorWithOpts = function(e) {\n        const t = (t, n)=>e(n).update(a(t)).digest(), n = e({});\n        return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = (t)=>e(t), t;\n    }, e.wrapXOFConstructorWithOpts = function(e) {\n        const t = (t, n)=>e(n).update(a(t)).digest(), n = e({});\n        return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = (t)=>e(t), t;\n    }, e.randomBytes = function() {\n        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 32;\n        if (t.crypto && \"function\" == typeof t.crypto.getRandomValues) return t.crypto.getRandomValues(new Uint8Array(e));\n        if (t.crypto && \"function\" == typeof t.crypto.randomBytes) return t.crypto.randomBytes(e);\n        throw new Error(\"crypto.getRandomValues must be defined\");\n    };\n    const t = qe, n = Le;\n    e.u8 = (e)=>new Uint8Array(e.buffer, e.byteOffset, e.byteLength);\n    e.u32 = (e)=>new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4));\n    e.createView = (e)=>new DataView(e.buffer, e.byteOffset, e.byteLength);\n    e.rotr = (e, t)=>e << 32 - t | e >>> t;\n    e.rotl = (e, t)=>e << t | e >>> 32 - t >>> 0, e.isLE = 68 === new Uint8Array(new Uint32Array([\n        287454020\n    ]).buffer)[0];\n    e.byteSwap = (e)=>e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255, e.byteSwapIfBE = e.isLE ? (e)=>e : (t)=>(0, e.byteSwap)(t);\n    const r = Array.from({\n        length: 256\n    }, (e, t)=>t.toString(16).padStart(2, \"0\"));\n    const i = {\n        _0: 48,\n        _9: 57,\n        _A: 65,\n        _F: 70,\n        _a: 97,\n        _f: 102\n    };\n    function o(e) {\n        return e >= i._0 && e <= i._9 ? e - i._0 : e >= i._A && e <= i._F ? e - (i._A - 10) : e >= i._a && e <= i._f ? e - (i._a - 10) : void 0;\n    }\n    function s(e) {\n        if (\"string\" != typeof e) throw new Error(\"utf8ToBytes expected string, got \" + typeof e);\n        return new Uint8Array((new TextEncoder).encode(e));\n    }\n    function a(e) {\n        return \"string\" == typeof e && (e = s(e)), (0, n.bytes)(e), e;\n    }\n    e.nextTick = async ()=>{};\n    e.Hash = class {\n        clone() {\n            return this._cloneInto();\n        }\n    };\n    const c = {}.toString;\n}(ze), Object.defineProperty(Ne, \"__esModule\", {\n    value: !0\n}), Ne.HashMD = Ne.Maj = Ne.Chi = void 0;\nconst We = Le, Ve = ze;\nNe.Chi = (e, t, n)=>e & t ^ ~e & n;\nNe.Maj = (e, t, n)=>e & t ^ e & n ^ t & n;\nNe.HashMD = class extends Ve.Hash {\n    update(e) {\n        (0, We.exists)(this);\n        const { view: t, buffer: n, blockLen: r } = this, i = (e = (0, Ve.toBytes)(e)).length;\n        for(let o = 0; o < i;){\n            const s = Math.min(r - this.pos, i - o);\n            if (s !== r) n.set(e.subarray(o, o + s), this.pos), this.pos += s, o += s, this.pos === r && (this.process(t, 0), this.pos = 0);\n            else {\n                const t = (0, Ve.createView)(e);\n                for(; r <= i - o; o += r)this.process(t, o);\n            }\n        }\n        return this.length += e.length, this.roundClean(), this;\n    }\n    digestInto(e) {\n        (0, We.exists)(this), (0, We.output)(e, this), this.finished = !0;\n        const { buffer: t, view: n, blockLen: r, isLE: i } = this;\n        let { pos: o } = this;\n        t[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > r - o && (this.process(n, 0), o = 0);\n        for(let e = o; e < r; e++)t[e] = 0;\n        !function(e, t, n, r) {\n            if (\"function\" == typeof e.setBigUint64) return e.setBigUint64(t, n, r);\n            const i = BigInt(32), o = BigInt(4294967295), s = Number(n >> i & o), a = Number(n & o), c = r ? 4 : 0, l = r ? 0 : 4;\n            e.setUint32(t + c, s, r), e.setUint32(t + l, a, r);\n        }(n, r - 8, BigInt(8 * this.length), i), this.process(n, 0);\n        const s = (0, Ve.createView)(e), a = this.outputLen;\n        if (a % 4) throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n        const c = a / 4, l = this.get();\n        if (c > l.length) throw new Error(\"_sha2: outputLen bigger than state\");\n        for(let e = 0; e < c; e++)s.setUint32(4 * e, l[e], i);\n    }\n    digest() {\n        const { buffer: e, outputLen: t } = this;\n        this.digestInto(e);\n        const n = e.slice(0, t);\n        return this.destroy(), n;\n    }\n    _cloneInto(e) {\n        e || (e = new this.constructor), e.set(...this.get());\n        const { blockLen: t, buffer: n, length: r, finished: i, destroyed: o, pos: s } = this;\n        return e.length = r, e.pos = s, e.finished = i, e.destroyed = o, r % t && e.buffer.set(n), e;\n    }\n    constructor(e, t, n, r){\n        super(), this.blockLen = e, this.outputLen = t, this.padOffset = n, this.isLE = r, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(e), this.view = (0, Ve.createView)(this.buffer);\n    }\n};\nvar Ge = {};\nObject.defineProperty(Ge, \"__esModule\", {\n    value: !0\n}), Ge.add5L = Ge.add5H = Ge.add4H = Ge.add4L = Ge.add3H = Ge.add3L = Ge.rotlBL = Ge.rotlBH = Ge.rotlSL = Ge.rotlSH = Ge.rotr32L = Ge.rotr32H = Ge.rotrBL = Ge.rotrBH = Ge.rotrSL = Ge.rotrSH = Ge.shrSL = Ge.shrSH = Ge.toBig = void 0, Ge.fromBig = Je, Ge.split = Qe, Ge.add = ht;\nconst Ye = BigInt(2 ** 32 - 1), Ze = BigInt(32);\nfunction Je(e) {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;\n    return t ? {\n        h: Number(e & Ye),\n        l: Number(e >> Ze & Ye)\n    } : {\n        h: 0 | Number(e >> Ze & Ye),\n        l: 0 | Number(e & Ye)\n    };\n}\n_c33 = Je;\nfunction Qe(e) {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;\n    let n = new Uint32Array(e.length), r = new Uint32Array(e.length);\n    for(let i = 0; i < e.length; i++){\n        const { h: o, l: s } = Je(e[i], t);\n        [n[i], r[i]] = [\n            o,\n            s\n        ];\n    }\n    return [\n        n,\n        r\n    ];\n}\n_c34 = Qe;\nconst Xe = (e, t)=>BigInt(e >>> 0) << Ze | BigInt(t >>> 0);\n_c35 = Xe;\nGe.toBig = Xe;\nconst et = (e, t, n)=>e >>> n;\nGe.shrSH = et;\nconst tt = (e, t, n)=>e << 32 - n | t >>> n;\nGe.shrSL = tt;\nconst nt = (e, t, n)=>e >>> n | t << 32 - n;\nGe.rotrSH = nt;\nconst rt = (e, t, n)=>e << 32 - n | t >>> n;\nGe.rotrSL = rt;\nconst it = (e, t, n)=>e << 64 - n | t >>> n - 32;\nGe.rotrBH = it;\nconst ot = (e, t, n)=>e >>> n - 32 | t << 64 - n;\nGe.rotrBL = ot;\nconst st = (e, t)=>t;\nGe.rotr32H = st;\nconst at = (e, t)=>e;\nGe.rotr32L = at;\nconst ct = (e, t, n)=>e << n | t >>> 32 - n;\nGe.rotlSH = ct;\nconst lt = (e, t, n)=>t << n | e >>> 32 - n;\nGe.rotlSL = lt;\nconst dt = (e, t, n)=>t << n - 32 | e >>> 64 - n;\nGe.rotlBH = dt;\nconst ut = (e, t, n)=>e << n - 32 | t >>> 64 - n;\nfunction ht(e, t, n, r) {\n    const i = (t >>> 0) + (r >>> 0);\n    return {\n        h: e + n + (i / 2 ** 32 | 0) | 0,\n        l: 0 | i\n    };\n}\nGe.rotlBL = ut;\nconst ft = (e, t, n)=>(e >>> 0) + (t >>> 0) + (n >>> 0);\nGe.add3L = ft;\nconst pt = (e, t, n, r)=>t + n + r + (e / 2 ** 32 | 0) | 0;\nGe.add3H = pt;\nconst gt = (e, t, n, r)=>(e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0);\nGe.add4L = gt;\nconst mt = (e, t, n, r, i)=>t + n + r + i + (e / 2 ** 32 | 0) | 0;\nGe.add4H = mt;\nconst yt = (e, t, n, r, i)=>(e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0);\nGe.add5L = yt;\nconst vt = (e, t, n, r, i, o)=>t + n + r + i + o + (e / 2 ** 32 | 0) | 0;\nGe.add5H = vt;\nconst bt = {\n    fromBig: Je,\n    split: Qe,\n    toBig: Xe,\n    shrSH: et,\n    shrSL: tt,\n    rotrSH: nt,\n    rotrSL: rt,\n    rotrBH: it,\n    rotrBL: ot,\n    rotr32H: st,\n    rotr32L: at,\n    rotlSH: ct,\n    rotlSL: lt,\n    rotlBH: dt,\n    rotlBL: ut,\n    add: ht,\n    add3L: ft,\n    add3H: pt,\n    add4L: gt,\n    add4H: mt,\n    add5H: vt,\n    add5L: yt\n};\nGe.default = bt, Object.defineProperty(Oe, \"__esModule\", {\n    value: !0\n}), Oe.sha384 = Oe.sha512_256 = Oe.sha512_224 = Oe.sha512 = Oe.SHA384 = Oe.SHA512_256 = Oe.SHA512_224 = Oe.SHA512 = void 0;\nconst wt = Ne, Et = Ge, St = ze, [_t, Ct] = (()=>Et.default.split([\n        \"0x428a2f98d728ae22\",\n        \"0x7137449123ef65cd\",\n        \"0xb5c0fbcfec4d3b2f\",\n        \"0xe9b5dba58189dbbc\",\n        \"0x3956c25bf348b538\",\n        \"0x59f111f1b605d019\",\n        \"0x923f82a4af194f9b\",\n        \"0xab1c5ed5da6d8118\",\n        \"0xd807aa98a3030242\",\n        \"0x12835b0145706fbe\",\n        \"0x243185be4ee4b28c\",\n        \"0x550c7dc3d5ffb4e2\",\n        \"0x72be5d74f27b896f\",\n        \"0x80deb1fe3b1696b1\",\n        \"0x9bdc06a725c71235\",\n        \"0xc19bf174cf692694\",\n        \"0xe49b69c19ef14ad2\",\n        \"0xefbe4786384f25e3\",\n        \"0x0fc19dc68b8cd5b5\",\n        \"0x240ca1cc77ac9c65\",\n        \"0x2de92c6f592b0275\",\n        \"0x4a7484aa6ea6e483\",\n        \"0x5cb0a9dcbd41fbd4\",\n        \"0x76f988da831153b5\",\n        \"0x983e5152ee66dfab\",\n        \"0xa831c66d2db43210\",\n        \"0xb00327c898fb213f\",\n        \"0xbf597fc7beef0ee4\",\n        \"0xc6e00bf33da88fc2\",\n        \"0xd5a79147930aa725\",\n        \"0x06ca6351e003826f\",\n        \"0x142929670a0e6e70\",\n        \"0x27b70a8546d22ffc\",\n        \"0x2e1b21385c26c926\",\n        \"0x4d2c6dfc5ac42aed\",\n        \"0x53380d139d95b3df\",\n        \"0x650a73548baf63de\",\n        \"0x766a0abb3c77b2a8\",\n        \"0x81c2c92e47edaee6\",\n        \"0x92722c851482353b\",\n        \"0xa2bfe8a14cf10364\",\n        \"0xa81a664bbc423001\",\n        \"0xc24b8b70d0f89791\",\n        \"0xc76c51a30654be30\",\n        \"0xd192e819d6ef5218\",\n        \"0xd69906245565a910\",\n        \"0xf40e35855771202a\",\n        \"0x106aa07032bbd1b8\",\n        \"0x19a4c116b8d2d0c8\",\n        \"0x1e376c085141ab53\",\n        \"0x2748774cdf8eeb99\",\n        \"0x34b0bcb5e19b48a8\",\n        \"0x391c0cb3c5c95a63\",\n        \"0x4ed8aa4ae3418acb\",\n        \"0x5b9cca4f7763e373\",\n        \"0x682e6ff3d6b2b8a3\",\n        \"0x748f82ee5defb2fc\",\n        \"0x78a5636f43172f60\",\n        \"0x84c87814a1f0ab72\",\n        \"0x8cc702081a6439ec\",\n        \"0x90befffa23631e28\",\n        \"0xa4506cebde82bde9\",\n        \"0xbef9a3f7b2c67915\",\n        \"0xc67178f2e372532b\",\n        \"0xca273eceea26619c\",\n        \"0xd186b8c721c0c207\",\n        \"0xeada7dd6cde0eb1e\",\n        \"0xf57d4f7fee6ed178\",\n        \"0x06f067aa72176fba\",\n        \"0x0a637dc5a2c898a6\",\n        \"0x113f9804bef90dae\",\n        \"0x1b710b35131c471b\",\n        \"0x28db77f523047d84\",\n        \"0x32caab7b40c72493\",\n        \"0x3c9ebe0a15c9bebc\",\n        \"0x431d67c49c100d4c\",\n        \"0x4cc5d4becb3e42b6\",\n        \"0x597f299cfc657e2a\",\n        \"0x5fcb6fab3ad6faec\",\n        \"0x6c44198c4a475817\"\n    ].map((e)=>BigInt(e))))(), kt = new Uint32Array(80), At = new Uint32Array(80);\nclass xt extends wt.HashMD {\n    get() {\n        const { Ah: e, Al: t, Bh: n, Bl: r, Ch: i, Cl: o, Dh: s, Dl: a, Eh: c, El: l, Fh: d, Fl: u, Gh: h, Gl: f, Hh: p, Hl: g } = this;\n        return [\n            e,\n            t,\n            n,\n            r,\n            i,\n            o,\n            s,\n            a,\n            c,\n            l,\n            d,\n            u,\n            h,\n            f,\n            p,\n            g\n        ];\n    }\n    set(e, t, n, r, i, o, s, a, c, l, d, u, h, f, p, g) {\n        this.Ah = 0 | e, this.Al = 0 | t, this.Bh = 0 | n, this.Bl = 0 | r, this.Ch = 0 | i, this.Cl = 0 | o, this.Dh = 0 | s, this.Dl = 0 | a, this.Eh = 0 | c, this.El = 0 | l, this.Fh = 0 | d, this.Fl = 0 | u, this.Gh = 0 | h, this.Gl = 0 | f, this.Hh = 0 | p, this.Hl = 0 | g;\n    }\n    process(e, t) {\n        for(let n = 0; n < 16; n++, t += 4)kt[n] = e.getUint32(t), At[n] = e.getUint32(t += 4);\n        for(let e = 16; e < 80; e++){\n            const t = 0 | kt[e - 15], n = 0 | At[e - 15], r = Et.default.rotrSH(t, n, 1) ^ Et.default.rotrSH(t, n, 8) ^ Et.default.shrSH(t, n, 7), i = Et.default.rotrSL(t, n, 1) ^ Et.default.rotrSL(t, n, 8) ^ Et.default.shrSL(t, n, 7), o = 0 | kt[e - 2], s = 0 | At[e - 2], a = Et.default.rotrSH(o, s, 19) ^ Et.default.rotrBH(o, s, 61) ^ Et.default.shrSH(o, s, 6), c = Et.default.rotrSL(o, s, 19) ^ Et.default.rotrBL(o, s, 61) ^ Et.default.shrSL(o, s, 6), l = Et.default.add4L(i, c, At[e - 7], At[e - 16]), d = Et.default.add4H(l, r, a, kt[e - 7], kt[e - 16]);\n            kt[e] = 0 | d, At[e] = 0 | l;\n        }\n        let { Ah: n, Al: r, Bh: i, Bl: o, Ch: s, Cl: a, Dh: c, Dl: l, Eh: d, El: u, Fh: h, Fl: f, Gh: p, Gl: g, Hh: m, Hl: y } = this;\n        for(let e = 0; e < 80; e++){\n            const t = Et.default.rotrSH(d, u, 14) ^ Et.default.rotrSH(d, u, 18) ^ Et.default.rotrBH(d, u, 41), v = Et.default.rotrSL(d, u, 14) ^ Et.default.rotrSL(d, u, 18) ^ Et.default.rotrBL(d, u, 41), b = d & h ^ ~d & p, w = u & f ^ ~u & g, E = Et.default.add5L(y, v, w, Ct[e], At[e]), S = Et.default.add5H(E, m, t, b, _t[e], kt[e]), _ = 0 | E, C = Et.default.rotrSH(n, r, 28) ^ Et.default.rotrBH(n, r, 34) ^ Et.default.rotrBH(n, r, 39), k = Et.default.rotrSL(n, r, 28) ^ Et.default.rotrBL(n, r, 34) ^ Et.default.rotrBL(n, r, 39), A = n & i ^ n & s ^ i & s, x = r & o ^ r & a ^ o & a;\n            m = 0 | p, y = 0 | g, p = 0 | h, g = 0 | f, h = 0 | d, f = 0 | u, ({ h: d, l: u } = Et.default.add(0 | c, 0 | l, 0 | S, 0 | _)), c = 0 | s, l = 0 | a, s = 0 | i, a = 0 | o, i = 0 | n, o = 0 | r;\n            const M = Et.default.add3L(_, k, x);\n            n = Et.default.add3H(M, S, C, A), r = 0 | M;\n        }\n        ({ h: n, l: r } = Et.default.add(0 | this.Ah, 0 | this.Al, 0 | n, 0 | r)), ({ h: i, l: o } = Et.default.add(0 | this.Bh, 0 | this.Bl, 0 | i, 0 | o)), ({ h: s, l: a } = Et.default.add(0 | this.Ch, 0 | this.Cl, 0 | s, 0 | a)), ({ h: c, l: l } = Et.default.add(0 | this.Dh, 0 | this.Dl, 0 | c, 0 | l)), ({ h: d, l: u } = Et.default.add(0 | this.Eh, 0 | this.El, 0 | d, 0 | u)), ({ h: h, l: f } = Et.default.add(0 | this.Fh, 0 | this.Fl, 0 | h, 0 | f)), ({ h: p, l: g } = Et.default.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | g)), ({ h: m, l: y } = Et.default.add(0 | this.Hh, 0 | this.Hl, 0 | m, 0 | y)), this.set(n, r, i, o, s, a, c, l, d, u, h, f, p, g, m, y);\n    }\n    roundClean() {\n        kt.fill(0), At.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n    constructor(){\n        super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;\n    }\n}\nOe.SHA512 = xt;\nclass Mt extends xt {\n    constructor(){\n        super(), this.Ah = -1942145080, this.Al = 424955298, this.Bh = 1944164710, this.Bl = -1982016298, this.Ch = 502970286, this.Cl = 855612546, this.Dh = 1738396948, this.Dl = 1479516111, this.Eh = 258812777, this.El = 2077511080, this.Fh = 2011393907, this.Fl = 79989058, this.Gh = 1067287976, this.Gl = 1780299464, this.Hh = 286451373, this.Hl = -1848208735, this.outputLen = 28;\n    }\n}\nOe.SHA512_224 = Mt;\nclass It extends xt {\n    constructor(){\n        super(), this.Ah = 573645204, this.Al = -64227540, this.Bh = -1621794909, this.Bl = -934517566, this.Ch = 596883563, this.Cl = 1867755857, this.Dh = -1774684391, this.Dl = 1497426621, this.Eh = -1775747358, this.El = -1467023389, this.Fh = -1101128155, this.Fl = 1401305490, this.Gh = 721525244, this.Gl = 746961066, this.Hh = 246885852, this.Hl = -2117784414, this.outputLen = 32;\n    }\n}\nOe.SHA512_256 = It;\nclass Tt extends xt {\n    constructor(){\n        super(), this.Ah = -876896931, this.Al = -1056596264, this.Bh = 1654270250, this.Bl = 914150663, this.Ch = -1856437926, this.Cl = 812702999, this.Dh = 355462360, this.Dl = -150054599, this.Eh = 1731405415, this.El = -4191439, this.Fh = -1900787065, this.Fl = 1750603025, this.Gh = -619958771, this.Gl = 1694076839, this.Hh = 1203062813, this.Hl = -1090891868, this.outputLen = 48;\n    }\n}\nOe.SHA384 = Tt, Oe.sha512 = (0, St.wrapConstructor)(()=>new xt), Oe.sha512_224 = (0, St.wrapConstructor)(()=>new Mt), Oe.sha512_256 = (0, St.wrapConstructor)(()=>new It), Oe.sha384 = (0, St.wrapConstructor)(()=>new Tt);\nvar Rt = {}, Pt = {}, Ot = {}, Nt = {};\nObject.defineProperty(Nt, \"__esModule\", {\n    value: !0\n}), Nt.notImplemented = Nt.bitMask = void 0, Nt.isBytes = Bt, Nt.abytes = Kt, Nt.abool = function(e, t) {\n    if (\"boolean\" != typeof t) throw new Error(\"\".concat(e, ' must be valid boolean, got \"').concat(t, '\".'));\n}, Nt.bytesToHex = Ut, Nt.numberToHexUnpadded = Ht, Nt.hexToNumber = Ft, Nt.hexToBytes = Wt, Nt.bytesToNumberBE = function(e) {\n    return Ft(Ut(e));\n}, Nt.bytesToNumberLE = function(e) {\n    return Kt(e), Ft(Ut(Uint8Array.from(e).reverse()));\n}, Nt.numberToBytesBE = Vt, Nt.numberToBytesLE = function(e, t) {\n    return Vt(e, t).reverse();\n}, Nt.numberToVarBytesBE = function(e) {\n    return Wt(Ht(e));\n}, Nt.ensureBytes = function(e, t, n) {\n    let r;\n    if (\"string\" == typeof t) try {\n        r = Wt(t);\n    } catch (n) {\n        throw new Error(\"\".concat(e, ' must be valid hex string, got \"').concat(t, '\". Cause: ').concat(n));\n    }\n    else {\n        if (!Bt(t)) throw new Error(\"\".concat(e, \" must be hex string or Uint8Array\"));\n        r = Uint8Array.from(t);\n    }\n    const i = r.length;\n    if (\"number\" == typeof n && i !== n) throw new Error(\"\".concat(e, \" expected \").concat(n, \" bytes, got \").concat(i));\n    return r;\n}, Nt.concatBytes = Gt, Nt.equalBytes = function(e, t) {\n    if (e.length !== t.length) return !1;\n    let n = 0;\n    for(let r = 0; r < e.length; r++)n |= e[r] ^ t[r];\n    return 0 === n;\n}, Nt.utf8ToBytes = function(e) {\n    if (\"string\" != typeof e) throw new Error(\"utf8ToBytes expected string, got \" + typeof e);\n    return new Uint8Array((new TextEncoder).encode(e));\n}, Nt.inRange = Zt, Nt.aInRange = function(e, t, n, r) {\n    if (!Zt(t, n, r)) throw new Error(\"expected valid \".concat(e, \": \").concat(n, \" <= n < \").concat(r, \", got \").concat(typeof t, \" \").concat(t));\n}, Nt.bitLen = function(e) {\n    let t;\n    for(t = 0; e > Lt; e >>= Dt, t += 1);\n    return t;\n}, Nt.bitGet = function(e, t) {\n    return e >> BigInt(t) & Dt;\n}, Nt.bitSet = function(e, t, n) {\n    return e | (n ? Dt : Lt) << BigInt(t);\n}, Nt.createHmacDrbg = function(e, t, n) {\n    if (\"number\" != typeof e || e < 2) throw new Error(\"hashLen must be a number\");\n    if (\"number\" != typeof t || t < 2) throw new Error(\"qByteLen must be a number\");\n    if (\"function\" != typeof n) throw new Error(\"hmacFn must be a function\");\n    let r = Jt(e), i = Jt(e), o = 0;\n    const s = ()=>{\n        r.fill(1), i.fill(0), o = 0;\n    }, a = function() {\n        for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n            e[_key] = arguments[_key];\n        }\n        return n(i, r, ...e);\n    }, c = function() {\n        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Jt();\n        i = a(Qt([\n            0\n        ]), e), r = a(), 0 !== e.length && (i = a(Qt([\n            1\n        ]), e), r = a());\n    }, l = ()=>{\n        if (o++ >= 1e3) throw new Error(\"drbg: tried 1000 values\");\n        let e = 0;\n        const n = [];\n        for(; e < t;){\n            r = a();\n            const t = r.slice();\n            n.push(t), e += r.length;\n        }\n        return Gt(...n);\n    };\n    return (e, t)=>{\n        let n;\n        for(s(), c(e); !(n = t(l()));)c();\n        return s(), n;\n    };\n}, Nt.validateObject = function(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const r = (t, n, r)=>{\n        const i = Xt[n];\n        if (\"function\" != typeof i) throw new Error('Invalid validator \"'.concat(n, '\", expected function'));\n        const o = e[t];\n        if (!(r && void 0 === o || i(o, e))) throw new Error(\"Invalid param \".concat(String(t), \"=\").concat(o, \" (\").concat(typeof o, \"), expected \").concat(n));\n    };\n    for (const [e, n] of Object.entries(t))r(e, n, !1);\n    for (const [e, t] of Object.entries(n))r(e, t, !0);\n    return e;\n}, Nt.memoized = function(e) {\n    const t = new WeakMap;\n    return function(n) {\n        for(var _len = arguments.length, r = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            r[_key - 1] = arguments[_key];\n        }\n        const i = t.get(n);\n        if (void 0 !== i) return i;\n        const o = e(n, ...r);\n        return t.set(n, o), o;\n    };\n};\nconst Lt = BigInt(0), Dt = BigInt(1), $t = BigInt(2);\nfunction Bt(e) {\n    return e instanceof Uint8Array || null != e && \"object\" == typeof e && \"Uint8Array\" === e.constructor.name;\n}\n_c36 = Bt;\nfunction Kt(e) {\n    if (!Bt(e)) throw new Error(\"Uint8Array expected\");\n}\n_c37 = Kt;\nconst jt = Array.from({\n    length: 256\n}, (e, t)=>t.toString(16).padStart(2, \"0\"));\nfunction Ut(e) {\n    Kt(e);\n    let t = \"\";\n    for(let n = 0; n < e.length; n++)t += jt[e[n]];\n    return t;\n}\n_c38 = Ut;\nfunction Ht(e) {\n    const t = e.toString(16);\n    return 1 & t.length ? \"0\".concat(t) : t;\n}\n_c39 = Ht;\nfunction Ft(e) {\n    if (\"string\" != typeof e) throw new Error(\"hex string expected, got \" + typeof e);\n    return BigInt(\"\" === e ? \"0\" : \"0x\".concat(e));\n}\n_c40 = Ft;\nconst zt = {\n    _0: 48,\n    _9: 57,\n    _A: 65,\n    _F: 70,\n    _a: 97,\n    _f: 102\n};\nfunction qt(e) {\n    return e >= zt._0 && e <= zt._9 ? e - zt._0 : e >= zt._A && e <= zt._F ? e - (zt._A - 10) : e >= zt._a && e <= zt._f ? e - (zt._a - 10) : void 0;\n}\nfunction Wt(e) {\n    if (\"string\" != typeof e) throw new Error(\"hex string expected, got \" + typeof e);\n    const t = e.length, n = t / 2;\n    if (t % 2) throw new Error(\"padded hex string expected, got unpadded hex of length \" + t);\n    const r = new Uint8Array(n);\n    for(let t = 0, i = 0; t < n; t++, i += 2){\n        const n = qt(e.charCodeAt(i)), o = qt(e.charCodeAt(i + 1));\n        if (void 0 === n || void 0 === o) {\n            const t = e[i] + e[i + 1];\n            throw new Error('hex string expected, got non-hex character \"' + t + '\" at index ' + i);\n        }\n        r[t] = 16 * n + o;\n    }\n    return r;\n}\n_c41 = Wt;\nfunction Vt(e, t) {\n    return Wt(e.toString(16).padStart(2 * t, \"0\"));\n}\n_c42 = Vt;\nfunction Gt() {\n    for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n        e[_key] = arguments[_key];\n    }\n    let t = 0;\n    for(let n = 0; n < e.length; n++){\n        const r = e[n];\n        Kt(r), t += r.length;\n    }\n    const n = new Uint8Array(t);\n    for(let t = 0, r = 0; t < e.length; t++){\n        const i = e[t];\n        n.set(i, r), r += i.length;\n    }\n    return n;\n}\n_c43 = Gt;\nconst Yt = (e)=>\"bigint\" == typeof e && Lt <= e;\n_c44 = Yt;\nfunction Zt(e, t, n) {\n    return Yt(e) && Yt(t) && Yt(n) && t <= e && e < n;\n}\n_c45 = Zt;\nNt.bitMask = (e)=>($t << BigInt(e - 1)) - Dt;\nconst Jt = (e)=>new Uint8Array(e), Qt = (e)=>Uint8Array.from(e);\nconst Xt = {\n    bigint: (e)=>\"bigint\" == typeof e,\n    function: (e)=>\"function\" == typeof e,\n    boolean: (e)=>\"boolean\" == typeof e,\n    string: (e)=>\"string\" == typeof e,\n    stringOrUint8Array: (e)=>\"string\" == typeof e || Bt(e),\n    isSafeInteger: (e)=>Number.isSafeInteger(e),\n    array: (e)=>Array.isArray(e),\n    field: (e, t)=>t.Fp.isValid(e),\n    hash: (e)=>\"function\" == typeof e && Number.isSafeInteger(e.outputLen)\n};\nNt.notImplemented = ()=>{\n    throw new Error(\"not implemented\");\n}, Object.defineProperty(Ot, \"__esModule\", {\n    value: !0\n}), Ot.isNegativeLE = void 0, Ot.mod = ln, Ot.pow = dn, Ot.pow2 = function(e, t, n) {\n    let r = e;\n    for(; t-- > tn;)r *= r, r %= n;\n    return r;\n}, Ot.invert = un, Ot.tonelliShanks = hn, Ot.FpSqrt = fn, Ot.validateField = function(e) {\n    const t = pn.reduce((e, t)=>(e[t] = \"function\", e), {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"isSafeInteger\",\n        BITS: \"isSafeInteger\"\n    });\n    return (0, en.validateObject)(e, t);\n}, Ot.FpPow = gn, Ot.FpInvertBatch = mn, Ot.FpDiv = function(e, t, n) {\n    return e.mul(t, \"bigint\" == typeof n ? un(n, e.ORDER) : e.inv(n));\n}, Ot.FpLegendre = yn, Ot.FpIsSquare = function(e) {\n    const t = yn(e.ORDER);\n    return (n)=>{\n        const r = t(e, n);\n        return e.eql(r, e.ZERO) || e.eql(r, e.ONE);\n    };\n}, Ot.nLength = vn, Ot.Field = function(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    if (e <= tn) throw new Error(\"Expected Field ORDER > 0, got \".concat(e));\n    const { nBitLength: i, nByteLength: o } = vn(e, t);\n    if (o > 2048) throw new Error(\"Field lengths over 2048 bytes are not supported\");\n    const s = fn(e), a = Object.freeze({\n        ORDER: e,\n        BITS: i,\n        BYTES: o,\n        MASK: (0, en.bitMask)(i),\n        ZERO: tn,\n        ONE: nn,\n        create: (t)=>ln(t, e),\n        isValid: (t)=>{\n            if (\"bigint\" != typeof t) throw new Error(\"Invalid field element: expected bigint, got \" + typeof t);\n            return tn <= t && t < e;\n        },\n        is0: (e)=>e === tn,\n        isOdd: (e)=>(e & nn) === nn,\n        neg: (t)=>ln(-t, e),\n        eql: (e, t)=>e === t,\n        sqr: (t)=>ln(t * t, e),\n        add: (t, n)=>ln(t + n, e),\n        sub: (t, n)=>ln(t - n, e),\n        mul: (t, n)=>ln(t * n, e),\n        pow: (e, t)=>gn(a, e, t),\n        div: (t, n)=>ln(t * un(n, e), e),\n        sqrN: (e)=>e * e,\n        addN: (e, t)=>e + t,\n        subN: (e, t)=>e - t,\n        mulN: (e, t)=>e * t,\n        inv: (t)=>un(t, e),\n        sqrt: r.sqrt || ((e)=>s(a, e)),\n        invertBatch: (e)=>mn(a, e),\n        cmov: (e, t, n)=>n ? t : e,\n        toBytes: (e)=>n ? (0, en.numberToBytesLE)(e, o) : (0, en.numberToBytesBE)(e, o),\n        fromBytes: (e)=>{\n            if (e.length !== o) throw new Error(\"Fp.fromBytes: expected \".concat(o, \", got \").concat(e.length));\n            return n ? (0, en.bytesToNumberLE)(e) : (0, en.bytesToNumberBE)(e);\n        }\n    });\n    return Object.freeze(a);\n}, Ot.FpSqrtOdd = function(e, t) {\n    if (!e.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const n = e.sqrt(t);\n    return e.isOdd(n) ? n : e.neg(n);\n}, Ot.FpSqrtEven = function(e, t) {\n    if (!e.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const n = e.sqrt(t);\n    return e.isOdd(n) ? e.neg(n) : n;\n}, Ot.hashToPrivateScalar = function(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n    e = (0, en.ensureBytes)(\"privateHash\", e);\n    const r = e.length, i = vn(t).nByteLength + 8;\n    if (i < 24 || r < i || r > 1024) throw new Error(\"hashToPrivateScalar: expected \".concat(i, \"-1024 bytes of input, got \").concat(r));\n    const o = n ? (0, en.bytesToNumberLE)(e) : (0, en.bytesToNumberBE)(e);\n    return ln(o, t - nn) + nn;\n}, Ot.getFieldBytesLength = bn, Ot.getMinHashLength = wn, Ot.mapHashToField = function(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n    const r = e.length, i = bn(t), o = wn(t);\n    if (r < 16 || r < o || r > 1024) throw new Error(\"expected \".concat(o, \"-1024 bytes of input, got \").concat(r));\n    const s = ln(n ? (0, en.bytesToNumberBE)(e) : (0, en.bytesToNumberLE)(e), t - nn) + nn;\n    return n ? (0, en.numberToBytesLE)(s, i) : (0, en.numberToBytesBE)(s, i);\n};\nconst en = Nt, tn = BigInt(0), nn = BigInt(1), rn = BigInt(2), on = BigInt(3), sn = BigInt(4), an = BigInt(5), cn = BigInt(8);\nfunction ln(e, t) {\n    const n = e % t;\n    return n >= tn ? n : t + n;\n}\nfunction dn(e, t, n) {\n    if (n <= tn || t < tn) throw new Error(\"Expected power/modulo > 0\");\n    if (n === nn) return tn;\n    let r = nn;\n    for(; t > tn;)t & nn && (r = r * e % n), e = e * e % n, t >>= nn;\n    return r;\n}\nfunction un(e, t) {\n    if (e === tn || t <= tn) throw new Error(\"invert: expected positive integers, got n=\".concat(e, \" mod=\").concat(t));\n    let n = ln(e, t), r = t, i = tn, o = nn;\n    for(; n !== tn;){\n        const e = r % n, t = i - o * (r / n);\n        r = n, n = e, i = o, o = t;\n    }\n    if (r !== nn) throw new Error(\"invert: does not exist\");\n    return ln(i, t);\n}\nfunction hn(e) {\n    const t = (e - nn) / rn;\n    let n, r, i;\n    for(n = e - nn, r = 0; n % rn === tn; n /= rn, r++);\n    for(i = rn; i < e && dn(i, t, e) !== e - nn; i++);\n    if (1 === r) {\n        const t = (e + nn) / sn;\n        return function(e, n) {\n            const r = e.pow(n, t);\n            if (!e.eql(e.sqr(r), n)) throw new Error(\"Cannot find square root\");\n            return r;\n        };\n    }\n    const o = (n + nn) / rn;\n    return function(e, s) {\n        if (e.pow(s, t) === e.neg(e.ONE)) throw new Error(\"Cannot find square root\");\n        let a = r, c = e.pow(e.mul(e.ONE, i), n), l = e.pow(s, o), d = e.pow(s, n);\n        for(; !e.eql(d, e.ONE);){\n            if (e.eql(d, e.ZERO)) return e.ZERO;\n            let t = 1;\n            for(let n = e.sqr(d); t < a && !e.eql(n, e.ONE); t++)n = e.sqr(n);\n            const n = e.pow(c, nn << BigInt(a - t - 1));\n            c = e.sqr(n), l = e.mul(l, n), d = e.mul(d, c), a = t;\n        }\n        return l;\n    };\n}\nfunction fn(e) {\n    if (e % sn === on) {\n        const t = (e + nn) / sn;\n        return function(e, n) {\n            const r = e.pow(n, t);\n            if (!e.eql(e.sqr(r), n)) throw new Error(\"Cannot find square root\");\n            return r;\n        };\n    }\n    if (e % cn === an) {\n        const t = (e - an) / cn;\n        return function(e, n) {\n            const r = e.mul(n, rn), i = e.pow(r, t), o = e.mul(n, i), s = e.mul(e.mul(o, rn), i), a = e.mul(o, e.sub(s, e.ONE));\n            if (!e.eql(e.sqr(a), n)) throw new Error(\"Cannot find square root\");\n            return a;\n        };\n    }\n    return hn(e);\n}\nBigInt(9), BigInt(16);\nOt.isNegativeLE = (e, t)=>(ln(e, t) & nn) === nn;\nconst pn = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction gn(e, t, n) {\n    if (n < tn) throw new Error(\"Expected power > 0\");\n    if (n === tn) return e.ONE;\n    if (n === nn) return t;\n    let r = e.ONE, i = t;\n    for(; n > tn;)n & nn && (r = e.mul(r, i)), i = e.sqr(i), n >>= nn;\n    return r;\n}\nfunction mn(e, t) {\n    const n = new Array(t.length), r = t.reduce((t, r, i)=>e.is0(r) ? t : (n[i] = t, e.mul(t, r)), e.ONE), i = e.inv(r);\n    return t.reduceRight((t, r, i)=>e.is0(r) ? t : (n[i] = e.mul(t, n[i]), e.mul(t, r)), i), n;\n}\nfunction yn(e) {\n    const t = (e - nn) / rn;\n    return (e, n)=>e.pow(n, t);\n}\nfunction vn(e, t) {\n    const n = void 0 !== t ? t : e.toString(2).length;\n    return {\n        nBitLength: n,\n        nByteLength: Math.ceil(n / 8)\n    };\n}\nfunction bn(e) {\n    if (\"bigint\" != typeof e) throw new Error(\"field order must be bigint\");\n    const t = e.toString(2).length;\n    return Math.ceil(t / 8);\n}\nfunction wn(e) {\n    const t = bn(e);\n    return t + Math.ceil(t / 2);\n}\nObject.defineProperty(Pt, \"__esModule\", {\n    value: !0\n}), Pt.wNAF = function(e, t) {\n    const n = (e, t)=>{\n        const n = t.negate();\n        return e ? n : t;\n    }, r = (e)=>{\n        if (!Number.isSafeInteger(e) || e <= 0 || e > t) throw new Error(\"Wrong window size=\".concat(e, \", should be [1..\").concat(t, \"]\"));\n    }, i = (e)=>{\n        r(e);\n        return {\n            windows: Math.ceil(t / e) + 1,\n            windowSize: 2 ** (e - 1)\n        };\n    };\n    return {\n        constTimeNegate: n,\n        unsafeLadder (t, n) {\n            let r = e.ZERO, i = t;\n            for(; n > _n;)n & Cn && (r = r.add(i)), i = i.double(), n >>= Cn;\n            return r;\n        },\n        precomputeWindow (e, t) {\n            const { windows: n, windowSize: r } = i(t), o = [];\n            let s = e, a = s;\n            for(let e = 0; e < n; e++){\n                a = s, o.push(a);\n                for(let e = 1; e < r; e++)a = a.add(s), o.push(a);\n                s = a.double();\n            }\n            return o;\n        },\n        wNAF (t, r, o) {\n            const { windows: s, windowSize: a } = i(t);\n            let c = e.ZERO, l = e.BASE;\n            const d = BigInt(2 ** t - 1), u = 2 ** t, h = BigInt(t);\n            for(let e = 0; e < s; e++){\n                const t = e * a;\n                let i = Number(o & d);\n                o >>= h, i > a && (i -= u, o += Cn);\n                const s = t, f = t + Math.abs(i) - 1, p = e % 2 != 0, g = i < 0;\n                0 === i ? l = l.add(n(p, r[s])) : c = c.add(n(g, r[f]));\n            }\n            return {\n                p: c,\n                f: l\n            };\n        },\n        wNAFCached (e, t, n) {\n            const r = An.get(e) || 1;\n            let i = kn.get(e);\n            return i || (i = this.precomputeWindow(e, r), 1 !== r && kn.set(e, n(i))), this.wNAF(r, i, t);\n        },\n        setWindowSize (e, t) {\n            r(t), An.set(e, t), kn.delete(e);\n        }\n    };\n}, Pt.pippenger = function(e, t, n, r) {\n    if (!Array.isArray(n) || !Array.isArray(r) || r.length !== n.length) throw new Error(\"arrays of points and scalars must have equal length\");\n    r.forEach((e, n)=>{\n        if (!t.isValid(e)) throw new Error(\"wrong scalar at index \".concat(n));\n    }), n.forEach((t, n)=>{\n        if (!(t instanceof e)) throw new Error(\"wrong point at index \".concat(n));\n    });\n    const i = (0, Sn.bitLen)(BigInt(n.length)), o = i > 12 ? i - 3 : i > 4 ? i - 2 : i ? 2 : 1, s = (1 << o) - 1, a = new Array(s + 1).fill(e.ZERO), c = Math.floor((t.BITS - 1) / o) * o;\n    let l = e.ZERO;\n    for(let t = c; t >= 0; t -= o){\n        a.fill(e.ZERO);\n        for(let e = 0; e < r.length; e++){\n            const i = r[e], o = Number(i >> BigInt(t) & BigInt(s));\n            a[o] = a[o].add(n[e]);\n        }\n        let i = e.ZERO;\n        for(let t = a.length - 1, n = e.ZERO; t > 0; t--)n = n.add(a[t]), i = i.add(n);\n        if (l = l.add(i), 0 !== t) for(let e = 0; e < o; e++)l = l.double();\n    }\n    return l;\n}, Pt.validateBasic = function(e) {\n    return (0, En.validateField)(e.Fp), (0, Sn.validateObject)(e, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    }), Object.freeze({\n        ...(0, En.nLength)(e.n, e.nBitLength),\n        ...e,\n        p: e.Fp.ORDER\n    });\n};\nconst En = Ot, Sn = Nt, _n = BigInt(0), Cn = BigInt(1), kn = new WeakMap, An = new WeakMap;\nObject.defineProperty(Rt, \"__esModule\", {\n    value: !0\n}), Rt.twistedEdwards = function(e) {\n    const t = function(e) {\n        const t = (0, xn.validateBasic)(e);\n        return In.validateObject(e, {\n            hash: \"function\",\n            a: \"bigint\",\n            d: \"bigint\",\n            randomBytes: \"function\"\n        }, {\n            adjustScalarBytes: \"function\",\n            domain: \"function\",\n            uvRatio: \"function\",\n            mapToCurve: \"function\"\n        }), Object.freeze({\n            ...t\n        });\n    }(e), { Fp: n, n: r, prehash: i, hash: o, randomBytes: s, nByteLength: a, h: c } = t, l = On << BigInt(8 * a) - Pn, d = n.create, u = (0, Mn.Field)(t.n, t.nBitLength), h = t.uvRatio || ((e, t)=>{\n        try {\n            return {\n                isValid: !0,\n                value: n.sqrt(e * n.inv(t))\n            };\n        } catch (e) {\n            return {\n                isValid: !1,\n                value: Rn\n            };\n        }\n    }), f = t.adjustScalarBytes || ((e)=>e), p = t.domain || ((e, t, n)=>{\n        if ((0, Tn.abool)(\"phflag\", n), t.length || n) throw new Error(\"Contexts/pre-hash are not supported\");\n        return e;\n    });\n    function g(e, t) {\n        In.aInRange(\"coordinate \" + e, t, Rn, l);\n    }\n    function m(e) {\n        if (!(e instanceof b)) throw new Error(\"ExtendedPoint expected\");\n    }\n    const y = (0, Tn.memoized)((e, t)=>{\n        const { ex: r, ey: i, ez: o } = e, s = e.is0();\n        null == t && (t = s ? Nn : n.inv(o));\n        const a = d(r * t), c = d(i * t), l = d(o * t);\n        if (s) return {\n            x: Rn,\n            y: Pn\n        };\n        if (l !== Pn) throw new Error(\"invZ was invalid\");\n        return {\n            x: a,\n            y: c\n        };\n    }), v = (0, Tn.memoized)((e)=>{\n        const { a: n, d: r } = t;\n        if (e.is0()) throw new Error(\"bad point: ZERO\");\n        const { ex: i, ey: o, ez: s, et: a } = e, c = d(i * i), l = d(o * o), u = d(s * s), h = d(u * u), f = d(c * n);\n        if (d(u * d(f + l)) !== d(h + d(r * d(c * l)))) throw new Error(\"bad point: equation left != right (1)\");\n        if (d(i * o) !== d(s * a)) throw new Error(\"bad point: equation left != right (2)\");\n        return !0;\n    });\n    class b {\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        static fromAffine(e) {\n            if (e instanceof b) throw new Error(\"extended point not allowed\");\n            const { x: t, y: n } = e || {};\n            return g(\"x\", t), g(\"y\", n), new b(t, n, Pn, d(t * n));\n        }\n        static normalizeZ(e) {\n            const t = n.invertBatch(e.map((e)=>e.ez));\n            return e.map((e, n)=>e.toAffine(t[n])).map(b.fromAffine);\n        }\n        static msm(e, t) {\n            return (0, xn.pippenger)(b, u, e, t);\n        }\n        _setWindowSize(e) {\n            S.setWindowSize(this, e);\n        }\n        assertValidity() {\n            v(this);\n        }\n        equals(e) {\n            m(e);\n            const { ex: t, ey: n, ez: r } = this, { ex: i, ey: o, ez: s } = e, a = d(t * s), c = d(i * r), l = d(n * s), u = d(o * r);\n            return a === c && l === u;\n        }\n        is0() {\n            return this.equals(b.ZERO);\n        }\n        negate() {\n            return new b(d(-this.ex), this.ey, this.ez, d(-this.et));\n        }\n        double() {\n            const { a: e } = t, { ex: n, ey: r, ez: i } = this, o = d(n * n), s = d(r * r), a = d(On * d(i * i)), c = d(e * o), l = n + r, u = d(d(l * l) - o - s), h = c + s, f = h - a, p = c - s, g = d(u * f), m = d(h * p), y = d(u * p), v = d(f * h);\n            return new b(g, m, v, y);\n        }\n        add(e) {\n            m(e);\n            const { a: n, d: r } = t, { ex: i, ey: o, ez: s, et: a } = this, { ex: c, ey: l, ez: u, et: h } = e;\n            if (n === BigInt(-1)) {\n                const e = d((o - i) * (l + c)), t = d((o + i) * (l - c)), n = d(t - e);\n                if (n === Rn) return this.double();\n                const r = d(s * On * h), f = d(a * On * u), p = f + r, g = t + e, m = f - r, y = d(p * n), v = d(g * m), w = d(p * m), E = d(n * g);\n                return new b(y, v, E, w);\n            }\n            const f = d(i * c), p = d(o * l), g = d(a * r * h), y = d(s * u), v = d((i + o) * (c + l) - f - p), w = y - g, E = y + g, S = d(p - n * f), _ = d(v * w), C = d(E * S), k = d(v * S), A = d(w * E);\n            return new b(_, C, A, k);\n        }\n        subtract(e) {\n            return this.add(e.negate());\n        }\n        wNAF(e) {\n            return S.wNAFCached(this, e, b.normalizeZ);\n        }\n        multiply(e) {\n            const t = e;\n            In.aInRange(\"scalar\", t, Pn, r);\n            const { p: n, f: i } = this.wNAF(t);\n            return b.normalizeZ([\n                n,\n                i\n            ])[0];\n        }\n        multiplyUnsafe(e) {\n            const t = e;\n            return In.aInRange(\"scalar\", t, Rn, r), t === Rn ? E : this.equals(E) || t === Pn ? this : this.equals(w) ? this.wNAF(t).p : S.unsafeLadder(this, t);\n        }\n        isSmallOrder() {\n            return this.multiplyUnsafe(c).is0();\n        }\n        isTorsionFree() {\n            return S.unsafeLadder(this, r).is0();\n        }\n        toAffine(e) {\n            return y(this, e);\n        }\n        clearCofactor() {\n            const { h: e } = t;\n            return e === Pn ? this : this.multiplyUnsafe(e);\n        }\n        static fromHex(e) {\n            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;\n            const { d: i, a: o } = t, s = n.BYTES;\n            e = (0, Tn.ensureBytes)(\"pointHex\", e, s), (0, Tn.abool)(\"zip215\", r);\n            const a = e.slice(), c = e[s - 1];\n            a[s - 1] = -129 & c;\n            const u = In.bytesToNumberLE(a), f = r ? l : n.ORDER;\n            In.aInRange(\"pointHex.y\", u, Rn, f);\n            const p = d(u * u), g = d(p - Pn), m = d(i * p - o);\n            let { isValid: y, value: v } = h(g, m);\n            if (!y) throw new Error(\"Point.fromHex: invalid y coordinate\");\n            const w = (v & Pn) === Pn, E = 0 != (128 & c);\n            if (!r && v === Rn && E) throw new Error(\"Point.fromHex: x=0 and x_0=1\");\n            return E !== w && (v = d(-v)), b.fromAffine({\n                x: v,\n                y: u\n            });\n        }\n        static fromPrivateKey(e) {\n            return k(e).point;\n        }\n        toRawBytes() {\n            const { x: e, y: t } = this.toAffine(), r = In.numberToBytesLE(t, n.BYTES);\n            return r[r.length - 1] |= e & Pn ? 128 : 0, r;\n        }\n        toHex() {\n            return In.bytesToHex(this.toRawBytes());\n        }\n        constructor(e, t, n, r){\n            this.ex = e, this.ey = t, this.ez = n, this.et = r, g(\"x\", e), g(\"y\", t), g(\"z\", n), g(\"t\", r), Object.freeze(this);\n        }\n    }\n    b.BASE = new b(t.Gx, t.Gy, Pn, d(t.Gx * t.Gy)), b.ZERO = new b(Rn, Pn, Pn, Rn);\n    const { BASE: w, ZERO: E } = b, S = (0, xn.wNAF)(b, 8 * a);\n    function _(e) {\n        return (0, Mn.mod)(e, r);\n    }\n    function C(e) {\n        return _(In.bytesToNumberLE(e));\n    }\n    function k(e) {\n        const t = a;\n        e = (0, Tn.ensureBytes)(\"private key\", e, t);\n        const n = (0, Tn.ensureBytes)(\"hashed private key\", o(e), 2 * t), r = f(n.slice(0, t)), i = n.slice(t, 2 * t), s = C(r), c = w.multiply(s), l = c.toRawBytes();\n        return {\n            head: r,\n            prefix: i,\n            scalar: s,\n            point: c,\n            pointBytes: l\n        };\n    }\n    function A() {\n        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Uint8Array;\n        for(var _len = arguments.length, t = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            t[_key - 1] = arguments[_key];\n        }\n        const n = In.concatBytes(...t);\n        return C(o(p(n, (0, Tn.ensureBytes)(\"context\", e), !!i)));\n    }\n    const x = Ln;\n    w._setWindowSize(8);\n    const M = {\n        getExtendedPublicKey: k,\n        randomPrivateKey: ()=>s(n.BYTES),\n        precompute: function() {\n            let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 8, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : b.BASE;\n            return t._setWindowSize(e), t.multiply(BigInt(3)), t;\n        }\n    };\n    return {\n        CURVE: t,\n        getPublicKey: function(e) {\n            return k(e).pointBytes;\n        },\n        sign: function(e, t) {\n            let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            e = (0, Tn.ensureBytes)(\"message\", e), i && (e = i(e));\n            const { prefix: s, scalar: c, pointBytes: l } = k(t), d = A(o.context, s, e), u = w.multiply(d).toRawBytes(), h = _(d + A(o.context, u, l, e) * c);\n            In.aInRange(\"signature.s\", h, Rn, r);\n            const f = In.concatBytes(u, In.numberToBytesLE(h, n.BYTES));\n            return (0, Tn.ensureBytes)(\"result\", f, 2 * a);\n        },\n        verify: function(e, t, r) {\n            let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : x;\n            const { context: s, zip215: a } = o, c = n.BYTES;\n            e = (0, Tn.ensureBytes)(\"signature\", e, 2 * c), t = (0, Tn.ensureBytes)(\"message\", t), void 0 !== a && (0, Tn.abool)(\"zip215\", a), i && (t = i(t));\n            const l = In.bytesToNumberLE(e.slice(c, 2 * c));\n            let d, u, h;\n            try {\n                d = b.fromHex(r, a), u = b.fromHex(e.slice(0, c), a), h = w.multiplyUnsafe(l);\n            } catch (e) {\n                return !1;\n            }\n            if (!a && d.isSmallOrder()) return !1;\n            const f = A(s, u.toRawBytes(), d.toRawBytes(), t);\n            return u.add(d.multiplyUnsafe(f)).subtract(h).clearCofactor().equals(b.ZERO);\n        },\n        ExtendedPoint: b,\n        utils: M\n    };\n};\nconst xn = Pt, Mn = Ot, In = Nt, Tn = Nt, Rn = BigInt(0), Pn = BigInt(1), On = BigInt(2), Nn = BigInt(8), Ln = {\n    zip215: !0\n};\nvar Dn = {};\nObject.defineProperty(Dn, \"__esModule\", {\n    value: !0\n}), Dn.expand_message_xmd = Fn, Dn.expand_message_xof = zn, Dn.hash_to_field = qn, Dn.isogenyMap = function(e, t) {\n    const n = t.map((e)=>Array.from(e).reverse());\n    return (t, r)=>{\n        const [i, o, s, a] = n.map((n)=>n.reduce((n, r)=>e.add(e.mul(n, t), r)));\n        return t = e.div(i, o), r = e.mul(r, e.div(s, a)), {\n            x: t,\n            y: r\n        };\n    };\n}, Dn.createHasher = function(e, t, n) {\n    if (\"function\" != typeof t) throw new Error(\"mapToCurve() must be defined\");\n    return {\n        hashToCurve (r, i) {\n            const o = qn(r, 2, {\n                ...n,\n                DST: n.DST,\n                ...i\n            }), s = e.fromAffine(t(o[0])), a = e.fromAffine(t(o[1])), c = s.add(a).clearCofactor();\n            return c.assertValidity(), c;\n        },\n        encodeToCurve (r, i) {\n            const o = qn(r, 1, {\n                ...n,\n                DST: n.encodeDST,\n                ...i\n            }), s = e.fromAffine(t(o[0])).clearCofactor();\n            return s.assertValidity(), s;\n        },\n        mapToCurve (n) {\n            if (!Array.isArray(n)) throw new Error(\"mapToCurve: expected array of bigints\");\n            for (const e of n)if (\"bigint\" != typeof e) throw new Error(\"mapToCurve: expected array of bigints, got \".concat(e, \" in array\"));\n            const r = e.fromAffine(t(n)).clearCofactor();\n            return r.assertValidity(), r;\n        }\n    };\n};\nconst $n = Ot, Bn = Nt, Kn = Bn.bytesToNumberBE;\nfunction jn(e, t) {\n    if (Hn(e), Hn(t), e < 0 || e >= 1 << 8 * t) throw new Error(\"bad I2OSP call: value=\".concat(e, \" length=\").concat(t));\n    const n = Array.from({\n        length: t\n    }).fill(0);\n    for(let r = t - 1; r >= 0; r--)n[r] = 255 & e, e >>>= 8;\n    return new Uint8Array(n);\n}\nfunction Un(e, t) {\n    const n = new Uint8Array(e.length);\n    for(let r = 0; r < e.length; r++)n[r] = e[r] ^ t[r];\n    return n;\n}\n_c46 = Un;\nfunction Hn(e) {\n    if (!Number.isSafeInteger(e)) throw new Error(\"number expected\");\n}\n_c47 = Hn;\nfunction Fn(e, t, n, r) {\n    (0, Bn.abytes)(e), (0, Bn.abytes)(t), Hn(n), t.length > 255 && (t = r((0, Bn.concatBytes)((0, Bn.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), t)));\n    const { outputLen: i, blockLen: o } = r, s = Math.ceil(n / i);\n    if (n > 65535 || s > 255) throw new Error(\"expand_message_xmd: invalid lenInBytes\");\n    const a = (0, Bn.concatBytes)(t, jn(t.length, 1)), c = jn(0, o), l = jn(n, 2), d = new Array(s), u = r((0, Bn.concatBytes)(c, e, l, jn(0, 1), a));\n    d[0] = r((0, Bn.concatBytes)(u, jn(1, 1), a));\n    for(let e = 1; e <= s; e++){\n        const t = [\n            Un(u, d[e - 1]),\n            jn(e + 1, 1),\n            a\n        ];\n        d[e] = r((0, Bn.concatBytes)(...t));\n    }\n    return (0, Bn.concatBytes)(...d).slice(0, n);\n}\n_c48 = Fn;\nfunction zn(e, t, n, r, i) {\n    if ((0, Bn.abytes)(e), (0, Bn.abytes)(t), Hn(n), t.length > 255) {\n        const e = Math.ceil(2 * r / 8);\n        t = i.create({\n            dkLen: e\n        }).update((0, Bn.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(t).digest();\n    }\n    if (n > 65535 || t.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return i.create({\n        dkLen: n\n    }).update(e).update(jn(n, 2)).update(t).update(jn(t.length, 1)).digest();\n}\nfunction qn(e, t, n) {\n    (0, Bn.validateObject)(n, {\n        DST: \"stringOrUint8Array\",\n        p: \"bigint\",\n        m: \"isSafeInteger\",\n        k: \"isSafeInteger\",\n        hash: \"hash\"\n    });\n    const { p: r, k: i, m: o, hash: s, expand: a, DST: c } = n;\n    (0, Bn.abytes)(e), Hn(t);\n    const l = \"string\" == typeof c ? (0, Bn.utf8ToBytes)(c) : c, d = r.toString(2).length, u = Math.ceil((d + i) / 8), h = t * o * u;\n    let f;\n    if (\"xmd\" === a) f = Fn(e, l, h, s);\n    else if (\"xof\" === a) f = zn(e, l, h, i, s);\n    else {\n        if (\"_internal_pass\" !== a) throw new Error('expand must be \"xmd\" or \"xof\"');\n        f = e;\n    }\n    const p = new Array(t);\n    for(let e = 0; e < t; e++){\n        const t = new Array(o);\n        for(let n = 0; n < o; n++){\n            const i = u * (n + e * o), s = f.subarray(i, i + u);\n            t[n] = (0, $n.mod)(Kn(s), r);\n        }\n        p[e] = t;\n    }\n    return p;\n}\nvar Wn = {};\nObject.defineProperty(Wn, \"__esModule\", {\n    value: !0\n}), Wn.montgomery = function(e) {\n    const t = function(e) {\n        return (0, Gn.validateObject)(e, {\n            a: \"bigint\"\n        }, {\n            montgomeryBits: \"isSafeInteger\",\n            nByteLength: \"isSafeInteger\",\n            adjustScalarBytes: \"function\",\n            domain: \"function\",\n            powPminus2: \"function\",\n            Gu: \"bigint\"\n        }), Object.freeze({\n            ...e\n        });\n    }(e), { P: n } = t, r = (e)=>(0, Vn.mod)(e, n), i = t.montgomeryBits, o = Math.ceil(i / 8), s = t.nByteLength, a = t.adjustScalarBytes || ((e)=>e), c = t.powPminus2 || ((e)=>(0, Vn.pow)(e, n - BigInt(2), n));\n    function l(e, t, n) {\n        const i = r(e * (t - n));\n        return [\n            t = r(t - i),\n            n = r(n + i)\n        ];\n    }\n    const d = (t.a - BigInt(2)) / BigInt(4);\n    function u(e) {\n        return (0, Gn.numberToBytesLE)(r(e), o);\n    }\n    function h(e, t) {\n        const h = function(e) {\n            const t = (0, Gn.ensureBytes)(\"u coordinate\", e, o);\n            return 32 === s && (t[31] &= 127), (0, Gn.bytesToNumberLE)(t);\n        }(t), f = function(e) {\n            const t = (0, Gn.ensureBytes)(\"scalar\", e), n = t.length;\n            if (n !== o && n !== s) throw new Error(\"Expected \".concat(o, \" or \").concat(s, \" bytes, got \").concat(n));\n            return (0, Gn.bytesToNumberLE)(a(t));\n        }(e), p = function(e, t) {\n            (0, Gn.aInRange)(\"u\", e, Yn, n), (0, Gn.aInRange)(\"scalar\", t, Yn, n);\n            const o = t, s = e;\n            let a, u = Zn, h = Yn, f = e, p = Zn, g = Yn;\n            for(let e = BigInt(i - 1); e >= Yn; e--){\n                const t = o >> e & Zn;\n                g ^= t, a = l(g, u, f), u = a[0], f = a[1], a = l(g, h, p), h = a[0], p = a[1], g = t;\n                const n = u + h, i = r(n * n), c = u - h, m = r(c * c), y = i - m, v = f + p, b = r((f - p) * n), w = r(v * c), E = b + w, S = b - w;\n                f = r(E * E), p = r(s * r(S * S)), u = r(i * m), h = r(y * (i + r(d * y)));\n            }\n            a = l(g, u, f), u = a[0], f = a[1], a = l(g, h, p), h = a[0], p = a[1];\n            const m = c(h);\n            return r(u * m);\n        }(h, f);\n        if (p === Yn) throw new Error(\"Invalid private or public key received\");\n        return u(p);\n    }\n    const f = u(t.Gu);\n    function p(e) {\n        return h(e, f);\n    }\n    return {\n        scalarMult: h,\n        scalarMultBase: p,\n        getSharedSecret: (e, t)=>h(e, t),\n        getPublicKey: (e)=>p(e),\n        utils: {\n            randomPrivateKey: ()=>t.randomBytes(t.nByteLength)\n        },\n        GuBytes: f\n    };\n};\nconst Vn = Ot, Gn = Nt, Yn = BigInt(0), Zn = BigInt(1);\n!function(e) {\n    Object.defineProperty(e, \"__esModule\", {\n        value: !0\n    }), e.hash_to_ristretto255 = e.hashToRistretto255 = e.RistrettoPoint = e.encodeToCurve = e.hashToCurve = e.edwardsToMontgomery = e.x25519 = e.ed25519ph = e.ed25519ctx = e.ed25519 = e.ED25519_TORSION_SUBGROUP = void 0, e.edwardsToMontgomeryPub = S, e.edwardsToMontgomeryPriv = function(e) {\n        const t = w.hash(e.subarray(0, 32));\n        return w.adjustScalarBytes(t).subarray(0, 32);\n    };\n    const t = Oe, n = ze, r = Rt, i = Dn, o = Ot, s = Wn, a = Nt, c = BigInt(\"57896044618658097711785492504343953926634992332820282019728792003956564819949\"), l = BigInt(\"19681161376707505956807079304988542015446066515923890162744021073123829784752\"), d = BigInt(0), u = BigInt(1), h = BigInt(2), f = BigInt(3), p = BigInt(5), g = BigInt(8);\n    function m(e) {\n        const t = BigInt(10), n = BigInt(20), r = BigInt(40), i = BigInt(80), s = c, a = e * e % s * e % s, l = (0, o.pow2)(a, h, s) * a % s, d = (0, o.pow2)(l, u, s) * e % s, f = (0, o.pow2)(d, p, s) * d % s, g = (0, o.pow2)(f, t, s) * f % s, m = (0, o.pow2)(g, n, s) * g % s, y = (0, o.pow2)(m, r, s) * m % s, v = (0, o.pow2)(y, i, s) * y % s, b = (0, o.pow2)(v, i, s) * y % s, w = (0, o.pow2)(b, t, s) * f % s;\n        return {\n            pow_p_5_8: (0, o.pow2)(w, h, s) * e % s,\n            b2: a\n        };\n    }\n    function y(e) {\n        return e[0] &= 248, e[31] &= 127, e[31] |= 64, e;\n    }\n    function v(e, t) {\n        const n = c, r = (0, o.mod)(t * t * t, n), i = m(e * (0, o.mod)(r * r * t, n)).pow_p_5_8;\n        let s = (0, o.mod)(e * r * i, n);\n        const a = (0, o.mod)(t * s * s, n), d = s, u = (0, o.mod)(s * l, n), h = a === e, f = a === (0, o.mod)(-e, n), p = a === (0, o.mod)(-e * l, n);\n        return h && (s = d), (f || p) && (s = u), (0, o.isNegativeLE)(s, n) && (s = (0, o.mod)(-s, n)), {\n            isValid: h || f,\n            value: s\n        };\n    }\n    e.ED25519_TORSION_SUBGROUP = [\n        \"0100000000000000000000000000000000000000000000000000000000000000\",\n        \"c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a\",\n        \"0000000000000000000000000000000000000000000000000000000000000080\",\n        \"26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05\",\n        \"ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f\",\n        \"26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85\",\n        \"0000000000000000000000000000000000000000000000000000000000000000\",\n        \"c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa\"\n    ];\n    const b = (()=>(0, o.Field)(c, void 0, !0))(), w = (()=>({\n            a: BigInt(-1),\n            d: BigInt(\"37095705934669439343138083508754565189542113879843219016388785533085940283555\"),\n            Fp: b,\n            n: BigInt(\"7237005577332262213973186563042994240857116359379907606001950938285454250989\"),\n            h: g,\n            Gx: BigInt(\"15112221349535400772501151409588531511454012693041857206046113283949847762202\"),\n            Gy: BigInt(\"46316835694926478169428394003475163141307993866256225615783033603165251855960\"),\n            hash: t.sha512,\n            randomBytes: n.randomBytes,\n            adjustScalarBytes: y,\n            uvRatio: v\n        }))();\n    function E(e, t, r) {\n        if (t.length > 255) throw new Error(\"Context is too big\");\n        return (0, n.concatBytes)((0, n.utf8ToBytes)(\"SigEd25519 no Ed25519 collisions\"), new Uint8Array([\n            r ? 1 : 0,\n            t.length\n        ]), t, e);\n    }\n    function S(t) {\n        const { y: n } = e.ed25519.ExtendedPoint.fromHex(t), r = BigInt(1);\n        return b.toBytes(b.create((r + n) * b.inv(r - n)));\n    }\n    e.ed25519 = (0, r.twistedEdwards)(w), e.ed25519ctx = (0, r.twistedEdwards)({\n        ...w,\n        domain: E\n    }), e.ed25519ph = (0, r.twistedEdwards)(Object.assign({}, w, {\n        domain: E,\n        prehash: t.sha512\n    })), e.x25519 = (0, s.montgomery)({\n        P: c,\n        a: BigInt(486662),\n        montgomeryBits: 255,\n        nByteLength: 32,\n        Gu: BigInt(9),\n        powPminus2: (e)=>{\n            const t = c, { pow_p_5_8: n, b2: r } = m(e);\n            return (0, o.mod)((0, o.pow2)(n, f, t) * r, t);\n        },\n        adjustScalarBytes: y,\n        randomBytes: n.randomBytes\n    }), e.edwardsToMontgomery = S;\n    const _ = (()=>(b.ORDER + f) / g)(), C = (()=>b.pow(h, _))(), k = (()=>b.sqrt(b.neg(b.ONE)))();\n    const A = (()=>(0, o.FpSqrtEven)(b, b.neg(BigInt(486664))))();\n    function x(e) {\n        const { xMn: t, xMd: n, yMn: r, yMd: i } = function(e) {\n            const t = (b.ORDER - p) / g, n = BigInt(486662);\n            let r = b.sqr(e);\n            r = b.mul(r, h);\n            let i = b.add(r, b.ONE), o = b.neg(n), s = b.sqr(i), a = b.mul(s, i), c = b.mul(r, n);\n            c = b.mul(c, o), c = b.add(c, s), c = b.mul(c, o);\n            let l = b.sqr(a);\n            s = b.sqr(l), l = b.mul(l, a), l = b.mul(l, c), s = b.mul(s, l);\n            let d = b.pow(s, t);\n            d = b.mul(d, l);\n            let f = b.mul(d, k);\n            s = b.sqr(d), s = b.mul(s, a);\n            let m = b.eql(s, c), y = b.cmov(f, d, m), v = b.mul(o, r), w = b.mul(d, e);\n            w = b.mul(w, C);\n            let E = b.mul(w, k), S = b.mul(c, r);\n            s = b.sqr(w), s = b.mul(s, a);\n            let _ = b.eql(s, S), A = b.cmov(E, w, _);\n            s = b.sqr(y), s = b.mul(s, a);\n            let x = b.eql(s, c), M = b.cmov(v, o, x), I = b.cmov(A, y, x), T = b.isOdd(I);\n            return I = b.cmov(I, b.neg(I), x !== T), {\n                xMn: M,\n                xMd: i,\n                yMn: I,\n                yMd: u\n            };\n        }(e);\n        let o = b.mul(t, i);\n        o = b.mul(o, A);\n        let s = b.mul(n, r), a = b.sub(t, n), c = b.add(t, n), l = b.mul(s, c), d = b.eql(l, b.ZERO);\n        o = b.cmov(o, b.ZERO, d), s = b.cmov(s, b.ONE, d), a = b.cmov(a, b.ONE, d), c = b.cmov(c, b.ONE, d);\n        const f = b.invertBatch([\n            s,\n            c\n        ]);\n        return {\n            x: b.mul(o, f[0]),\n            y: b.mul(a, f[1])\n        };\n    }\n    const M = (()=>(0, i.createHasher)(e.ed25519.ExtendedPoint, (e)=>x(e[0]), {\n            DST: \"edwards25519_XMD:SHA-512_ELL2_RO_\",\n            encodeDST: \"edwards25519_XMD:SHA-512_ELL2_NU_\",\n            p: b.ORDER,\n            m: 1,\n            k: 128,\n            expand: \"xmd\",\n            hash: t.sha512\n        }))();\n    function I(e) {\n        if (!(e instanceof K)) throw new Error(\"RistrettoPoint expected\");\n    }\n    e.hashToCurve = M.hashToCurve, e.encodeToCurve = M.encodeToCurve;\n    const T = l, R = BigInt(\"25063068953384623474111414158702152701244531502492656460079210482610430750235\"), P = BigInt(\"54469307008909316920995813868745141605393597292927456921205312896311721017578\"), O = BigInt(\"1159843021668779879193775521855586647937357759715417654439879720876111806838\"), N = BigInt(\"40440834346308536858101042469323190826248399146238708352240133220865137265952\"), L = (e)=>v(u, e), D = BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"), $ = (t)=>e.ed25519.CURVE.Fp.create((0, a.bytesToNumberLE)(t) & D);\n    function B(t) {\n        const { d: n } = e.ed25519.CURVE, r = e.ed25519.CURVE.Fp.ORDER, i = e.ed25519.CURVE.Fp.create, s = i(T * t * t), a = i((s + u) * O);\n        let c = BigInt(-1);\n        const l = i((c - n * s) * i(s + n));\n        let { isValid: d, value: h } = v(a, l), f = i(h * t);\n        (0, o.isNegativeLE)(f, r) || (f = i(-f)), d || (h = f), d || (c = s);\n        const p = i(c * (s - u) * N - l), g = h * h, m = i((h + h) * l), y = i(p * R), b = i(u - g), w = i(u + g);\n        return new e.ed25519.ExtendedPoint(i(m * w), i(b * y), i(y * w), i(m * b));\n    }\n    class K {\n        static fromAffine(t) {\n            return new K(e.ed25519.ExtendedPoint.fromAffine(t));\n        }\n        static hashToCurve(e) {\n            e = (0, a.ensureBytes)(\"ristrettoHash\", e, 64);\n            const t = B($(e.slice(0, 32))), n = B($(e.slice(32, 64)));\n            return new K(t.add(n));\n        }\n        static fromHex(t) {\n            t = (0, a.ensureBytes)(\"ristrettoHex\", t, 32);\n            const { a: n, d: r } = e.ed25519.CURVE, i = e.ed25519.CURVE.Fp.ORDER, s = e.ed25519.CURVE.Fp.create, c = \"RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint\", l = $(t);\n            if (!(0, a.equalBytes)((0, a.numberToBytesLE)(l, 32), t) || (0, o.isNegativeLE)(l, i)) throw new Error(c);\n            const h = s(l * l), f = s(u + n * h), p = s(u - n * h), g = s(f * f), m = s(p * p), y = s(n * r * g - m), { isValid: v, value: b } = L(s(y * m)), w = s(b * p), E = s(b * w * y);\n            let S = s((l + l) * w);\n            (0, o.isNegativeLE)(S, i) && (S = s(-S));\n            const _ = s(f * E), C = s(S * _);\n            if (!v || (0, o.isNegativeLE)(C, i) || _ === d) throw new Error(c);\n            return new K(new e.ed25519.ExtendedPoint(S, _, u, C));\n        }\n        toRawBytes() {\n            let { ex: t, ey: n, ez: r, et: i } = this.ep;\n            const s = e.ed25519.CURVE.Fp.ORDER, c = e.ed25519.CURVE.Fp.create, l = c(c(r + n) * c(r - n)), d = c(t * n), u = c(d * d), { value: h } = L(c(l * u)), f = c(h * l), p = c(h * d), g = c(f * p * i);\n            let m;\n            if ((0, o.isNegativeLE)(i * g, s)) {\n                let e = c(n * T), r = c(t * T);\n                t = e, n = r, m = c(f * P);\n            } else m = p;\n            (0, o.isNegativeLE)(t * g, s) && (n = c(-n));\n            let y = c((r - n) * m);\n            return (0, o.isNegativeLE)(y, s) && (y = c(-y)), (0, a.numberToBytesLE)(y, 32);\n        }\n        toHex() {\n            return (0, a.bytesToHex)(this.toRawBytes());\n        }\n        toString() {\n            return this.toHex();\n        }\n        equals(t) {\n            I(t);\n            const { ex: n, ey: r } = this.ep, { ex: i, ey: o } = t.ep, s = e.ed25519.CURVE.Fp.create, a = s(n * o) === s(r * i), c = s(r * o) === s(n * i);\n            return a || c;\n        }\n        add(e) {\n            return I(e), new K(this.ep.add(e.ep));\n        }\n        subtract(e) {\n            return I(e), new K(this.ep.subtract(e.ep));\n        }\n        multiply(e) {\n            return new K(this.ep.multiply(e));\n        }\n        multiplyUnsafe(e) {\n            return new K(this.ep.multiplyUnsafe(e));\n        }\n        double() {\n            return new K(this.ep.double());\n        }\n        negate() {\n            return new K(this.ep.negate());\n        }\n        constructor(e){\n            this.ep = e;\n        }\n    }\n    e.RistrettoPoint = (K.BASE || (K.BASE = new K(e.ed25519.ExtendedPoint.BASE)), K.ZERO || (K.ZERO = new K(e.ed25519.ExtendedPoint.ZERO)), K);\n    e.hashToRistretto255 = (e, r)=>{\n        const o = r.DST, s = \"string\" == typeof o ? (0, n.utf8ToBytes)(o) : o, a = (0, i.expand_message_xmd)(e, s, 64, t.sha512);\n        return K.hashToCurve(a);\n    }, e.hash_to_ristretto255 = e.hashToRistretto255;\n}(Pe);\nvar Jn = {}, Qn = {};\nObject.defineProperty(Qn, \"__esModule\", {\n    value: !0\n}), Qn.sha224 = Qn.sha256 = Qn.SHA256 = void 0;\nconst Xn = Ne, er = ze, tr = new Uint32Array([\n    1116352408,\n    1899447441,\n    3049323471,\n    3921009573,\n    961987163,\n    1508970993,\n    2453635748,\n    2870763221,\n    3624381080,\n    310598401,\n    607225278,\n    1426881987,\n    1925078388,\n    2162078206,\n    2614888103,\n    3248222580,\n    3835390401,\n    4022224774,\n    264347078,\n    604807628,\n    770255983,\n    1249150122,\n    1555081692,\n    1996064986,\n    2554220882,\n    2821834349,\n    2952996808,\n    3210313671,\n    3336571891,\n    3584528711,\n    113926993,\n    338241895,\n    666307205,\n    773529912,\n    1294757372,\n    1396182291,\n    1695183700,\n    1986661051,\n    2177026350,\n    2456956037,\n    2730485921,\n    2820302411,\n    3259730800,\n    3345764771,\n    3516065817,\n    3600352804,\n    4094571909,\n    275423344,\n    430227734,\n    506948616,\n    659060556,\n    883997877,\n    958139571,\n    1322822218,\n    1537002063,\n    1747873779,\n    1955562222,\n    2024104815,\n    2227730452,\n    2361852424,\n    2428436474,\n    2756734187,\n    3204031479,\n    3329325298\n]), nr = new Uint32Array([\n    1779033703,\n    3144134277,\n    1013904242,\n    2773480762,\n    1359893119,\n    2600822924,\n    528734635,\n    1541459225\n]), rr = new Uint32Array(64);\nclass ir extends Xn.HashMD {\n    get() {\n        const { A: e, B: t, C: n, D: r, E: i, F: o, G: s, H: a } = this;\n        return [\n            e,\n            t,\n            n,\n            r,\n            i,\n            o,\n            s,\n            a\n        ];\n    }\n    set(e, t, n, r, i, o, s, a) {\n        this.A = 0 | e, this.B = 0 | t, this.C = 0 | n, this.D = 0 | r, this.E = 0 | i, this.F = 0 | o, this.G = 0 | s, this.H = 0 | a;\n    }\n    process(e, t) {\n        for(let n = 0; n < 16; n++, t += 4)rr[n] = e.getUint32(t, !1);\n        for(let e = 16; e < 64; e++){\n            const t = rr[e - 15], n = rr[e - 2], r = (0, er.rotr)(t, 7) ^ (0, er.rotr)(t, 18) ^ t >>> 3, i = (0, er.rotr)(n, 17) ^ (0, er.rotr)(n, 19) ^ n >>> 10;\n            rr[e] = i + rr[e - 7] + r + rr[e - 16] | 0;\n        }\n        let { A: n, B: r, C: i, D: o, E: s, F: a, G: c, H: l } = this;\n        for(let e = 0; e < 64; e++){\n            const t = l + ((0, er.rotr)(s, 6) ^ (0, er.rotr)(s, 11) ^ (0, er.rotr)(s, 25)) + (0, Xn.Chi)(s, a, c) + tr[e] + rr[e] | 0, d = ((0, er.rotr)(n, 2) ^ (0, er.rotr)(n, 13) ^ (0, er.rotr)(n, 22)) + (0, Xn.Maj)(n, r, i) | 0;\n            l = c, c = a, a = s, s = o + t | 0, o = i, i = r, r = n, n = t + d | 0;\n        }\n        n = n + this.A | 0, r = r + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, s = s + this.E | 0, a = a + this.F | 0, c = c + this.G | 0, l = l + this.H | 0, this.set(n, r, i, o, s, a, c, l);\n    }\n    roundClean() {\n        rr.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);\n    }\n    constructor(){\n        super(64, 32, 8, !1), this.A = 0 | nr[0], this.B = 0 | nr[1], this.C = 0 | nr[2], this.D = 0 | nr[3], this.E = 0 | nr[4], this.F = 0 | nr[5], this.G = 0 | nr[6], this.H = 0 | nr[7];\n    }\n}\nQn.SHA256 = ir;\nclass or extends ir {\n    constructor(){\n        super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;\n    }\n}\nQn.sha256 = (0, er.wrapConstructor)(()=>new ir), Qn.sha224 = (0, er.wrapConstructor)(()=>new or);\nvar sr = {}, ar = {};\n!function(e) {\n    Object.defineProperty(e, \"__esModule\", {\n        value: !0\n    }), e.hmac = e.HMAC = void 0;\n    const t = Le, n = ze;\n    class r extends n.Hash {\n        update(e) {\n            return (0, t.exists)(this), this.iHash.update(e), this;\n        }\n        digestInto(e) {\n            (0, t.exists)(this), (0, t.bytes)(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();\n        }\n        digest() {\n            const e = new Uint8Array(this.oHash.outputLen);\n            return this.digestInto(e), e;\n        }\n        _cloneInto(e) {\n            e || (e = Object.create(Object.getPrototypeOf(this), {}));\n            const { oHash: t, iHash: n, finished: r, destroyed: i, blockLen: o, outputLen: s } = this;\n            return e.finished = r, e.destroyed = i, e.blockLen = o, e.outputLen = s, e.oHash = t._cloneInto(e.oHash), e.iHash = n._cloneInto(e.iHash), e;\n        }\n        destroy() {\n            this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();\n        }\n        constructor(e, r){\n            super(), this.finished = !1, this.destroyed = !1, (0, t.hash)(e);\n            const i = (0, n.toBytes)(r);\n            if (this.iHash = e.create(), \"function\" != typeof this.iHash.update) throw new Error(\"Expected instance of class which extends utils.Hash\");\n            this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;\n            const o = this.blockLen, s = new Uint8Array(o);\n            s.set(i.length > o ? e.create().update(i).digest() : i);\n            for(let e = 0; e < s.length; e++)s[e] ^= 54;\n            this.iHash.update(s), this.oHash = e.create();\n            for(let e = 0; e < s.length; e++)s[e] ^= 106;\n            this.oHash.update(s), s.fill(0);\n        }\n    }\n    e.HMAC = r;\n    e.hmac = (e, t, n)=>new r(e, t).update(n).digest(), e.hmac.create = (e, t)=>new r(e, t);\n}(ar);\nvar cr = {};\n!function(e) {\n    Object.defineProperty(e, \"__esModule\", {\n        value: !0\n    }), e.DER = void 0, e.weierstrassPoints = f, e.weierstrass = function(s) {\n        const a = function(e) {\n            const n = (0, t.validateBasic)(e);\n            return r.validateObject(n, {\n                hash: \"hash\",\n                hmac: \"function\",\n                randomBytes: \"function\"\n            }, {\n                bits2int: \"function\",\n                bits2int_modN: \"function\",\n                lowS: \"boolean\"\n            }), Object.freeze({\n                lowS: !0,\n                ...n\n            });\n        }(s), { Fp: d, n: u } = a, h = d.BYTES + 1, p = 2 * d.BYTES + 1;\n        function g(e) {\n            return n.mod(e, u);\n        }\n        function m(e) {\n            return n.invert(e, u);\n        }\n        const { ProjectivePoint: y, normPrivateKeyToScalar: v, weierstrassEquation: b, isWithinCurveOrder: w } = f({\n            ...a,\n            toBytes (e, t, n) {\n                const o = t.toAffine(), s = d.toBytes(o.x), a = r.concatBytes;\n                return (0, i.abool)(\"isCompressed\", n), n ? a(Uint8Array.from([\n                    t.hasEvenY() ? 2 : 3\n                ]), s) : a(Uint8Array.from([\n                    4\n                ]), s, d.toBytes(o.y));\n            },\n            fromBytes (e) {\n                const t = e.length, n = e[0], i = e.subarray(1);\n                if (t !== h || 2 !== n && 3 !== n) {\n                    if (t === p && 4 === n) {\n                        return {\n                            x: d.fromBytes(i.subarray(0, d.BYTES)),\n                            y: d.fromBytes(i.subarray(d.BYTES, 2 * d.BYTES))\n                        };\n                    }\n                    throw new Error(\"Point of length \".concat(t, \" was invalid. Expected \").concat(h, \" compressed bytes or \").concat(p, \" uncompressed bytes\"));\n                }\n                {\n                    const e = r.bytesToNumberBE(i);\n                    if (!r.inRange(e, l, d.ORDER)) throw new Error(\"Point is not on curve\");\n                    const t = b(e);\n                    let o;\n                    try {\n                        o = d.sqrt(t);\n                    } catch (e) {\n                        const t = e instanceof Error ? \": \" + e.message : \"\";\n                        throw new Error(\"Point is not on curve\" + t);\n                    }\n                    return 1 == (1 & n) !== ((o & l) === l) && (o = d.neg(o)), {\n                        x: e,\n                        y: o\n                    };\n                }\n            }\n        }), E = (e)=>r.bytesToHex(r.numberToBytesBE(e, a.nByteLength));\n        function S(e) {\n            return e > u >> l;\n        }\n        const _ = (e, t, n)=>r.bytesToNumberBE(e.slice(t, n));\n        class C {\n            static fromCompact(e) {\n                const t = a.nByteLength;\n                return e = (0, i.ensureBytes)(\"compactSignature\", e, 2 * t), new C(_(e, 0, t), _(e, t, 2 * t));\n            }\n            static fromDER(t) {\n                const { r: n, s: r } = e.DER.toSig((0, i.ensureBytes)(\"DER\", t));\n                return new C(n, r);\n            }\n            assertValidity() {\n                r.aInRange(\"r\", this.r, l, u), r.aInRange(\"s\", this.s, l, u);\n            }\n            addRecoveryBit(e) {\n                return new C(this.r, this.s, e);\n            }\n            recoverPublicKey(e) {\n                const { r: t, s: n, recovery: r } = this, o = M((0, i.ensureBytes)(\"msgHash\", e));\n                if (null == r || ![\n                    0,\n                    1,\n                    2,\n                    3\n                ].includes(r)) throw new Error(\"recovery id invalid\");\n                const s = 2 === r || 3 === r ? t + a.n : t;\n                if (s >= d.ORDER) throw new Error(\"recovery id 2 or 3 invalid\");\n                const c = 0 == (1 & r) ? \"02\" : \"03\", l = y.fromHex(c + E(s)), u = m(s), h = g(-o * u), f = g(n * u), p = y.BASE.multiplyAndAddUnsafe(l, h, f);\n                if (!p) throw new Error(\"point at infinify\");\n                return p.assertValidity(), p;\n            }\n            hasHighS() {\n                return S(this.s);\n            }\n            normalizeS() {\n                return this.hasHighS() ? new C(this.r, g(-this.s), this.recovery) : this;\n            }\n            toDERRawBytes() {\n                return r.hexToBytes(this.toDERHex());\n            }\n            toDERHex() {\n                return e.DER.hexFromSig({\n                    r: this.r,\n                    s: this.s\n                });\n            }\n            toCompactRawBytes() {\n                return r.hexToBytes(this.toCompactHex());\n            }\n            toCompactHex() {\n                return E(this.r) + E(this.s);\n            }\n            constructor(e, t, n){\n                this.r = e, this.s = t, this.recovery = n, this.assertValidity();\n            }\n        }\n        const k = {\n            isValidPrivateKey (e) {\n                try {\n                    return v(e), !0;\n                } catch (e) {\n                    return !1;\n                }\n            },\n            normPrivateKeyToScalar: v,\n            randomPrivateKey: ()=>{\n                const e = n.getMinHashLength(a.n);\n                return n.mapHashToField(a.randomBytes(e), a.n);\n            },\n            precompute: function() {\n                let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 8, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : y.BASE;\n                return t._setWindowSize(e), t.multiply(BigInt(3)), t;\n            }\n        };\n        function A(e) {\n            const t = r.isBytes(e), n = \"string\" == typeof e, i = (t || n) && e.length;\n            return t ? i === h || i === p : n ? i === 2 * h || i === 2 * p : e instanceof y;\n        }\n        const x = a.bits2int || function(e) {\n            const t = r.bytesToNumberBE(e), n = 8 * e.length - a.nBitLength;\n            return n > 0 ? t >> BigInt(n) : t;\n        }, M = a.bits2int_modN || function(e) {\n            return g(x(e));\n        }, I = r.bitMask(a.nBitLength);\n        function T(e) {\n            return r.aInRange(\"num < 2^\".concat(a.nBitLength), e, c, I), r.numberToBytesBE(e, a.nByteLength);\n        }\n        function R(e, t) {\n            let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : P;\n            if ([\n                \"recovered\",\n                \"canonical\"\n            ].some((e)=>e in n)) throw new Error(\"sign() legacy options not supported\");\n            const { hash: s, randomBytes: u } = a;\n            let { lowS: h, prehash: f, extraEntropy: p } = n;\n            null == h && (h = !0), e = (0, i.ensureBytes)(\"msgHash\", e), o(n), f && (e = (0, i.ensureBytes)(\"prehashed msgHash\", s(e)));\n            const b = M(e), E = v(t), _ = [\n                T(E),\n                T(b)\n            ];\n            if (null != p && !1 !== p) {\n                const e = !0 === p ? u(d.BYTES) : p;\n                _.push((0, i.ensureBytes)(\"extraEntropy\", e));\n            }\n            const k = r.concatBytes(..._), A = b;\n            return {\n                seed: k,\n                k2sig: function(e) {\n                    const t = x(e);\n                    if (!w(t)) return;\n                    const n = m(t), r = y.BASE.multiply(t).toAffine(), i = g(r.x);\n                    if (i === c) return;\n                    const o = g(n * g(A + i * E));\n                    if (o === c) return;\n                    let s = (r.x === i ? 0 : 2) | Number(r.y & l), a = o;\n                    return h && S(o) && (a = function(e) {\n                        return S(e) ? g(-e) : e;\n                    }(o), s ^= 1), new C(i, a, s);\n                }\n            };\n        }\n        const P = {\n            lowS: a.lowS,\n            prehash: !1\n        }, O = {\n            lowS: a.lowS,\n            prehash: !1\n        };\n        return y.BASE._setWindowSize(8), {\n            CURVE: a,\n            getPublicKey: function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;\n                return y.fromPrivateKey(e).toRawBytes(t);\n            },\n            getSharedSecret: function(e, t) {\n                let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;\n                if (A(e)) throw new Error(\"first arg must be private key\");\n                if (!A(t)) throw new Error(\"second arg must be public key\");\n                const r = y.fromHex(t);\n                return r.multiply(v(e)).toRawBytes(n);\n            },\n            sign: function(e, t) {\n                let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : P;\n                const { seed: i, k2sig: o } = R(e, t, n), s = a, c = r.createHmacDrbg(s.hash.outputLen, s.nByteLength, s.hmac);\n                return c(i, o);\n            },\n            verify: function(t, n, s) {\n                let c = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : O;\n                var _y_BASE_multiplyAndAddUnsafe;\n                const l = t;\n                if (n = (0, i.ensureBytes)(\"msgHash\", n), s = (0, i.ensureBytes)(\"publicKey\", s), \"strict\" in c) throw new Error(\"options.strict was renamed to lowS\");\n                o(c);\n                const { lowS: d, prehash: u } = c;\n                let h, f;\n                try {\n                    if (\"string\" == typeof l || r.isBytes(l)) try {\n                        h = C.fromDER(l);\n                    } catch (t) {\n                        if (!(t instanceof e.DER.Err)) throw t;\n                        h = C.fromCompact(l);\n                    }\n                    else {\n                        if (\"object\" != typeof l || \"bigint\" != typeof l.r || \"bigint\" != typeof l.s) throw new Error(\"PARSE\");\n                        {\n                            const { r: e, s: t } = l;\n                            h = new C(e, t);\n                        }\n                    }\n                    f = y.fromHex(s);\n                } catch (e) {\n                    if (\"PARSE\" === e.message) throw new Error(\"signature must be Signature instance, Uint8Array or hex string\");\n                    return !1;\n                }\n                if (d && h.hasHighS()) return !1;\n                u && (n = a.hash(n));\n                const { r: p, s: v } = h, b = M(n), w = m(v), E = g(b * w), S = g(p * w), _ = (_y_BASE_multiplyAndAddUnsafe = y.BASE.multiplyAndAddUnsafe(f, E, S)) === null || _y_BASE_multiplyAndAddUnsafe === void 0 ? void 0 : _y_BASE_multiplyAndAddUnsafe.toAffine();\n                if (!_) return !1;\n                const k = g(_.x);\n                return k === p;\n            },\n            ProjectivePoint: y,\n            Signature: C,\n            utils: k\n        };\n    }, e.SWUFpSqrtRatio = p, e.mapToCurveSimpleSWU = function(e, t) {\n        if (n.validateField(e), !e.isValid(t.A) || !e.isValid(t.B) || !e.isValid(t.Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n        const r = p(e, t.Z);\n        if (!e.isOdd) throw new Error(\"Fp.isOdd is not implemented!\");\n        return (n)=>{\n            let i, o, s, a, c, l, d, u;\n            i = e.sqr(n), i = e.mul(i, t.Z), o = e.sqr(i), o = e.add(o, i), s = e.add(o, e.ONE), s = e.mul(s, t.B), a = e.cmov(t.Z, e.neg(o), !e.eql(o, e.ZERO)), a = e.mul(a, t.A), o = e.sqr(s), l = e.sqr(a), c = e.mul(l, t.A), o = e.add(o, c), o = e.mul(o, s), l = e.mul(l, a), c = e.mul(l, t.B), o = e.add(o, c), d = e.mul(i, s);\n            const { isValid: h, value: f } = r(o, l);\n            u = e.mul(i, n), u = e.mul(u, f), d = e.cmov(d, s, h), u = e.cmov(u, f, h);\n            const p = e.isOdd(n) === e.isOdd(u);\n            return u = e.cmov(e.neg(u), u, p), d = e.div(d, a), {\n                x: d,\n                y: u\n            };\n        };\n    };\n    const t = Pt, n = Ot, r = Nt, i = Nt;\n    function o(e) {\n        void 0 !== e.lowS && (0, i.abool)(\"lowS\", e.lowS), void 0 !== e.prehash && (0, i.abool)(\"prehash\", e.prehash);\n    }\n    const { bytesToNumberBE: s, hexToBytes: a } = r;\n    e.DER = {\n        Err: class extends Error {\n            constructor(e = \"\"){\n                super(e);\n            }\n        },\n        _tlv: {\n            encode: (t, n)=>{\n                const { Err: i } = e.DER;\n                if (t < 0 || t > 256) throw new i(\"tlv.encode: wrong tag\");\n                if (1 & n.length) throw new i(\"tlv.encode: unpadded data\");\n                const o = n.length / 2, s = r.numberToHexUnpadded(o);\n                if (s.length / 2 & 128) throw new i(\"tlv.encode: long form length too big\");\n                const a = o > 127 ? r.numberToHexUnpadded(s.length / 2 | 128) : \"\";\n                return \"\".concat(r.numberToHexUnpadded(t)).concat(a).concat(s).concat(n);\n            },\n            decode (t, n) {\n                const { Err: r } = e.DER;\n                let i = 0;\n                if (t < 0 || t > 256) throw new r(\"tlv.encode: wrong tag\");\n                if (n.length < 2 || n[i++] !== t) throw new r(\"tlv.decode: wrong tlv\");\n                const o = n[i++];\n                let s = 0;\n                if (!!(128 & o)) {\n                    const e = 127 & o;\n                    if (!e) throw new r(\"tlv.decode(long): indefinite length not supported\");\n                    if (e > 4) throw new r(\"tlv.decode(long): byte length is too big\");\n                    const t = n.subarray(i, i + e);\n                    if (t.length !== e) throw new r(\"tlv.decode: length bytes not complete\");\n                    if (0 === t[0]) throw new r(\"tlv.decode(long): zero leftmost byte\");\n                    for (const e of t)s = s << 8 | e;\n                    if (i += e, s < 128) throw new r(\"tlv.decode(long): not minimal encoding\");\n                } else s = o;\n                const a = n.subarray(i, i + s);\n                if (a.length !== s) throw new r(\"tlv.decode: wrong value length\");\n                return {\n                    v: a,\n                    l: n.subarray(i + s)\n                };\n            }\n        },\n        _int: {\n            encode (t) {\n                const { Err: n } = e.DER;\n                if (t < c) throw new n(\"integer: negative integers are not allowed\");\n                let i = r.numberToHexUnpadded(t);\n                if (8 & Number.parseInt(i[0], 16) && (i = \"00\" + i), 1 & i.length) throw new n(\"unexpected assertion\");\n                return i;\n            },\n            decode (t) {\n                const { Err: n } = e.DER;\n                if (128 & t[0]) throw new n(\"Invalid signature integer: negative\");\n                if (0 === t[0] && !(128 & t[1])) throw new n(\"Invalid signature integer: unnecessary leading zero\");\n                return s(t);\n            }\n        },\n        toSig (t) {\n            const { Err: n, _int: i, _tlv: o } = e.DER, s = \"string\" == typeof t ? a(t) : t;\n            r.abytes(s);\n            const { v: c, l: l } = o.decode(48, s);\n            if (l.length) throw new n(\"Invalid signature: left bytes after parsing\");\n            const { v: d, l: u } = o.decode(2, c), { v: h, l: f } = o.decode(2, u);\n            if (f.length) throw new n(\"Invalid signature: left bytes after parsing\");\n            return {\n                r: i.decode(d),\n                s: i.decode(h)\n            };\n        },\n        hexFromSig (t) {\n            const { _tlv: n, _int: r } = e.DER, i = \"\".concat(n.encode(2, r.encode(t.r))).concat(n.encode(2, r.encode(t.s)));\n            return n.encode(48, i);\n        }\n    };\n    const c = BigInt(0), l = BigInt(1), d = BigInt(2), u = BigInt(3), h = BigInt(4);\n    function f(e) {\n        const o = function(e) {\n            const n = (0, t.validateBasic)(e);\n            r.validateObject(n, {\n                a: \"field\",\n                b: \"field\"\n            }, {\n                allowedPrivateKeyLengths: \"array\",\n                wrapPrivateKey: \"boolean\",\n                isTorsionFree: \"function\",\n                clearCofactor: \"function\",\n                allowInfinityPoint: \"boolean\",\n                fromBytes: \"function\",\n                toBytes: \"function\"\n            });\n            const { endo: i, Fp: o, a: s } = n;\n            if (i) {\n                if (!o.eql(s, o.ZERO)) throw new Error(\"Endomorphism can only be defined for Koblitz curves that have a=0\");\n                if (\"object\" != typeof i || \"bigint\" != typeof i.beta || \"function\" != typeof i.splitScalar) throw new Error(\"Expected endomorphism with beta: bigint and splitScalar: function\");\n            }\n            return Object.freeze({\n                ...n\n            });\n        }(e), { Fp: s } = o, a = n.Field(o.n, o.nBitLength), d = o.toBytes || ((e, t, n)=>{\n            const i = t.toAffine();\n            return r.concatBytes(Uint8Array.from([\n                4\n            ]), s.toBytes(i.x), s.toBytes(i.y));\n        }), h = o.fromBytes || ((e)=>{\n            const t = e.subarray(1);\n            return {\n                x: s.fromBytes(t.subarray(0, s.BYTES)),\n                y: s.fromBytes(t.subarray(s.BYTES, 2 * s.BYTES))\n            };\n        });\n        function f(e) {\n            const { a: t, b: n } = o, r = s.sqr(e), i = s.mul(r, e);\n            return s.add(s.add(i, s.mul(e, t)), n);\n        }\n        if (!s.eql(s.sqr(o.Gy), f(o.Gx))) throw new Error(\"bad generator point: equation left != right\");\n        function p(e) {\n            const { allowedPrivateKeyLengths: t, nByteLength: s, wrapPrivateKey: a, n: c } = o;\n            if (t && \"bigint\" != typeof e) {\n                if (r.isBytes(e) && (e = r.bytesToHex(e)), \"string\" != typeof e || !t.includes(e.length)) throw new Error(\"Invalid key\");\n                e = e.padStart(2 * s, \"0\");\n            }\n            let d;\n            try {\n                d = \"bigint\" == typeof e ? e : r.bytesToNumberBE((0, i.ensureBytes)(\"private key\", e, s));\n            } catch (t) {\n                throw new Error(\"private key must be \".concat(s, \" bytes, hex or bigint, not \").concat(typeof e));\n            }\n            return a && (d = n.mod(d, c)), r.aInRange(\"private key\", d, l, c), d;\n        }\n        function g(e) {\n            if (!(e instanceof v)) throw new Error(\"ProjectivePoint expected\");\n        }\n        const m = (0, i.memoized)((e, t)=>{\n            const { px: n, py: r, pz: i } = e;\n            if (s.eql(i, s.ONE)) return {\n                x: n,\n                y: r\n            };\n            const o = e.is0();\n            null == t && (t = o ? s.ONE : s.inv(i));\n            const a = s.mul(n, t), c = s.mul(r, t), l = s.mul(i, t);\n            if (o) return {\n                x: s.ZERO,\n                y: s.ZERO\n            };\n            if (!s.eql(l, s.ONE)) throw new Error(\"invZ was invalid\");\n            return {\n                x: a,\n                y: c\n            };\n        }), y = (0, i.memoized)((e)=>{\n            if (e.is0()) {\n                if (o.allowInfinityPoint && !s.is0(e.py)) return;\n                throw new Error(\"bad point: ZERO\");\n            }\n            const { x: t, y: n } = e.toAffine();\n            if (!s.isValid(t) || !s.isValid(n)) throw new Error(\"bad point: x or y not FE\");\n            const r = s.sqr(n), i = f(t);\n            if (!s.eql(r, i)) throw new Error(\"bad point: equation left != right\");\n            if (!e.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n            return !0;\n        });\n        class v {\n            static fromAffine(e) {\n                const { x: t, y: n } = e || {};\n                if (!e || !s.isValid(t) || !s.isValid(n)) throw new Error(\"invalid affine point\");\n                if (e instanceof v) throw new Error(\"projective point not allowed\");\n                const r = (e)=>s.eql(e, s.ZERO);\n                return r(t) && r(n) ? v.ZERO : new v(t, n, s.ONE);\n            }\n            get x() {\n                return this.toAffine().x;\n            }\n            get y() {\n                return this.toAffine().y;\n            }\n            static normalizeZ(e) {\n                const t = s.invertBatch(e.map((e)=>e.pz));\n                return e.map((e, n)=>e.toAffine(t[n])).map(v.fromAffine);\n            }\n            static fromHex(e) {\n                const t = v.fromAffine(h((0, i.ensureBytes)(\"pointHex\", e)));\n                return t.assertValidity(), t;\n            }\n            static fromPrivateKey(e) {\n                return v.BASE.multiply(p(e));\n            }\n            static msm(e, n) {\n                return (0, t.pippenger)(v, a, e, n);\n            }\n            _setWindowSize(e) {\n                w.setWindowSize(this, e);\n            }\n            assertValidity() {\n                y(this);\n            }\n            hasEvenY() {\n                const { y: e } = this.toAffine();\n                if (s.isOdd) return !s.isOdd(e);\n                throw new Error(\"Field doesn't support isOdd\");\n            }\n            equals(e) {\n                g(e);\n                const { px: t, py: n, pz: r } = this, { px: i, py: o, pz: a } = e, c = s.eql(s.mul(t, a), s.mul(i, r)), l = s.eql(s.mul(n, a), s.mul(o, r));\n                return c && l;\n            }\n            negate() {\n                return new v(this.px, s.neg(this.py), this.pz);\n            }\n            double() {\n                const { a: e, b: t } = o, n = s.mul(t, u), { px: r, py: i, pz: a } = this;\n                let c = s.ZERO, l = s.ZERO, d = s.ZERO, h = s.mul(r, r), f = s.mul(i, i), p = s.mul(a, a), g = s.mul(r, i);\n                return g = s.add(g, g), d = s.mul(r, a), d = s.add(d, d), c = s.mul(e, d), l = s.mul(n, p), l = s.add(c, l), c = s.sub(f, l), l = s.add(f, l), l = s.mul(c, l), c = s.mul(g, c), d = s.mul(n, d), p = s.mul(e, p), g = s.sub(h, p), g = s.mul(e, g), g = s.add(g, d), d = s.add(h, h), h = s.add(d, h), h = s.add(h, p), h = s.mul(h, g), l = s.add(l, h), p = s.mul(i, a), p = s.add(p, p), h = s.mul(p, g), c = s.sub(c, h), d = s.mul(p, f), d = s.add(d, d), d = s.add(d, d), new v(c, l, d);\n            }\n            add(e) {\n                g(e);\n                const { px: t, py: n, pz: r } = this, { px: i, py: a, pz: c } = e;\n                let l = s.ZERO, d = s.ZERO, h = s.ZERO;\n                const f = o.a, p = s.mul(o.b, u);\n                let m = s.mul(t, i), y = s.mul(n, a), b = s.mul(r, c), w = s.add(t, n), E = s.add(i, a);\n                w = s.mul(w, E), E = s.add(m, y), w = s.sub(w, E), E = s.add(t, r);\n                let S = s.add(i, c);\n                return E = s.mul(E, S), S = s.add(m, b), E = s.sub(E, S), S = s.add(n, r), l = s.add(a, c), S = s.mul(S, l), l = s.add(y, b), S = s.sub(S, l), h = s.mul(f, E), l = s.mul(p, b), h = s.add(l, h), l = s.sub(y, h), h = s.add(y, h), d = s.mul(l, h), y = s.add(m, m), y = s.add(y, m), b = s.mul(f, b), E = s.mul(p, E), y = s.add(y, b), b = s.sub(m, b), b = s.mul(f, b), E = s.add(E, b), m = s.mul(y, E), d = s.add(d, m), m = s.mul(S, E), l = s.mul(w, l), l = s.sub(l, m), m = s.mul(w, y), h = s.mul(S, h), h = s.add(h, m), new v(l, d, h);\n            }\n            subtract(e) {\n                return this.add(e.negate());\n            }\n            is0() {\n                return this.equals(v.ZERO);\n            }\n            wNAF(e) {\n                return w.wNAFCached(this, e, v.normalizeZ);\n            }\n            multiplyUnsafe(e) {\n                r.aInRange(\"scalar\", e, c, o.n);\n                const t = v.ZERO;\n                if (e === c) return t;\n                if (e === l) return this;\n                const { endo: n } = o;\n                if (!n) return w.unsafeLadder(this, e);\n                let { k1neg: i, k1: a, k2neg: d, k2: u } = n.splitScalar(e), h = t, f = t, p = this;\n                for(; a > c || u > c;)a & l && (h = h.add(p)), u & l && (f = f.add(p)), p = p.double(), a >>= l, u >>= l;\n                return i && (h = h.negate()), d && (f = f.negate()), f = new v(s.mul(f.px, n.beta), f.py, f.pz), h.add(f);\n            }\n            multiply(e) {\n                const { endo: t, n: n } = o;\n                let i, a;\n                if (r.aInRange(\"scalar\", e, l, n), t) {\n                    const { k1neg: n, k1: r, k2neg: o, k2: c } = t.splitScalar(e);\n                    let { p: l, f: d } = this.wNAF(r), { p: u, f: h } = this.wNAF(c);\n                    l = w.constTimeNegate(n, l), u = w.constTimeNegate(o, u), u = new v(s.mul(u.px, t.beta), u.py, u.pz), i = l.add(u), a = d.add(h);\n                } else {\n                    const { p: t, f: n } = this.wNAF(e);\n                    i = t, a = n;\n                }\n                return v.normalizeZ([\n                    i,\n                    a\n                ])[0];\n            }\n            multiplyAndAddUnsafe(e, t, n) {\n                const r = v.BASE, i = (e, t)=>t !== c && t !== l && e.equals(r) ? e.multiply(t) : e.multiplyUnsafe(t), o = i(this, t).add(i(e, n));\n                return o.is0() ? void 0 : o;\n            }\n            toAffine(e) {\n                return m(this, e);\n            }\n            isTorsionFree() {\n                const { h: e, isTorsionFree: t } = o;\n                if (e === l) return !0;\n                if (t) return t(v, this);\n                throw new Error(\"isTorsionFree() has not been declared for the elliptic curve\");\n            }\n            clearCofactor() {\n                const { h: e, clearCofactor: t } = o;\n                return e === l ? this : t ? t(v, this) : this.multiplyUnsafe(o.h);\n            }\n            toRawBytes() {\n                let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;\n                return (0, i.abool)(\"isCompressed\", e), this.assertValidity(), d(v, this, e);\n            }\n            toHex() {\n                let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;\n                return (0, i.abool)(\"isCompressed\", e), r.bytesToHex(this.toRawBytes(e));\n            }\n            constructor(e, t, n){\n                if (this.px = e, this.py = t, this.pz = n, null == e || !s.isValid(e)) throw new Error(\"x required\");\n                if (null == t || !s.isValid(t)) throw new Error(\"y required\");\n                if (null == n || !s.isValid(n)) throw new Error(\"z required\");\n                Object.freeze(this);\n            }\n        }\n        v.BASE = new v(o.Gx, o.Gy, s.ONE), v.ZERO = new v(s.ZERO, s.ONE, s.ZERO);\n        const b = o.nBitLength, w = (0, t.wNAF)(v, o.endo ? Math.ceil(b / 2) : b);\n        return {\n            CURVE: o,\n            ProjectivePoint: v,\n            normPrivateKeyToScalar: p,\n            weierstrassEquation: f,\n            isWithinCurveOrder: function(e) {\n                return r.inRange(e, l, o.n);\n            }\n        };\n    }\n    function p(e, t) {\n        const n = e.ORDER;\n        let r = c;\n        for(let e = n - l; e % d === c; e /= d)r += l;\n        const i = r, o = d << i - l - l, s = o * d, a = (n - l) / s, f = (a - l) / d, p = s - l, g = o, m = e.pow(t, a), y = e.pow(t, (a + l) / d);\n        let v = (t, n)=>{\n            let r = m, o = e.pow(n, p), s = e.sqr(o);\n            s = e.mul(s, n);\n            let a = e.mul(t, s);\n            a = e.pow(a, f), a = e.mul(a, o), o = e.mul(a, n), s = e.mul(a, t);\n            let c = e.mul(s, o);\n            a = e.pow(c, g);\n            let u = e.eql(a, e.ONE);\n            o = e.mul(s, y), a = e.mul(c, r), s = e.cmov(o, s, u), c = e.cmov(a, c, u);\n            for(let t = i; t > l; t--){\n                let n = t - d;\n                n = d << n - l;\n                let i = e.pow(c, n);\n                const a = e.eql(i, e.ONE);\n                o = e.mul(s, r), r = e.mul(r, r), i = e.mul(c, r), s = e.cmov(o, s, a), c = e.cmov(i, c, a);\n            }\n            return {\n                isValid: u,\n                value: s\n            };\n        };\n        if (e.ORDER % h === u) {\n            const n = (e.ORDER - u) / h, r = e.sqrt(e.neg(t));\n            v = (t, i)=>{\n                let o = e.sqr(i);\n                const s = e.mul(t, i);\n                o = e.mul(o, s);\n                let a = e.pow(o, n);\n                a = e.mul(a, s);\n                const c = e.mul(a, r), l = e.mul(e.sqr(a), i), d = e.eql(l, t);\n                return {\n                    isValid: d,\n                    value: e.cmov(c, a, d)\n                };\n            };\n        }\n        return v;\n    }\n}(cr), Object.defineProperty(sr, \"__esModule\", {\n    value: !0\n}), sr.getHash = hr, sr.createCurve = function(e, t) {\n    const n = (t)=>(0, ur.weierstrass)({\n            ...e,\n            ...hr(t)\n        });\n    return Object.freeze({\n        ...n(t),\n        create: n\n    });\n};\nconst lr = ar, dr = ze, ur = cr;\nfunction hr(e) {\n    return {\n        hash: e,\n        hmac: function(t) {\n            for(var _len = arguments.length, n = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                n[_key - 1] = arguments[_key];\n            }\n            return (0, lr.hmac)(e, t, (0, dr.concatBytes)(...n));\n        },\n        randomBytes: dr.randomBytes\n    };\n}\n!function(e) {\n    Object.defineProperty(e, \"__esModule\", {\n        value: !0\n    }), e.encodeToCurve = e.hashToCurve = e.schnorr = e.secp256k1 = void 0;\n    const t = Qn, n = ze, r = sr, i = Dn, o = Ot, s = Nt, a = cr, c = BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\"), l = BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"), d = BigInt(1), u = BigInt(2), h = (e, t)=>(e + t / u) / t;\n    function f(e) {\n        const t = c, n = BigInt(3), r = BigInt(6), i = BigInt(11), s = BigInt(22), a = BigInt(23), l = BigInt(44), d = BigInt(88), h = e * e * e % t, f = h * h * e % t, g = (0, o.pow2)(f, n, t) * f % t, m = (0, o.pow2)(g, n, t) * f % t, y = (0, o.pow2)(m, u, t) * h % t, v = (0, o.pow2)(y, i, t) * y % t, b = (0, o.pow2)(v, s, t) * v % t, w = (0, o.pow2)(b, l, t) * b % t, E = (0, o.pow2)(w, d, t) * w % t, S = (0, o.pow2)(E, l, t) * b % t, _ = (0, o.pow2)(S, n, t) * f % t, C = (0, o.pow2)(_, a, t) * v % t, k = (0, o.pow2)(C, r, t) * h % t, A = (0, o.pow2)(k, u, t);\n        if (!p.eql(p.sqr(A), e)) throw new Error(\"Cannot find square root\");\n        return A;\n    }\n    const p = (0, o.Field)(c, void 0, void 0, {\n        sqrt: f\n    });\n    e.secp256k1 = (0, r.createCurve)({\n        a: BigInt(0),\n        b: BigInt(7),\n        Fp: p,\n        n: l,\n        Gx: BigInt(\"55066263022277343669578718895168534326250603453777594175500187360389116729240\"),\n        Gy: BigInt(\"32670510020758816978083085130507043184471273380659243275938904335757337482424\"),\n        h: BigInt(1),\n        lowS: !0,\n        endo: {\n            beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n            splitScalar: (e)=>{\n                const t = l, n = BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\"), r = -d * BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\"), i = BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\"), s = n, a = BigInt(\"0x100000000000000000000000000000000\"), c = h(s * e, t), u = h(-r * e, t);\n                let f = (0, o.mod)(e - c * n - u * i, t), p = (0, o.mod)(-c * r - u * s, t);\n                const g = f > a, m = p > a;\n                if (g && (f = t - f), m && (p = t - p), f > a || p > a) throw new Error(\"splitScalar: Endomorphism failed, k=\" + e);\n                return {\n                    k1neg: g,\n                    k1: f,\n                    k2neg: m,\n                    k2: p\n                };\n            }\n        }\n    }, t.sha256);\n    const g = BigInt(0), m = {};\n    function y(e) {\n        for(var _len = arguments.length, n = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            n[_key - 1] = arguments[_key];\n        }\n        let r = m[e];\n        if (void 0 === r) {\n            const n = (0, t.sha256)(Uint8Array.from(e, (e)=>e.charCodeAt(0)));\n            r = (0, s.concatBytes)(n, n), m[e] = r;\n        }\n        return (0, t.sha256)((0, s.concatBytes)(r, ...n));\n    }\n    const v = (e)=>e.toRawBytes(!0).slice(1), b = (e)=>(0, s.numberToBytesBE)(e, 32), w = (e)=>(0, o.mod)(e, c), E = (e)=>(0, o.mod)(e, l), S = e.secp256k1.ProjectivePoint, _ = (e, t, n)=>S.BASE.multiplyAndAddUnsafe(e, t, n);\n    function C(t) {\n        let n = e.secp256k1.utils.normPrivateKeyToScalar(t), r = S.fromPrivateKey(n);\n        return {\n            scalar: r.hasEvenY() ? n : E(-n),\n            bytes: v(r)\n        };\n    }\n    function k(e) {\n        (0, s.aInRange)(\"x\", e, d, c);\n        const t = w(e * e);\n        let n = f(w(t * e + BigInt(7)));\n        n % u !== g && (n = w(-n));\n        const r = new S(e, n, d);\n        return r.assertValidity(), r;\n    }\n    const A = s.bytesToNumberBE;\n    function x() {\n        for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n            e[_key] = arguments[_key];\n        }\n        return E(A(y(\"BIP0340/challenge\", ...e)));\n    }\n    function M(e) {\n        return C(e).bytes;\n    }\n    function I(e, t) {\n        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (0, n.randomBytes)(32);\n        const i = (0, s.ensureBytes)(\"message\", e), { bytes: o, scalar: a } = C(t), c = (0, s.ensureBytes)(\"auxRand\", r, 32), l = b(a ^ A(y(\"BIP0340/aux\", c))), d = y(\"BIP0340/nonce\", l, o, i), u = E(A(d));\n        if (u === g) throw new Error(\"sign failed: k is zero\");\n        const { bytes: h, scalar: f } = C(u), p = x(h, o, i), m = new Uint8Array(64);\n        if (m.set(h, 0), m.set(b(E(f + p * a)), 32), !T(m, i, o)) throw new Error(\"sign: Invalid signature produced\");\n        return m;\n    }\n    function T(e, t, n) {\n        const r = (0, s.ensureBytes)(\"signature\", e, 64), i = (0, s.ensureBytes)(\"message\", t), o = (0, s.ensureBytes)(\"publicKey\", n, 32);\n        try {\n            const e = k(A(o)), t = A(r.subarray(0, 32));\n            if (!(0, s.inRange)(t, d, c)) return !1;\n            const n = A(r.subarray(32, 64));\n            if (!(0, s.inRange)(n, d, l)) return !1;\n            const a = x(b(t), v(e), i), u = _(e, n, E(-a));\n            return !(!u || !u.hasEvenY() || u.toAffine().x !== t);\n        } catch (e) {\n            return !1;\n        }\n    }\n    e.schnorr = {\n        getPublicKey: M,\n        sign: I,\n        verify: T,\n        utils: {\n            randomPrivateKey: e.secp256k1.utils.randomPrivateKey,\n            lift_x: k,\n            pointToBytes: v,\n            numberToBytesBE: s.numberToBytesBE,\n            bytesToNumberBE: s.bytesToNumberBE,\n            taggedHash: y,\n            mod: o.mod\n        }\n    };\n    const R = (()=>(0, i.isogenyMap)(p, [\n            [\n                \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n                \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n                \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n                \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n            ],\n            [\n                \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n                \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n                \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n            ],\n            [\n                \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n                \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n                \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n                \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n            ],\n            [\n                \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n                \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n                \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n                \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n            ]\n        ].map((e)=>e.map((e)=>BigInt(e)))))(), P = (()=>(0, a.mapToCurveSimpleSWU)(p, {\n            A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n            B: BigInt(\"1771\"),\n            Z: p.create(BigInt(\"-11\"))\n        }))(), O = (()=>(0, i.createHasher)(e.secp256k1.ProjectivePoint, (e)=>{\n            const { x: t, y: n } = P(p.create(e[0]));\n            return R(t, n);\n        }, {\n            DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n            encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n            p: p.ORDER,\n            m: 1,\n            k: 128,\n            expand: \"xmd\",\n            hash: t.sha256\n        }))();\n    e.hashToCurve = O.hashToCurve, e.encodeToCurve = O.encodeToCurve;\n}(Jn);\nvar fr = {};\n!function(e) {\n    Object.defineProperty(e, \"__esModule\", {\n        value: !0\n    }), e.decodeHex = e.remove0x = void 0;\n    var t = pe;\n    e.remove0x = function(e) {\n        return e.startsWith(\"0x\") || e.startsWith(\"0X\") ? e.slice(2) : e;\n    };\n    e.decodeHex = function(n) {\n        return (0, t.hexToBytes)((0, e.remove0x)(n));\n    };\n}(fr), function(e) {\n    Object.defineProperty(e, \"__esModule\", {\n        value: !0\n    }), e.hexToPublicKey = e.convertPublicKeyFormat = e.getSharedPoint = e.getPublicKey = e.isValidPrivateKey = e.getValidSecret = void 0;\n    var t = Te, n = Pe, r = Jn, i = Ce, o = ke, s = fr;\n    e.getValidSecret = function() {\n        var n;\n        do {\n            n = (0, t.randomBytes)(o.SECRET_KEY_LENGTH);\n        }while (!(0, e.isValidPrivateKey)(n));\n        return n;\n    };\n    e.isValidPrivateKey = function(e) {\n        return a((0, i.ellipticCurve)(), function(t) {\n            return t.utils.isValidPrivateKey(e);\n        }, function() {\n            return !0;\n        }, function() {\n            return !0;\n        });\n    };\n    e.getPublicKey = function(e) {\n        return a((0, i.ellipticCurve)(), function(t) {\n            return t.getPublicKey(e);\n        }, function(t) {\n            return t.getPublicKey(e);\n        }, function(t) {\n            return t.getPublicKey(e);\n        });\n    };\n    e.getSharedPoint = function(e, t, n) {\n        return a((0, i.ellipticCurve)(), function(r) {\n            return r.getSharedSecret(e, t, n);\n        }, function(n) {\n            return n.getSharedSecret(e, t);\n        }, function(n) {\n            return l(n, e, t);\n        });\n    };\n    e.convertPublicKeyFormat = function(e, t) {\n        return a((0, i.ellipticCurve)(), function(n) {\n            return n.getSharedSecret(BigInt(1), e, t);\n        }, function() {\n            return e;\n        }, function() {\n            return e;\n        });\n    };\n    function a(e, t, i, o) {\n        if (\"secp256k1\" === e) return t(r.secp256k1);\n        if (\"x25519\" === e) return i(n.x25519);\n        if (\"ed25519\" === e) return o(n.ed25519);\n        throw new Error(\"Not implemented\");\n    }\n    e.hexToPublicKey = function(e) {\n        var t = (0, s.decodeHex)(e);\n        return a((0, i.ellipticCurve)(), function() {\n            return c(t);\n        }, function() {\n            return t;\n        }, function() {\n            return t;\n        });\n    };\n    var c = function(e) {\n        if (e.length === o.ETH_PUBLIC_KEY_SIZE) {\n            var t = new Uint8Array(1 + e.length);\n            return t.set([\n                4\n            ]), t.set(e, 1), t;\n        }\n        return e;\n    }, l = function(e, t, n) {\n        var r = e.utils.getExtendedPublicKey(t).scalar;\n        return e.ExtendedPoint.fromHex(n).multiply(r).toRawBytes();\n    };\n}(Ie);\nvar pr = {}, gr = {};\nObject.defineProperty(gr, \"__esModule\", {\n    value: !0\n}), gr.hkdf = void 0, gr.extract = br, gr.expand = Sr;\nconst mr = Le, yr = ze, vr = ar;\nfunction br(e, t, n) {\n    return (0, mr.hash)(e), void 0 === n && (n = new Uint8Array(e.outputLen)), (0, vr.hmac)(e, (0, yr.toBytes)(n), (0, yr.toBytes)(t));\n}\nconst wr = new Uint8Array([\n    0\n]), Er = new Uint8Array;\nfunction Sr(e, t, n) {\n    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 32;\n    if ((0, mr.hash)(e), (0, mr.number)(r), r > 255 * e.outputLen) throw new Error(\"Length should be <= 255*HashLen\");\n    const i = Math.ceil(r / e.outputLen);\n    void 0 === n && (n = Er);\n    const o = new Uint8Array(i * e.outputLen), s = vr.hmac.create(e, t), a = s._cloneInto(), c = new Uint8Array(s.outputLen);\n    for(let t = 0; t < i; t++)wr[0] = t + 1, a.update(0 === t ? Er : c).update(n).update(wr).digestInto(c), o.set(c, e.outputLen * t), s._cloneInto(a);\n    return s.destroy(), a.destroy(), c.fill(0), wr.fill(0), o.slice(0, r);\n}\n_c49 = Sr;\ngr.hkdf = (e, t, n, r, i)=>Sr(e, br(e, t, n), r, i), function(e) {\n    Object.defineProperty(e, \"__esModule\", {\n        value: !0\n    }), e.getSharedKey = e.deriveKey = void 0;\n    var t = pe, n = gr, r = Qn;\n    e.deriveKey = function(e, t, i) {\n        return (0, n.hkdf)(r.sha256, e, t, i, 32);\n    };\n    e.getSharedKey = function() {\n        for(var n = [], r = 0; r < arguments.length; r++)n[r] = arguments[r];\n        return (0, e.deriveKey)(t.concatBytes.apply(void 0, n));\n    };\n}(pr);\nvar _r = {}, Cr = {}, kr = {}, Ar = {};\nObject.defineProperty(Ar, \"__esModule\", {\n    value: !0\n}), Ar.polyval = Ar.ghash = void 0, Ar._toGHASHKey = Or;\nconst xr = ge, Mr = pe, Ir = 16, Tr = new Uint8Array(16), Rr = (0, Mr.u32)(Tr), Pr = (e)=>(e >>> 0 & 255) << 24 | (e >>> 8 & 255) << 16 | (e >>> 16 & 255) << 8 | e >>> 24 & 255 | 0;\nfunction Or(e) {\n    e.reverse();\n    const t = 1 & e[15];\n    let n = 0;\n    for(let t = 0; t < e.length; t++){\n        const r = e[t];\n        e[t] = r >>> 1 | n, n = (1 & r) << 7;\n    }\n    return e[0] ^= 225 & -t, e;\n}\n_c50 = Or;\nclass Nr {\n    _updateBlock(e, t, n, r) {\n        e ^= this.s0, t ^= this.s1, n ^= this.s2, r ^= this.s3;\n        const { W: i, t: o, windowSize: s } = this;\n        let a = 0, c = 0, l = 0, d = 0;\n        const u = (1 << i) - 1;\n        let h = 0;\n        for (const f of [\n            e,\n            t,\n            n,\n            r\n        ])for(let e = 0; e < 4; e++){\n            const t = f >>> 8 * e & 255;\n            for(let e = 8 / i - 1; e >= 0; e--){\n                const n = t >>> i * e & u, { s0: r, s1: f, s2: p, s3: g } = o[h * s + n];\n                a ^= r, c ^= f, l ^= p, d ^= g, h += 1;\n            }\n        }\n        this.s0 = a, this.s1 = c, this.s2 = l, this.s3 = d;\n    }\n    update(e) {\n        e = (0, Mr.toBytes)(e), (0, xr.exists)(this);\n        const t = (0, Mr.u32)(e), n = Math.floor(e.length / Ir), r = e.length % Ir;\n        for(let e = 0; e < n; e++)this._updateBlock(t[4 * e + 0], t[4 * e + 1], t[4 * e + 2], t[4 * e + 3]);\n        return r && (Tr.set(e.subarray(n * Ir)), this._updateBlock(Rr[0], Rr[1], Rr[2], Rr[3]), (0, Mr.clean)(Rr)), this;\n    }\n    destroy() {\n        const { t: e } = this;\n        for (const t of e)t.s0 = 0, t.s1 = 0, t.s2 = 0, t.s3 = 0;\n    }\n    digestInto(e) {\n        (0, xr.exists)(this), (0, xr.output)(e, this), this.finished = !0;\n        const { s0: t, s1: n, s2: r, s3: i } = this, o = (0, Mr.u32)(e);\n        return o[0] = t, o[1] = n, o[2] = r, o[3] = i, e;\n    }\n    digest() {\n        const e = new Uint8Array(Ir);\n        return this.digestInto(e), this.destroy(), e;\n    }\n    constructor(e, t){\n        this.blockLen = Ir, this.outputLen = Ir, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.s3 = 0, this.finished = !1, e = (0, Mr.toBytes)(e), (0, xr.bytes)(e, 16);\n        const n = (0, Mr.createView)(e);\n        let r = n.getUint32(0, !1), i = n.getUint32(4, !1), o = n.getUint32(8, !1), s = n.getUint32(12, !1);\n        const a = [];\n        for(let e = 0; e < 128; e++)a.push({\n            s0: Pr(r),\n            s1: Pr(i),\n            s2: Pr(o),\n            s3: Pr(s)\n        }), { s0: r, s1: i, s2: o, s3: s } = {\n            s3: (d = o) << 31 | (u = s) >>> 1,\n            s2: (l = i) << 31 | d >>> 1,\n            s1: (c = r) << 31 | l >>> 1,\n            s0: c >>> 1 ^ 225 << 24 & -(1 & u)\n        };\n        var c, l, d, u;\n        const h = ((e)=>e > 65536 ? 8 : e > 1024 ? 4 : 2)(t || 1024);\n        if (![\n            1,\n            2,\n            4,\n            8\n        ].includes(h)) throw new Error(\"ghash: wrong window size=\".concat(h, \", should be 2, 4 or 8\"));\n        this.W = h;\n        const f = 128 / h, p = this.windowSize = 2 ** h, g = [];\n        for(let e = 0; e < f; e++)for(let t = 0; t < p; t++){\n            let n = 0, r = 0, i = 0, o = 0;\n            for(let s = 0; s < h; s++){\n                if (!(t >>> h - s - 1 & 1)) continue;\n                const { s0: c, s1: l, s2: d, s3: u } = a[h * e + s];\n                n ^= c, r ^= l, i ^= d, o ^= u;\n            }\n            g.push({\n                s0: n,\n                s1: r,\n                s2: i,\n                s3: o\n            });\n        }\n        this.t = g;\n    }\n}\nclass Lr extends Nr {\n    update(e) {\n        e = (0, Mr.toBytes)(e), (0, xr.exists)(this);\n        const t = (0, Mr.u32)(e), n = e.length % Ir, r = Math.floor(e.length / Ir);\n        for(let e = 0; e < r; e++)this._updateBlock(Pr(t[4 * e + 3]), Pr(t[4 * e + 2]), Pr(t[4 * e + 1]), Pr(t[4 * e + 0]));\n        return n && (Tr.set(e.subarray(r * Ir)), this._updateBlock(Pr(Rr[3]), Pr(Rr[2]), Pr(Rr[1]), Pr(Rr[0])), (0, Mr.clean)(Rr)), this;\n    }\n    digestInto(e) {\n        (0, xr.exists)(this), (0, xr.output)(e, this), this.finished = !0;\n        const { s0: t, s1: n, s2: r, s3: i } = this, o = (0, Mr.u32)(e);\n        return o[0] = t, o[1] = n, o[2] = r, o[3] = i, e.reverse();\n    }\n    constructor(e, t){\n        e = (0, Mr.toBytes)(e);\n        const n = Or((0, Mr.copyBytes)(e));\n        super(n, t), (0, Mr.clean)(n);\n    }\n}\nfunction Dr(e) {\n    const t = (t, n)=>e(n, t.length).update((0, Mr.toBytes)(t)).digest(), n = e(new Uint8Array(16), 0);\n    return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = (t, n)=>e(t, n), t;\n}\n_c51 = Dr;\nAr.ghash = Dr((e, t)=>new Nr(e, t)), Ar.polyval = Dr((e, t)=>new Lr(e, t)), Object.defineProperty(kr, \"__esModule\", {\n    value: !0\n}), kr.unsafe = kr.aeskwp = kr.aeskw = kr.siv = kr.gcm = kr.cfb = kr.cbc = kr.ecb = kr.ctr = void 0, kr.expandKeyLE = ei, kr.expandKeyDecLE = ti;\nconst $r = ge, Br = Ar, Kr = pe, jr = 16, Ur = new Uint8Array(jr), Hr = 283;\nfunction Fr(e) {\n    return e << 1 ^ Hr & -(e >> 7);\n}\n_c52 = Fr;\nfunction zr(e, t) {\n    let n = 0;\n    for(; t > 0; t >>= 1)n ^= e & -(1 & t), e = Fr(e);\n    return n;\n}\nconst qr = (()=>{\n    const e = new Uint8Array(256);\n    for(let t = 0, n = 1; t < 256; t++, n ^= Fr(n))e[t] = n;\n    const t = new Uint8Array(256);\n    t[0] = 99;\n    for(let n = 0; n < 255; n++){\n        let r = e[255 - n];\n        r |= r << 8, t[e[n]] = 255 & (r ^ r >> 4 ^ r >> 5 ^ r >> 6 ^ r >> 7 ^ 99);\n    }\n    return (0, Kr.clean)(e), t;\n})(), Wr = qr.map((e, t)=>qr.indexOf(t)), Vr = (e)=>e << 24 | e >>> 8, Gr = (e)=>e << 8 | e >>> 24, Yr = (e)=>e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;\nfunction Zr(e, t) {\n    if (256 !== e.length) throw new Error(\"Wrong sbox length\");\n    const n = new Uint32Array(256).map((n, r)=>t(e[r])), r = n.map(Gr), i = r.map(Gr), o = i.map(Gr), s = new Uint32Array(65536), a = new Uint32Array(65536), c = new Uint16Array(65536);\n    for(let t = 0; t < 256; t++)for(let l = 0; l < 256; l++){\n        const d = 256 * t + l;\n        s[d] = n[t] ^ r[l], a[d] = i[t] ^ o[l], c[d] = e[t] << 8 | e[l];\n    }\n    return {\n        sbox: e,\n        sbox2: c,\n        T0: n,\n        T1: r,\n        T2: i,\n        T3: o,\n        T01: s,\n        T23: a\n    };\n}\n_c53 = Zr;\nconst Jr = Zr(qr, (e)=>zr(e, 3) << 24 | e << 16 | e << 8 | zr(e, 2)), Qr = Zr(Wr, (e)=>zr(e, 11) << 24 | zr(e, 13) << 16 | zr(e, 9) << 8 | zr(e, 14)), Xr = (()=>{\n    const e = new Uint8Array(16);\n    for(let t = 0, n = 1; t < 16; t++, n = Fr(n))e[t] = n;\n    return e;\n})();\nfunction ei(e) {\n    (0, $r.bytes)(e);\n    const t = e.length;\n    if (![\n        16,\n        24,\n        32\n    ].includes(t)) throw new Error(\"aes: wrong key size: should be 16, 24 or 32, got: \".concat(t));\n    const { sbox2: n } = Jr, r = [];\n    (0, Kr.isAligned32)(e) || r.push(e = (0, Kr.copyBytes)(e));\n    const i = (0, Kr.u32)(e), o = i.length, s = (e)=>ri(n, e, e, e, e), a = new Uint32Array(t + 28);\n    a.set(i);\n    for(let e = o; e < a.length; e++){\n        let t = a[e - 1];\n        e % o == 0 ? t = s(Vr(t)) ^ Xr[e / o - 1] : o > 6 && e % o == 4 && (t = s(t)), a[e] = a[e - o] ^ t;\n    }\n    return (0, Kr.clean)(...r), a;\n}\nfunction ti(e) {\n    const t = ei(e), n = t.slice(), r = t.length, { sbox2: i } = Jr, { T0: o, T1: s, T2: a, T3: c } = Qr;\n    for(let e = 0; e < r; e += 4)for(let i = 0; i < 4; i++)n[e + i] = t[r - e - 4 + i];\n    (0, Kr.clean)(t);\n    for(let e = 4; e < r - 4; e++){\n        const t = n[e], r = ri(i, t, t, t, t);\n        n[e] = o[255 & r] ^ s[r >>> 8 & 255] ^ a[r >>> 16 & 255] ^ c[r >>> 24];\n    }\n    return n;\n}\nfunction ni(e, t, n, r, i, o) {\n    return e[n << 8 & 65280 | r >>> 8 & 255] ^ t[i >>> 8 & 65280 | o >>> 24 & 255];\n}\nfunction ri(e, t, n, r, i) {\n    return e[255 & t | 65280 & n] | e[r >>> 16 & 255 | i >>> 16 & 65280] << 16;\n}\nfunction ii(e, t, n, r, i) {\n    const { sbox2: o, T01: s, T23: a } = Jr;\n    let c = 0;\n    t ^= e[c++], n ^= e[c++], r ^= e[c++], i ^= e[c++];\n    const l = e.length / 4 - 2;\n    for(let o = 0; o < l; o++){\n        const o = e[c++] ^ ni(s, a, t, n, r, i), l = e[c++] ^ ni(s, a, n, r, i, t), d = e[c++] ^ ni(s, a, r, i, t, n), u = e[c++] ^ ni(s, a, i, t, n, r);\n        t = o, n = l, r = d, i = u;\n    }\n    return {\n        s0: e[c++] ^ ri(o, t, n, r, i),\n        s1: e[c++] ^ ri(o, n, r, i, t),\n        s2: e[c++] ^ ri(o, r, i, t, n),\n        s3: e[c++] ^ ri(o, i, t, n, r)\n    };\n}\nfunction oi(e, t, n, r, i) {\n    const { sbox2: o, T01: s, T23: a } = Qr;\n    let c = 0;\n    t ^= e[c++], n ^= e[c++], r ^= e[c++], i ^= e[c++];\n    const l = e.length / 4 - 2;\n    for(let o = 0; o < l; o++){\n        const o = e[c++] ^ ni(s, a, t, i, r, n), l = e[c++] ^ ni(s, a, n, t, i, r), d = e[c++] ^ ni(s, a, r, n, t, i), u = e[c++] ^ ni(s, a, i, r, n, t);\n        t = o, n = l, r = d, i = u;\n    }\n    return {\n        s0: e[c++] ^ ri(o, t, i, r, n),\n        s1: e[c++] ^ ri(o, n, t, i, r),\n        s2: e[c++] ^ ri(o, r, n, t, i),\n        s3: e[c++] ^ ri(o, i, r, n, t)\n    };\n}\nfunction si(e, t) {\n    if (void 0 === t) return new Uint8Array(e);\n    if ((0, $r.bytes)(t), t.length < e) throw new Error(\"aes: wrong destination length, expected at least \".concat(e, \", got: \").concat(t.length));\n    if (!(0, Kr.isAligned32)(t)) throw new Error(\"unaligned dst\");\n    return t;\n}\nfunction ai(e, t, n, r) {\n    (0, $r.bytes)(t, jr), (0, $r.bytes)(n);\n    const i = n.length;\n    r = si(i, r);\n    const o = t, s = (0, Kr.u32)(o);\n    let { s0: a, s1: c, s2: l, s3: d } = ii(e, s[0], s[1], s[2], s[3]);\n    const u = (0, Kr.u32)(n), h = (0, Kr.u32)(r);\n    for(let t = 0; t + 4 <= u.length; t += 4){\n        h[t + 0] = u[t + 0] ^ a, h[t + 1] = u[t + 1] ^ c, h[t + 2] = u[t + 2] ^ l, h[t + 3] = u[t + 3] ^ d;\n        let n = 1;\n        for(let e = o.length - 1; e >= 0; e--)n = n + (255 & o[e]) | 0, o[e] = 255 & n, n >>>= 8;\n        ({ s0: a, s1: c, s2: l, s3: d } = ii(e, s[0], s[1], s[2], s[3]));\n    }\n    const f = jr * Math.floor(u.length / 4);\n    if (f < i) {\n        const e = new Uint32Array([\n            a,\n            c,\n            l,\n            d\n        ]), t = (0, Kr.u8)(e);\n        for(let e = f, o = 0; e < i; e++, o++)r[e] = n[e] ^ t[o];\n        (0, Kr.clean)(e);\n    }\n    return r;\n}\nfunction ci(e, t, n, r, i) {\n    (0, $r.bytes)(n, jr), (0, $r.bytes)(r), i = si(r.length, i);\n    const o = n, s = (0, Kr.u32)(o), a = (0, Kr.createView)(o), c = (0, Kr.u32)(r), l = (0, Kr.u32)(i), d = t ? 0 : 12, u = r.length;\n    let h = a.getUint32(d, t), { s0: f, s1: p, s2: g, s3: m } = ii(e, s[0], s[1], s[2], s[3]);\n    for(let n = 0; n + 4 <= c.length; n += 4)l[n + 0] = c[n + 0] ^ f, l[n + 1] = c[n + 1] ^ p, l[n + 2] = c[n + 2] ^ g, l[n + 3] = c[n + 3] ^ m, h = h + 1 >>> 0, a.setUint32(d, h, t), { s0: f, s1: p, s2: g, s3: m } = ii(e, s[0], s[1], s[2], s[3]);\n    const y = jr * Math.floor(c.length / 4);\n    if (y < u) {\n        const e = new Uint32Array([\n            f,\n            p,\n            g,\n            m\n        ]), t = (0, Kr.u8)(e);\n        for(let e = y, n = 0; e < u; e++, n++)i[e] = r[e] ^ t[n];\n        (0, Kr.clean)(e);\n    }\n    return i;\n}\nfunction li(e) {\n    if ((0, $r.bytes)(e), e.length % jr != 0) throw new Error(\"aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size 16\");\n}\nfunction di(e, t, n) {\n    (0, $r.bytes)(e);\n    let r = e.length;\n    const i = r % jr;\n    if (!t && 0 !== i) throw new Error(\"aec/(cbc-ecb): unpadded plaintext with disabled padding\");\n    (0, Kr.isAligned32)(e) || (e = (0, Kr.copyBytes)(e));\n    const o = (0, Kr.u32)(e);\n    if (t) {\n        let e = jr - i;\n        e || (e = jr), r += e;\n    }\n    const s = si(r, n);\n    return {\n        b: o,\n        o: (0, Kr.u32)(s),\n        out: s\n    };\n}\nfunction ui(e, t) {\n    if (!t) return e;\n    const n = e.length;\n    if (!n) throw new Error(\"aes/pcks5: empty ciphertext not allowed\");\n    const r = e[n - 1];\n    if (r <= 0 || r > 16) throw new Error(\"aes/pcks5: wrong padding\");\n    const i = e.subarray(0, -r);\n    for(let t = 0; t < r; t++)if (e[n - t - 1] !== r) throw new Error(\"aes/pcks5: wrong padding\");\n    return i;\n}\nfunction hi(e) {\n    const t = new Uint8Array(16), n = (0, Kr.u32)(t);\n    t.set(e);\n    const r = jr - e.length;\n    for(let e = jr - r; e < jr; e++)t[e] = r;\n    return n;\n}\nfunction fi(e, t, n, r, i) {\n    const o = null == i ? 0 : i.length, s = e.create(n, r.length + o);\n    i && s.update(i), s.update(r);\n    const a = new Uint8Array(16), c = (0, Kr.createView)(a);\n    i && (0, Kr.setBigUint64)(c, 0, BigInt(8 * o), t), (0, Kr.setBigUint64)(c, 8, BigInt(8 * r.length), t), s.update(a);\n    const l = s.digest();\n    return (0, Kr.clean)(a), l;\n}\nkr.ctr = (0, Kr.wrapCipher)({\n    blockSize: 16,\n    nonceLength: 16\n}, function(e, t) {\n    function n(n, r) {\n        if ((0, $r.bytes)(n), void 0 !== r && ((0, $r.bytes)(r), !(0, Kr.isAligned32)(r))) throw new Error(\"unaligned destination\");\n        const i = ei(e), o = (0, Kr.copyBytes)(t), s = [\n            i,\n            o\n        ];\n        (0, Kr.isAligned32)(n) || s.push(n = (0, Kr.copyBytes)(n));\n        const a = ai(i, o, n, r);\n        return (0, Kr.clean)(...s), a;\n    }\n    return (0, $r.bytes)(e), (0, $r.bytes)(t, jr), {\n        encrypt: (e, t)=>n(e, t),\n        decrypt: (e, t)=>n(e, t)\n    };\n}), kr.ecb = (0, Kr.wrapCipher)({\n    blockSize: 16\n}, function(e) {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    (0, $r.bytes)(e);\n    const n = !t.disablePadding;\n    return {\n        encrypt (t, r) {\n            const { b: i, o: o, out: s } = di(t, n, r), a = ei(e);\n            let c = 0;\n            for(; c + 4 <= i.length;){\n                const { s0: e, s1: t, s2: n, s3: r } = ii(a, i[c + 0], i[c + 1], i[c + 2], i[c + 3]);\n                o[c++] = e, o[c++] = t, o[c++] = n, o[c++] = r;\n            }\n            if (n) {\n                const e = hi(t.subarray(4 * c)), { s0: n, s1: r, s2: i, s3: s } = ii(a, e[0], e[1], e[2], e[3]);\n                o[c++] = n, o[c++] = r, o[c++] = i, o[c++] = s;\n            }\n            return (0, Kr.clean)(a), s;\n        },\n        decrypt (t, r) {\n            li(t);\n            const i = ti(e), o = si(t.length, r), s = [\n                i\n            ];\n            (0, Kr.isAligned32)(t) || s.push(t = (0, Kr.copyBytes)(t));\n            const a = (0, Kr.u32)(t), c = (0, Kr.u32)(o);\n            for(let e = 0; e + 4 <= a.length;){\n                const { s0: t, s1: n, s2: r, s3: o } = oi(i, a[e + 0], a[e + 1], a[e + 2], a[e + 3]);\n                c[e++] = t, c[e++] = n, c[e++] = r, c[e++] = o;\n            }\n            return (0, Kr.clean)(...s), ui(o, n);\n        }\n    };\n}), kr.cbc = (0, Kr.wrapCipher)({\n    blockSize: 16,\n    nonceLength: 16\n}, function(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    (0, $r.bytes)(e), (0, $r.bytes)(t, 16);\n    const r = !n.disablePadding;\n    return {\n        encrypt (n, i) {\n            const o = ei(e), { b: s, o: a, out: c } = di(n, r, i);\n            let l = t;\n            const d = [\n                o\n            ];\n            (0, Kr.isAligned32)(l) || d.push(l = (0, Kr.copyBytes)(l));\n            const u = (0, Kr.u32)(l);\n            let h = u[0], f = u[1], p = u[2], g = u[3], m = 0;\n            for(; m + 4 <= s.length;)h ^= s[m + 0], f ^= s[m + 1], p ^= s[m + 2], g ^= s[m + 3], ({ s0: h, s1: f, s2: p, s3: g } = ii(o, h, f, p, g)), a[m++] = h, a[m++] = f, a[m++] = p, a[m++] = g;\n            if (r) {\n                const e = hi(n.subarray(4 * m));\n                h ^= e[0], f ^= e[1], p ^= e[2], g ^= e[3], ({ s0: h, s1: f, s2: p, s3: g } = ii(o, h, f, p, g)), a[m++] = h, a[m++] = f, a[m++] = p, a[m++] = g;\n            }\n            return (0, Kr.clean)(...d), c;\n        },\n        decrypt (n, i) {\n            li(n);\n            const o = ti(e);\n            let s = t;\n            const a = [\n                o\n            ];\n            (0, Kr.isAligned32)(s) || a.push(s = (0, Kr.copyBytes)(s));\n            const c = (0, Kr.u32)(s), l = si(n.length, i);\n            (0, Kr.isAligned32)(n) || a.push(n = (0, Kr.copyBytes)(n));\n            const d = (0, Kr.u32)(n), u = (0, Kr.u32)(l);\n            let h = c[0], f = c[1], p = c[2], g = c[3];\n            for(let e = 0; e + 4 <= d.length;){\n                const t = h, n = f, r = p, i = g;\n                h = d[e + 0], f = d[e + 1], p = d[e + 2], g = d[e + 3];\n                const { s0: s, s1: a, s2: c, s3: l } = oi(o, h, f, p, g);\n                u[e++] = s ^ t, u[e++] = a ^ n, u[e++] = c ^ r, u[e++] = l ^ i;\n            }\n            return (0, Kr.clean)(...a), ui(l, r);\n        }\n    };\n}), kr.cfb = (0, Kr.wrapCipher)({\n    blockSize: 16,\n    nonceLength: 16\n}, function(e, t) {\n    function n(n, r, i) {\n        (0, $r.bytes)(n);\n        const o = n.length;\n        i = si(o, i);\n        const s = ei(e);\n        let a = t;\n        const c = [\n            s\n        ];\n        (0, Kr.isAligned32)(a) || c.push(a = (0, Kr.copyBytes)(a)), (0, Kr.isAligned32)(n) || c.push(n = (0, Kr.copyBytes)(n));\n        const l = (0, Kr.u32)(n), d = (0, Kr.u32)(i), u = r ? d : l, h = (0, Kr.u32)(a);\n        let f = h[0], p = h[1], g = h[2], m = h[3];\n        for(let e = 0; e + 4 <= l.length;){\n            const { s0: t, s1: n, s2: r, s3: i } = ii(s, f, p, g, m);\n            d[e + 0] = l[e + 0] ^ t, d[e + 1] = l[e + 1] ^ n, d[e + 2] = l[e + 2] ^ r, d[e + 3] = l[e + 3] ^ i, f = u[e++], p = u[e++], g = u[e++], m = u[e++];\n        }\n        const y = jr * Math.floor(l.length / 4);\n        if (y < o) {\n            ({ s0: f, s1: p, s2: g, s3: m } = ii(s, f, p, g, m));\n            const e = (0, Kr.u8)(new Uint32Array([\n                f,\n                p,\n                g,\n                m\n            ]));\n            for(let t = y, r = 0; t < o; t++, r++)i[t] = n[t] ^ e[r];\n            (0, Kr.clean)(e);\n        }\n        return (0, Kr.clean)(...c), i;\n    }\n    return (0, $r.bytes)(e), (0, $r.bytes)(t, 16), {\n        encrypt: (e, t)=>n(e, !0, t),\n        decrypt: (e, t)=>n(e, !1, t)\n    };\n}), kr.gcm = (0, Kr.wrapCipher)({\n    blockSize: 16,\n    nonceLength: 12,\n    tagLength: 16\n}, function(e, t, n) {\n    if ((0, $r.bytes)(e), (0, $r.bytes)(t), void 0 !== n && (0, $r.bytes)(n), t.length < 8) throw new Error(\"aes/gcm: invalid nonce length\");\n    const r = 16;\n    function i(e, t, r) {\n        const i = fi(Br.ghash, !1, e, r, n);\n        for(let e = 0; e < t.length; e++)i[e] ^= t[e];\n        return i;\n    }\n    function o() {\n        const n = ei(e), r = Ur.slice(), i = Ur.slice();\n        if (ci(n, !1, i, i, r), 12 === t.length) i.set(t);\n        else {\n            const e = Ur.slice(), n = (0, Kr.createView)(e);\n            (0, Kr.setBigUint64)(n, 8, BigInt(8 * t.length), !1);\n            const o = Br.ghash.create(r).update(t).update(e);\n            o.digestInto(i), o.destroy();\n        }\n        return {\n            xk: n,\n            authKey: r,\n            counter: i,\n            tagMask: ci(n, !1, i, Ur)\n        };\n    }\n    return {\n        encrypt (e) {\n            (0, $r.bytes)(e);\n            const { xk: t, authKey: n, counter: s, tagMask: a } = o(), c = new Uint8Array(e.length + r), l = [\n                t,\n                n,\n                s,\n                a\n            ];\n            (0, Kr.isAligned32)(e) || l.push(e = (0, Kr.copyBytes)(e)), ci(t, !1, s, e, c);\n            const d = i(n, a, c.subarray(0, c.length - r));\n            return l.push(d), c.set(d, e.length), (0, Kr.clean)(...l), c;\n        },\n        decrypt (e) {\n            if ((0, $r.bytes)(e), e.length < r) throw new Error(\"aes/gcm: ciphertext less than tagLen (16)\");\n            const { xk: t, authKey: n, counter: s, tagMask: a } = o(), c = [\n                t,\n                n,\n                a,\n                s\n            ];\n            (0, Kr.isAligned32)(e) || c.push(e = (0, Kr.copyBytes)(e));\n            const l = e.subarray(0, -16), d = e.subarray(-16), u = i(n, a, l);\n            if (c.push(u), !(0, Kr.equalBytes)(u, d)) throw new Error(\"aes/gcm: invalid ghash tag\");\n            const h = ci(t, !1, s, l);\n            return (0, Kr.clean)(...c), h;\n        }\n    };\n});\nconst pi = (e, t, n)=>(r)=>{\n        if (!Number.isSafeInteger(r) || t > r || r > n) throw new Error(\"\".concat(e, \": invalid value=\").concat(r, \", must be [\").concat(t, \"..\").concat(n, \"]\"));\n    };\nfunction gi(e) {\n    return null != e && \"object\" == typeof e && (e instanceof Uint32Array || \"Uint32Array\" === e.constructor.name);\n}\nfunction mi(e, t) {\n    if ((0, $r.bytes)(t, 16), !gi(e)) throw new Error(\"_encryptBlock accepts result of expandKeyLE\");\n    const n = (0, Kr.u32)(t);\n    let { s0: r, s1: i, s2: o, s3: s } = ii(e, n[0], n[1], n[2], n[3]);\n    return n[0] = r, n[1] = i, n[2] = o, n[3] = s, t;\n}\nfunction yi(e, t) {\n    if ((0, $r.bytes)(t, 16), !gi(e)) throw new Error(\"_decryptBlock accepts result of expandKeyLE\");\n    const n = (0, Kr.u32)(t);\n    let { s0: r, s1: i, s2: o, s3: s } = oi(e, n[0], n[1], n[2], n[3]);\n    return n[0] = r, n[1] = i, n[2] = o, n[3] = s, t;\n}\nkr.siv = (0, Kr.wrapCipher)({\n    blockSize: 16,\n    nonceLength: 12,\n    tagLength: 16\n}, function(e, t, n) {\n    const r = pi(\"AAD\", 0, 2 ** 36), i = pi(\"plaintext\", 0, 2 ** 36), o = pi(\"nonce\", 12, 12), s = pi(\"ciphertext\", 16, 2 ** 36 + 16);\n    function a() {\n        const n = ei(e), r = new Uint8Array(e.length), i = new Uint8Array(16), o = [\n            n,\n            r\n        ];\n        let s = t;\n        (0, Kr.isAligned32)(s) || o.push(s = (0, Kr.copyBytes)(s));\n        const a = (0, Kr.u32)(s);\n        let c = 0, l = a[0], d = a[1], u = a[2], h = 0;\n        for (const e of [\n            i,\n            r\n        ].map(Kr.u32)){\n            const t = (0, Kr.u32)(e);\n            for(let e = 0; e < t.length; e += 2){\n                const { s0: r, s1: i } = ii(n, c, l, d, u);\n                t[e + 0] = r, t[e + 1] = i, c = ++h;\n            }\n        }\n        const f = {\n            authKey: i,\n            encKey: ei(r)\n        };\n        return (0, Kr.clean)(...o), f;\n    }\n    function c(e, r, i) {\n        const o = fi(Br.polyval, !0, r, i, n);\n        for(let e = 0; e < 12; e++)o[e] ^= t[e];\n        o[15] &= 127;\n        const s = (0, Kr.u32)(o);\n        let a = s[0], c = s[1], l = s[2], d = s[3];\n        return { s0: a, s1: c, s2: l, s3: d } = ii(e, a, c, l, d), s[0] = a, s[1] = c, s[2] = l, s[3] = d, o;\n    }\n    function l(e, t, n) {\n        let r = (0, Kr.copyBytes)(t);\n        r[15] |= 128;\n        const i = ci(e, !0, r, n);\n        return (0, Kr.clean)(r), i;\n    }\n    return (0, $r.bytes)(e, 16, 24, 32), (0, $r.bytes)(t), o(t.length), void 0 !== n && ((0, $r.bytes)(n), r(n.length)), {\n        encrypt (e) {\n            (0, $r.bytes)(e), i(e.length);\n            const { encKey: t, authKey: n } = a(), r = c(t, n, e), o = [\n                t,\n                n,\n                r\n            ];\n            (0, Kr.isAligned32)(e) || o.push(e = (0, Kr.copyBytes)(e));\n            const s = new Uint8Array(e.length + 16);\n            return s.set(r, e.length), s.set(l(t, r, e)), (0, Kr.clean)(...o), s;\n        },\n        decrypt (e) {\n            (0, $r.bytes)(e), s(e.length);\n            const t = e.subarray(-16), { encKey: n, authKey: r } = a(), i = [\n                n,\n                r\n            ];\n            (0, Kr.isAligned32)(e) || i.push(e = (0, Kr.copyBytes)(e));\n            const o = l(n, t, e.subarray(0, -16)), d = c(n, r, o);\n            if (i.push(d), !(0, Kr.equalBytes)(t, d)) throw (0, Kr.clean)(...i), new Error(\"invalid polyval tag\");\n            return (0, Kr.clean)(...i), o;\n        }\n    };\n});\nconst vi = {\n    encrypt (e, t) {\n        if (t.length >= 2 ** 32) throw new Error(\"plaintext should be less than 4gb\");\n        const n = ei(e);\n        if (16 === t.length) mi(n, t);\n        else {\n            const e = (0, Kr.u32)(t);\n            let r = e[0], i = e[1];\n            for(let t = 0, o = 1; t < 6; t++)for(let t = 2; t < e.length; t += 2, o++){\n                const { s0: s, s1: a, s2: c, s3: l } = ii(n, r, i, e[t], e[t + 1]);\n                r = s, i = a ^ Yr(o), e[t] = c, e[t + 1] = l;\n            }\n            e[0] = r, e[1] = i;\n        }\n        n.fill(0);\n    },\n    decrypt (e, t) {\n        if (t.length - 8 >= 2 ** 32) throw new Error(\"ciphertext should be less than 4gb\");\n        const n = ti(e), r = t.length / 8 - 1;\n        if (1 === r) yi(n, t);\n        else {\n            const e = (0, Kr.u32)(t);\n            let i = e[0], o = e[1];\n            for(let t = 0, s = 6 * r; t < 6; t++)for(let t = 2 * r; t >= 1; t -= 2, s--){\n                o ^= Yr(s);\n                const { s0: r, s1: a, s2: c, s3: l } = oi(n, i, o, e[t], e[t + 1]);\n                i = r, o = a, e[t] = c, e[t + 1] = l;\n            }\n            e[0] = i, e[1] = o;\n        }\n        n.fill(0);\n    }\n}, bi = new Uint8Array(8).fill(166);\nkr.aeskw = (0, Kr.wrapCipher)({\n    blockSize: 8\n}, (e)=>({\n        encrypt (t) {\n            if ((0, $r.bytes)(t), !t.length || t.length % 8 != 0) throw new Error(\"invalid plaintext length\");\n            if (8 === t.length) throw new Error(\"8-byte keys not allowed in AESKW, use AESKWP instead\");\n            const n = (0, Kr.concatBytes)(bi, t);\n            return vi.encrypt(e, n), n;\n        },\n        decrypt (t) {\n            if ((0, $r.bytes)(t), t.length % 8 != 0 || t.length < 24) throw new Error(\"invalid ciphertext length\");\n            const n = (0, Kr.copyBytes)(t);\n            if (vi.decrypt(e, n), !(0, Kr.equalBytes)(n.subarray(0, 8), bi)) throw new Error(\"integrity check failed\");\n            return n.subarray(0, 8).fill(0), n.subarray(8);\n        }\n    }));\nconst wi = 2790873510;\nkr.aeskwp = (0, Kr.wrapCipher)({\n    blockSize: 8\n}, (e)=>({\n        encrypt (t) {\n            if ((0, $r.bytes)(t), !t.length) throw new Error(\"invalid plaintext length\");\n            const n = 8 * Math.ceil(t.length / 8), r = new Uint8Array(8 + n);\n            r.set(t, 8);\n            const i = (0, Kr.u32)(r);\n            return i[0] = wi, i[1] = Yr(t.length), vi.encrypt(e, r), r;\n        },\n        decrypt (t) {\n            if ((0, $r.bytes)(t), t.length < 16) throw new Error(\"invalid ciphertext length\");\n            const n = (0, Kr.copyBytes)(t), r = (0, Kr.u32)(n);\n            vi.decrypt(e, n);\n            const i = Yr(r[1]) >>> 0, o = 8 * Math.ceil(i / 8);\n            if (r[0] !== wi || n.length - 8 !== o) throw new Error(\"integrity check failed\");\n            for(let e = i; e < o; e++)if (0 !== n[8 + e]) throw new Error(\"integrity check failed\");\n            return n.subarray(0, 8).fill(0), n.subarray(8, 8 + i);\n        }\n    })), kr.unsafe = {\n    expandKeyLE: ei,\n    expandKeyDecLE: ti,\n    encrypt: ii,\n    decrypt: oi,\n    encryptBlock: mi,\n    decryptBlock: yi,\n    ctrCounter: ai,\n    ctr32: ci\n}, Object.defineProperty(Cr, \"__esModule\", {\n    value: !0\n}), Cr.aes256cbc = Cr.aes256gcm = void 0;\nvar Ei = kr;\nCr.aes256gcm = function(e, t, n) {\n    return (0, Ei.gcm)(e, t, n);\n};\nCr.aes256cbc = function(e, t, n) {\n    return (0, Ei.cbc)(e, t);\n};\nvar Si = {}, _i = {}, Ci = {};\nObject.defineProperty(Ci, \"__esModule\", {\n    value: !0\n}), Ci.sigma = void 0, Ci.rotl = function(e, t) {\n    return e << t | e >>> 32 - t;\n}, Ci.createCipher = function(e, t) {\n    const { allowShortKeys: n, extendNonceFn: r, counterLength: i, counterRight: o, rounds: s } = (0, Ai.checkOpts)({\n        allowShortKeys: !1,\n        counterLength: 8,\n        counterRight: !1,\n        rounds: 20\n    }, t);\n    if (\"function\" != typeof e) throw new Error(\"core must be a function\");\n    return (0, ki.number)(i), (0, ki.number)(s), (0, ki.bool)(o), (0, ki.bool)(n), function(t, a, c, l) {\n        let d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;\n        (0, ki.bytes)(t), (0, ki.bytes)(a), (0, ki.bytes)(c);\n        const u = c.length;\n        if (void 0 === l && (l = new Uint8Array(u)), (0, ki.bytes)(l), (0, ki.number)(d), d < 0 || d >= Li) throw new Error(\"arx: counter overflow\");\n        if (l.length < u) throw new Error(\"arx: output (\".concat(l.length, \") is shorter than data (\").concat(u, \")\"));\n        const h = [];\n        let f, p, g = t.length;\n        if (32 === g) h.push(f = (0, Ai.copyBytes)(t)), p = Ri;\n        else {\n            if (16 !== g || !n) throw new Error(\"arx: invalid 32-byte key, got length=\".concat(g));\n            f = new Uint8Array(32), f.set(t), f.set(t, 16), p = Ti, h.push(f);\n        }\n        Pi(a) || h.push(a = (0, Ai.copyBytes)(a));\n        const m = (0, Ai.u32)(f);\n        if (r) {\n            if (24 !== a.length) throw new Error(\"arx: extended nonce must be 24 bytes\");\n            r(p, m, (0, Ai.u32)(a.subarray(0, 16)), m), a = a.subarray(16);\n        }\n        const y = 16 - i;\n        if (y !== a.length) throw new Error(\"arx: nonce must be \".concat(y, \" or 16 bytes\"));\n        if (12 !== y) {\n            const e = new Uint8Array(12);\n            e.set(a, o ? 0 : 12 - a.length), a = e, h.push(a);\n        }\n        const v = (0, Ai.u32)(a);\n        return function(e, t, n, r, i, o, s, a) {\n            const c = i.length, l = new Uint8Array(Oi), d = (0, Ai.u32)(l), u = Pi(i) && Pi(o), h = u ? (0, Ai.u32)(i) : Di, f = u ? (0, Ai.u32)(o) : Di;\n            for(let p = 0; p < c; s++){\n                if (e(t, n, r, d, s, a), s >= Li) throw new Error(\"arx: counter overflow\");\n                const g = Math.min(Oi, c - p);\n                if (u && g === Oi) {\n                    const e = p / 4;\n                    if (p % 4 != 0) throw new Error(\"arx: invalid block position\");\n                    for(let t, n = 0; n < Ni; n++)t = e + n, f[t] = h[t] ^ d[n];\n                    p += Oi;\n                } else {\n                    for(let e, t = 0; t < g; t++)e = p + t, o[e] = i[e] ^ l[t];\n                    p += g;\n                }\n            }\n        }(e, p, m, v, c, l, d, s), (0, Ai.clean)(...h), l;\n    };\n};\nconst ki = ge, Ai = pe, xi = (e)=>Uint8Array.from(e.split(\"\").map((e)=>e.charCodeAt(0))), Mi = xi(\"expand 16-byte k\"), Ii = xi(\"expand 32-byte k\"), Ti = (0, Ai.u32)(Mi), Ri = (0, Ai.u32)(Ii);\nfunction Pi(e) {\n    return e.byteOffset % 4 == 0;\n}\n_c54 = Pi;\nCi.sigma = Ri.slice();\nconst Oi = 64, Ni = 16, Li = 2 ** 32 - 1, Di = new Uint32Array;\nvar $i = {};\nObject.defineProperty($i, \"__esModule\", {\n    value: !0\n}), $i.poly1305 = void 0, $i.wrapConstructorWithKey = Hi;\nconst Bi = ge, Ki = pe, ji = (e, t)=>255 & e[t++] | (255 & e[t++]) << 8;\nclass Ui {\n    process(e, t) {\n        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n        const r = n ? 0 : 2048, { h: i, r: o } = this, s = o[0], a = o[1], c = o[2], l = o[3], d = o[4], u = o[5], h = o[6], f = o[7], p = o[8], g = o[9], m = ji(e, t + 0), y = ji(e, t + 2), v = ji(e, t + 4), b = ji(e, t + 6), w = ji(e, t + 8), E = ji(e, t + 10), S = ji(e, t + 12), _ = ji(e, t + 14);\n        let C = i[0] + (8191 & m), k = i[1] + (8191 & (m >>> 13 | y << 3)), A = i[2] + (8191 & (y >>> 10 | v << 6)), x = i[3] + (8191 & (v >>> 7 | b << 9)), M = i[4] + (8191 & (b >>> 4 | w << 12)), I = i[5] + (w >>> 1 & 8191), T = i[6] + (8191 & (w >>> 14 | E << 2)), R = i[7] + (8191 & (E >>> 11 | S << 5)), P = i[8] + (8191 & (S >>> 8 | _ << 8)), O = i[9] + (_ >>> 5 | r), N = 0, L = N + C * s + k * (5 * g) + A * (5 * p) + x * (5 * f) + M * (5 * h);\n        N = L >>> 13, L &= 8191, L += I * (5 * u) + T * (5 * d) + R * (5 * l) + P * (5 * c) + O * (5 * a), N += L >>> 13, L &= 8191;\n        let D = N + C * a + k * s + A * (5 * g) + x * (5 * p) + M * (5 * f);\n        N = D >>> 13, D &= 8191, D += I * (5 * h) + T * (5 * u) + R * (5 * d) + P * (5 * l) + O * (5 * c), N += D >>> 13, D &= 8191;\n        let $ = N + C * c + k * a + A * s + x * (5 * g) + M * (5 * p);\n        N = $ >>> 13, $ &= 8191, $ += I * (5 * f) + T * (5 * h) + R * (5 * u) + P * (5 * d) + O * (5 * l), N += $ >>> 13, $ &= 8191;\n        let B = N + C * l + k * c + A * a + x * s + M * (5 * g);\n        N = B >>> 13, B &= 8191, B += I * (5 * p) + T * (5 * f) + R * (5 * h) + P * (5 * u) + O * (5 * d), N += B >>> 13, B &= 8191;\n        let K = N + C * d + k * l + A * c + x * a + M * s;\n        N = K >>> 13, K &= 8191, K += I * (5 * g) + T * (5 * p) + R * (5 * f) + P * (5 * h) + O * (5 * u), N += K >>> 13, K &= 8191;\n        let j = N + C * u + k * d + A * l + x * c + M * a;\n        N = j >>> 13, j &= 8191, j += I * s + T * (5 * g) + R * (5 * p) + P * (5 * f) + O * (5 * h), N += j >>> 13, j &= 8191;\n        let U = N + C * h + k * u + A * d + x * l + M * c;\n        N = U >>> 13, U &= 8191, U += I * a + T * s + R * (5 * g) + P * (5 * p) + O * (5 * f), N += U >>> 13, U &= 8191;\n        let H = N + C * f + k * h + A * u + x * d + M * l;\n        N = H >>> 13, H &= 8191, H += I * c + T * a + R * s + P * (5 * g) + O * (5 * p), N += H >>> 13, H &= 8191;\n        let F = N + C * p + k * f + A * h + x * u + M * d;\n        N = F >>> 13, F &= 8191, F += I * l + T * c + R * a + P * s + O * (5 * g), N += F >>> 13, F &= 8191;\n        let z = N + C * g + k * p + A * f + x * h + M * u;\n        N = z >>> 13, z &= 8191, z += I * d + T * l + R * c + P * a + O * s, N += z >>> 13, z &= 8191, N = (N << 2) + N | 0, N = N + L | 0, L = 8191 & N, N >>>= 13, D += N, i[0] = L, i[1] = D, i[2] = $, i[3] = B, i[4] = K, i[5] = j, i[6] = U, i[7] = H, i[8] = F, i[9] = z;\n    }\n    finalize() {\n        const { h: e, pad: t } = this, n = new Uint16Array(10);\n        let r = e[1] >>> 13;\n        e[1] &= 8191;\n        for(let t = 2; t < 10; t++)e[t] += r, r = e[t] >>> 13, e[t] &= 8191;\n        e[0] += 5 * r, r = e[0] >>> 13, e[0] &= 8191, e[1] += r, r = e[1] >>> 13, e[1] &= 8191, e[2] += r, n[0] = e[0] + 5, r = n[0] >>> 13, n[0] &= 8191;\n        for(let t = 1; t < 10; t++)n[t] = e[t] + r, r = n[t] >>> 13, n[t] &= 8191;\n        n[9] -= 8192;\n        let i = (1 ^ r) - 1;\n        for(let e = 0; e < 10; e++)n[e] &= i;\n        i = ~i;\n        for(let t = 0; t < 10; t++)e[t] = e[t] & i | n[t];\n        e[0] = 65535 & (e[0] | e[1] << 13), e[1] = 65535 & (e[1] >>> 3 | e[2] << 10), e[2] = 65535 & (e[2] >>> 6 | e[3] << 7), e[3] = 65535 & (e[3] >>> 9 | e[4] << 4), e[4] = 65535 & (e[4] >>> 12 | e[5] << 1 | e[6] << 14), e[5] = 65535 & (e[6] >>> 2 | e[7] << 11), e[6] = 65535 & (e[7] >>> 5 | e[8] << 8), e[7] = 65535 & (e[8] >>> 8 | e[9] << 5);\n        let o = e[0] + t[0];\n        e[0] = 65535 & o;\n        for(let n = 1; n < 8; n++)o = (e[n] + t[n] | 0) + (o >>> 16) | 0, e[n] = 65535 & o;\n        (0, Ki.clean)(n);\n    }\n    update(e) {\n        (0, Bi.exists)(this);\n        const { buffer: t, blockLen: n } = this, r = (e = (0, Ki.toBytes)(e)).length;\n        for(let i = 0; i < r;){\n            const o = Math.min(n - this.pos, r - i);\n            if (o !== n) t.set(e.subarray(i, i + o), this.pos), this.pos += o, i += o, this.pos === n && (this.process(t, 0, !1), this.pos = 0);\n            else for(; n <= r - i; i += n)this.process(e, i);\n        }\n        return this;\n    }\n    destroy() {\n        (0, Ki.clean)(this.h, this.r, this.buffer, this.pad);\n    }\n    digestInto(e) {\n        (0, Bi.exists)(this), (0, Bi.output)(e, this), this.finished = !0;\n        const { buffer: t, h: n } = this;\n        let { pos: r } = this;\n        if (r) {\n            for(t[r++] = 1; r < 16; r++)t[r] = 0;\n            this.process(t, 0, !0);\n        }\n        this.finalize();\n        let i = 0;\n        for(let t = 0; t < 8; t++)e[i++] = n[t] >>> 0, e[i++] = n[t] >>> 8;\n        return e;\n    }\n    digest() {\n        const { buffer: e, outputLen: t } = this;\n        this.digestInto(e);\n        const n = e.slice(0, t);\n        return this.destroy(), n;\n    }\n    constructor(e){\n        this.blockLen = 16, this.outputLen = 16, this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.pos = 0, this.finished = !1, e = (0, Ki.toBytes)(e), (0, Bi.bytes)(e, 32);\n        const t = ji(e, 0), n = ji(e, 2), r = ji(e, 4), i = ji(e, 6), o = ji(e, 8), s = ji(e, 10), a = ji(e, 12), c = ji(e, 14);\n        this.r[0] = 8191 & t, this.r[1] = 8191 & (t >>> 13 | n << 3), this.r[2] = 7939 & (n >>> 10 | r << 6), this.r[3] = 8191 & (r >>> 7 | i << 9), this.r[4] = 255 & (i >>> 4 | o << 12), this.r[5] = o >>> 1 & 8190, this.r[6] = 8191 & (o >>> 14 | s << 2), this.r[7] = 8065 & (s >>> 11 | a << 5), this.r[8] = 8191 & (a >>> 8 | c << 8), this.r[9] = c >>> 5 & 127;\n        for(let t = 0; t < 8; t++)this.pad[t] = ji(e, 16 + 2 * t);\n    }\n}\nfunction Hi(e) {\n    const t = (t, n)=>e(n).update((0, Ki.toBytes)(t)).digest(), n = e(new Uint8Array(32));\n    return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = (t)=>e(t), t;\n}\n_c55 = Hi;\n$i.poly1305 = Hi((e)=>new Ui(e)), function(e) {\n    Object.defineProperty(e, \"__esModule\", {\n        value: !0\n    }), e.xchacha20poly1305 = e.chacha20poly1305 = e._poly1305_aead = e.chacha12 = e.chacha8 = e.xchacha20 = e.chacha20 = e.chacha20orig = void 0, e.hchacha = s;\n    const t = Ci, n = ge, r = $i, i = pe;\n    function o(e, n, r, i, o) {\n        let s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 20;\n        let a = e[0], c = e[1], l = e[2], d = e[3], u = n[0], h = n[1], f = n[2], p = n[3], g = n[4], m = n[5], y = n[6], v = n[7], b = o, w = r[0], E = r[1], S = r[2], _ = a, C = c, k = l, A = d, x = u, M = h, I = f, T = p, R = g, P = m, O = y, N = v, L = b, D = w, $ = E, B = S;\n        for(let e = 0; e < s; e += 2)_ = _ + x | 0, L = (0, t.rotl)(L ^ _, 16), R = R + L | 0, x = (0, t.rotl)(x ^ R, 12), _ = _ + x | 0, L = (0, t.rotl)(L ^ _, 8), R = R + L | 0, x = (0, t.rotl)(x ^ R, 7), C = C + M | 0, D = (0, t.rotl)(D ^ C, 16), P = P + D | 0, M = (0, t.rotl)(M ^ P, 12), C = C + M | 0, D = (0, t.rotl)(D ^ C, 8), P = P + D | 0, M = (0, t.rotl)(M ^ P, 7), k = k + I | 0, $ = (0, t.rotl)($ ^ k, 16), O = O + $ | 0, I = (0, t.rotl)(I ^ O, 12), k = k + I | 0, $ = (0, t.rotl)($ ^ k, 8), O = O + $ | 0, I = (0, t.rotl)(I ^ O, 7), A = A + T | 0, B = (0, t.rotl)(B ^ A, 16), N = N + B | 0, T = (0, t.rotl)(T ^ N, 12), A = A + T | 0, B = (0, t.rotl)(B ^ A, 8), N = N + B | 0, T = (0, t.rotl)(T ^ N, 7), _ = _ + M | 0, B = (0, t.rotl)(B ^ _, 16), O = O + B | 0, M = (0, t.rotl)(M ^ O, 12), _ = _ + M | 0, B = (0, t.rotl)(B ^ _, 8), O = O + B | 0, M = (0, t.rotl)(M ^ O, 7), C = C + I | 0, L = (0, t.rotl)(L ^ C, 16), N = N + L | 0, I = (0, t.rotl)(I ^ N, 12), C = C + I | 0, L = (0, t.rotl)(L ^ C, 8), N = N + L | 0, I = (0, t.rotl)(I ^ N, 7), k = k + T | 0, D = (0, t.rotl)(D ^ k, 16), R = R + D | 0, T = (0, t.rotl)(T ^ R, 12), k = k + T | 0, D = (0, t.rotl)(D ^ k, 8), R = R + D | 0, T = (0, t.rotl)(T ^ R, 7), A = A + x | 0, $ = (0, t.rotl)($ ^ A, 16), P = P + $ | 0, x = (0, t.rotl)(x ^ P, 12), A = A + x | 0, $ = (0, t.rotl)($ ^ A, 8), P = P + $ | 0, x = (0, t.rotl)(x ^ P, 7);\n        let K = 0;\n        i[K++] = a + _ | 0, i[K++] = c + C | 0, i[K++] = l + k | 0, i[K++] = d + A | 0, i[K++] = u + x | 0, i[K++] = h + M | 0, i[K++] = f + I | 0, i[K++] = p + T | 0, i[K++] = g + R | 0, i[K++] = m + P | 0, i[K++] = y + O | 0, i[K++] = v + N | 0, i[K++] = b + L | 0, i[K++] = w + D | 0, i[K++] = E + $ | 0, i[K++] = S + B | 0;\n    }\n    function s(e, n, r, i) {\n        let o = e[0], s = e[1], a = e[2], c = e[3], l = n[0], d = n[1], u = n[2], h = n[3], f = n[4], p = n[5], g = n[6], m = n[7], y = r[0], v = r[1], b = r[2], w = r[3];\n        for(let e = 0; e < 20; e += 2)o = o + l | 0, y = (0, t.rotl)(y ^ o, 16), f = f + y | 0, l = (0, t.rotl)(l ^ f, 12), o = o + l | 0, y = (0, t.rotl)(y ^ o, 8), f = f + y | 0, l = (0, t.rotl)(l ^ f, 7), s = s + d | 0, v = (0, t.rotl)(v ^ s, 16), p = p + v | 0, d = (0, t.rotl)(d ^ p, 12), s = s + d | 0, v = (0, t.rotl)(v ^ s, 8), p = p + v | 0, d = (0, t.rotl)(d ^ p, 7), a = a + u | 0, b = (0, t.rotl)(b ^ a, 16), g = g + b | 0, u = (0, t.rotl)(u ^ g, 12), a = a + u | 0, b = (0, t.rotl)(b ^ a, 8), g = g + b | 0, u = (0, t.rotl)(u ^ g, 7), c = c + h | 0, w = (0, t.rotl)(w ^ c, 16), m = m + w | 0, h = (0, t.rotl)(h ^ m, 12), c = c + h | 0, w = (0, t.rotl)(w ^ c, 8), m = m + w | 0, h = (0, t.rotl)(h ^ m, 7), o = o + d | 0, w = (0, t.rotl)(w ^ o, 16), g = g + w | 0, d = (0, t.rotl)(d ^ g, 12), o = o + d | 0, w = (0, t.rotl)(w ^ o, 8), g = g + w | 0, d = (0, t.rotl)(d ^ g, 7), s = s + u | 0, y = (0, t.rotl)(y ^ s, 16), m = m + y | 0, u = (0, t.rotl)(u ^ m, 12), s = s + u | 0, y = (0, t.rotl)(y ^ s, 8), m = m + y | 0, u = (0, t.rotl)(u ^ m, 7), a = a + h | 0, v = (0, t.rotl)(v ^ a, 16), f = f + v | 0, h = (0, t.rotl)(h ^ f, 12), a = a + h | 0, v = (0, t.rotl)(v ^ a, 8), f = f + v | 0, h = (0, t.rotl)(h ^ f, 7), c = c + l | 0, b = (0, t.rotl)(b ^ c, 16), p = p + b | 0, l = (0, t.rotl)(l ^ p, 12), c = c + l | 0, b = (0, t.rotl)(b ^ c, 8), p = p + b | 0, l = (0, t.rotl)(l ^ p, 7);\n        let E = 0;\n        i[E++] = o, i[E++] = s, i[E++] = a, i[E++] = c, i[E++] = y, i[E++] = v, i[E++] = b, i[E++] = w;\n    }\n    e.chacha20orig = (0, t.createCipher)(o, {\n        counterRight: !1,\n        counterLength: 8,\n        allowShortKeys: !0\n    }), e.chacha20 = (0, t.createCipher)(o, {\n        counterRight: !1,\n        counterLength: 4,\n        allowShortKeys: !1\n    }), e.xchacha20 = (0, t.createCipher)(o, {\n        counterRight: !1,\n        counterLength: 8,\n        extendNonceFn: s,\n        allowShortKeys: !1\n    }), e.chacha8 = (0, t.createCipher)(o, {\n        counterRight: !1,\n        counterLength: 4,\n        rounds: 8\n    }), e.chacha12 = (0, t.createCipher)(o, {\n        counterRight: !1,\n        counterLength: 4,\n        rounds: 12\n    });\n    const a = new Uint8Array(16), c = (e, t)=>{\n        e.update(t);\n        const n = t.length % 16;\n        n && e.update(a.subarray(n));\n    }, l = new Uint8Array(32);\n    function d(e, t, n, o, s) {\n        const a = e(t, n, l), d = r.poly1305.create(a);\n        s && c(d, s), c(d, o);\n        const u = new Uint8Array(16), h = (0, i.createView)(u);\n        (0, i.setBigUint64)(h, 0, BigInt(s ? s.length : 0), !0), (0, i.setBigUint64)(h, 8, BigInt(o.length), !0), d.update(u);\n        const f = d.digest();\n        return (0, i.clean)(a, u), f;\n    }\n    e._poly1305_aead = (e)=>(t, r, o)=>{\n            const s = 16;\n            return (0, n.bytes)(t, 32), (0, n.bytes)(r), {\n                encrypt (a, c) {\n                    const l = a.length, u = l + s;\n                    c ? (0, n.bytes)(c, u) : c = new Uint8Array(u), e(t, r, a, c, 1);\n                    const h = d(e, t, r, c.subarray(0, -16), o);\n                    return c.set(h, l), (0, i.clean)(h), c;\n                },\n                decrypt (a, c) {\n                    const l = a.length, u = l - s;\n                    if (l < s) throw new Error(\"encrypted data must be at least 16 bytes\");\n                    c ? (0, n.bytes)(c, u) : c = new Uint8Array(u);\n                    const h = a.subarray(0, -16), f = a.subarray(-16), p = d(e, t, r, h, o);\n                    if (!(0, i.equalBytes)(f, p)) throw new Error(\"invalid tag\");\n                    return e(t, r, h, c, 1), (0, i.clean)(p), c;\n                }\n            };\n        }, e.chacha20poly1305 = (0, i.wrapCipher)({\n        blockSize: 64,\n        nonceLength: 12,\n        tagLength: 16\n    }, (0, e._poly1305_aead)(e.chacha20)), e.xchacha20poly1305 = (0, i.wrapCipher)({\n        blockSize: 64,\n        nonceLength: 24,\n        tagLength: 16\n    }, (0, e._poly1305_aead)(e.xchacha20));\n}(_i), Object.defineProperty(Si, \"__esModule\", {\n    value: !0\n}), Si.xchacha20 = void 0;\nvar Fi, zi, qi, Wi = _i;\nSi.xchacha20 = function(e, t, n) {\n    return (0, Wi.xchacha20poly1305)(e, t, n);\n}, function(e) {\n    Object.defineProperty(e, \"__esModule\", {\n        value: !0\n    }), e.aesDecrypt = e.aesEncrypt = e.symDecrypt = e.symEncrypt = void 0;\n    var t = pe, n = Te, r = Cr, i = Si, o = Ce, s = ke;\n    e.symEncrypt = function(e, t, n) {\n        return a(c, e, t, n);\n    };\n    function a(e, t, n, a) {\n        var c = (0, o.symmetricAlgorithm)();\n        if (\"aes-256-gcm\" === c) return e(r.aes256gcm, t, n, (0, o.symmetricNonceLength)(), s.AEAD_TAG_LENGTH, a);\n        if (\"xchacha20\" === c) return e(i.xchacha20, t, n, s.XCHACHA20_NONCE_LENGTH, s.AEAD_TAG_LENGTH, a);\n        if (\"aes-256-cbc\" === c) return e(r.aes256cbc, t, n, 16, 0);\n        throw new Error(\"Not implemented\");\n    }\n    function c(e, r, i, o, s, a) {\n        var c = (0, n.randomBytes)(o), l = e(r, c, a).encrypt(i);\n        if (0 === s) return (0, t.concatBytes)(c, l);\n        var d = l.length - s, u = l.subarray(0, d), h = l.subarray(d);\n        return (0, t.concatBytes)(c, h, u);\n    }\n    function l(e, n, r, i, o, s) {\n        var a = r.subarray(0, i), c = e(n, Uint8Array.from(a), s), l = r.subarray(i);\n        if (0 === o) return c.decrypt(l);\n        var d = l.subarray(0, o), u = l.subarray(o);\n        return c.decrypt((0, t.concatBytes)(u, d));\n    }\n    e.symDecrypt = function(e, t, n) {\n        return a(l, e, t, n);\n    }, e.aesEncrypt = e.symEncrypt, e.aesDecrypt = e.symDecrypt;\n}(_r), Fi = Me, zi = de && de.__createBinding || (Object.create ? function(e, t, n, r) {\n    void 0 === r && (r = n);\n    var i = Object.getOwnPropertyDescriptor(t, n);\n    i && !(\"get\" in i ? !t.__esModule : i.writable || i.configurable) || (i = {\n        enumerable: !0,\n        get: function() {\n            return t[n];\n        }\n    }), Object.defineProperty(e, r, i);\n} : function(e, t, n, r) {\n    void 0 === r && (r = n), e[r] = t[n];\n}), qi = de && de.__exportStar || function(e, t) {\n    for(var n in e)\"default\" === n || Object.prototype.hasOwnProperty.call(t, n) || zi(t, e, n);\n}, Object.defineProperty(Fi, \"__esModule\", {\n    value: !0\n}), qi(Ie, Fi), qi(pr, Fi), qi(fr, Fi), qi(_r, Fi);\nvar Vi = {};\nObject.defineProperty(Vi, \"__esModule\", {\n    value: !0\n}), Vi.PublicKey = void 0;\nvar Gi = pe, Yi = Me, Zi = function() {\n    function e(e) {\n        this.data = (0, Yi.convertPublicKeyFormat)(e, !0);\n    }\n    return e.fromHex = function(t) {\n        return new e((0, Yi.hexToPublicKey)(t));\n    }, Object.defineProperty(e.prototype, \"uncompressed\", {\n        get: function() {\n            return C.from((0, Yi.convertPublicKeyFormat)(this.data, !1));\n        },\n        enumerable: !1,\n        configurable: !0\n    }), Object.defineProperty(e.prototype, \"compressed\", {\n        get: function() {\n            return C.from(this.data);\n        },\n        enumerable: !1,\n        configurable: !0\n    }), e.prototype.toHex = function(e) {\n        return void 0 === e && (e = !0), (0, Gi.bytesToHex)(e ? this.data : this.uncompressed);\n    }, e.prototype.decapsulate = function(e, t) {\n        void 0 === t && (t = !1);\n        var n = t ? this.data : this.uncompressed, r = e.multiply(this, t);\n        return (0, Yi.getSharedKey)(n, r);\n    }, e.prototype.equals = function(e) {\n        return (0, Gi.equalBytes)(this.data, e.data);\n    }, e;\n}();\nVi.PublicKey = Zi, Object.defineProperty(xe, \"__esModule\", {\n    value: !0\n}), xe.PrivateKey = void 0;\nvar Ji = pe, Qi = Me, Xi = Vi, eo = function() {\n    function e(e) {\n        if (void 0 === e) this.data = (0, Qi.getValidSecret)();\n        else {\n            if (!(0, Qi.isValidPrivateKey)(e)) throw new Error(\"Invalid private key\");\n            this.data = e;\n        }\n        this.publicKey = new Xi.PublicKey((0, Qi.getPublicKey)(this.data));\n    }\n    return e.fromHex = function(t) {\n        return new e((0, Qi.decodeHex)(t));\n    }, Object.defineProperty(e.prototype, \"secret\", {\n        get: function() {\n            return C.from(this.data);\n        },\n        enumerable: !1,\n        configurable: !0\n    }), e.prototype.toHex = function() {\n        return (0, Ji.bytesToHex)(this.data);\n    }, e.prototype.encapsulate = function(e, t) {\n        void 0 === t && (t = !1);\n        var n = t ? this.publicKey.compressed : this.publicKey.uncompressed, r = this.multiply(e, t);\n        return (0, Qi.getSharedKey)(n, r);\n    }, e.prototype.multiply = function(e, t) {\n        return void 0 === t && (t = !1), (0, Qi.getSharedPoint)(this.data, e.compressed, t);\n    }, e.prototype.equals = function(e) {\n        return (0, Ji.equalBytes)(this.data, e.data);\n    }, e;\n}();\nxe.PrivateKey = eo, function(e) {\n    Object.defineProperty(e, \"__esModule\", {\n        value: !0\n    }), e.PublicKey = e.PrivateKey = void 0;\n    var t = xe;\n    Object.defineProperty(e, \"PrivateKey\", {\n        enumerable: !0,\n        get: function() {\n            return t.PrivateKey;\n        }\n    });\n    var n = Vi;\n    Object.defineProperty(e, \"PublicKey\", {\n        enumerable: !0,\n        get: function() {\n            return n.PublicKey;\n        }\n    });\n}(Ae), function(e) {\n    Object.defineProperty(e, \"__esModule\", {\n        value: !0\n    }), e.utils = e.PublicKey = e.PrivateKey = e.ECIES_CONFIG = void 0, e.encrypt = function(e, o) {\n        var s = new r.PrivateKey, a = e instanceof Uint8Array ? new r.PublicKey(e) : r.PublicKey.fromHex(e), c = s.encapsulate(a, (0, n.isHkdfKeyCompressed)()), l = (0, n.isEphemeralKeyCompressed)() ? s.publicKey.compressed : s.publicKey.uncompressed, d = (0, i.symEncrypt)(c, o);\n        return C.from((0, t.concatBytes)(l, d));\n    }, e.decrypt = function(e, t) {\n        var o = e instanceof Uint8Array ? new r.PrivateKey(e) : r.PrivateKey.fromHex(e), s = (0, n.ephemeralKeySize)(), a = new r.PublicKey(t.subarray(0, s)), c = t.subarray(s), l = a.decapsulate(o, (0, n.isHkdfKeyCompressed)());\n        return C.from((0, i.symDecrypt)(l, c));\n    };\n    var t = pe, n = Ce, r = Ae, i = Me;\n    var o = Ce;\n    Object.defineProperty(e, \"ECIES_CONFIG\", {\n        enumerable: !0,\n        get: function() {\n            return o.ECIES_CONFIG;\n        }\n    });\n    var s = Ae;\n    Object.defineProperty(e, \"PrivateKey\", {\n        enumerable: !0,\n        get: function() {\n            return s.PrivateKey;\n        }\n    }), Object.defineProperty(e, \"PublicKey\", {\n        enumerable: !0,\n        get: function() {\n            return s.PublicKey;\n        }\n    }), e.utils = {\n        aesEncrypt: i.aesEncrypt,\n        aesDecrypt: i.aesDecrypt,\n        symEncrypt: i.symEncrypt,\n        symDecrypt: i.symDecrypt,\n        decodeHex: i.decodeHex,\n        getValidSecret: i.getValidSecret,\n        remove0x: i.remove0x\n    };\n}(fe);\nconst to = debug__WEBPACK_IMPORTED_MODULE_1___default()(\"KeyExchange:Layer\"), no = debug__WEBPACK_IMPORTED_MODULE_1___default()(\"SocketService:Layer\"), ro = debug__WEBPACK_IMPORTED_MODULE_1___default()(\"Ecies:Layer\"), io = debug__WEBPACK_IMPORTED_MODULE_1___default()(\"RemoteCommunication:Layer\");\nto.color = \"##95c44e\", no.color = \"#f638d7\", ro.color = \"#465b9c\", io.color = \"#47a2be\";\nconst oo = {\n    KeyExchange: to,\n    SocketService: no,\n    Ecies: ro,\n    RemoteCommunication: io\n};\nlet so, ao = [], co = [];\nconst lo = (t, n)=>c(void 0, void 0, void 0, function*() {\n        so = n, co.push(t), (function(t) {\n            return c(this, void 0, void 0, function*() {\n                if (!so || !t) return;\n                !function() {\n                    const e = co;\n                    co = ao, ao = e;\n                }();\n                const n = so.endsWith(\"/\") ? \"\".concat(so, \"evt\") : \"\".concat(so, \"/evt\"), r = Object.assign({}, t);\n                if (delete r.params, t.params) for (const [e, n] of Object.entries(t.params))r[e] = n;\n                const i = JSON.stringify(r);\n                oo.RemoteCommunication(\"[sendBufferedEvents] Sending \".concat(ao.length, \" analytics events to \").concat(n));\n                try {\n                    const t = yield cross_fetch__WEBPACK_IMPORTED_MODULE_0___default()(n, {\n                        method: \"POST\",\n                        headers: {\n                            Accept: \"application/json\",\n                            \"Content-Type\": \"application/json\"\n                        },\n                        body: i\n                    }), r = yield t.text();\n                    oo.RemoteCommunication(\"[sendBufferedEvents] Response: \".concat(r)), ao.length = 0;\n                } catch (n) {}\n            });\n        })(t).catch(()=>{});\n    });\nclass uo {\n    generateECIES() {\n        this.ecies = new fe.PrivateKey;\n    }\n    getPublicKey() {\n        return this.ecies.publicKey.toHex();\n    }\n    encrypt(e, t) {\n        let n = e;\n        if (this.enabled) try {\n            oo.Ecies(\"[ECIES: encrypt()] using otherPublicKey\", t);\n            const r = C.from(e), i = fe.encrypt(t, r);\n            n = C.from(i).toString(\"base64\");\n        } catch (n) {\n            throw oo.Ecies(\"[ECIES: encrypt()] error encrypt:\", n), oo.Ecies(\"[ECIES: encrypt()] private: \", this.ecies.toHex()), oo.Ecies(\"[ECIES: encrypt()] data: \", e), oo.Ecies(\"[ECIES: encrypt()] otherkey: \", t), n;\n        }\n        return n;\n    }\n    decrypt(e) {\n        let t = e;\n        if (this.enabled) try {\n            oo.Ecies(\"[ECIES: decrypt()] using privateKey\", this.ecies.toHex());\n            const n = C.from(e.toString(), \"base64\");\n            t = fe.decrypt(this.ecies.toHex(), n).toString();\n        } catch (t) {\n            throw oo.Ecies(\"[ECIES: decrypt()] error decrypt\", t), oo.Ecies(\"[ECIES: decrypt()] private: \", this.ecies.toHex()), oo.Ecies(\"[ECIES: decrypt()] encryptedData: \", e), t;\n        }\n        return t;\n    }\n    getKeyInfo() {\n        return {\n            private: this.ecies.toHex(),\n            public: this.ecies.publicKey.toHex()\n        };\n    }\n    toString() {\n        oo.Ecies(\"[ECIES: toString()]\", this.getKeyInfo());\n    }\n    constructor(e){\n        this.enabled = !0, (null == e ? void 0 : e.debug) && debug__WEBPACK_IMPORTED_MODULE_1___default().enable(\"Ecies:Layer\"), this.ecies = (null == e ? void 0 : e.privateKey) ? fe.PrivateKey.fromHex(e.privateKey) : new fe.PrivateKey, oo.Ecies(\"[ECIES constructor()] initialized secret: \", this.ecies.toHex()), oo.Ecies(\"[ECIES constructor()] initialized public: \", this.ecies.publicKey.toHex()), oo.Ecies(\"[ECIES constructor()] init with\", this);\n    }\n}\nvar ho = {\n    name: \"@metamask/sdk-communication-layer\",\n    version: \"0.33.1\",\n    description: \"\",\n    homepage: \"https://github.com/MetaMask/metamask-sdk#readme\",\n    bugs: {\n        url: \"https://github.com/MetaMask/metamask-sdk/issues\"\n    },\n    repository: {\n        type: \"git\",\n        url: \"https://github.com/MetaMask/metamask-sdk.git\",\n        directory: \"packages/sdk-communication-layer\"\n    },\n    main: \"dist/node/cjs/metamask-sdk-communication-layer.js\",\n    unpkg: \"dist/browser/umd/metamask-sdk-communication-layer.js\",\n    module: \"dist/node/es/metamask-sdk-communication-layer.js\",\n    browser: \"dist/browser/es/metamask-sdk-communication-layer.js\",\n    \"react-native\": \"dist/react-native/es/metamask-sdk-communication-layer.js\",\n    types: \"dist/types/src/index.d.ts\",\n    files: [\n        \"/dist\"\n    ],\n    scripts: {\n        \"build:types\": \"tsc --project tsconfig.build.json --emitDeclarationOnly --outDir dist/types\",\n        \"build:clean\": \"yarn clean && yarn build\",\n        build: \"yarn build:types && rollup -c --bundleConfigAsCjs\",\n        \"build:dev\": \"yarn build:types && NODE_ENV=dev rollup -c --bundleConfigAsCjs\",\n        dev: 'concurrently \"tsc --watch\" \"rollup -c --bundleConfigAsCjs -w\"',\n        \"build:post-tsc\": \"echo 'N/A'\",\n        \"build:pre-tsc\": \"echo 'N/A'\",\n        size: \"size-limit\",\n        clean: \"rimraf ./dist\",\n        lint: \"yarn lint:eslint && yarn lint:misc --check\",\n        \"lint:changelog\": \"../../scripts/validate-changelog.sh @metamask/sdk-communication-layer\",\n        \"lint:eslint\": \"eslint . --cache --ext js,ts\",\n        \"lint:fix\": \"yarn lint:eslint --fix && yarn lint:misc --write\",\n        \"lint:misc\": \"prettier '**/*.json' '**/*.md' '!CHANGELOG.md' --ignore-path ../../.gitignore\",\n        \"publish:preview\": \"yarn npm publish --tag preview\",\n        prepack: \"../../scripts/prepack.sh\",\n        reset: \"yarn clean && rimraf ./node_modules/\",\n        test: 'jest --testPathIgnorePatterns \"/e2e/\"',\n        \"test:e2e\": 'jest --testPathPattern \"/e2e/\"',\n        \"test:coverage\": \"jest --coverage\",\n        \"test:ci\": 'jest --coverage --passWithNoTests --setupFilesAfterEnv ./jest-preload.js --testPathIgnorePatterns \"/e2e/\"',\n        \"test:dev\": \"jest\",\n        watch: \"rollup -c --bundleConfigAsCjs -w\"\n    },\n    dependencies: {\n        \"@metamask/sdk-analytics\": \"workspace:*\",\n        bufferutil: \"^4.0.8\",\n        \"date-fns\": \"^2.29.3\",\n        debug: \"4.3.4\",\n        \"utf-8-validate\": \"^5.0.2\",\n        uuid: \"^8.3.2\"\n    },\n    devDependencies: {\n        \"@jest/globals\": \"^29.3.1\",\n        \"@lavamoat/allow-scripts\": \"^2.3.1\",\n        \"@metamask/auto-changelog\": \"3.1.0\",\n        \"@metamask/eslint-config\": \"^6.0.0\",\n        \"@metamask/eslint-config-nodejs\": \"^6.0.0\",\n        \"@metamask/eslint-config-typescript\": \"^6.0.0\",\n        \"@rollup/plugin-commonjs\": \"^25.0.0\",\n        \"@rollup/plugin-json\": \"^6.0.0\",\n        \"@rollup/plugin-node-resolve\": \"^15.0.2\",\n        \"@rollup/plugin-replace\": \"^6.0.1\",\n        \"@rollup/plugin-terser\": \"^0.4.4\",\n        \"@size-limit/preset-big-lib\": \"^11.0.2\",\n        \"@types/jest\": \"^29.2.4\",\n        \"@types/node\": \"^20.1.3\",\n        \"@types/uuid\": \"^9.0.0\",\n        \"@typescript-eslint/eslint-plugin\": \"^4.26.0\",\n        \"@typescript-eslint/parser\": \"^4.26.0\",\n        concurrently: \"^9.1.2\",\n        \"cross-fetch\": \"^4.0.0\",\n        eciesjs: \"^0.4.11\",\n        eslint: \"^7.30.0\",\n        \"eslint-config-prettier\": \"^8.3.0\",\n        \"eslint-plugin-import\": \"^2.23.4\",\n        \"eslint-plugin-jest\": \"^24.4.0\",\n        \"eslint-plugin-jsdoc\": \"^36.1.0\",\n        \"eslint-plugin-node\": \"^11.1.0\",\n        \"eslint-plugin-prettier\": \"^3.4.0\",\n        eventemitter2: \"^6.4.9\",\n        jest: \"^29.3.1\",\n        prettier: \"^2.3.0\",\n        rimraf: \"^3.0.2\",\n        rollup: \"^4.26.0\",\n        \"rollup-plugin-jscc\": \"^2.0.0\",\n        \"rollup-plugin-natives\": \"^0.7.5\",\n        \"rollup-plugin-node-builtins\": \"^2.1.2\",\n        \"rollup-plugin-node-globals\": \"^1.4.0\",\n        \"rollup-plugin-peer-deps-external\": \"^2.2.4\",\n        \"rollup-plugin-polyfill-node\": \"^0.13.0\",\n        \"rollup-plugin-sizes\": \"^1.0.6\",\n        \"rollup-plugin-typescript2\": \"^0.31.2\",\n        \"rollup-plugin-visualizer\": \"^5.12.0\",\n        \"size-limit\": \"^11.1.6\",\n        \"socket.io-client\": \"^4.5.1\",\n        \"stream-browserify\": \"^3.0.0\",\n        \"ts-jest\": \"^29.0.3\",\n        \"ts-node\": \"^10.9.1\",\n        typescript: \"^5.6.3\"\n    },\n    peerDependencies: {\n        \"cross-fetch\": \"^4.0.0\",\n        eciesjs: \"*\",\n        eventemitter2: \"^6.4.9\",\n        \"readable-stream\": \"^3.6.2\",\n        \"socket.io-client\": \"^4.5.1\"\n    },\n    publishConfig: {\n        access: \"public\",\n        registry: \"https://registry.npmjs.org/\"\n    },\n    lavamoat: {\n        allowScripts: {\n            \"@lavamoat/preinstall-always-fail\": !1,\n            canvas: !0,\n            \"eciesjs>secp256k1\": !1,\n            \"socket.io-client>engine.io-client>ws>bufferutil\": !1,\n            \"socket.io-client>engine.io-client>ws>utf-8-validate\": !1,\n            bufferutil: !1,\n            \"utf-8-validate\": !1\n        }\n    }\n};\nconst fo = \"https://metamask-sdk.api.cx.metamask.io/\", po = [\n    \"websocket\"\n], go = 6048e5, mo = 3e3, yo = {\n    METAMASK_GETPROVIDERSTATE: \"metamask_getProviderState\",\n    METAMASK_CONNECTSIGN: \"metamask_connectSign\",\n    METAMASK_CONNECTWITH: \"metamask_connectWith\",\n    METAMASK_OPEN: \"metamask_open\",\n    METAMASK_BATCH: \"metamask_batch\",\n    PERSONAL_SIGN: \"personal_sign\",\n    WALLET_REQUESTPERMISSIONS: \"wallet_requestPermissions\",\n    WALLET_REVOKEPERMISSIONS: \"wallet_revokePermissions\",\n    WALLET_GETPERMISSIONS: \"wallet_getPermissions\",\n    WALLET_WATCHASSET: \"wallet_watchAsset\",\n    WALLET_SWITCHETHEREUMCHAIN: \"wallet_switchEthereumChain\",\n    WALLET_ADDETHEREUMCHAIN: \"wallet_addEthereumChain\",\n    ETH_REQUESTACCOUNTS: \"eth_requestAccounts\",\n    ETH_ACCOUNTS: \"eth_accounts\",\n    ETH_CHAINID: \"eth_chainId\",\n    ETH_SENDTRANSACTION: \"eth_sendTransaction\",\n    ETH_SIGNTYPEDDATA: \"eth_signTypedData\",\n    ETH_SIGNTYPEDDATA_V3: \"eth_signTypedData_v3\",\n    ETH_SIGNTYPEDDATA_V4: \"eth_signTypedData_v4\",\n    ETH_SIGNTRANSACTION: \"eth_signTransaction\",\n    ETH_SIGN: \"eth_sign\",\n    PERSONAL_EC_RECOVER: \"personal_ecRecover\"\n}, vo = [\n    yo.METAMASK_CONNECTSIGN,\n    yo.METAMASK_CONNECTWITH,\n    yo.METAMASK_OPEN,\n    yo.METAMASK_BATCH,\n    yo.PERSONAL_SIGN,\n    yo.WALLET_REQUESTPERMISSIONS,\n    yo.WALLET_REVOKEPERMISSIONS,\n    yo.WALLET_WATCHASSET,\n    yo.ETH_SENDTRANSACTION,\n    yo.ETH_SIGNTYPEDDATA,\n    yo.ETH_SIGNTYPEDDATA_V3,\n    yo.ETH_SIGNTYPEDDATA_V4,\n    yo.ETH_SIGNTRANSACTION,\n    yo.ETH_SIGN,\n    yo.PERSONAL_EC_RECOVER\n];\nfunction bo(e) {\n    return vo.includes(e);\n}\nfunction wo(e) {\n    const { context: t } = e;\n    oo.RemoteCommunication(\"[RemoteCommunication: clean()] context=\".concat(t)), e.channelConfig = void 0, e.ready = !1, e.originatorConnectStarted = !1;\n}\nvar Eo, So, _o, Co, ko, Ao, xo;\n(xo = Eo || (Eo = {})).DISCONNECTED = \"disconnected\", xo.WAITING = \"waiting\", xo.TIMEOUT = \"timeout\", xo.LINKED = \"linked\", xo.PAUSED = \"paused\", xo.TERMINATED = \"terminated\", function(e) {\n    e.KEY_INFO = \"key_info\", e.SERVICE_STATUS = \"service_status\", e.PROVIDER_UPDATE = \"provider_update\", e.RPC_UPDATE = \"rpc_update\", e.KEYS_EXCHANGED = \"keys_exchanged\", e.JOIN_CHANNEL = \"join_channel\", e.PUBLIC_KEY = \"public_key\", e.CHANNEL_CREATED = \"channel_created\", e.CLIENTS_CONNECTED = \"clients_connected\", e.CLIENTS_DISCONNECTED = \"clients_disconnected\", e.CLIENTS_WAITING = \"clients_waiting\", e.CLIENTS_READY = \"clients_ready\", e.REJECTED = \"rejected\", e.WALLET_INIT = \"wallet_init\", e.CHANNEL_PERSISTENCE = \"channel_persistence\", e.CONFIG = \"config\", e.MESSAGE_ACK = \"ack\", e.SOCKET_DISCONNECTED = \"socket_disconnected\", e.SOCKET_RECONNECT = \"socket_reconnect\", e.OTP = \"otp\", e.SDK_RPC_CALL = \"sdk_rpc_call\", e.AUTHORIZED = \"authorized\", e.CONNECTION_STATUS = \"connection_status\", e.MESSAGE = \"message\", e.TERMINATE = \"terminate\";\n}(So || (So = {})), (_o || (_o = {})).KEY_EXCHANGE = \"key_exchange\", function(e) {\n    e.KEY_HANDSHAKE_START = \"key_handshake_start\", e.KEY_HANDSHAKE_CHECK = \"key_handshake_check\", e.KEY_HANDSHAKE_SYN = \"key_handshake_SYN\", e.KEY_HANDSHAKE_SYNACK = \"key_handshake_SYNACK\", e.KEY_HANDSHAKE_ACK = \"key_handshake_ACK\", e.KEY_HANDSHAKE_WALLET = \"key_handshake_wallet\", e.KEY_HANDSHAKE_NONE = \"none\";\n}(Co || (Co = {}));\nclass Mo extends eventemitter2__WEBPACK_IMPORTED_MODULE_3__.EventEmitter2 {\n    onKeyExchangeMessage(e) {\n        const { relayPersistence: t } = this.communicationLayer.remote.state;\n        if (oo.KeyExchange(\"[KeyExchange: onKeyExchangeMessage()] context=\".concat(this.context, \" keysExchanged=\").concat(this.keysExchanged, \" relayPersistence=\").concat(t), e), t) return void oo.KeyExchange(\"[KeyExchange: onKeyExchangeMessage()] Ignoring key exchange message because relay persistence is activated\");\n        const { message: n } = e;\n        this.keysExchanged && oo.KeyExchange(\"[KeyExchange: onKeyExchangeMessage()] context=\".concat(this.context, \" received handshake while already exchanged. step=\").concat(this.step, \" otherPubKey=\").concat(this.otherPublicKey)), this.emit(So.KEY_INFO, n.type), n.type === Co.KEY_HANDSHAKE_SYN ? (this.checkStep([\n            Co.KEY_HANDSHAKE_NONE,\n            Co.KEY_HANDSHAKE_ACK\n        ]), oo.KeyExchange(\"[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYN\", n), n.pubkey && this.setOtherPublicKey(n.pubkey), this.communicationLayer.sendMessage({\n            type: Co.KEY_HANDSHAKE_SYNACK,\n            pubkey: this.myPublicKey\n        }).catch((e)=>{\n            oo.KeyExchange(\"[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_SYNACK\", e);\n        }), this.setStep(Co.KEY_HANDSHAKE_ACK)) : n.type === Co.KEY_HANDSHAKE_SYNACK ? (this.checkStep([\n            Co.KEY_HANDSHAKE_SYNACK,\n            Co.KEY_HANDSHAKE_ACK,\n            Co.KEY_HANDSHAKE_NONE\n        ]), oo.KeyExchange(\"[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYNACK\"), n.pubkey && this.setOtherPublicKey(n.pubkey), this.communicationLayer.sendMessage({\n            type: Co.KEY_HANDSHAKE_ACK\n        }).catch((e)=>{\n            oo.KeyExchange(\"[KeyExchange: onKeyExchangeMessage()] Error sending KEY_HANDSHAKE_ACK\", e);\n        }), this.keysExchanged = !0, this.setStep(Co.KEY_HANDSHAKE_ACK), this.emit(So.KEYS_EXCHANGED)) : n.type === Co.KEY_HANDSHAKE_ACK && (oo.KeyExchange(\"[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_ACK set keysExchanged to true!\"), this.checkStep([\n            Co.KEY_HANDSHAKE_ACK,\n            Co.KEY_HANDSHAKE_NONE\n        ]), this.keysExchanged = !0, this.setStep(Co.KEY_HANDSHAKE_ACK), this.emit(So.KEYS_EXCHANGED));\n    }\n    resetKeys(e) {\n        this.clean(), this.myECIES = new uo(e);\n    }\n    clean() {\n        oo.KeyExchange(\"[KeyExchange: clean()] context=\".concat(this.context, \" reset handshake state\")), this.setStep(Co.KEY_HANDSHAKE_NONE), this.emit(So.KEY_INFO, this.step), this.keysExchanged = !1;\n    }\n    start(param) {\n        let { isOriginator: e, force: t } = param;\n        const { relayPersistence: n, protocolVersion: r } = this.communicationLayer.remote.state, i = r >= 2;\n        n ? oo.KeyExchange(\"[KeyExchange: start()] Ignoring key exchange message because relay persistence is activated\") : (oo.KeyExchange(\"[KeyExchange: start()] context=\".concat(this.context, \" protocolVersion=\").concat(r, \" isOriginator=\").concat(e, \" step=\").concat(this.step, \" force=\").concat(t, \" relayPersistence=\").concat(n, \" keysExchanged=\").concat(this.keysExchanged)), e ? !(this.keysExchanged || this.step !== Co.KEY_HANDSHAKE_NONE && this.step !== Co.KEY_HANDSHAKE_SYNACK) || t ? (oo.KeyExchange(\"[KeyExchange: start()] context=\".concat(this.context, \" -- start key exchange (force=\").concat(t, \") -- step=\").concat(this.step), this.step), this.clean(), this.setStep(Co.KEY_HANDSHAKE_SYNACK), this.communicationLayer.sendMessage({\n            type: Co.KEY_HANDSHAKE_SYN,\n            pubkey: this.myPublicKey,\n            v: 2\n        }).catch((e)=>{\n            oo.KeyExchange(\"[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYN\", e);\n        })) : oo.KeyExchange(\"[KeyExchange: start()] context=\".concat(this.context, \" -- key exchange already \").concat(this.keysExchanged ? \"done\" : \"in progress\", \" -- aborted.\"), this.step) : this.keysExchanged && !0 !== t ? oo.KeyExchange(\"[KeyExchange: start()] don't send KEY_HANDSHAKE_START -- exchange already done.\") : i ? this.communicationLayer.sendMessage({\n            type: Co.KEY_HANDSHAKE_SYNACK,\n            pubkey: this.myPublicKey,\n            v: 2\n        }).catch((e)=>{\n            oo.KeyExchange(\"[KeyExchange: start()] Error sending KEY_HANDSHAKE_SYNACK\", e);\n        }) : (this.communicationLayer.sendMessage({\n            type: Co.KEY_HANDSHAKE_START\n        }).catch((e)=>{\n            oo.KeyExchange(\"[KeyExchange: start()] Error sending KEY_HANDSHAKE_START\", e);\n        }), this.clean()));\n    }\n    setStep(e) {\n        this.step = e, this.emit(So.KEY_INFO, e);\n    }\n    checkStep(e) {\n        e.length > 0 && e.indexOf(this.step.toString());\n    }\n    setRelayPersistence(param) {\n        let { localKey: e, otherKey: t } = param;\n        this.otherPublicKey = t, this.myECIES = new uo({\n            privateKey: e,\n            debug: this.debug\n        }), this.keysExchanged = !0;\n    }\n    setKeysExchanged(e) {\n        this.keysExchanged = e;\n    }\n    areKeysExchanged() {\n        return this.keysExchanged;\n    }\n    getMyPublicKey() {\n        return this.myPublicKey;\n    }\n    getOtherPublicKey() {\n        return this.otherPublicKey;\n    }\n    setOtherPublicKey(e) {\n        oo.KeyExchange(\"[KeyExchange: setOtherPubKey()]\", e), this.otherPublicKey = e;\n    }\n    encryptMessage(e) {\n        if (!this.otherPublicKey) throw new Error(\"encryptMessage: Keys not exchanged - missing otherPubKey\");\n        return this.myECIES.encrypt(e, this.otherPublicKey);\n    }\n    decryptMessage(e) {\n        if (!this.otherPublicKey) throw new Error(\"decryptMessage: Keys not exchanged - missing otherPubKey\");\n        return this.myECIES.decrypt(e);\n    }\n    getKeyInfo() {\n        return {\n            ecies: Object.assign(Object.assign({}, this.myECIES.getKeyInfo()), {\n                otherPubKey: this.otherPublicKey\n            }),\n            step: this.step,\n            keysExchanged: this.areKeysExchanged()\n        };\n    }\n    toString() {\n        const e = {\n            keyInfo: this.getKeyInfo(),\n            keysExchanged: this.keysExchanged,\n            step: this.step\n        };\n        return JSON.stringify(e);\n    }\n    constructor({ communicationLayer: e, otherPublicKey: t, context: n, ecies: r, logging: i }){\n        super(), this.keysExchanged = !1, this.step = Co.KEY_HANDSHAKE_NONE, this.debug = !1, this.context = n, this.communicationLayer = e, (null == r ? void 0 : r.privateKey) && t && (oo.KeyExchange(\"[KeyExchange: constructor()] otherPubKey=\".concat(t, \" set keysExchanged to true!\"), r), this.keysExchanged = !0), this.myECIES = new uo(Object.assign(Object.assign({}, r), {\n            debug: null == i ? void 0 : i.eciesLayer\n        })), this.communicationLayer.state.eciesInstance = this.myECIES, this.myPublicKey = this.myECIES.getPublicKey(), this.debug = !0 === (null == i ? void 0 : i.keyExchangeLayer), t && this.setOtherPublicKey(t), this.communicationLayer.on(_o.KEY_EXCHANGE, this.onKeyExchangeMessage.bind(this));\n    }\n}\n!function(e) {\n    e.TERMINATE = \"terminate\", e.ANSWER = \"answer\", e.OFFER = \"offer\", e.CANDIDATE = \"candidate\", e.JSONRPC = \"jsonrpc\", e.WALLET_INFO = \"wallet_info\", e.WALLET_INIT = \"wallet_init\", e.ORIGINATOR_INFO = \"originator_info\", e.PAUSE = \"pause\", e.OTP = \"otp\", e.AUTHORIZED = \"authorized\", e.PING = \"ping\", e.READY = \"ready\";\n}(ko || (ko = {})), function(e) {\n    e.REQUEST = \"sdk_connect_request_started\", e.REQUEST_MOBILE = \"sdk_connect_request_started_mobile\", e.RECONNECT = \"sdk_reconnect_request_started\", e.CONNECTED = \"sdk_connection_established\", e.CONNECTED_MOBILE = \"sdk_connection_established_mobile\", e.AUTHORIZED = \"sdk_connection_authorized\", e.REJECTED = \"sdk_connection_rejected\", e.TERMINATED = \"sdk_connection_terminated\", e.DISCONNECTED = \"sdk_disconnected\", e.SDK_USE_EXTENSION = \"sdk_use_extension\", e.SDK_RPC_REQUEST = \"sdk_rpc_request\", e.SDK_RPC_REQUEST_RECEIVED = \"sdk_rpc_request_received\", e.SDK_RPC_REQUEST_DONE = \"sdk_rpc_request_done\", e.SDK_EXTENSION_UTILIZED = \"sdk_extension_utilized\", e.SDK_USE_INAPP_BROWSER = \"sdk_use_inapp_browser\";\n}(Ao || (Ao = {}));\nconst Io = (e, t, n)=>c(void 0, void 0, void 0, function*() {\n        var r, i, o, s, a, c;\n        const { remote: l, state: d } = e, { channelId: u, isOriginator: h } = d;\n        if (\"error_terminated\" === t) return oo.SocketService(\"handleJoinChannelResults: Channel \".concat(u, \" terminated\")), void e.emit(So.TERMINATE);\n        if (!n) return void oo.SocketService(\"handleJoinChannelResults: No result for channel \".concat(u));\n        const { persistence: f, walletKey: p, rejected: g } = n;\n        if (oo.SocketService(\"handleJoinChannelResults: Channel \".concat(u, \" persistence=\").concat(f, \" walletKey=\").concat(p, \" rejected=\").concat(g)), g) return oo.SocketService(\"handleJoinChannelResults: Channel \".concat(u, \" rejected\")), yield e.remote.disconnect({\n            terminate: !0\n        }), e.remote.emit(So.REJECTED, {\n            channelId: u\n        }), void e.remote.emitServiceStatusEvent();\n        if (p && !(null === (r = l.state.channelConfig) || void 0 === r ? void 0 : r.otherKey)) {\n            e.getKeyExchange().setOtherPublicKey(p), null === (i = e.state.keyExchange) || void 0 === i || i.setKeysExchanged(!0), l.state.ready = !0, l.state.authorized = !0, l.emit(So.AUTHORIZED);\n            const { communicationLayer: t, storageManager: n } = l.state, r = Object.assign(Object.assign({}, l.state.channelConfig), {\n                channelId: null !== (o = l.state.channelId) && void 0 !== o ? o : \"\",\n                validUntil: Date.now() + go,\n                localKey: null == t ? void 0 : t.getKeyInfo().ecies.private,\n                otherKey: p\n            });\n            e.sendMessage({\n                type: Co.KEY_HANDSHAKE_ACK\n            }).catch((e)=>{}), null === (s = e.state.socket) || void 0 === s || s.emit(ko.PING, {\n                id: u,\n                clientType: h ? \"dapp\" : \"wallet\",\n                context: \"on_channel_reconnect\",\n                message: \"\"\n            }), yield null == n ? void 0 : n.persistChannelConfig(r), l.emitServiceStatusEvent(), l.setConnectionStatus(Eo.LINKED);\n        }\n        f && (e.emit(So.CHANNEL_PERSISTENCE), null === (a = e.state.keyExchange) || void 0 === a || a.setKeysExchanged(!0), l.state.ready = !0, l.state.authorized = !0, l.emit(So.AUTHORIZED), lo(Object.assign(Object.assign({\n            id: null != u ? u : \"\",\n            event: h ? Ao.CONNECTED : Ao.CONNECTED_MOBILE\n        }, e.remote.state.originatorInfo), {\n            sdkVersion: e.remote.state.sdkVersion,\n            commLayer: e.state.communicationLayerPreference,\n            commLayerVersion: ho.version,\n            walletVersion: null === (c = e.remote.state.walletInfo) || void 0 === c ? void 0 : c.version\n        }), d.communicationServerUrl).catch((e)=>{}));\n    }), To = (e)=>new Promise((t)=>{\n        setTimeout(t, e);\n    }), Ro = function(e, t) {\n    for(var _len = arguments.length, n = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n        n[_key - 2] = arguments[_key];\n    }\n    return c(void 0, [\n        e,\n        t,\n        ...n\n    ], void 0, function*(e, t) {\n        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200;\n        let r;\n        const i = Date.now();\n        let o = !1;\n        for(; !o;){\n            if (o = Date.now() - i > 3e5, r = t[e], void 0 !== r.elapsedTime) return r;\n            yield To(n);\n        }\n        throw new Error(\"RPC \".concat(e, \" timed out\"));\n    });\n}, Po = (e)=>c(void 0, void 0, void 0, function*() {\n        const { state: t } = e, { socket: n, channelId: r, context: i, isOriginator: o, isReconnecting: s } = t;\n        if (s) return oo.SocketService(\"[SocketService: reconnectSocket()] Reconnection already in progress, skipping\", e), !1;\n        if (!n) return oo.SocketService(\"[SocketService: reconnectSocket()] socket is not defined\", e), !1;\n        if (!r) return !1;\n        const { connected: a } = n;\n        t.isReconnecting = !0, t.reconnectionAttempts = 0, oo.SocketService(\"[SocketService: reconnectSocket()] connected=\".concat(a, \" trying to reconnect after socketio disconnection\"), e);\n        try {\n            for(; 3 > t.reconnectionAttempts;){\n                if (oo.SocketService(\"[SocketService: reconnectSocket()] Attempt \".concat(t.reconnectionAttempts + 1, \" of 3\"), e), yield To(200), n.connected) return oo.SocketService(\"Socket already connected --- ping to retrieve messages\"), n.emit(ko.PING, {\n                    id: r,\n                    clientType: o ? \"dapp\" : \"wallet\",\n                    context: \"on_channel_config\",\n                    message: \"\"\n                }), !0;\n                t.resumed = !0, n.connect(), e.emit(So.SOCKET_RECONNECT);\n                try {\n                    if (yield new Promise((t, s)=>{\n                        n.emit(So.JOIN_CHANNEL, {\n                            channelId: r,\n                            context: \"\".concat(i, \"connect_again\"),\n                            clientType: o ? \"dapp\" : \"wallet\"\n                        }, (n, r)=>c(void 0, void 0, void 0, function*() {\n                                try {\n                                    yield Io(e, n, r), t();\n                                } catch (e) {\n                                    s(e);\n                                }\n                            }));\n                    }), yield To(100), n.connected) return oo.SocketService(\"Reconnection successful on attempt \".concat(t.reconnectionAttempts + 1)), !0;\n                } catch (e) {\n                    oo.SocketService(\"Error during reconnection attempt \".concat(t.reconnectionAttempts + 1, \":\"), e);\n                }\n                t.reconnectionAttempts += 1, 3 > t.reconnectionAttempts && (yield To(200));\n            }\n            return oo.SocketService(\"Failed to reconnect after 3 attempts\"), !1;\n        } finally{\n            t.isReconnecting = !1, t.reconnectionAttempts = 0;\n        }\n    });\nfunction Oo(e, t) {\n    return c(this, void 0, void 0, function*() {\n        var n;\n        const r = null === (n = e.state.keyExchange) || void 0 === n ? void 0 : n.encryptMessage(JSON.stringify(t)), i = {\n            id: e.state.channelId,\n            context: e.state.context,\n            clientType: e.state.isOriginator ? \"dapp\" : \"wallet\",\n            message: r,\n            plaintext: e.state.hasPlaintext ? JSON.stringify(t) : void 0\n        };\n        return oo.SocketService(\"[SocketService: encryptAndSendMessage()] context=\".concat(e.state.context), i), t.type === ko.TERMINATE && (e.state.manualDisconnect = !0), new Promise((t, n)=>{\n            var r;\n            null === (r = e.state.socket) || void 0 === r || r.emit(So.MESSAGE, i, (e, r)=>{\n                var i;\n                e && (oo.SocketService(\"[SocketService: encryptAndSendMessage()] error=\".concat(e)), n(e)), oo.SocketService(\"[encryptAndSendMessage] response\", r), t(null !== (i = null == r ? void 0 : r.success) && void 0 !== i && i);\n            });\n        });\n    });\n}\n_c56 = Oo;\nvar No;\n!function(e) {\n    e.RPC_CHECK = \"rpcCheck\", e.SKIPPED_RPC = \"skippedRpc\";\n}(No || (No = {}));\nconst Lo = [\n    \"eth_sendTransaction\",\n    \"eth_signTypedData\",\n    \"eth_signTransaction\",\n    \"personal_sign\",\n    \"wallet_requestPermissions\",\n    \"wallet_switchEthereumChain\",\n    \"eth_signTypedData_v3\",\n    \"eth_signTypedData_v4\",\n    \"metamask_connectSign\",\n    \"metamask_connectWith\",\n    \"metamask_batch\"\n].map((e)=>e.toLowerCase());\nconst Do = [\n    {\n        event: So.CLIENTS_CONNECTED,\n        handler: function(e, t) {\n            return (n)=>c(this, void 0, void 0, function*() {\n                    var n, r, i, o, s, a, c, l, d, u, h;\n                    const f = null !== (r = null === (n = e.remote.state.channelConfig) || void 0 === n ? void 0 : n.relayPersistence) && void 0 !== r && r;\n                    if (oo.SocketService(\"[SocketService: handleClientsConnected()] context=\".concat(e.state.context, \" on 'clients_connected-\").concat(t, \"' relayPersistence=\").concat(f, \" resumed=\").concat(e.state.resumed, \"  clientsPaused=\").concat(e.state.clientsPaused, \" keysExchanged=\").concat(null === (i = e.state.keyExchange) || void 0 === i ? void 0 : i.areKeysExchanged(), \" isOriginator=\").concat(e.state.isOriginator)), e.emit(So.CLIENTS_CONNECTED, {\n                        isOriginator: e.state.isOriginator,\n                        keysExchanged: null === (o = e.state.keyExchange) || void 0 === o ? void 0 : o.areKeysExchanged(),\n                        context: e.state.context\n                    }), e.state.resumed) e.state.isOriginator || (oo.SocketService(\"[SocketService: handleClientsConnected()] context=\".concat(e.state.context, \" 'clients_connected' / keysExchanged=\").concat(null === (s = e.state.keyExchange) || void 0 === s ? void 0 : s.areKeysExchanged(), \" -- backward compatibility\")), null === (a = e.state.keyExchange) || void 0 === a || a.start({\n                        isOriginator: null !== (c = e.state.isOriginator) && void 0 !== c && c\n                    })), e.state.resumed = !1;\n                    else if (e.state.clientsPaused) oo.SocketService(\"[SocketService: handleClientsConnected()] 'clients_connected' skip sending originatorInfo on pause\");\n                    else if (!e.state.isOriginator) {\n                        const t = !f;\n                        oo.SocketService(\"[SocketService: handleClientsConnected()] context=\".concat(e.state.context, \" on 'clients_connected' / keysExchanged=\").concat(null === (l = e.state.keyExchange) || void 0 === l ? void 0 : l.areKeysExchanged(), \" -- force=\").concat(t, \" -- backward compatibility\")), oo.SocketService(\"[SocketService: handleClientsConnected()] context=\".concat(e.state.context, \" on 'clients_connected' / keysExchanged=\").concat(null === (d = e.state.keyExchange) || void 0 === d ? void 0 : d.areKeysExchanged(), \" -- force=\").concat(t, \" -- backward compatibility\")), null === (u = e.state.keyExchange) || void 0 === u || u.start({\n                            isOriginator: null !== (h = e.state.isOriginator) && void 0 !== h && h,\n                            force: t\n                        });\n                    }\n                    e.state.clientsConnected = !0, e.state.clientsPaused = !1;\n                });\n        }\n    },\n    {\n        event: So.CHANNEL_CREATED,\n        handler: function(e, t) {\n            return (n)=>{\n                oo.SocketService(\"[SocketService: handleChannelCreated()] context=\".concat(e.state.context, \" on 'channel_created-\").concat(t, \"'\"), n), e.emit(So.CHANNEL_CREATED, n);\n            };\n        }\n    },\n    {\n        event: So.CLIENTS_DISCONNECTED,\n        handler: function(e, t) {\n            return ()=>{\n                var n;\n                e.state.clientsConnected = !1, oo.SocketService(\"[SocketService: handlesClientsDisconnected()] context=\".concat(e.state.context, \" on 'clients_disconnected-\").concat(t, \"'\")), e.remote.state.relayPersistence ? oo.SocketService(\"[SocketService: handlesClientsDisconnected()] context=\".concat(e.state.context, \" on 'clients_disconnected-\").concat(t, \"' - relayPersistence enabled, skipping key exchange cleanup.\")) : (e.state.isOriginator && !e.state.clientsPaused && (null === (n = e.state.keyExchange) || void 0 === n || n.clean()), e.emit(So.CLIENTS_DISCONNECTED, t));\n            };\n        }\n    },\n    {\n        event: So.CONFIG,\n        handler: function(e, t) {\n            return (n)=>c(this, void 0, void 0, function*() {\n                    var r, i, o;\n                    oo.SocketService(\"[SocketService: handleChannelConfig()] update relayPersistence on 'config-\".concat(t, \"'\"), n);\n                    const { persistence: s, walletKey: a } = n;\n                    e.state.isOriginator && e.remote.state.channelConfig ? (n.walletKey && !e.remote.state.channelConfig.otherKey && (oo.SocketService(\"Setting wallet key \".concat(a)), e.remote.state.channelConfig.otherKey = a, e.getKeyExchange().setOtherPublicKey(n.walletKey), null === (r = e.state.keyExchange) || void 0 === r || r.setKeysExchanged(!0), yield e.remote.sendMessage({\n                        type: Co.KEY_HANDSHAKE_ACK\n                    }), yield e.remote.sendMessage({\n                        type: ko.PING\n                    }), yield null === (i = e.remote.state.storageManager) || void 0 === i ? void 0 : i.persistChannelConfig(e.remote.state.channelConfig)), !0 !== s || e.remote.state.channelConfig.relayPersistence || (oo.SocketService(\"Setting relay persistence \".concat(s)), e.remote.state.channelConfig.relayPersistence = s, e.remote.state.relayPersistence = !0, e.remote.emit(So.CHANNEL_PERSISTENCE), e.remote.state.authorized = !0, e.remote.state.ready = !0, e.remote.emit(So.AUTHORIZED), yield null === (o = e.remote.state.storageManager) || void 0 === o ? void 0 : o.persistChannelConfig(e.remote.state.channelConfig))) : e.state.isOriginator || n.persistence && (e.remote.state.relayPersistence = !0, e.remote.emit(So.CHANNEL_PERSISTENCE));\n                });\n        }\n    },\n    {\n        event: So.MESSAGE,\n        handler: function(e, t) {\n            return (r)=>{\n                var i, o, s, a, c, l, d, u, h, f, p, g, m, y, v, b, w, E;\n                const { ackId: S, message: _, error: C } = r, k = null !== (i = e.remote.state.relayPersistence) && void 0 !== i && i;\n                if (oo.SocketService(\"[SocketService handleMessage()]  relayPersistence=\".concat(k, \"  context=\").concat(e.state.context, \" on 'message' \").concat(t, \" keysExchanged=\").concat(null === (o = e.state.keyExchange) || void 0 === o ? void 0 : o.areKeysExchanged()), r), C) throw oo.SocketService(\"\\n      [SocketService handleMessage()] context=\".concat(e.state.context, \"::on 'message' error=\").concat(C)), new Error(C);\n                const A = \"string\" == typeof _;\n                if (!A && (null == _ ? void 0 : _.type) === Co.KEY_HANDSHAKE_START) {\n                    if (k) return;\n                    return oo.SocketService(\"[SocketService handleMessage()] context=\".concat(e.state.context, \"::on 'message' received HANDSHAKE_START isOriginator=\").concat(e.state.isOriginator), _), void (null === (s = e.state.keyExchange) || void 0 === s || s.start({\n                        isOriginator: null !== (a = e.state.isOriginator) && void 0 !== a && a,\n                        force: !0\n                    }));\n                }\n                if (!A && (null === (c = null == _ ? void 0 : _.type) || void 0 === c ? void 0 : c.startsWith(\"key_handshake\"))) {\n                    if (k) return;\n                    return oo.SocketService(\"[SocketService handleMessage()] context=\".concat(e.state.context, \"::on 'message' emit KEY_EXCHANGE\"), _), void e.emit(_o.KEY_EXCHANGE, {\n                        message: _,\n                        context: e.state.context\n                    });\n                }\n                if (A && !(null === (l = e.state.keyExchange) || void 0 === l ? void 0 : l.areKeysExchanged())) {\n                    let t = !1;\n                    try {\n                        oo.SocketService(\"[SocketService handleMessage()] context=\".concat(e.state.context, \"::on 'message' trying to decrypt message\")), null === (d = e.state.keyExchange) || void 0 === d || d.decryptMessage(_), t = !0;\n                    } catch (t) {\n                        oo.SocketService(\"[SocketService handleMessage()] context=\".concat(e.state.context, \"::on 'message' error\"), t);\n                    }\n                    if (!t) return e.state.isOriginator ? null === (h = e.state.keyExchange) || void 0 === h || h.start({\n                        isOriginator: null !== (f = e.state.isOriginator) && void 0 !== f && f\n                    }) : e.sendMessage({\n                        type: Co.KEY_HANDSHAKE_START\n                    }).catch((e)=>{}), void oo.SocketService(\"Message ignored because invalid key exchange status. step=\".concat(null === (p = e.state.keyExchange) || void 0 === p ? void 0 : p.getKeyInfo().step), null === (g = e.state.keyExchange) || void 0 === g ? void 0 : g.getKeyInfo(), _);\n                    oo.SocketService(\"Invalid key exchange status detected --- updating it.\"), null === (u = e.state.keyExchange) || void 0 === u || u.setKeysExchanged(!0);\n                } else if (!A && (null == _ ? void 0 : _.type)) return void e.emit(So.MESSAGE, _);\n                if (!A) return void e.emit(So.MESSAGE, _);\n                const x = null === (m = e.state.keyExchange) || void 0 === m ? void 0 : m.decryptMessage(_), M = JSON.parse(null != x ? x : \"{}\");\n                if (S && (null == S ? void 0 : S.length) > 0 && (oo.SocketService(\"[SocketService handleMessage()] context=\".concat(e.state.context, \"::on 'message' ackid=\").concat(S, \" channelId=\").concat(t)), null === (y = e.state.socket) || void 0 === y || y.emit(So.MESSAGE_ACK, {\n                    ackId: S,\n                    channelId: t,\n                    clientType: e.state.isOriginator ? \"dapp\" : \"wallet\"\n                })), e.state.clientsPaused = (null == M ? void 0 : M.type) === ko.PAUSE, e.state.isOriginator && M.data) {\n                    const t = M.data, r = e.state.rpcMethodTracker[t.id];\n                    if (r) {\n                        const i = Date.now() - r.timestamp;\n                        oo.SocketService(\"[SocketService handleMessage()] context=\".concat(e.state.context, \"::on 'message' received answer for id=\").concat(t.id, \" method=\").concat(r.method, \" responseTime=\").concat(i), M), e.remote.state.analytics && Lo.includes(r.method.toLowerCase()) && lo(Object.assign(Object.assign({\n                            id: null !== (v = e.remote.state.channelId) && void 0 !== v ? v : \"\",\n                            event: Ao.SDK_RPC_REQUEST_DONE,\n                            sdkVersion: e.remote.state.sdkVersion,\n                            commLayerVersion: ho.version\n                        }, e.remote.state.originatorInfo), {\n                            walletVersion: null === (b = e.remote.state.walletInfo) || void 0 === b ? void 0 : b.version,\n                            params: {\n                                method: r.method,\n                                from: \"mobile\"\n                            }\n                        }), e.remote.state.communicationServerUrl).catch((e)=>{}), bo(r.method) && _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.track(t.error ? 4001 === t.error.code ? \"sdk_action_rejected\" : \"sdk_action_failed\" : \"sdk_action_succeeded\", {\n                            action: r.method\n                        });\n                        const o = Object.assign(Object.assign({}, r), {\n                            result: t.result,\n                            error: t.error ? {\n                                code: null === (w = t.error) || void 0 === w ? void 0 : w.code,\n                                message: null === (E = t.error) || void 0 === E ? void 0 : E.message\n                            } : void 0,\n                            elapsedTime: i\n                        });\n                        e.state.rpcMethodTracker[t.id] = o, e.emit(So.RPC_UPDATE, o);\n                    }\n                }\n                e.emit(So.MESSAGE, {\n                    message: M\n                });\n            };\n        }\n    },\n    {\n        event: So.REJECTED,\n        handler: function(e, t) {\n            return (r)=>c(this, void 0, void 0, function*() {\n                    var r;\n                    e.state.isOriginator && !e.remote.state.ready ? (oo.SocketService(\"[SocketService: handleChannelRejected()] context=\".concat(e.state.context, \" channelId=\").concat(t, \" isOriginator=\").concat(e.state.isOriginator, \" ready=\").concat(e.remote.state.ready), e.remote.state.originatorInfo), lo(Object.assign(Object.assign({\n                        id: t,\n                        event: Ao.REJECTED\n                    }, e.remote.state.originatorInfo), {\n                        sdkVersion: e.remote.state.sdkVersion,\n                        commLayer: e.state.communicationLayerPreference,\n                        commLayerVersion: ho.version,\n                        walletVersion: null === (r = e.remote.state.walletInfo) || void 0 === r ? void 0 : r.version\n                    }), e.remote.state.communicationServerUrl).catch((e)=>{}), _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.track(\"sdk_connection_rejected\", {\n                        transport_type: \"websocket\"\n                    }), yield e.remote.disconnect({\n                        terminate: !0\n                    }), e.remote.emit(So.REJECTED, {\n                        channelId: t\n                    }), e.remote.setConnectionStatus(Eo.DISCONNECTED)) : oo.SocketService(\"[SocketService: handleChannelRejected()] SKIP -- channelId=\".concat(t, \" isOriginator=\").concat(e.state.isOriginator, \" ready=\").concat(e.remote.state.ready));\n                });\n        }\n    },\n    {\n        event: \"clients_waiting_to_join\",\n        handler: function(e, t) {\n            return (n)=>{\n                oo.SocketService(\"[SocketService: handleClientsWaitingToJoin()] context=\".concat(e.state.context, \" on 'clients_waiting_to_join-\").concat(t, \"'\"), n), e.emit(So.CLIENTS_WAITING, n);\n            };\n        }\n    }\n], $o = [\n    {\n        event: So.KEY_INFO,\n        handler: function(e) {\n            return (t)=>{\n                oo.SocketService(\"[SocketService: handleKeyInfo()] on 'KEY_INFO'\", t), e.emit(So.KEY_INFO, t);\n            };\n        }\n    },\n    {\n        event: So.KEYS_EXCHANGED,\n        handler: function(e) {\n            return ()=>{\n                var t, n, r;\n                oo.SocketService(\"[SocketService: handleKeysExchanged()] on 'keys_exchanged' keyschanged=\".concat(null === (t = e.state.keyExchange) || void 0 === t ? void 0 : t.areKeysExchanged()));\n                const { channelConfig: i } = e.remote.state;\n                if (i) {\n                    const t = e.getKeyExchange().getKeyInfo().ecies;\n                    i.localKey = t.private, i.otherKey = t.otherPubKey, e.remote.state.channelConfig = i, null === (n = e.remote.state.storageManager) || void 0 === n || n.persistChannelConfig(i).catch((e)=>{});\n                }\n                e.emit(So.KEYS_EXCHANGED, {\n                    keysExchanged: null === (r = e.state.keyExchange) || void 0 === r ? void 0 : r.areKeysExchanged(),\n                    isOriginator: e.state.isOriginator\n                });\n                const o = {\n                    keyInfo: e.getKeyInfo()\n                };\n                e.emit(So.SERVICE_STATUS, o);\n            };\n        }\n    }\n];\nfunction Bo(e, t) {\n    oo.SocketService(\"[SocketService: setupChannelListener()] context=\".concat(e.state.context, \" setting socket listeners for channel \").concat(t, \"...\"));\n    const { socket: n } = e.state, { keyExchange: r } = e.state;\n    n && e.state.isOriginator && (e.state.debug && (null == n || n.io.on(\"error\", (t)=>{\n        oo.SocketService(\"[SocketService: setupChannelListener()] context=\".concat(e.state.context, \" socket event=error\"), t);\n    }), null == n || n.io.on(\"reconnect\", (t)=>{\n        oo.SocketService(\"[SocketService: setupChannelListener()] context=\".concat(e.state.context, \" socket event=reconnect\"), t), Po(e).catch((e)=>{});\n    }), null == n || n.io.on(\"reconnect_error\", (t)=>{\n        oo.SocketService(\"[SocketService: setupChannelListener()] context=\".concat(e.state.context, \" socket event=reconnect_error\"), t);\n    }), null == n || n.io.on(\"reconnect_failed\", ()=>{\n        oo.SocketService(\"[SocketService: setupChannelListener()] context=\".concat(e.state.context, \" socket event=reconnect_failed\"));\n    })), null == n || n.on(\"disconnect\", (t)=>(oo.SocketService(\"[SocketService: setupChannelListener()] on 'disconnect' -- MetaMaskSDK socket disconnected '\".concat(t, \"' begin recovery...\")), (function(e) {\n            return (t)=>{\n                oo.SocketService(\"[SocketService: handleDisconnect()] on 'disconnect' manualDisconnect=\".concat(e.state.manualDisconnect), t), e.state.manualDisconnect || (e.emit(So.SOCKET_DISCONNECTED), Po(e).catch((e)=>{}));\n            };\n        })(e)(t)))), Do.forEach((param)=>{\n        let { event: r, handler: i } = param;\n        null == n || n.on(\"\".concat(r, \"-\").concat(t), i(e, t));\n    }), $o.forEach((param)=>{\n        let { event: t, handler: n } = param;\n        null == r || r.on(t, n(e));\n    }), e.state.setupChannelListeners = !0;\n}\n_c57 = Bo;\nclass Ko extends eventemitter2__WEBPACK_IMPORTED_MODULE_3__.EventEmitter2 {\n    initSocket() {\n        var e;\n        const { otherPublicKey: t, ecies: n, logging: r } = this.options, i = {\n            autoConnect: !1,\n            transports: po,\n            withCredentials: !0\n        }, o = this.state.communicationServerUrl;\n        oo.SocketService(\"[SocketService: initSocket()] Socket IO url: \".concat(o)), this.state.socket = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_4__.io)(o, i), function(e) {\n            if ( true && \"undefined\" != typeof document && (oo.SocketService(\"[SocketService: setupSocketFocusListener()] hasFocus=\".concat(document.hasFocus()), e), !e.state.focusListenerAdded)) {\n                const t = ()=>{\n                    oo.SocketService(\"Document has focus --- reconnecting socket\"), Po(e).catch((e)=>{});\n                };\n                window.addEventListener(\"focus\", t), e.state.focusListenerAdded = !0, e.state.removeFocusListener = ()=>{\n                    window.removeEventListener(\"focus\", t), e.state.focusListenerAdded = !1;\n                };\n            }\n        }(this);\n        const s = {\n            communicationLayer: this,\n            otherPublicKey: t,\n            sendPublicKey: !1,\n            context: null !== (e = this.state.context) && void 0 !== e ? e : \"\",\n            ecies: n,\n            logging: r\n        };\n        this.state.keyExchange = new Mo(s);\n    }\n    resetKeys() {\n        return oo.SocketService(\"[SocketService: resetKeys()] Resetting keys.\"), void (null === (e = this.state.keyExchange) || void 0 === e || e.resetKeys());\n        var e;\n    }\n    createChannel() {\n        return c(this, void 0, void 0, function*() {\n            return function(e) {\n                return c(this, void 0, void 0, function*() {\n                    var t, n, r;\n                    if (oo.SocketService(\"[SocketService: createChannel()] context=\".concat(e.state.context)), e.state.socket || e.initSocket(), null === (t = e.state.socket) || void 0 === t ? void 0 : t.connected) throw new Error(\"socket already connected\");\n                    null === (n = e.state.socket) || void 0 === n || n.connect(), e.state.manualDisconnect = !1, e.state.isOriginator = !0;\n                    const i = (0,uuid__WEBPACK_IMPORTED_MODULE_5__.v4)();\n                    e.state.channelId = i, Bo(e, i), yield new Promise((t, n)=>{\n                        var r;\n                        null === (r = e.state.socket) || void 0 === r || r.emit(So.JOIN_CHANNEL, {\n                            channelId: i,\n                            context: \"\".concat(e.state.context, \"createChannel\"),\n                            clientType: \"dapp\"\n                        }, (r, i)=>c(this, void 0, void 0, function*() {\n                                try {\n                                    yield Io(e, r, i), t();\n                                } catch (e) {\n                                    n(e);\n                                }\n                            }));\n                    });\n                    const o = null === (r = e.state.keyExchange) || void 0 === r ? void 0 : r.getKeyInfo();\n                    return {\n                        channelId: i,\n                        pubKey: (null == o ? void 0 : o.ecies.public) || \"\",\n                        privKey: (null == o ? void 0 : o.ecies.private) || \"\"\n                    };\n                });\n            }(this);\n        });\n    }\n    connectToChannel(param) {\n        let { channelId: e, withKeyExchange: t = !1, authorized: n } = param;\n        return function(e) {\n            return c(this, arguments, void 0, function*(param) {\n                let { options: e, instance: t } = param;\n                const { channelId: n, authorized: r, withKeyExchange: i } = e, { state: o, remote: s } = t, { isOriginator: a = !1, socket: l, keyExchange: d } = o, { channelConfig: u } = s.state;\n                if (null == l ? void 0 : l.connected) throw new Error(\"socket already connected\");\n                if (a && (null == u ? void 0 : u.relayPersistence)) {\n                    const { localKey: e, otherKey: t } = u;\n                    e && t && (null == d || d.setRelayPersistence({\n                        localKey: e,\n                        otherKey: t\n                    }));\n                }\n                return Object.assign(o, {\n                    manualDisconnect: !1,\n                    withKeyExchange: i,\n                    isOriginator: a,\n                    channelId: n\n                }), null == l || l.connect(), Bo(t, n), !a && r && (null == d || d.setKeysExchanged(!0), Object.assign(s.state, {\n                    ready: !0,\n                    authorized: !0\n                })), new Promise((e)=>{\n                    var i;\n                    const s = null === (i = null == d ? void 0 : d.getKeyInfo()) || void 0 === i ? void 0 : i.ecies.public;\n                    null == l || l.emit(So.JOIN_CHANNEL, {\n                        channelId: n,\n                        context: \"\".concat(o.context, \"_connectToChannel\"),\n                        clientType: a ? \"dapp\" : \"wallet\",\n                        publicKey: r && !a ? s : void 0\n                    }, (n, r)=>c(this, void 0, void 0, function*() {\n                            yield Io(t, n, r), e();\n                        }));\n                });\n            });\n        }({\n            options: {\n                channelId: e,\n                withKeyExchange: t,\n                authorized: n\n            },\n            instance: this\n        });\n    }\n    getKeyInfo() {\n        return this.state.keyExchange.getKeyInfo();\n    }\n    keyCheck() {\n        var e, t;\n        null === (t = (e = this).state.socket) || void 0 === t || t.emit(So.MESSAGE, {\n            id: e.state.channelId,\n            context: e.state.context,\n            message: {\n                type: Co.KEY_HANDSHAKE_CHECK,\n                pubkey: e.getKeyInfo().ecies.otherPubKey\n            }\n        });\n    }\n    getKeyExchange() {\n        return this.state.keyExchange;\n    }\n    sendMessage(e) {\n        return c(this, void 0, void 0, function*() {\n            return function(e, t) {\n                return c(this, void 0, void 0, function*() {\n                    var r, i, o;\n                    if (!e.state.channelId) throw oo.SocketService(\"handleSendMessage: no channelId - Create a channel first\"), new Error(\"Create a channel first\");\n                    if (oo.SocketService(\"[SocketService: handleSendMessage()] context=\".concat(e.state.context, \" areKeysExchanged=\").concat(null === (r = e.state.keyExchange) || void 0 === r ? void 0 : r.areKeysExchanged()), t), null === (i = null == t ? void 0 : t.type) || void 0 === i ? void 0 : i.startsWith(\"key_handshake\")) return function(e, t) {\n                        var n;\n                        oo.SocketService(\"[SocketService: handleKeyHandshake()] context=\".concat(e.state.context), t), null === (n = e.state.socket) || void 0 === n || n.emit(So.MESSAGE, {\n                            id: e.state.channelId,\n                            context: e.state.context,\n                            clientType: e.state.isOriginator ? \"dapp\" : \"wallet\",\n                            message: t\n                        });\n                    }(e, t), !0;\n                    !function(e, t) {\n                        var n;\n                        if (!(null === (n = e.state.keyExchange) || void 0 === n ? void 0 : n.areKeysExchanged()) && !e.remote.state.relayPersistence) throw oo.SocketService(\"[SocketService: validateKeyExchange()] context=\".concat(e.state.context, \" ERROR keys not exchanged\"), t), new Error(\"Keys not exchanged BBB\");\n                    }(e, t), function(e, t) {\n                        var n;\n                        const r = null !== (n = null == t ? void 0 : t.method) && void 0 !== n ? n : \"\", i = null == t ? void 0 : t.id;\n                        e.state.isOriginator && i && (e.state.rpcMethodTracker[i] = {\n                            id: i,\n                            timestamp: Date.now(),\n                            method: r\n                        }, e.emit(So.RPC_UPDATE, e.state.rpcMethodTracker[i]));\n                    }(e, t);\n                    const s = yield Oo(e, t);\n                    return e.remote.state.analytics && e.remote.state.isOriginator && t.method && Lo.includes(t.method.toLowerCase()) && lo({\n                        id: null !== (o = e.remote.state.channelId) && void 0 !== o ? o : \"\",\n                        event: Ao.SDK_RPC_REQUEST,\n                        params: {\n                            method: t.method,\n                            from: \"mobile\"\n                        }\n                    }, e.remote.state.communicationServerUrl).catch((e)=>{}), e.remote.state.isOriginator && t.method && bo(t.method) && _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.track(\"sdk_action_requested\", {\n                        action: t.method\n                    }), (function(e, t) {\n                        return c(this, void 0, void 0, function*() {\n                            var n;\n                            const r = null == t ? void 0 : t.id, i = null !== (n = null == t ? void 0 : t.method) && void 0 !== n ? n : \"\";\n                            if (e.state.isOriginator && r) try {\n                                const n = Ro(r, e.state.rpcMethodTracker, 200).then((e)=>({\n                                        type: No.RPC_CHECK,\n                                        result: e\n                                    })), o = (()=>c(this, void 0, void 0, function*() {\n                                        const t = yield ((e)=>c(void 0, [\n                                                e\n                                            ], void 0, function*(param) {\n                                                let { rpcId: e, instance: t } = param;\n                                                for(; t.state.lastRpcId === e || void 0 === t.state.lastRpcId;)yield To(200);\n                                                return t.state.lastRpcId;\n                                            }))({\n                                            instance: e,\n                                            rpcId: r\n                                        }), n = yield Ro(t, e.state.rpcMethodTracker, 200);\n                                        return {\n                                            type: No.SKIPPED_RPC,\n                                            result: n\n                                        };\n                                    }))(), s = yield Promise.race([\n                                    n,\n                                    o\n                                ]);\n                                if (s.type === No.RPC_CHECK) {\n                                    const e = s.result;\n                                    oo.SocketService(\"[SocketService:handleRpcReplies()] id=\".concat(t.id, \" \").concat(i, \" ( \").concat(e.elapsedTime, \" ms)\"), e.result);\n                                } else {\n                                    if (s.type !== No.SKIPPED_RPC) throw new Error(\"Error handling RPC replies for \".concat(r));\n                                    {\n                                        const t = Object.assign(Object.assign({}, e.state.rpcMethodTracker[r]), {\n                                            error: new Error(\"SDK_CONNECTION_ISSUE\")\n                                        });\n                                        e.emit(So.RPC_UPDATE, t);\n                                        const n = {\n                                            data: Object.assign(Object.assign({}, t), {\n                                                jsonrpc: \"2.0\"\n                                            }),\n                                            name: \"metamask-provider\"\n                                        };\n                                        e.emit(So.MESSAGE, {\n                                            message: n\n                                        });\n                                    }\n                                }\n                            } catch (e) {\n                                throw e;\n                            }\n                        });\n                    })(e, t).catch((e)=>{}), s;\n                });\n            }(this, e);\n        });\n    }\n    ping() {\n        return function(e) {\n            return c(this, void 0, void 0, function*() {\n                var t, n;\n                oo.SocketService(\"[SocketService: ping()] context=\".concat(e.state.context, \" originator=\").concat(e.state.isOriginator, \" keysExchanged=\").concat(null === (t = e.state.keyExchange) || void 0 === t ? void 0 : t.areKeysExchanged())), null === (n = e.state.socket) || void 0 === n || n.emit(ko.PING, {\n                    id: e.state.channelId,\n                    context: \"ping\",\n                    clientType: e.remote.state.isOriginator ? \"dapp\" : \"wallet\",\n                    message: \"\"\n                });\n            });\n        }(this);\n    }\n    pause() {\n        return function(e) {\n            return c(this, void 0, void 0, function*() {\n                var t, n;\n                oo.SocketService(\"[SocketService: pause()] context=\".concat(e.state.context)), e.state.manualDisconnect = !0, (null === (t = e.state.keyExchange) || void 0 === t ? void 0 : t.areKeysExchanged()) && (yield e.sendMessage({\n                    type: ko.PAUSE\n                })), null === (n = e.state.socket) || void 0 === n || n.disconnect();\n            });\n        }(this);\n    }\n    isConnected() {\n        var e;\n        return null === (e = this.state.socket) || void 0 === e ? void 0 : e.connected;\n    }\n    resume() {\n        return function(e) {\n            return c(this, void 0, void 0, function*() {\n                const { state: t, remote: n } = e, { socket: r, channelId: i, context: o, keyExchange: s, isOriginator: a } = t, { isOriginator: l } = n.state;\n                if (oo.SocketService(\"[SocketService: resume()] channelId=\".concat(i, \" context=\").concat(o, \" connected=\").concat(null == r ? void 0 : r.connected, \" manualDisconnect=\").concat(t.manualDisconnect, \" resumed=\").concat(t.resumed, \" keysExchanged=\").concat(null == s ? void 0 : s.areKeysExchanged())), !i) throw oo.SocketService(\"[SocketService: resume()] channelId is not defined\"), new Error(\"ChannelId is not defined\");\n                (null == r ? void 0 : r.connected) ? (oo.SocketService(\"[SocketService: resume()] already connected.\"), r.emit(ko.PING, {\n                    id: i,\n                    clientType: l ? \"dapp\" : \"wallet\",\n                    context: \"on_channel_config\",\n                    message: \"\"\n                }), n.hasRelayPersistence() || (null == s ? void 0 : s.areKeysExchanged()) || (a ? yield e.sendMessage({\n                    type: ko.READY\n                }) : null == s || s.start({\n                    isOriginator: !1\n                }))) : (null == r || r.connect(), oo.SocketService(\"[SocketService: resume()] after connecting socket --> connected=\".concat(null == r ? void 0 : r.connected)), null == r || r.emit(So.JOIN_CHANNEL, {\n                    channelId: i,\n                    context: \"\".concat(o, \"_resume\"),\n                    clientType: l ? \"dapp\" : \"wallet\"\n                }, (t, n)=>c(this, void 0, void 0, function*() {\n                        try {\n                            yield Io(e, t, n);\n                        } catch (e) {}\n                    }))), t.manualDisconnect = !1, t.resumed = !0;\n            });\n        }(this);\n    }\n    getRPCMethodTracker() {\n        return this.state.rpcMethodTracker;\n    }\n    disconnect(e) {\n        return function(e, t) {\n            var n, r, i, o, s;\n            oo.SocketService(\"[SocketService: disconnect()] context=\".concat(e.state.context), t), (null == t ? void 0 : t.terminate) && (null === (r = (n = e.state).removeFocusListener) || void 0 === r || r.call(n), e.state.channelId = t.channelId, null === (i = e.state.socket) || void 0 === i || i.removeAllListeners(), null === (o = e.state.keyExchange) || void 0 === o || o.clean(), e.remote.state.ready = !1, e.state.socket = void 0, e.state.rpcMethodTracker = {}), e.state.manualDisconnect = !0, null === (s = e.state.socket) || void 0 === s || s.disconnect();\n        }(this, e);\n    }\n    constructor(e){\n        super(), this.state = {\n            clientsConnected: !1,\n            clientsPaused: !1,\n            manualDisconnect: !1,\n            lastRpcId: void 0,\n            rpcMethodTracker: {},\n            hasPlaintext: !1,\n            communicationServerUrl: \"\",\n            focusListenerAdded: !1,\n            removeFocusListener: void 0,\n            isReconnecting: !1,\n            reconnectionAttempts: 0\n        }, this.options = e;\n        const { reconnect: n, communicationLayerPreference: r, communicationServerUrl: i, context: o, remote: s, logging: a } = e;\n        this.state.resumed = n, this.state.context = o, this.state.isOriginator = s.state.isOriginator, this.state.communicationLayerPreference = r, this.state.debug = !0 === (null == a ? void 0 : a.serviceLayer), this.remote = s, !0 === (null == a ? void 0 : a.serviceLayer) && debug__WEBPACK_IMPORTED_MODULE_1___default().enable(\"SocketService:Layer\"), this.state.communicationServerUrl = i, this.state.hasPlaintext = this.state.communicationServerUrl !== fo && !0 === (null == a ? void 0 : a.plaintext), oo.SocketService(\"[SocketService: constructor()] Socket IO url: \".concat(this.state.communicationServerUrl)), this.initSocket();\n    }\n}\nvar jo, Uo, Ho;\nfunction Fo(e) {\n    return ()=>c(this, void 0, void 0, function*() {\n            var t, n, r;\n            const { state: i } = e;\n            if (i.authorized) return;\n            yield (()=>c(this, void 0, void 0, function*() {\n                    for(; !i.walletInfo;)yield To(500);\n                }))();\n            const o = \"7.3\".localeCompare((null === (t = i.walletInfo) || void 0 === t ? void 0 : t.version) || \"\");\n            if (oo.RemoteCommunication(\"[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' version=\".concat(null === (n = i.walletInfo) || void 0 === n ? void 0 : n.version, \" compareValue=\").concat(o)), 1 !== o) return;\n            const s = i.platformType === Uo.MobileWeb || i.platformType === Uo.ReactNative || i.platformType === Uo.MetaMaskMobileWebview;\n            oo.RemoteCommunication(\"[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' platform=\".concat(i.platformType, \" secure=\").concat(s, \" channel=\").concat(i.channelId, \" walletVersion=\").concat(null === (r = i.walletInfo) || void 0 === r ? void 0 : r.version)), s && (i.authorized = !0, e.emit(So.AUTHORIZED));\n        });\n}\n_c58 = Fo;\nfunction zo(e) {\n    return (t)=>{\n        const { state: n } = e;\n        oo.RemoteCommunication(\"[RemoteCommunication: handleChannelCreatedEvent()] context=\".concat(n.context, \" on 'channel_created' channelId=\").concat(t)), e.emit(So.CHANNEL_CREATED, t);\n    };\n}\nfunction qo(e, t) {\n    return ()=>{\n        var r, i, o, s;\n        const { state: a } = e;\n        oo.RemoteCommunication(\"[RemoteCommunication: handleClientsConnectedEvent()] on 'clients_connected' channel=\".concat(a.channelId, \" keysExchanged=\").concat(null === (i = null === (r = a.communicationLayer) || void 0 === r ? void 0 : r.getKeyInfo()) || void 0 === i ? void 0 : i.keysExchanged)), a.analytics && lo(Object.assign(Object.assign({\n            id: null !== (o = a.channelId) && void 0 !== o ? o : \"\",\n            event: a.reconnection ? Ao.RECONNECT : a.isOriginator ? Ao.REQUEST : Ao.REQUEST_MOBILE\n        }, a.originatorInfo), {\n            commLayer: t,\n            sdkVersion: a.sdkVersion,\n            walletVersion: null === (s = a.walletInfo) || void 0 === s ? void 0 : s.version,\n            commLayerVersion: ho.version\n        }), a.communicationServerUrl).catch((e)=>{}), a.isOriginator && !a.reconnection && _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.track(\"sdk_connection_established\", {\n            transport_type: \"websocket\"\n        }), a.clientsConnected = !0, a.originatorInfoSent = !1, e.emit(So.CLIENTS_CONNECTED);\n    };\n}\nfunction Wo(e) {\n    return (t)=>{\n        const { state: n } = e;\n        oo.RemoteCommunication(\"[RemoteCommunication: handleClientsDisconnectedEvent()] context=\".concat(n.context, \" on 'clients_disconnected' channelId=\").concat(t)), n.relayPersistence || (n.clientsConnected = !1, n.ready = !1, n.authorized = !1), e.emit(So.CLIENTS_DISCONNECTED, n.channelId), e.setConnectionStatus(Eo.DISCONNECTED);\n    };\n}\n_c59 = Wo;\nfunction Vo(e) {\n    return (t)=>{\n        var n;\n        const { state: r } = e;\n        if (oo.RemoteCommunication(\"[RemoteCommunication: handleClientsWaitingEvent()] context=\".concat(r.context, \" on 'clients_waiting' numberUsers=\").concat(t, \" ready=\").concat(r.ready, \" autoStarted=\").concat(r.originatorConnectStarted)), e.setConnectionStatus(Eo.WAITING), e.emit(So.CLIENTS_WAITING, t), r.originatorConnectStarted) {\n            oo.RemoteCommunication(\"[RemoteCommunication: handleClientsWaitingEvent()] on 'clients_waiting' watch autoStarted=\".concat(r.originatorConnectStarted, \" timeout\"), r.autoConnectOptions);\n            const t = (null === (n = r.autoConnectOptions) || void 0 === n ? void 0 : n.timeout) || 3e3, i = setTimeout(()=>{\n                oo.RemoteCommunication(\"[RemoteCommunication: handleClientsWaitingEvent()] setTimeout(\".concat(t, \") terminate channelConfig\"), r.autoConnectOptions), r.originatorConnectStarted = !1, r.ready || e.setConnectionStatus(Eo.TIMEOUT), clearTimeout(i);\n            }, t);\n        }\n    };\n}\n_c60 = Vo;\nfunction Go(e, t) {\n    return (n)=>{\n        var r, i, o, s, a, c, l, d;\n        const { state: u } = e;\n        if (oo.RemoteCommunication(\"[RemoteCommunication: handleKeysExchangedEvent()] context=\".concat(u.context, \" on commLayer.'keys_exchanged' channel=\").concat(u.channelId), n), null === (i = null === (r = u.communicationLayer) || void 0 === r ? void 0 : r.getKeyInfo()) || void 0 === i ? void 0 : i.keysExchanged) {\n            const t = Object.assign(Object.assign({}, u.channelConfig), {\n                channelId: null !== (o = u.channelId) && void 0 !== o ? o : \"\",\n                validUntil: (null === (s = u.channelConfig) || void 0 === s ? void 0 : s.validUntil) || go,\n                localKey: u.communicationLayer.getKeyInfo().ecies.private,\n                otherKey: u.communicationLayer.getKeyInfo().ecies.otherPubKey\n            });\n            null === (a = u.storageManager) || void 0 === a || a.persistChannelConfig(t).catch((e)=>{}), e.setConnectionStatus(Eo.LINKED);\n        }\n        !function(e, t) {\n            var n, r, i, o, s, a, c, l;\n            const { state: d } = e;\n            oo.RemoteCommunication(\"[RemoteCommunication: setLastActiveDate()] channel=\".concat(d.channelId), t);\n            const u = Object.assign(Object.assign({}, d.channelConfig), {\n                channelId: null !== (n = d.channelId) && void 0 !== n ? n : \"\",\n                validUntil: null !== (i = null === (r = d.channelConfig) || void 0 === r ? void 0 : r.validUntil) && void 0 !== i ? i : 0,\n                relayPersistence: d.relayPersistence,\n                localKey: null === (s = null === (o = d.communicationLayer) || void 0 === o ? void 0 : o.state.keyExchange) || void 0 === s ? void 0 : s.getKeyInfo().ecies.private,\n                otherKey: null === (c = null === (a = d.communicationLayer) || void 0 === a ? void 0 : a.state.keyExchange) || void 0 === c ? void 0 : c.getKeyInfo().ecies.otherPubKey,\n                lastActive: t.getTime()\n            });\n            null === (l = d.storageManager) || void 0 === l || l.persistChannelConfig(u);\n        }(e, new Date), u.analytics && u.channelId && lo(Object.assign(Object.assign({\n            id: u.channelId,\n            event: n.isOriginator ? Ao.CONNECTED : Ao.CONNECTED_MOBILE\n        }, u.originatorInfo), {\n            sdkVersion: u.sdkVersion,\n            commLayer: t,\n            commLayerVersion: ho.version,\n            walletVersion: null === (c = u.walletInfo) || void 0 === c ? void 0 : c.version\n        }), u.communicationServerUrl).catch((e)=>{}), u.isOriginator = n.isOriginator, n.isOriginator || (null === (l = u.communicationLayer) || void 0 === l || l.sendMessage({\n            type: ko.READY\n        }), u.ready = !0, u.paused = !1), n.isOriginator && !u.originatorInfoSent && (null === (d = u.communicationLayer) || void 0 === d || d.sendMessage({\n            type: ko.ORIGINATOR_INFO,\n            originatorInfo: u.originatorInfo,\n            originator: u.originatorInfo\n        }), u.originatorInfoSent = !0);\n    };\n}\n_c61 = Go;\nfunction Yo(e) {\n    return (t)=>{\n        let n = t;\n        t.message && (n = n.message), function(e, t) {\n            const { state: n } = t;\n            if (oo.RemoteCommunication(\"[RemoteCommunication: onCommunicationLayerMessage()] context=\".concat(n.context, \" on 'message' typeof=\").concat(typeof e), e), t.state.ready = !0, n.isOriginator || e.type !== ko.ORIGINATOR_INFO) if (n.isOriginator && e.type === ko.WALLET_INFO) !function(e, t) {\n                const { state: n } = e;\n                n.walletInfo = t.walletInfo, n.paused = !1;\n            }(t, e);\n            else {\n                if (n.isOriginator && e.type === ko.WALLET_INIT) (function(e, t) {\n                    return c(this, void 0, void 0, function*() {\n                        var n, r, i;\n                        const { state: o } = e;\n                        if (o.isOriginator) {\n                            const o = t.data || {};\n                            if (\"object\" == typeof o && \"accounts\" in o && \"chainId\" in o && \"walletKey\" in o) try {\n                                const { channelConfig: t } = e.state;\n                                if (oo.RemoteCommunication(\"WALLET_INIT: channelConfig\", JSON.stringify(t, null, 2)), t) {\n                                    const s = o.accounts, a = o.chainId, c = o.walletKey;\n                                    let l, d = !1;\n                                    \"deeplinkProtocol\" in o && (d = Boolean(o.deeplinkProtocol), e.state.deeplinkProtocolAvailable = d), \"walletVersion\" in o && (l = o.walletVersion), yield null === (n = e.state.storageManager) || void 0 === n ? void 0 : n.persistChannelConfig(Object.assign(Object.assign({}, t), {\n                                        otherKey: c,\n                                        walletVersion: l,\n                                        deeplinkProtocolAvailable: d,\n                                        relayPersistence: !0\n                                    })), yield null === (r = e.state.storageManager) || void 0 === r ? void 0 : r.persistAccounts(s), yield null === (i = e.state.storageManager) || void 0 === i ? void 0 : i.persistChainId(a);\n                                }\n                                e.emit(So.WALLET_INIT, {\n                                    accounts: o.accounts,\n                                    chainId: o.chainId\n                                });\n                            } catch (n) {}\n                        }\n                    });\n                })(t, e).catch((e)=>{\n                    oo.RemoteCommunication(\"[RemoteCommunication: onCommunicationLayerMessage()] error=\".concat(e));\n                });\n                else if (e.type === ko.TERMINATE) (function(e) {\n                    return c(this, void 0, void 0, function*() {\n                        const { state: t } = e;\n                        t.isOriginator && (yield es({\n                            options: {\n                                terminate: !0,\n                                sendMessage: !1\n                            },\n                            instance: e\n                        }), e.emit(So.TERMINATE));\n                    });\n                })(t).catch((e)=>{\n                    oo.RemoteCommunication(\"[RemoteCommunication: onCommunicationLayerMessage()] error=\".concat(e));\n                });\n                else if (e.type === ko.PAUSE) !function(e) {\n                    const { state: t } = e;\n                    t.paused = !0, e.setConnectionStatus(Eo.PAUSED);\n                }(t);\n                else if (e.type === ko.READY && n.isOriginator) !function(e) {\n                    const { state: t } = e;\n                    e.setConnectionStatus(Eo.LINKED);\n                    const n = t.paused;\n                    t.paused = !1, e.emit(So.CLIENTS_READY, {\n                        isOriginator: t.isOriginator,\n                        walletInfo: t.walletInfo\n                    }), n && (t.authorized = !0, e.emit(So.AUTHORIZED));\n                }(t);\n                else {\n                    if (e.type === ko.OTP && n.isOriginator) return void function(e, t) {\n                        var n;\n                        const { state: r } = e;\n                        e.emit(So.OTP, t.otpAnswer), 1 === \"6.6\".localeCompare((null === (n = r.walletInfo) || void 0 === n ? void 0 : n.version) || \"\") && e.emit(So.SDK_RPC_CALL, {\n                            method: yo.ETH_REQUESTACCOUNTS,\n                            params: []\n                        });\n                    }(t, e);\n                    e.type === ko.AUTHORIZED && n.isOriginator && function(e) {\n                        const { state: t } = e;\n                        t.authorized = !0, e.emit(So.AUTHORIZED);\n                    }(t);\n                }\n                t.emit(So.MESSAGE, e);\n            }\n            else !function(e, t) {\n                var n;\n                const { state: r } = e;\n                null === (n = r.communicationLayer) || void 0 === n || n.sendMessage({\n                    type: ko.WALLET_INFO,\n                    walletInfo: r.walletInfo\n                }), r.originatorInfo = t.originatorInfo || t.originator, e.emit(So.CLIENTS_READY, {\n                    isOriginator: r.isOriginator,\n                    originatorInfo: r.originatorInfo\n                }), r.paused = !1;\n            }(t, e);\n        }(n, e);\n    };\n}\n_c62 = Yo;\nfunction Zo(e) {\n    return ()=>{\n        const { state: t } = e;\n        oo.RemoteCommunication(\"[RemoteCommunication: handleSocketReconnectEvent()] on 'socket_reconnect' -- reset key exchange status / set ready to false\"), t.ready = !1, t.authorized = !1, wo(t), e.emitServiceStatusEvent({\n            context: \"socket_reconnect\"\n        });\n    };\n}\n_c63 = Zo;\nfunction Jo(e) {\n    return ()=>{\n        const { state: t } = e;\n        oo.RemoteCommunication(\"[RemoteCommunication: handleSocketDisconnectedEvent()] on 'socket_Disconnected' set ready to false\"), t.ready = !1;\n    };\n}\n_c64 = Jo;\nfunction Qo(e) {\n    return ()=>c(this, void 0, void 0, function*() {\n            var t, n, r, i, o, s, a;\n            const { state: c } = e;\n            oo.RemoteCommunication(\"[RemoteCommunication: handleFullPersistenceEvent()] context=\".concat(c.context)), e.state.ready = !0, e.state.clientsConnected = !0, e.state.authorized = !0, e.state.relayPersistence = !0, null === (t = e.state.communicationLayer) || void 0 === t || t.getKeyExchange().setKeysExchanged(!0), e.emit(So.KEYS_EXCHANGED, {\n                keysExchanged: !0,\n                isOriginator: !0\n            }), e.emit(So.AUTHORIZED), e.emit(So.CLIENTS_READY), e.emit(So.CHANNEL_PERSISTENCE);\n            try {\n                c.channelConfig = Object.assign(Object.assign({}, c.channelConfig), {\n                    localKey: null === (n = c.communicationLayer) || void 0 === n ? void 0 : n.getKeyExchange().getKeyInfo().ecies.private,\n                    otherKey: null === (r = c.communicationLayer) || void 0 === r ? void 0 : r.getKeyExchange().getOtherPublicKey(),\n                    channelId: null !== (i = c.channelId) && void 0 !== i ? i : \"\",\n                    validUntil: null !== (s = null === (o = c.channelConfig) || void 0 === o ? void 0 : o.validUntil) && void 0 !== s ? s : go,\n                    relayPersistence: !0\n                }), yield null === (a = c.storageManager) || void 0 === a ? void 0 : a.persistChannelConfig(c.channelConfig);\n            } catch (t) {}\n        });\n}\n_c65 = Qo;\nfunction Xo(param) {\n    let { communicationLayerPreference: e, otherPublicKey: t, reconnect: n, ecies: r, communicationServerUrl: i = fo, instance: o } = param;\n    var s, a, c, l, d, u, h, f, p, g, m;\n    const { state: y } = o;\n    if (oo.RemoteCommunication(\"[initCommunicationLayer()] \", JSON.stringify(y, null, 2)), e !== jo.SOCKET) throw new Error(\"Invalid communication protocol\");\n    y.communicationLayer = new Ko({\n        communicationLayerPreference: e,\n        otherPublicKey: t,\n        reconnect: n,\n        transports: y.transports,\n        communicationServerUrl: i,\n        context: y.context,\n        ecies: r,\n        logging: y.logging,\n        remote: o\n    });\n    let v = \"undefined\" != typeof document && document.URL || \"\", b = \"undefined\" != typeof document && document.title || \"\";\n    (null === (s = y.dappMetadata) || void 0 === s ? void 0 : s.url) && (v = y.dappMetadata.url), (null === (a = y.dappMetadata) || void 0 === a ? void 0 : a.name) && (b = y.dappMetadata.name);\n    const w = null !== (u = null !== (l = null === (c = y.dappMetadata) || void 0 === c ? void 0 : c.name) && void 0 !== l ? l : null === (d = y.dappMetadata) || void 0 === d ? void 0 : d.url) && void 0 !== u ? u : \"N/A\", E =  true && void 0 !== window.location && null !== (h = window.location.hostname) && void 0 !== h ? h : w, S = {\n        url: v,\n        title: b,\n        source: null === (f = y.dappMetadata) || void 0 === f ? void 0 : f.source,\n        dappId: E,\n        anonId: y.anonId,\n        icon: (null === (p = y.dappMetadata) || void 0 === p ? void 0 : p.iconUrl) || (null === (g = y.dappMetadata) || void 0 === g ? void 0 : g.base64Icon),\n        platform: y.platformType,\n        apiVersion: ho.version,\n        connector: null === (m = y.dappMetadata) || void 0 === m ? void 0 : m.connector\n    };\n    y.originatorInfo = S;\n    const _ = {\n        [So.AUTHORIZED]: Fo(o),\n        [So.MESSAGE]: Yo(o),\n        [So.CHANNEL_PERSISTENCE]: Qo(o),\n        [So.CLIENTS_CONNECTED]: qo(o, e),\n        [So.KEYS_EXCHANGED]: Go(o, e),\n        [So.SOCKET_DISCONNECTED]: Jo(o),\n        [So.SOCKET_RECONNECT]: Zo(o),\n        [So.CLIENTS_DISCONNECTED]: Wo(o),\n        [So.KEY_INFO]: ()=>{},\n        [So.CHANNEL_CREATED]: zo(o),\n        [So.CLIENTS_WAITING]: Vo(o),\n        [So.RPC_UPDATE]: (e)=>{\n            o.emit(So.RPC_UPDATE, e);\n        }\n    };\n    for (const [t, n] of Object.entries(_))try {\n        y.communicationLayer.on(t, n);\n    } catch (e) {}\n}\n_c66 = Xo;\nfunction es(e) {\n    return c(this, arguments, void 0, function*(param) {\n        let { options: e, instance: t } = param;\n        const { state: n } = t;\n        return oo.RemoteCommunication(\"[RemoteCommunication: disconnect()] channel=\".concat(n.channelId), e), new Promise((r, i)=>{\n            var o, a, c, l, d, u;\n            (null == e ? void 0 : e.terminate) ? (t.state.ready && lo({\n                id: null !== (o = t.state.channelId) && void 0 !== o ? o : \"\",\n                event: Ao.TERMINATED\n            }, t.state.communicationServerUrl).catch((e)=>{}), n.ready = !1, n.paused = !1, null === (a = n.storageManager) || void 0 === a || a.terminate(null !== (c = n.channelId) && void 0 !== c ? c : \"\"), t.state.terminated = !0, e.sendMessage ? (null === (l = n.communicationLayer) || void 0 === l ? void 0 : l.getKeyInfo().keysExchanged) && t.state.communicationLayer && Oo(t.state.communicationLayer, {\n                type: ko.TERMINATE\n            }).then(()=>{\n                r(!0);\n            }).catch((e)=>{\n                i(e);\n            }) : r(!0), n.authorized = !1, n.relayPersistence = !1, n.channelId = (0,uuid__WEBPACK_IMPORTED_MODULE_5__.v4)(), e.channelId = n.channelId, n.channelConfig = void 0, n.originatorConnectStarted = !1, null === (d = n.communicationLayer) || void 0 === d || d.disconnect(e), t.setConnectionStatus(Eo.TERMINATED)) : (null === (u = n.communicationLayer) || void 0 === u || u.disconnect(e), t.setConnectionStatus(Eo.DISCONNECTED), r(!0));\n        });\n    });\n}\n(jo || (jo = {})).SOCKET = \"socket\", function(e) {\n    e.NonBrowser = \"nodejs\", e.MetaMaskMobileWebview = \"in-app-browser\", e.DesktopWeb = \"web-desktop\", e.MobileWeb = \"web-mobile\", e.ReactNative = \"react-native\";\n}(Uo || (Uo = {}));\nclass ts extends eventemitter2__WEBPACK_IMPORTED_MODULE_3__.EventEmitter2 {\n    initFromDappStorage() {\n        return c(this, void 0, void 0, function*() {\n            var e;\n            if (this.state.storageManager) {\n                const t = yield this.state.storageManager.getPersistedChannelConfig({});\n                t && (this.state.channelConfig = t, this.state.channelId = t.channelId, this.state.deeplinkProtocolAvailable = null !== (e = t.deeplinkProtocolAvailable) && void 0 !== e && e, t.relayPersistence && (this.state.authorized = !0, this.state.ready = !0, this.setConnectionStatus(Eo.LINKED), yield this.connectToChannel({\n                    channelId: t.channelId\n                })));\n            }\n            Xo({\n                communicationLayerPreference: jo.SOCKET,\n                otherPublicKey: this.state.otherPublicKey,\n                reconnect: this._options.reconnect,\n                ecies: this._options.ecies,\n                communicationServerUrl: this.state.communicationServerUrl,\n                instance: this\n            });\n        });\n    }\n    originatorSessionConnect() {\n        return c(this, void 0, void 0, function*() {\n            return yield function(e) {\n                return c(this, void 0, void 0, function*() {\n                    var t;\n                    const { state: n } = e;\n                    if (!n.storageManager) return void oo.RemoteCommunication(\"[RemoteCommunication: originatorSessionConnect()] no storage manager defined - skip\");\n                    const r = yield n.storageManager.getPersistedChannelConfig({});\n                    if (oo.RemoteCommunication(\"[RemoteCommunication: originatorSessionConnect()] autoStarted=\".concat(n.originatorConnectStarted, \" channelConfig\"), r), null === (t = n.communicationLayer) || void 0 === t ? void 0 : t.isConnected()) return oo.RemoteCommunication(\"[RemoteCommunication: originatorSessionConnect()] socket already connected - skip\"), r;\n                    if (r) {\n                        if (r.validUntil > Date.now()) return n.channelConfig = r, n.originatorConnectStarted = !0, n.channelId = null == r ? void 0 : r.channelId, n.reconnection = !0, r;\n                        oo.RemoteCommunication(\"[RemoteCommunication: autoConnect()] Session has expired\");\n                    }\n                    n.originatorConnectStarted = !1;\n                });\n            }(this);\n        });\n    }\n    generateChannelIdConnect() {\n        return c(this, void 0, void 0, function*() {\n            return function(e) {\n                return c(this, void 0, void 0, function*() {\n                    var t, n, r, i, o, s;\n                    if (!e.communicationLayer) throw new Error(\"communication layer not initialized\");\n                    if (e.ready) throw new Error(\"Channel already connected\");\n                    if (e.channelId && (null === (t = e.communicationLayer) || void 0 === t ? void 0 : t.isConnected())) return e.channelConfig = Object.assign(Object.assign({}, e.channelConfig), {\n                        channelId: e.channelId,\n                        validUntil: Date.now() + e.sessionDuration\n                    }), null === (n = e.storageManager) || void 0 === n || n.persistChannelConfig(e.channelConfig), {\n                        channelId: e.channelId,\n                        privKey: null === (i = null === (r = e.communicationLayer) || void 0 === r ? void 0 : r.getKeyInfo()) || void 0 === i ? void 0 : i.ecies.private,\n                        pubKey: null === (s = null === (o = e.communicationLayer) || void 0 === o ? void 0 : o.getKeyInfo()) || void 0 === s ? void 0 : s.ecies.public\n                    };\n                    oo.RemoteCommunication(\"[RemoteCommunication: generateChannelId()]\");\n                    const a = yield e.communicationLayer.createChannel();\n                    oo.RemoteCommunication(\"[RemoteCommunication: generateChannelId()] channel created\", a);\n                    const c = Object.assign(Object.assign({}, e.channelConfig), {\n                        channelId: a.channelId,\n                        localKey: a.privKey,\n                        validUntil: Date.now() + e.sessionDuration\n                    });\n                    return e.channelId = a.channelId, e.channelConfig = c, {\n                        channelId: e.channelId,\n                        pubKey: a.pubKey,\n                        privKey: a.privKey\n                    };\n                });\n            }(this.state);\n        });\n    }\n    clean() {\n        return wo(this.state);\n    }\n    connectToChannel(param) {\n        let { channelId: e, withKeyExchange: t, authorized: n } = param;\n        return function(e) {\n            return c(this, arguments, void 0, function*(param) {\n                let { channelId: e, withKeyExchange: t, authorized: n, state: r } = param;\n                var i, s, a;\n                if (!(0,uuid__WEBPACK_IMPORTED_MODULE_5__.validate)(e)) throw oo.RemoteCommunication(\"[RemoteCommunication: connectToChannel()] context=\".concat(r.context, \" invalid channel channelId=\").concat(e)), new Error(\"Invalid channel \".concat(e));\n                if (oo.RemoteCommunication(\"[RemoteCommunication: connectToChannel()] context=\".concat(r.context, \" channelId=\").concat(e, \" withKeyExchange=\").concat(t)), null === (i = r.communicationLayer) || void 0 === i ? void 0 : i.isConnected()) return void oo.RemoteCommunication(\"[RemoteCommunication: connectToChannel()] context=\".concat(r.context, \" already connected - interrupt connection.\"));\n                r.channelId = e, yield null === (s = r.communicationLayer) || void 0 === s ? void 0 : s.connectToChannel({\n                    channelId: e,\n                    authorized: n,\n                    withKeyExchange: t\n                });\n                const c = Object.assign(Object.assign({}, r.channelConfig), {\n                    channelId: e,\n                    validUntil: Date.now() + r.sessionDuration\n                });\n                r.channelConfig = c, null === (a = r.storageManager) || void 0 === a || a.persistChannelConfig(c);\n            });\n        }({\n            channelId: e,\n            authorized: n,\n            withKeyExchange: t,\n            state: this.state\n        });\n    }\n    sendMessage(e) {\n        return c(this, void 0, void 0, function*() {\n            const t = this.state.isOriginator && e.method && bo(e.method);\n            t && _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.track(\"sdk_action_requested\", {\n                action: e.method\n            });\n            try {\n                return yield function(e, t) {\n                    return c(this, void 0, void 0, function*() {\n                        var n, r;\n                        const { state: i } = e;\n                        oo.RemoteCommunication(\"[RemoteCommunication: sendMessage()] context=\".concat(i.context, \" paused=\").concat(i.paused, \" ready=\").concat(i.ready, \" relayPersistence=\").concat(i.relayPersistence, \" authorized=\").concat(i.authorized, \" socket=\").concat(null === (n = i.communicationLayer) || void 0 === n ? void 0 : n.isConnected(), \" clientsConnected=\").concat(i.clientsConnected, \" status=\").concat(i._connectionStatus), t), i.relayPersistence || i.ready && (null === (r = i.communicationLayer) || void 0 === r ? void 0 : r.isConnected()) && i.clientsConnected || (oo.RemoteCommunication(\"[RemoteCommunication: sendMessage()] context=\".concat(i.context, \"  SKIP message waiting for MM mobile readiness.\")), yield new Promise((t)=>{\n                            e.once(So.CLIENTS_READY, t);\n                        }), oo.RemoteCommunication(\"[RemoteCommunication: sendMessage()] context=\".concat(i.context, \"  AFTER SKIP / READY -- sending pending message\")));\n                        try {\n                            const n = yield function(e, t) {\n                                return c(this, void 0, void 0, function*() {\n                                    return new Promise((n)=>{\n                                        var r;\n                                        const { state: i } = e;\n                                        oo.RemoteCommunication(\"[RemoteCommunication: handleAuthorization()] context=\".concat(i.context, \" ready=\").concat(i.ready, \" authorized=\").concat(i.authorized, \" method=\").concat(t.method)), !i.isOriginator || i.authorized || i.relayPersistence ? null === (r = i.communicationLayer) || void 0 === r || r.sendMessage(t).then((e)=>{\n                                            n(e);\n                                        }).catch((e)=>{\n                                            n(!1);\n                                        }) : e.once(So.AUTHORIZED, ()=>{\n                                            var e;\n                                            oo.RemoteCommunication(\"[RemoteCommunication: handleAuthorization()] context=\".concat(i.context, \"  AFTER SKIP / AUTHORIZED -- sending pending message\")), null === (e = i.communicationLayer) || void 0 === e || e.sendMessage(t).then((e)=>{\n                                                n(e);\n                                            }).catch((e)=>{\n                                                n(!1);\n                                            });\n                                        });\n                                    });\n                                });\n                            }(e, t);\n                            return n;\n                        } catch (e) {\n                            throw e;\n                        }\n                    });\n                }(this, e);\n            } catch (r) {\n                throw t && _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.track(\"sdk_action_failed\", {\n                    action: e.method\n                }), r;\n            }\n        });\n    }\n    testStorage() {\n        return c(this, void 0, void 0, function*() {\n            return function(e) {\n                return c(this, void 0, void 0, function*() {\n                    var t;\n                    const n = yield null === (t = e.storageManager) || void 0 === t ? void 0 : t.getPersistedChannelConfig();\n                    oo.RemoteCommunication(\"[RemoteCommunication: testStorage()] res\", n);\n                });\n            }(this.state);\n        });\n    }\n    hasDeeplinkProtocol() {\n        return this.state.deeplinkProtocolAvailable;\n    }\n    getChannelConfig() {\n        return this.state.channelConfig;\n    }\n    isReady() {\n        return this.state.ready;\n    }\n    isConnected() {\n        var e;\n        return null === (e = this.state.communicationLayer) || void 0 === e ? void 0 : e.isConnected();\n    }\n    isAuthorized() {\n        return this.state.authorized;\n    }\n    isPaused() {\n        return this.state.paused;\n    }\n    getCommunicationLayer() {\n        return this.state.communicationLayer;\n    }\n    ping() {\n        return c(this, void 0, void 0, function*() {\n            var e;\n            oo.RemoteCommunication(\"[RemoteCommunication: ping()] channel=\".concat(this.state.channelId)), yield null === (e = this.state.communicationLayer) || void 0 === e ? void 0 : e.ping();\n        });\n    }\n    testLogger() {\n        oo.RemoteCommunication(\"testLogger() channel=\".concat(this.state.channelId)), oo.SocketService(\"testLogger() channel=\".concat(this.state.channelId)), oo.Ecies(\"testLogger() channel=\".concat(this.state.channelId)), oo.KeyExchange(\"testLogger() channel=\".concat(this.state.channelId));\n    }\n    keyCheck() {\n        var e;\n        oo.RemoteCommunication(\"[RemoteCommunication: keyCheck()] channel=\".concat(this.state.channelId)), null === (e = this.state.communicationLayer) || void 0 === e || e.keyCheck();\n    }\n    setConnectionStatus(e) {\n        this.state._connectionStatus !== e && (this.state._connectionStatus = e, this.emit(So.CONNECTION_STATUS, e), this.emitServiceStatusEvent({\n            context: \"setConnectionStatus\"\n        }));\n    }\n    emitServiceStatusEvent() {\n        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        this.emit(So.SERVICE_STATUS, this.getServiceStatus());\n    }\n    getConnectionStatus() {\n        return this.state._connectionStatus;\n    }\n    getServiceStatus() {\n        return {\n            originatorInfo: this.state.originatorInfo,\n            keyInfo: this.getKeyInfo(),\n            connectionStatus: this.state._connectionStatus,\n            channelConfig: this.state.channelConfig,\n            channelId: this.state.channelId\n        };\n    }\n    getKeyInfo() {\n        var e;\n        return null === (e = this.state.communicationLayer) || void 0 === e ? void 0 : e.getKeyInfo();\n    }\n    resetKeys() {\n        var e;\n        null === (e = this.state.communicationLayer) || void 0 === e || e.resetKeys();\n    }\n    setOtherPublicKey(e) {\n        var t;\n        const n = null === (t = this.state.communicationLayer) || void 0 === t ? void 0 : t.getKeyExchange();\n        if (!n) throw new Error(\"KeyExchange is not initialized.\");\n        n.getOtherPublicKey() !== e && n.setOtherPublicKey(e);\n    }\n    pause() {\n        return c(this, void 0, void 0, function*() {\n            var e;\n            oo.RemoteCommunication(\"[RemoteCommunication: pause()] channel=\".concat(this.state.channelId)), yield null === (e = this.state.communicationLayer) || void 0 === e ? void 0 : e.pause(), this.setConnectionStatus(Eo.PAUSED);\n        });\n    }\n    getVersion() {\n        return ho.version;\n    }\n    hasRelayPersistence() {\n        var e;\n        return null !== (e = this.state.relayPersistence) && void 0 !== e && e;\n    }\n    resume() {\n        return c(this, void 0, void 0, function*() {\n            return function(e) {\n                return c(this, void 0, void 0, function*() {\n                    var t;\n                    const { state: n } = e;\n                    oo.RemoteCommunication(\"[RemoteCommunication: resume()] channel=\".concat(n.channelId)), yield null === (t = n.communicationLayer) || void 0 === t ? void 0 : t.resume(), e.setConnectionStatus(Eo.LINKED);\n                });\n            }(this);\n        });\n    }\n    encrypt(e) {\n        var t, n, r;\n        const i = null === (t = this.state.communicationLayer) || void 0 === t ? void 0 : t.getKeyExchange(), o = null == i ? void 0 : i.getOtherPublicKey();\n        if (!o) throw new Error(\"KeyExchange not completed\");\n        return null === (r = null === (n = this.state.communicationLayer) || void 0 === n ? void 0 : n.state.eciesInstance) || void 0 === r ? void 0 : r.encrypt(e, o);\n    }\n    decrypt(e) {\n        var t, n, r;\n        if (!(null === (t = this.state.communicationLayer) || void 0 === t ? void 0 : t.state.eciesInstance)) throw new Error(\"ECIES instance is not initialized\");\n        return null === (r = null === (n = this.state.communicationLayer) || void 0 === n ? void 0 : n.state.eciesInstance) || void 0 === r ? void 0 : r.decrypt(e);\n    }\n    getChannelId() {\n        return this.state.channelId;\n    }\n    getRPCMethodTracker() {\n        var e;\n        return null === (e = this.state.communicationLayer) || void 0 === e ? void 0 : e.getRPCMethodTracker();\n    }\n    reject(param) {\n        let { channelId: e } = param;\n        return function(e) {\n            return c(this, arguments, void 0, function*(param) {\n                let { channelId: e, state: t } = param;\n                var n, r, i;\n                if (!(0,uuid__WEBPACK_IMPORTED_MODULE_5__.validate)(e)) throw oo.RemoteCommunication(\"[RemoteCommunication: connectToChannel()] context=\".concat(t.context, \" invalid channel channelId=\").concat(e)), new Error(\"Invalid channel \".concat(e));\n                if (t.isOriginator) return void oo.RemoteCommunication(\"[RemoteCommunication: reject()] context=\".concat(t.context, \" isOriginator=\").concat(t.isOriginator, \" channelId=\").concat(e));\n                const { socket: s } = null !== (r = null === (n = t.communicationLayer) || void 0 === n ? void 0 : n.state) && void 0 !== r ? r : {};\n                (null == s ? void 0 : s.connected) || (oo.RemoteCommunication(\"[RemoteCommunication: reject()] context=\".concat(t.context, \" socket already connected\")), null == s || s.connect()), lo(Object.assign(Object.assign({\n                    id: e,\n                    event: Ao.REJECTED\n                }, t.originatorInfo), {\n                    sdkVersion: t.sdkVersion,\n                    commLayerVersion: ho.version,\n                    walletVersion: null === (i = t.walletInfo) || void 0 === i ? void 0 : i.version\n                }), t.communicationServerUrl).catch((e)=>{}), yield new Promise((n, r)=>{\n                    null == s || s.emit(So.REJECTED, {\n                        channelId: e\n                    }, (e, i)=>{\n                        oo.RemoteCommunication(\"[RemoteCommunication: reject()] context=\".concat(t.context, \" socket=\").concat(null == s ? void 0 : s.id), {\n                            error: e,\n                            response: i\n                        }), e ? r(e) : n(i);\n                    });\n                });\n            });\n        }({\n            channelId: e,\n            state: this.state\n        });\n    }\n    disconnect(e) {\n        return c(this, void 0, void 0, function*() {\n            return es({\n                options: e,\n                instance: this\n            });\n        });\n    }\n    constructor(e){\n        super(), this.state = {\n            ready: !1,\n            anonId: \"\",\n            authorized: !1,\n            isOriginator: !1,\n            terminated: !1,\n            protocolVersion: 1,\n            paused: !1,\n            deeplinkProtocolAvailable: !1,\n            platformType: \"metamask-mobile\",\n            analytics: !1,\n            reconnection: !1,\n            originatorInfoSent: !1,\n            communicationServerUrl: fo,\n            context: \"\",\n            persist: !1,\n            clientsConnected: !1,\n            sessionDuration: go,\n            originatorConnectStarted: !1,\n            debug: !1,\n            _connectionStatus: Eo.DISCONNECTED\n        }, this._options = e;\n        const { anonId: n, platformType: r, communicationLayerPreference: i, otherPublicKey: o, reconnect: s, walletInfo: a, dappMetadata: c, protocolVersion: l, transports: d, context: u, relayPersistence: h, ecies: f, analytics: p = !1, storage: g, sdkVersion: m, communicationServerUrl: y = fo, logging: v, autoConnect: b = {\n            timeout: mo\n        } } = e;\n        this.state.anonId = n, this.state.otherPublicKey = o, this.state.dappMetadata = c, this.state.walletInfo = a, this.state.transports = d, this.state.platformType = r, this.state.analytics = p, this.state.protocolVersion = null != l ? l : 1, this.state.isOriginator = !o, this.state.relayPersistence = h, this.state.communicationServerUrl = y, this.state.context = u, this.state.terminated = !1, this.state.sdkVersion = m, this.setMaxListeners(50), this.setConnectionStatus(Eo.DISCONNECTED), (null == g ? void 0 : g.duration) && (this.state.sessionDuration = go), this.state.storageOptions = g, this.state.autoConnectOptions = b, this.state.debug = !0 === (null == v ? void 0 : v.remoteLayer), !0 === (null == v ? void 0 : v.remoteLayer) && debug__WEBPACK_IMPORTED_MODULE_1___default().enable(\"RemoteCommunication:Layer\"), !0 === (null == v ? void 0 : v.serviceLayer) && debug__WEBPACK_IMPORTED_MODULE_1___default().enable(\"SocketService:Layer\"), !0 === (null == v ? void 0 : v.eciesLayer) && debug__WEBPACK_IMPORTED_MODULE_1___default().enable(\"ECIES:Layer\"), !0 === (null == v ? void 0 : v.keyExchangeLayer) && debug__WEBPACK_IMPORTED_MODULE_1___default().enable(\"KeyExchange:Layer\"), this.state.logging = v, (null == g ? void 0 : g.storageManager) && (this.state.storageManager = g.storageManager), oo.RemoteCommunication(\"[RemoteCommunication: constructor()] protocolVersion=\".concat(l, \" relayPersistence=\").concat(h, \" isOriginator=\").concat(this.state.isOriginator, \" communicationLayerPreference=\").concat(i, \" otherPublicKey=\").concat(o, \" reconnect=\").concat(s)), this.state.isOriginator || Xo({\n            communicationLayerPreference: i,\n            otherPublicKey: o,\n            reconnect: s,\n            ecies: f,\n            communicationServerUrl: y,\n            instance: this\n        }), this.emitServiceStatusEvent({\n            context: \"constructor\"\n        });\n    }\n}\n!function(e) {\n    e.RENEW = \"renew\", e.LINK = \"link\";\n}(Ho || (Ho = {}));\nvar ns = \"ERC721\", rs = \"ERC1155\", is = {\n    errors: {\n        disconnected: ()=>\"MetaMask: Disconnected from chain. Attempting to connect.\",\n        permanentlyDisconnected: ()=>\"MetaMask: Disconnected from MetaMask background. Page reload required.\",\n        sendSiteMetadata: ()=>\"MetaMask: Failed to send site metadata. This is an internal error, please report this bug.\",\n        unsupportedSync: (e)=>\"MetaMask: The MetaMask Ethereum provider does not support synchronous methods like \".concat(e, \" without a callback parameter.\"),\n        invalidDuplexStream: ()=>\"Must provide a Node.js-style duplex stream.\",\n        invalidNetworkParams: ()=>\"MetaMask: Received invalid network parameters. Please report this bug.\",\n        invalidRequestArgs: ()=>\"Expected a single, non-array, object argument.\",\n        invalidRequestMethod: ()=>\"'args.method' must be a non-empty string.\",\n        invalidRequestParams: ()=>\"'args.params' must be an object or array if provided.\",\n        invalidLoggerObject: ()=>\"'args.logger' must be an object if provided.\",\n        invalidLoggerMethod: (e)=>\"'args.logger' must include required method '\".concat(e, \"'.\")\n    },\n    info: {\n        connected: (e)=>'MetaMask: Connected to chain with ID \"'.concat(e, '\".')\n    },\n    warnings: {\n        chainIdDeprecation: \"MetaMask: 'ethereum.chainId' is deprecated and may be removed in the future. Please use the 'eth_chainId' RPC method instead.\\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23\",\n        networkVersionDeprecation: \"MetaMask: 'ethereum.networkVersion' is deprecated and may be removed in the future. Please use the 'net_version' RPC method instead.\\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23\",\n        selectedAddressDeprecation: \"MetaMask: 'ethereum.selectedAddress' is deprecated and may be removed in the future. Please use the 'eth_accounts' RPC method instead.\\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/discussions/23\",\n        enableDeprecation: \"MetaMask: 'ethereum.enable()' is deprecated and may be removed in the future. Please use the 'eth_requestAccounts' RPC method instead.\\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1102\",\n        sendDeprecation: \"MetaMask: 'ethereum.send(...)' is deprecated and may be removed in the future. Please use 'ethereum.sendAsync(...)' or 'ethereum.request(...)' instead.\\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193\",\n        events: {\n            close: \"MetaMask: The event 'close' is deprecated and may be removed in the future. Please use 'disconnect' instead.\\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#disconnect\",\n            data: \"MetaMask: The event 'data' is deprecated and will be removed in the future. Use 'message' instead.\\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#message\",\n            networkChanged: \"MetaMask: The event 'networkChanged' is deprecated and may be removed in the future. Use 'chainChanged' instead.\\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#chainchanged\",\n            notification: \"MetaMask: The event 'notification' is deprecated and may be removed in the future. Use 'message' instead.\\nFor more information, see: https://eips.ethereum.org/EIPS/eip-1193#message\"\n        },\n        rpc: {\n            ethDecryptDeprecation: \"MetaMask: The RPC method 'eth_decrypt' is deprecated and may be removed in the future.\\nFor more information, see: https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686\",\n            ethGetEncryptionPublicKeyDeprecation: \"MetaMask: The RPC method 'eth_getEncryptionPublicKey' is deprecated and may be removed in the future.\\nFor more information, see: https://medium.com/metamask/metamask-api-method-deprecation-2b0564a84686\",\n            walletWatchAssetNFTExperimental: \"MetaMask: The RPC method 'wallet_watchAsset' is experimental for ERC721/ERC1155 assets and may change in the future.\\nFor more information, see: https://github.com/MetaMask/metamask-improvement-proposals/blob/main/MIPs/mip-1.md and https://github.com/MetaMask/metamask-improvement-proposals/blob/main/PROCESS-GUIDE.md#proposal-lifecycle\"\n        },\n        experimentalMethods: \"MetaMask: 'ethereum._metamask' exposes non-standard, experimental methods. They may be removed or changed without warning.\"\n    }\n};\nfunction os(e) {\n    const t = {\n        ethDecryptDeprecation: !1,\n        ethGetEncryptionPublicKeyDeprecation: !1,\n        walletWatchAssetNFTExperimental: !1\n    };\n    return (n, r, i)=>{\n        var _n_params;\n        t.ethDecryptDeprecation || \"eth_decrypt\" !== n.method ? t.ethGetEncryptionPublicKeyDeprecation || \"eth_getEncryptionPublicKey\" !== n.method ? !t.walletWatchAssetNFTExperimental && \"wallet_watchAsset\" === n.method && [\n            ns,\n            rs\n        ].includes(((_n_params = n.params) === null || _n_params === void 0 ? void 0 : _n_params.type) || \"\") && (e.warn(is.warnings.rpc.walletWatchAssetNFTExperimental), t.walletWatchAssetNFTExperimental = !0) : (e.warn(is.warnings.rpc.ethGetEncryptionPublicKeyDeprecation), t.ethGetEncryptionPublicKeyDeprecation = !0) : (e.warn(is.warnings.rpc.ethDecryptDeprecation), t.ethDecryptDeprecation = !0), i();\n    };\n}\nvar ss = 4294967295, as = Math.floor(Math.random() * ss);\nfunction cs() {\n    return (e, t, n, r)=>{\n        const i = e.id, o = as = (as + 1) % ss;\n        e.id = o, t.id = o, n((n)=>{\n            e.id = i, t.id = i, n();\n        });\n    };\n}\nvar ls = (e, t, n)=>{\n    if (!t.has(e)) throw TypeError(\"Cannot \" + n);\n}, ds = (e, t, n)=>(ls(e, t, \"read from private field\"), n ? n.call(e) : t.get(e)), us = (e, t, n)=>{\n    if (t.has(e)) throw TypeError(\"Cannot add the same private member more than once\");\n    t instanceof WeakSet ? t.add(e) : t.set(e, n);\n}, hs = (e, t, n, r)=>(ls(e, t, \"write to private field\"), t.set(e, n), n), fs = (e, t, n)=>(ls(e, t, \"access private method\"), n), ps = {\n    invalidInput: -32e3,\n    resourceNotFound: -32001,\n    resourceUnavailable: -32002,\n    transactionRejected: -32003,\n    methodNotSupported: -32004,\n    limitExceeded: -32005,\n    parse: -32700,\n    invalidRequest: -32600,\n    methodNotFound: -32601,\n    invalidParams: -32602,\n    internal: -32603\n}, gs = {\n    \"-32700\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.\"\n    },\n    \"-32600\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The JSON sent is not a valid Request object.\"\n    },\n    \"-32601\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The method does not exist / is not available.\"\n    },\n    \"-32602\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid method parameter(s).\"\n    },\n    \"-32603\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Internal JSON-RPC error.\"\n    },\n    \"-32000\": {\n        standard: \"EIP-1474\",\n        message: \"Invalid input.\"\n    },\n    \"-32001\": {\n        standard: \"EIP-1474\",\n        message: \"Resource not found.\"\n    },\n    \"-32002\": {\n        standard: \"EIP-1474\",\n        message: \"Resource unavailable.\"\n    },\n    \"-32003\": {\n        standard: \"EIP-1474\",\n        message: \"Transaction rejected.\"\n    },\n    \"-32004\": {\n        standard: \"EIP-1474\",\n        message: \"Method not supported.\"\n    },\n    \"-32005\": {\n        standard: \"EIP-1474\",\n        message: \"Request limit exceeded.\"\n    },\n    4001: {\n        standard: \"EIP-1193\",\n        message: \"User rejected the request.\"\n    },\n    4100: {\n        standard: \"EIP-1193\",\n        message: \"The requested account and/or method has not been authorized by the user.\"\n    },\n    4200: {\n        standard: \"EIP-1193\",\n        message: \"The requested method is not supported by this Ethereum provider.\"\n    },\n    4900: {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from all chains.\"\n    },\n    4901: {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from the specified chain.\"\n    }\n};\nfunction ms(e) {\n    return Boolean(e) && \"object\" == typeof e && !Array.isArray(e);\n}\nvar ys = (e, t)=>Object.hasOwnProperty.call(e, t);\nclass vs extends TypeError {\n    constructor(e, t){\n        let n;\n        const { message: r, explanation: i, ...o } = e, { path: s } = e, a = 0 === s.length ? r : \"At path: \".concat(s.join(\".\"), \" -- \").concat(r);\n        super(i !== null && i !== void 0 ? i : a), null != i && (this.cause = a), Object.assign(this, o), this.name = this.constructor.name, this.failures = ()=>n !== null && n !== void 0 ? n : n = [\n                e,\n                ...t()\n            ];\n    }\n}\nfunction bs(e) {\n    return \"object\" == typeof e && null != e;\n}\nfunction ws(e) {\n    return \"symbol\" == typeof e ? e.toString() : \"string\" == typeof e ? JSON.stringify(e) : \"\".concat(e);\n}\nfunction Es(e, t, n, r) {\n    if (!0 === e) return;\n    !1 === e ? e = {} : \"string\" == typeof e && (e = {\n        message: e\n    });\n    const { path: i, branch: o } = t, { type: s } = n, { refinement: a, message: c = \"Expected a value of type `\".concat(s, \"`\").concat(a ? \" with refinement `\".concat(a, \"`\") : \"\", \", but received: `\").concat(ws(r), \"`\") } = e;\n    return {\n        value: r,\n        type: s,\n        refinement: a,\n        key: i[i.length - 1],\n        path: i,\n        branch: o,\n        ...e,\n        message: c\n    };\n}\n_c67 = Es;\nfunction* Ss(e, t, n, r) {\n    (function(e) {\n        return bs(e) && \"function\" == typeof e[Symbol.iterator];\n    })(e) || (e = [\n        e\n    ]);\n    for (const i of e){\n        const e = Es(i, t, n, r);\n        e && (yield e);\n    }\n}\n_c68 = Ss;\nfunction* _s(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const { path: r = [], branch: i = [\n        e\n    ], coerce: o = !1, mask: s = !1 } = n, a = {\n        path: r,\n        branch: i\n    };\n    if (o && (e = t.coercer(e, a), s && \"type\" !== t.type && bs(t.schema) && bs(e) && !Array.isArray(e))) for(const n in e)void 0 === t.schema[n] && delete e[n];\n    let c = \"valid\";\n    for (const r of t.validator(e, a))r.explanation = n.message, c = \"not_valid\", yield [\n        r,\n        void 0\n    ];\n    for (let [l, d, u] of t.entries(e, a)){\n        const t = _s(d, u, {\n            path: void 0 === l ? r : [\n                ...r,\n                l\n            ],\n            branch: void 0 === l ? i : [\n                ...i,\n                d\n            ],\n            coerce: o,\n            mask: s,\n            message: n.message\n        });\n        for (const n of t)n[0] ? (c = null != n[0].refinement ? \"not_refined\" : \"not_valid\", yield [\n            n[0],\n            void 0\n        ]) : o && (d = n[1], void 0 === l ? e = d : e instanceof Map ? e.set(l, d) : e instanceof Set ? e.add(d) : bs(e) && (void 0 !== d || l in e) && (e[l] = d));\n    }\n    if (\"not_valid\" !== c) for (const r of t.refiner(e, a))r.explanation = n.message, c = \"not_refined\", yield [\n        r,\n        void 0\n    ];\n    \"valid\" === c && (yield [\n        void 0,\n        e\n    ]);\n}\nclass Cs {\n    assert(e, t) {\n        return ks(e, this, t);\n    }\n    create(e, t) {\n        return As(e, this, t);\n    }\n    is(e) {\n        return xs(e, this);\n    }\n    mask(e, t) {\n        return function(e, t, n) {\n            const r = Ms(e, t, {\n                coerce: !0,\n                mask: !0,\n                message: n\n            });\n            if (r[0]) throw r[0];\n            return r[1];\n        }(e, this, t);\n    }\n    validate(e) {\n        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        return Ms(e, this, t);\n    }\n    constructor(e){\n        const { type: t, schema: n, validator: r, refiner: i, coercer: o = (e)=>e, entries: s = function*() {} } = e;\n        this.type = t, this.schema = n, this.entries = s, this.coercer = o, this.validator = r ? (e, t)=>Ss(r(e, t), t, this, e) : ()=>[], this.refiner = i ? (e, t)=>Ss(i(e, t), t, this, e) : ()=>[];\n    }\n}\nfunction ks(e, t, n) {\n    const r = Ms(e, t, {\n        message: n\n    });\n    if (r[0]) throw r[0];\n}\nfunction As(e, t, n) {\n    const r = Ms(e, t, {\n        coerce: !0,\n        message: n\n    });\n    if (r[0]) throw r[0];\n    return r[1];\n}\n_c69 = As;\nfunction xs(e, t) {\n    return !Ms(e, t)[0];\n}\nfunction Ms(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const r = _s(e, t, n), i = function(e) {\n        const { done: t, value: n } = e.next();\n        return t ? void 0 : n;\n    }(r);\n    if (i[0]) {\n        const e = new vs(i[0], function*() {\n            for (const e of r)e[0] && (yield e[0]);\n        });\n        return [\n            e,\n            void 0\n        ];\n    }\n    return [\n        void 0,\n        i[1]\n    ];\n}\n_c70 = Ms;\nfunction Is(e, t) {\n    return new Cs({\n        type: e,\n        schema: null,\n        validator: t\n    });\n}\n_c71 = Is;\nfunction Ts(e) {\n    let t;\n    return new Cs({\n        type: \"lazy\",\n        schema: null,\n        *entries (n, r) {\n            t !== null && t !== void 0 ? t : t = e(), yield* t.entries(n, r);\n        },\n        validator: (n, r)=>(t !== null && t !== void 0 ? t : t = e(), t.validator(n, r)),\n        coercer: (n, r)=>(t !== null && t !== void 0 ? t : t = e(), t.coercer(n, r)),\n        refiner: (n, r)=>(t !== null && t !== void 0 ? t : t = e(), t.refiner(n, r))\n    });\n}\n_c72 = Ts;\nfunction Rs(e) {\n    return new Cs({\n        type: \"array\",\n        schema: e,\n        *entries (t) {\n            if (e && Array.isArray(t)) for (const [n, r] of t.entries())yield [\n                n,\n                r,\n                e\n            ];\n        },\n        coercer: (e)=>Array.isArray(e) ? e.slice() : e,\n        validator: (e)=>Array.isArray(e) || \"Expected an array value, but received: \".concat(ws(e))\n    });\n}\n_c73 = Rs;\nfunction Ps(e) {\n    const t = ws(e), n = typeof e;\n    return new Cs({\n        type: \"literal\",\n        schema: \"string\" === n || \"number\" === n || \"boolean\" === n ? e : null,\n        validator: (n)=>n === e || \"Expected the literal `\".concat(t, \"`, but received: \").concat(ws(n))\n    });\n}\n_c74 = Ps;\nfunction Os() {\n    return Is(\"number\", (e)=>\"number\" == typeof e && !isNaN(e) || \"Expected a number, but received: \".concat(ws(e)));\n}\n_c75 = Os;\nfunction Ns(e) {\n    const t = e ? Object.keys(e) : [], n = Is(\"never\", ()=>!1);\n    return new Cs({\n        type: \"object\",\n        schema: e || null,\n        *entries (r) {\n            if (e && bs(r)) {\n                const i = new Set(Object.keys(r));\n                for (const n of t)i.delete(n), yield [\n                    n,\n                    r[n],\n                    e[n]\n                ];\n                for (const e of i)yield [\n                    e,\n                    r[e],\n                    n\n                ];\n            }\n        },\n        validator: (e)=>bs(e) || \"Expected an object, but received: \".concat(ws(e)),\n        coercer: (e)=>bs(e) ? {\n                ...e\n            } : e\n    });\n}\n_c76 = Ns;\nfunction Ls(e) {\n    return new Cs({\n        ...e,\n        validator: (t, n)=>void 0 === t || e.validator(t, n),\n        refiner: (t, n)=>void 0 === t || e.refiner(t, n)\n    });\n}\n_c77 = Ls;\nfunction Ds(e, t) {\n    return new Cs({\n        type: \"record\",\n        schema: null,\n        *entries (n) {\n            if (bs(n)) for(const r in n){\n                const i = n[r];\n                yield [\n                    r,\n                    r,\n                    e\n                ], yield [\n                    r,\n                    i,\n                    t\n                ];\n            }\n        },\n        validator: (e)=>bs(e) || \"Expected an object, but received: \".concat(ws(e))\n    });\n}\n_c78 = Ds;\nfunction $s() {\n    return Is(\"string\", (e)=>\"string\" == typeof e || \"Expected a string, but received: \".concat(ws(e)));\n}\nfunction Bs(e) {\n    const t = e.map((e)=>e.type).join(\" | \");\n    return new Cs({\n        type: \"union\",\n        schema: null,\n        coercer (t) {\n            for (const n of e){\n                const [e, r] = n.validate(t, {\n                    coerce: !0\n                });\n                if (!e) return r;\n            }\n            return t;\n        },\n        validator (n, r) {\n            const i = [];\n            for (const t of e){\n                const [...e] = _s(n, t, r), [o] = e;\n                if (!o[0]) return [];\n                for (const [t] of e)t && i.push(t);\n            }\n            return [\n                \"Expected the value to satisfy a union of `\".concat(t, \"`, but received: \").concat(ws(n)),\n                ...i\n            ];\n        }\n    });\n}\n_c79 = Bs;\nfunction Ks(e) {\n    return (function(e) {\n        return function(e) {\n            return \"object\" == typeof e && null !== e && \"message\" in e;\n        }(e) && \"string\" == typeof e.message ? e.message : null == e ? \"\" : String(e);\n    })(e).replace(/\\.$/u, \"\");\n}\n_c80 = Ks;\nfunction js(e, t) {\n    var _n_prototype_constructor, _n_prototype;\n    return n = e, Boolean(\"string\" == typeof (n === null || n === void 0 ? void 0 : (_n_prototype = n.prototype) === null || _n_prototype === void 0 ? void 0 : (_n_prototype_constructor = _n_prototype.constructor) === null || _n_prototype_constructor === void 0 ? void 0 : _n_prototype_constructor.name)) ? new e({\n        message: t\n    }) : e({\n        message: t\n    });\n    var n;\n}\nvar Us = class extends Error {\n    constructor(e){\n        super(e.message), this.code = \"ERR_ASSERTION\";\n    }\n};\nfunction Hs() {\n    throw new Error(\"setTimeout has not been defined\");\n}\n_c81 = Hs;\nfunction Fs() {\n    throw new Error(\"clearTimeout has not been defined\");\n}\n_c82 = Fs;\nvar zs = Hs, qs = Fs;\nfunction Ws(e) {\n    if (zs === setTimeout) return setTimeout(e, 0);\n    if ((zs === Hs || !zs) && setTimeout) return zs = setTimeout, setTimeout(e, 0);\n    try {\n        return zs(e, 0);\n    } catch (t) {\n        try {\n            return zs.call(null, e, 0);\n        } catch (t) {\n            return zs.call(this, e, 0);\n        }\n    }\n}\n_c83 = Ws;\n\"function\" == typeof l.setTimeout && (zs = setTimeout), \"function\" == typeof l.clearTimeout && (qs = clearTimeout);\nvar Vs, Gs = [], Ys = !1, Zs = -1;\nfunction Js() {\n    Ys && Vs && (Ys = !1, Vs.length ? Gs = Vs.concat(Gs) : Zs = -1, Gs.length && Qs());\n}\n_c84 = Js;\nfunction Qs() {\n    if (!Ys) {\n        var e = Ws(Js);\n        Ys = !0;\n        for(var t = Gs.length; t;){\n            for(Vs = Gs, Gs = []; ++Zs < t;)Vs && Vs[Zs].run();\n            Zs = -1, t = Gs.length;\n        }\n        Vs = null, Ys = !1, function(e) {\n            if (qs === clearTimeout) return clearTimeout(e);\n            if ((qs === Fs || !qs) && clearTimeout) return qs = clearTimeout, clearTimeout(e);\n            try {\n                return qs(e);\n            } catch (t) {\n                try {\n                    return qs.call(null, e);\n                } catch (t) {\n                    return qs.call(this, e);\n                }\n            }\n        }(e);\n    }\n}\n_c85 = Qs;\nfunction Xs(e, t) {\n    this.fun = e, this.array = t;\n}\n_c86 = Xs;\nXs.prototype.run = function() {\n    this.fun.apply(null, this.array);\n};\nfunction ea() {}\nvar ta = ea, na = ea, ra = ea, ia = ea, oa = ea, sa = ea, aa = ea;\nvar ca = l.performance || {}, la = ca.now || ca.mozNow || ca.msNow || ca.oNow || ca.webkitNow || function() {\n    return (new Date).getTime();\n};\nvar da = new Date;\nvar ua = {\n    nextTick: function(e) {\n        var t = new Array(arguments.length - 1);\n        if (arguments.length > 1) for(var n = 1; n < arguments.length; n++)t[n - 1] = arguments[n];\n        Gs.push(new Xs(e, t)), 1 !== Gs.length || Ys || Ws(Qs);\n    },\n    title: \"browser\",\n    browser: !0,\n    env: {},\n    argv: [],\n    version: \"\",\n    versions: {},\n    on: ta,\n    addListener: na,\n    once: ra,\n    off: ia,\n    removeListener: oa,\n    removeAllListeners: sa,\n    emit: aa,\n    binding: function(e) {\n        throw new Error(\"process.binding is not supported\");\n    },\n    cwd: function() {\n        return \"/\";\n    },\n    chdir: function(e) {\n        throw new Error(\"process.chdir is not supported\");\n    },\n    umask: function() {\n        return 0;\n    },\n    hrtime: function(e) {\n        var t = .001 * la.call(ca), n = Math.floor(t), r = Math.floor(t % 1 * 1e9);\n        return e && (n -= e[0], (r -= e[1]) < 0 && (n--, r += 1e9)), [\n            n,\n            r\n        ];\n    },\n    platform: \"browser\",\n    release: {},\n    config: {},\n    uptime: function() {\n        return (new Date - da) / 1e3;\n    }\n}, ha = (e)=>Ns(e);\nfunction fa(param) {\n    let { path: e, branch: t } = param;\n    const n = e[e.length - 1];\n    return ys(t[t.length - 2], n);\n}\nfunction pa(e) {\n    return new Cs({\n        ...e,\n        type: \"optional \".concat(e.type),\n        validator: (t, n)=>!fa(n) || e.validator(t, n),\n        refiner: (t, n)=>!fa(n) || e.refiner(t, n)\n    });\n}\nvar ga, ma, ya, va = Bs([\n    Ps(null),\n    Is(\"boolean\", (e)=>\"boolean\" == typeof e),\n    Is(\"finite number\", (e)=>xs(e, Os()) && Number.isFinite(e)),\n    $s(),\n    Rs(Ts(()=>va)),\n    Ds($s(), Ts(()=>va))\n]), ba = (ga = va, ma = Is(\"any\", ()=>!0), ya = (e)=>((function(e, t) {\n        let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"Assertion failed\", r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Us;\n        try {\n            ks(e, t);\n        } catch (e) {\n            throw js(r, \"\".concat(n, \": \").concat(Ks(e), \".\"));\n        }\n    })(e, va), JSON.parse(JSON.stringify(e, (e, t)=>{\n        if (\"__proto__\" !== e && \"constructor\" !== e) return t;\n    }))), new Cs({\n    ...ga,\n    coercer: (e, t)=>xs(e, ma) ? ga.coercer(ya(e, t), t) : ga.coercer(e, t)\n}));\nfunction wa(e) {\n    try {\n        return function(e) {\n            As(e, ba);\n        }(e), !0;\n    } catch (e) {\n        return !1;\n    }\n}\nvar Ea = Ps(\"2.0\"), Sa = function(e) {\n    return new Cs({\n        ...e,\n        validator: (t, n)=>null === t || e.validator(t, n),\n        refiner: (t, n)=>null === t || e.refiner(t, n)\n    });\n}(Bs([\n    Os(),\n    $s()\n])), _a = ha({\n    code: Is(\"integer\", (e)=>\"number\" == typeof e && !isNaN(e) && Number.isInteger(e) || \"Expected an integer, but received: \".concat(ws(e))),\n    message: $s(),\n    data: pa(ba),\n    stack: pa($s())\n}), Ca = Bs([\n    Ds($s(), ba),\n    Rs(ba)\n]), ka = ha({\n    id: Sa,\n    jsonrpc: Ea,\n    method: $s(),\n    params: pa(Ca)\n}), Aa = ha({\n    jsonrpc: Ea,\n    method: $s(),\n    params: pa(Ca)\n});\nfunction xa(e) {\n    return xs(e, ka);\n}\nfunction Ma(e) {\n    return xs(e, _a);\n}\n_c87 = Ma;\nNs({\n    id: Sa,\n    jsonrpc: Ea,\n    result: Ls(Is(\"unknown\", ()=>!0)),\n    error: Ls(_a)\n}), Bs([\n    ha({\n        id: Sa,\n        jsonrpc: Ea,\n        result: ba\n    }),\n    ha({\n        id: Sa,\n        jsonrpc: Ea,\n        error: _a\n    })\n]);\nvar Ia = ps.internal, Ta = \"Unspecified error message. This is a bug, please report it.\", Ra = {\n    code: Ia,\n    message: Oa(Ia)\n}, Pa = \"Unspecified server error.\";\nfunction Oa(e) {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Ta;\n    if (function(e) {\n        return Number.isInteger(e);\n    }(e)) {\n        const t = e.toString();\n        if (ys(gs, t)) return gs[t].message;\n        if (function(e) {\n            return e >= -32099 && e <= -32e3;\n        }(e)) return Pa;\n    }\n    return t;\n}\n_c88 = Oa;\nfunction Na(e) {\n    let { fallbackError: t = Ra, shouldIncludeStack: n = !0 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    if (!Ma(t)) throw new Error(\"Must provide fallback error with integer number code and string message.\");\n    const r = function(e, t) {\n        if (e && \"object\" == typeof e && \"serialize\" in e && \"function\" == typeof e.serialize) return e.serialize();\n        if (Ma(e)) return e;\n        const n = La(e), r = {\n            ...t,\n            data: {\n                cause: n\n            }\n        };\n        return r;\n    }(e, t);\n    return n || delete r.stack, r;\n}\n_c89 = Na;\nfunction La(e) {\n    return Array.isArray(e) ? e.map((e)=>wa(e) ? e : ms(e) ? Da(e) : null) : ms(e) ? Da(e) : wa(e) ? e : null;\n}\n_c90 = La;\nfunction Da(e) {\n    return Object.getOwnPropertyNames(e).reduce((t, n)=>{\n        const r = e[n];\n        return wa(r) && (t[n] = r), t;\n    }, {});\n}\n_c91 = Da;\nvar $a = Fa;\nFa.default = Fa, Fa.stable = Va, Fa.stableStringify = Va;\nvar Ba = \"[...]\", Ka = \"[Circular]\", ja = [], Ua = [];\nfunction Ha() {\n    return {\n        depthLimit: Number.MAX_SAFE_INTEGER,\n        edgesLimit: Number.MAX_SAFE_INTEGER\n    };\n}\n_c92 = Ha;\nfunction Fa(e, t, n, r) {\n    var i;\n    void 0 === r && (r = Ha()), qa(e, \"\", 0, [], void 0, 0, r);\n    try {\n        i = 0 === Ua.length ? JSON.stringify(e, t, n) : JSON.stringify(e, Ya(t), n);\n    } catch (e) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally{\n        for(; 0 !== ja.length;){\n            var o = ja.pop();\n            4 === o.length ? Object.defineProperty(o[0], o[1], o[3]) : o[0][o[1]] = o[2];\n        }\n    }\n    return i;\n}\n_c93 = Fa;\nfunction za(e, t, n, r) {\n    var i = Object.getOwnPropertyDescriptor(r, n);\n    void 0 !== i.get ? i.configurable ? (Object.defineProperty(r, n, {\n        value: e\n    }), ja.push([\n        r,\n        n,\n        t,\n        i\n    ])) : Ua.push([\n        t,\n        n,\n        e\n    ]) : (r[n] = e, ja.push([\n        r,\n        n,\n        t\n    ]));\n}\nfunction qa(e, t, n, r, i, o, s) {\n    var a;\n    if (o += 1, \"object\" == typeof e && null !== e) {\n        for(a = 0; a < r.length; a++)if (r[a] === e) return void za(Ka, e, t, i);\n        if (void 0 !== s.depthLimit && o > s.depthLimit) return void za(Ba, e, t, i);\n        if (void 0 !== s.edgesLimit && n + 1 > s.edgesLimit) return void za(Ba, e, t, i);\n        if (r.push(e), Array.isArray(e)) for(a = 0; a < e.length; a++)qa(e[a], a, a, r, e, o, s);\n        else {\n            var c = Object.keys(e);\n            for(a = 0; a < c.length; a++){\n                var l = c[a];\n                qa(e[l], l, a, r, e, o, s);\n            }\n        }\n        r.pop();\n    }\n}\nfunction Wa(e, t) {\n    return e < t ? -1 : e > t ? 1 : 0;\n}\n_c94 = Wa;\nfunction Va(e, t, n, r) {\n    void 0 === r && (r = Ha());\n    var i, o = Ga(e, \"\", 0, [], void 0, 0, r) || e;\n    try {\n        i = 0 === Ua.length ? JSON.stringify(o, t, n) : JSON.stringify(o, Ya(t), n);\n    } catch (e) {\n        return JSON.stringify(\"[unable to serialize, circular reference is too complex to analyze]\");\n    } finally{\n        for(; 0 !== ja.length;){\n            var s = ja.pop();\n            4 === s.length ? Object.defineProperty(s[0], s[1], s[3]) : s[0][s[1]] = s[2];\n        }\n    }\n    return i;\n}\n_c95 = Va;\nfunction Ga(e, t, n, r, i, o, s) {\n    var a;\n    if (o += 1, \"object\" == typeof e && null !== e) {\n        for(a = 0; a < r.length; a++)if (r[a] === e) return void za(Ka, e, t, i);\n        try {\n            if (\"function\" == typeof e.toJSON) return;\n        } catch (e) {\n            return;\n        }\n        if (void 0 !== s.depthLimit && o > s.depthLimit) return void za(Ba, e, t, i);\n        if (void 0 !== s.edgesLimit && n + 1 > s.edgesLimit) return void za(Ba, e, t, i);\n        if (r.push(e), Array.isArray(e)) for(a = 0; a < e.length; a++)Ga(e[a], a, a, r, e, o, s);\n        else {\n            var c = {}, l = Object.keys(e).sort(Wa);\n            for(a = 0; a < l.length; a++){\n                var d = l[a];\n                Ga(e[d], d, a, r, e, o, s), c[d] = e[d];\n            }\n            if (void 0 === i) return c;\n            ja.push([\n                i,\n                t,\n                e\n            ]), i[t] = c;\n        }\n        r.pop();\n    }\n}\n_c96 = Ga;\nfunction Ya(e) {\n    return e = void 0 !== e ? e : function(e, t) {\n        return t;\n    }, function(t, n) {\n        if (Ua.length > 0) for(var r = 0; r < Ua.length; r++){\n            var i = Ua[r];\n            if (i[1] === t && i[0] === n) {\n                n = i[2], Ua.splice(r, 1);\n                break;\n            }\n        }\n        return e.call(this, t, n);\n    };\n}\n_c97 = Ya;\nvar Za = ue($a), Ja = class extends Error {\n    serialize() {\n        const e = {\n            code: this.code,\n            message: this.message\n        };\n        return void 0 !== this.data && (e.data = this.data, function(e) {\n            if (\"object\" != typeof e || null === e) return !1;\n            try {\n                let t = e;\n                for(; null !== Object.getPrototypeOf(t);)t = Object.getPrototypeOf(t);\n                return Object.getPrototypeOf(e) === t;\n            } catch (e) {\n                return !1;\n            }\n        }(this.data) && (e.data.cause = La(this.data.cause))), this.stack && (e.stack = this.stack), e;\n    }\n    toString() {\n        return Za(this.serialize(), Qa, 2);\n    }\n    constructor(e, t, n){\n        if (!Number.isInteger(e)) throw new Error('\"code\" must be an integer.');\n        if (!t || \"string\" != typeof t) throw new Error('\"message\" must be a non-empty string.');\n        super(t), this.code = e, void 0 !== n && (this.data = n);\n    }\n};\nfunction Qa(e, t) {\n    if (\"[Circular]\" !== t) return t;\n}\n_c98 = Qa;\nvar Xa = (e)=>ec(ps.invalidRequest, e);\n_c99 = Xa;\nfunction ec(e, t) {\n    const [n, r] = function(e) {\n        if (e) {\n            if (\"string\" == typeof e) return [\n                e\n            ];\n            if (\"object\" == typeof e && !Array.isArray(e)) {\n                const { message: t, data: n } = e;\n                if (t && \"string\" != typeof t) throw new Error(\"Must specify string message.\");\n                return [\n                    t !== null && t !== void 0 ? t : void 0,\n                    n\n                ];\n            }\n        }\n        return [];\n    }(t);\n    return new Ja(e, n !== null && n !== void 0 ? n : Oa(e), r);\n}\nvar tc = {};\nfunction nc() {}\nfunction rc() {\n    rc.init.call(this);\n}\nfunction ic(e) {\n    return void 0 === e._maxListeners ? rc.defaultMaxListeners : e._maxListeners;\n}\nfunction oc(e, t, n, r) {\n    var i, o, s;\n    if (\"function\" != typeof n) throw new TypeError('\"listener\" argument must be a function');\n    if ((o = e._events) ? (o.newListener && (e.emit(\"newListener\", t, n.listener ? n.listener : n), o = e._events), s = o[t]) : (o = e._events = new nc, e._eventsCount = 0), s) {\n        if (\"function\" == typeof s ? s = o[t] = r ? [\n            n,\n            s\n        ] : [\n            s,\n            n\n        ] : r ? s.unshift(n) : s.push(n), !s.warned && (i = ic(e)) && i > 0 && s.length > i) {\n            s.warned = !0;\n            var a = new Error(\"Possible EventEmitter memory leak detected. \" + s.length + \" \" + t + \" listeners added. Use emitter.setMaxListeners() to increase limit\");\n            a.name = \"MaxListenersExceededWarning\", a.emitter = e, a.type = t, a.count = s.length, function(e) {\n                \"function\" == typeof console.warn ? console.warn(e) : console.log(e);\n            }(a);\n        }\n    } else s = o[t] = n, ++e._eventsCount;\n    return e;\n}\nfunction sc(e, t, n) {\n    var r = !1;\n    function i() {\n        e.removeListener(t, i), r || (r = !0, n.apply(e, arguments));\n    }\n    return i.listener = n, i;\n}\nfunction ac(e) {\n    var t = this._events;\n    if (t) {\n        var n = t[e];\n        if (\"function\" == typeof n) return 1;\n        if (n) return n.length;\n    }\n    return 0;\n}\nfunction cc(e, t) {\n    for(var n = new Array(t); t--;)n[t] = e[t];\n    return n;\n}\nnc.prototype = Object.create(null), rc.EventEmitter = rc, rc.usingDomains = !1, rc.prototype.domain = void 0, rc.prototype._events = void 0, rc.prototype._maxListeners = void 0, rc.defaultMaxListeners = 10, rc.init = function() {\n    this.domain = null, rc.usingDomains && undefined.active, this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = new nc, this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;\n}, rc.prototype.setMaxListeners = function(e) {\n    if (\"number\" != typeof e || e < 0 || isNaN(e)) throw new TypeError('\"n\" argument must be a positive number');\n    return this._maxListeners = e, this;\n}, rc.prototype.getMaxListeners = function() {\n    return ic(this);\n}, rc.prototype.emit = function(e) {\n    var t, n, r, i, o, s, a, c = \"error\" === e;\n    if (s = this._events) c = c && null == s.error;\n    else if (!c) return !1;\n    if (a = this.domain, c) {\n        if (t = arguments[1], !a) {\n            if (t instanceof Error) throw t;\n            var l = new Error('Uncaught, unspecified \"error\" event. (' + t + \")\");\n            throw l.context = t, l;\n        }\n        return t || (t = new Error('Uncaught, unspecified \"error\" event')), t.domainEmitter = this, t.domain = a, t.domainThrown = !1, a.emit(\"error\", t), !1;\n    }\n    if (!(n = s[e])) return !1;\n    var d = \"function\" == typeof n;\n    switch(r = arguments.length){\n        case 1:\n            !function(e, t, n) {\n                if (t) e.call(n);\n                else for(var r = e.length, i = cc(e, r), o = 0; o < r; ++o)i[o].call(n);\n            }(n, d, this);\n            break;\n        case 2:\n            !function(e, t, n, r) {\n                if (t) e.call(n, r);\n                else for(var i = e.length, o = cc(e, i), s = 0; s < i; ++s)o[s].call(n, r);\n            }(n, d, this, arguments[1]);\n            break;\n        case 3:\n            !function(e, t, n, r, i) {\n                if (t) e.call(n, r, i);\n                else for(var o = e.length, s = cc(e, o), a = 0; a < o; ++a)s[a].call(n, r, i);\n            }(n, d, this, arguments[1], arguments[2]);\n            break;\n        case 4:\n            !function(e, t, n, r, i, o) {\n                if (t) e.call(n, r, i, o);\n                else for(var s = e.length, a = cc(e, s), c = 0; c < s; ++c)a[c].call(n, r, i, o);\n            }(n, d, this, arguments[1], arguments[2], arguments[3]);\n            break;\n        default:\n            for(i = new Array(r - 1), o = 1; o < r; o++)i[o - 1] = arguments[o];\n            !function(e, t, n, r) {\n                if (t) e.apply(n, r);\n                else for(var i = e.length, o = cc(e, i), s = 0; s < i; ++s)o[s].apply(n, r);\n            }(n, d, this, i);\n    }\n    return !0;\n}, rc.prototype.addListener = function(e, t) {\n    return oc(this, e, t, !1);\n}, rc.prototype.on = rc.prototype.addListener, rc.prototype.prependListener = function(e, t) {\n    return oc(this, e, t, !0);\n}, rc.prototype.once = function(e, t) {\n    if (\"function\" != typeof t) throw new TypeError('\"listener\" argument must be a function');\n    return this.on(e, sc(this, e, t)), this;\n}, rc.prototype.prependOnceListener = function(e, t) {\n    if (\"function\" != typeof t) throw new TypeError('\"listener\" argument must be a function');\n    return this.prependListener(e, sc(this, e, t)), this;\n}, rc.prototype.removeListener = function(e, t) {\n    var n, r, i, o, s;\n    if (\"function\" != typeof t) throw new TypeError('\"listener\" argument must be a function');\n    if (!(r = this._events)) return this;\n    if (!(n = r[e])) return this;\n    if (n === t || n.listener && n.listener === t) 0 == --this._eventsCount ? this._events = new nc : (delete r[e], r.removeListener && this.emit(\"removeListener\", e, n.listener || t));\n    else if (\"function\" != typeof n) {\n        for(i = -1, o = n.length; o-- > 0;)if (n[o] === t || n[o].listener && n[o].listener === t) {\n            s = n[o].listener, i = o;\n            break;\n        }\n        if (i < 0) return this;\n        if (1 === n.length) {\n            if (n[0] = void 0, 0 == --this._eventsCount) return this._events = new nc, this;\n            delete r[e];\n        } else !function(e, t) {\n            for(var n = t, r = n + 1, i = e.length; r < i; n += 1, r += 1)e[n] = e[r];\n            e.pop();\n        }(n, i);\n        r.removeListener && this.emit(\"removeListener\", e, s || t);\n    }\n    return this;\n}, rc.prototype.off = function(e, t) {\n    return this.removeListener(e, t);\n}, rc.prototype.removeAllListeners = function(e) {\n    var t, n;\n    if (!(n = this._events)) return this;\n    if (!n.removeListener) return 0 === arguments.length ? (this._events = new nc, this._eventsCount = 0) : n[e] && (0 == --this._eventsCount ? this._events = new nc : delete n[e]), this;\n    if (0 === arguments.length) {\n        for(var r, i = Object.keys(n), o = 0; o < i.length; ++o)\"removeListener\" !== (r = i[o]) && this.removeAllListeners(r);\n        return this.removeAllListeners(\"removeListener\"), this._events = new nc, this._eventsCount = 0, this;\n    }\n    if (\"function\" == typeof (t = n[e])) this.removeListener(e, t);\n    else if (t) do {\n        this.removeListener(e, t[t.length - 1]);\n    }while (t[0]);\n    return this;\n}, rc.prototype.listeners = function(e) {\n    var t, n, r = this._events;\n    return n = r && (t = r[e]) ? \"function\" == typeof t ? [\n        t.listener || t\n    ] : function(e) {\n        for(var t = new Array(e.length), n = 0; n < t.length; ++n)t[n] = e[n].listener || e[n];\n        return t;\n    }(t) : [], n;\n}, rc.listenerCount = function(e, t) {\n    return \"function\" == typeof e.listenerCount ? e.listenerCount(t) : ac.call(e, t);\n}, rc.prototype.listenerCount = ac, rc.prototype.eventNames = function() {\n    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\nvar lc = he(Object.freeze({\n    __proto__: null,\n    EventEmitter: rc,\n    default: rc\n}));\nObject.defineProperty(tc, \"__esModule\", {\n    value: !0\n});\nconst dc = lc;\nfunction uc(e, t, n) {\n    try {\n        Reflect.apply(e, t, n);\n    } catch (e) {\n        setTimeout(()=>{\n            throw e;\n        });\n    }\n}\nlet hc = class extends dc.EventEmitter {\n    emit(e) {\n        for(var _len = arguments.length, t = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            t[_key - 1] = arguments[_key];\n        }\n        let n = \"error\" === e;\n        const r = this._events;\n        if (void 0 !== r) n = n && void 0 === r.error;\n        else if (!n) return !1;\n        if (n) {\n            let e;\n            if (t.length > 0 && ([e] = t), e instanceof Error) throw e;\n            const n = new Error(\"Unhandled error.\" + (e ? \" (\".concat(e.message, \")\") : \"\"));\n            throw n.context = e, n;\n        }\n        const i = r[e];\n        if (void 0 === i) return !1;\n        if (\"function\" == typeof i) uc(i, this, t);\n        else {\n            const e = i.length, n = function(e) {\n                const t = e.length, n = new Array(t);\n                for(let r = 0; r < t; r += 1)n[r] = e[r];\n                return n;\n            }(i);\n            for(let r = 0; r < e; r += 1)uc(n[r], this, t);\n        }\n        return !0;\n    }\n};\nvar fc, pc, gc, mc, yc, vc, bc, wc, Ec, Sc, _c, Cc, kc, Ac, xc, Mc, Ic, Tc, Rc, Pc = tc.default = hc, Oc = class e extends Pc {\n    destroy() {\n        ds(this, pc).forEach((e)=>{\n            \"destroy\" in e && \"function\" == typeof e.destroy && e.destroy();\n        }), hs(this, pc, []), hs(this, fc, !0);\n    }\n    push(e) {\n        fs(this, mc, yc).call(this), ds(this, pc).push(e);\n    }\n    handle(e, t) {\n        if (fs(this, mc, yc).call(this), t && \"function\" != typeof t) throw new Error('\"callback\" must be a function if provided.');\n        return Array.isArray(e) ? t ? fs(this, vc, bc).call(this, e, t) : fs(this, vc, bc).call(this, e) : t ? fs(this, wc, Ec).call(this, e, t) : this._promiseHandle(e);\n    }\n    asMiddleware() {\n        return fs(this, mc, yc).call(this), async (t, n, r, i)=>{\n            var o, s;\n            try {\n                const [a, c, l] = await fs(o = e, Cc, kc).call(o, t, n, ds(this, pc));\n                return c ? (await fs(s = e, Mc, Ic).call(s, l), i(a)) : r(async (t)=>{\n                    var n;\n                    try {\n                        await fs(n = e, Mc, Ic).call(n, l);\n                    } catch (e) {\n                        return t(e);\n                    }\n                    return t();\n                });\n            } catch (e) {\n                return i(e);\n            }\n        };\n    }\n    async _promiseHandle(e) {\n        return new Promise((t, n)=>{\n            fs(this, wc, Ec).call(this, e, (e, r)=>{\n                e && void 0 === r ? n(e) : t(r);\n            }).catch(n);\n        });\n    }\n    constructor({ notificationHandler: e } = {}){\n        super(), us(this, mc), us(this, vc), us(this, wc), us(this, fc, !1), us(this, pc, void 0), us(this, gc, void 0), hs(this, pc, []), hs(this, gc, e);\n    }\n};\nfc = new WeakMap, pc = new WeakMap, gc = new WeakMap, mc = new WeakSet, yc = function() {\n    if (ds(this, fc)) throw new Error(\"This engine is destroyed and can no longer be used.\");\n}, vc = new WeakSet, bc = async function(e, t) {\n    try {\n        if (0 === e.length) {\n            const e = [\n                {\n                    id: null,\n                    jsonrpc: \"2.0\",\n                    error: new Ja(ps.invalidRequest, \"Request batch must contain plain objects. Received an empty array\")\n                }\n            ];\n            return t ? t(null, e) : e;\n        }\n        const n = (await Promise.all(e.map(this._promiseHandle.bind(this)))).filter((e)=>void 0 !== e);\n        return t ? t(null, n) : n;\n    } catch (e) {\n        if (t) return t(e);\n        throw e;\n    }\n}, wc = new WeakSet, Ec = async function(e, t) {\n    var n;\n    if (!e || Array.isArray(e) || \"object\" != typeof e) {\n        const n = new Ja(ps.invalidRequest, \"Requests must be plain objects. Received: \" + typeof e, {\n            request: e\n        });\n        return t(n, {\n            id: null,\n            jsonrpc: \"2.0\",\n            error: n\n        });\n    }\n    if (\"string\" != typeof e.method) {\n        const n = new Ja(ps.invalidRequest, \"Must specify a string method. Received: \" + typeof e.method, {\n            request: e\n        });\n        var _e_id;\n        return ds(this, gc) && !xa(e) ? t(null) : t(n, {\n            id: (_e_id = e.id) !== null && _e_id !== void 0 ? _e_id : null,\n            jsonrpc: \"2.0\",\n            error: n\n        });\n    }\n    if (ds(this, gc) && xs(e, Aa) && !xa(e)) {\n        try {\n            await ds(this, gc).call(this, e);\n        } catch (e) {\n            return t(e);\n        }\n        return t(null);\n    }\n    let r = null;\n    const i = {\n        ...e\n    }, o = {\n        id: i.id,\n        jsonrpc: i.jsonrpc\n    };\n    try {\n        await fs(n = Oc, Sc, _c).call(n, i, o, ds(this, pc));\n    } catch (e) {\n        r = e;\n    }\n    return r && (delete o.result, o.error || (o.error = Na(r))), t(r, o);\n}, Sc = new WeakSet, _c = async function(e, t, n) {\n    var r, i, o;\n    const [s, a, c] = await fs(r = Oc, Cc, kc).call(r, e, t, n);\n    if (fs(i = Oc, Tc, Rc).call(i, e, t, a), await fs(o = Oc, Mc, Ic).call(o, c), s) throw s;\n}, Cc = new WeakSet, kc = async function(e, t, n) {\n    var r;\n    const i = [];\n    let o = null, s = !1;\n    for (const a of n)if ([o, s] = await fs(r = Oc, Ac, xc).call(r, e, t, a, i), s) break;\n    return [\n        o,\n        s,\n        i.reverse()\n    ];\n}, Ac = new WeakSet, xc = async function(e, t, n, r) {\n    return new Promise((i)=>{\n        const o = (e)=>{\n            const n = e || t.error;\n            n && (t.error = Na(n)), i([\n                n,\n                !0\n            ]);\n        }, s = (n)=>{\n            t.error ? o(t.error) : (n && (\"function\" != typeof n && o(new Ja(ps.internal, 'JsonRpcEngine: \"next\" return handlers must be functions. Received \"'.concat(typeof n, '\" for request:\\n').concat(Lc(e)), {\n                request: e\n            })), r.push(n)), i([\n                null,\n                !1\n            ]));\n        };\n        try {\n            n(e, t, s, o);\n        } catch (e) {\n            o(e);\n        }\n    });\n}, Mc = new WeakSet, Ic = async function(e) {\n    for (const t of e)await new Promise((e, n)=>{\n        t((t)=>t ? n(t) : e());\n    });\n}, Tc = new WeakSet, Rc = function(e, t, n) {\n    if (!ys(t, \"result\") && !ys(t, \"error\")) throw new Ja(ps.internal, \"JsonRpcEngine: Response has no error or result for request:\\n\".concat(Lc(e)), {\n        request: e\n    });\n    if (!n) throw new Ja(ps.internal, \"JsonRpcEngine: Nothing ended request:\\n\".concat(Lc(e)), {\n        request: e\n    });\n}, us(Oc, Sc), us(Oc, Cc), us(Oc, Ac), us(Oc, Mc), us(Oc, Tc);\nvar Nc = Oc;\nfunction Lc(e) {\n    return JSON.stringify(e, null, 2);\n}\n_c100 = Lc;\nvar Dc = Object.freeze([\n    \"eth_subscription\"\n]), $c = function() {\n    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : console;\n    return [\n        cs(),\n        Bc(e),\n        os(e)\n    ];\n};\nfunction Bc(e) {\n    return (t, n, r)=>{\n        \"string\" == typeof t.method && t.method || (n.error = Xa({\n            message: \"The request 'method' must be a non-empty string.\",\n            data: t\n        })), r((t)=>{\n            const { error: r } = n;\n            return r ? (e.error(\"MetaMask - RPC Error: \".concat(r.message), r), t()) : t();\n        });\n    };\n}\n_c101 = Bc;\nvar Kc = function(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;\n    return (r, i)=>{\n        r || i.error ? t(r || i.error) : !n || Array.isArray(i) ? e(i) : e(i.result);\n    };\n}, jc = (e)=>Boolean(e) && \"string\" == typeof e && e.startsWith(\"0x\"), Uc = ()=>{};\nasync function Hc(e, t) {\n    try {\n        const t = await async function() {\n            return {\n                name: Fc(window),\n                icon: await zc(window)\n            };\n        }();\n        e.handle({\n            jsonrpc: \"2.0\",\n            id: 1,\n            method: \"metamask_sendDomainMetadata\",\n            params: t\n        }, Uc);\n    } catch (e) {\n        t.error({\n            message: is.errors.sendSiteMetadata(),\n            originalError: e\n        });\n    }\n}\n_c102 = Hc;\nfunction Fc(e) {\n    const { document: t } = e, n = t.querySelector('head > meta[property=\"og:site_name\"]');\n    if (n) return n.content;\n    const r = t.querySelector('head > meta[name=\"title\"]');\n    return r ? r.content : t.title && t.title.length > 0 ? t.title : window.location.hostname;\n}\n_c103 = Fc;\nasync function zc(e) {\n    const { document: t } = e, n = t.querySelectorAll('head > link[rel~=\"icon\"]');\n    for (const e of Array.from(n))if (e && await qc(e.href)) return e.href;\n    return null;\n}\nasync function qc(e) {\n    return new Promise((t, n)=>{\n        try {\n            const n = document.createElement(\"img\");\n            n.onload = ()=>t(!0), n.onerror = ()=>t(!1), n.src = e;\n        } catch (e) {\n            n(e);\n        }\n    });\n}\nvar Wc = (e, t, n)=>{\n    if (!t.has(e)) throw TypeError(\"Cannot \" + n);\n}, Vc = (e, t, n)=>(Wc(e, t, \"read from private field\"), n ? n.call(e) : t.get(e)), Gc = (e, t, n)=>{\n    if (t.has(e)) throw TypeError(\"Cannot add the same private member more than once\");\n    t instanceof WeakSet ? t.add(e) : t.set(e, n);\n}, Yc = (e, t, n, r)=>(Wc(e, t, \"write to private field\"), t.set(e, n), n);\nfunction Zc(e, t, n) {\n    try {\n        Reflect.apply(e, t, n);\n    } catch (e) {\n        setTimeout(()=>{\n            throw e;\n        });\n    }\n}\n_c104 = Zc;\nclass Jc extends rc {\n    emit(e) {\n        for(var _len = arguments.length, t = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            t[_key - 1] = arguments[_key];\n        }\n        let n = \"error\" === e;\n        const r = this._events;\n        if (void 0 !== r) n = n && void 0 === r.error;\n        else if (!n) return !1;\n        if (n) {\n            let e;\n            if (t.length > 0 && ([e] = t), e instanceof Error) throw e;\n            const n = new Error(\"Unhandled error.\" + (e ? \" (\".concat(e.message, \")\") : \"\"));\n            throw n.context = e, n;\n        }\n        const i = r[e];\n        if (void 0 === i) return !1;\n        if (\"function\" == typeof i) Zc(i, this, t);\n        else {\n            const e = i.length, n = function(e) {\n                const t = e.length, n = new Array(t);\n                for(let r = 0; r < t; r += 1)n[r] = e[r];\n                return n;\n            }(i);\n            for(let r = 0; r < e; r += 1)Zc(n[r], this, t);\n        }\n        return !0;\n    }\n}\nvar Qc, Xc, el = function e(t, n) {\n    if (t === n) return !0;\n    if (t && n && \"object\" == typeof t && \"object\" == typeof n) {\n        if (t.constructor !== n.constructor) return !1;\n        var r, i, o;\n        if (Array.isArray(t)) {\n            if ((r = t.length) != n.length) return !1;\n            for(i = r; 0 != i--;)if (!e(t[i], n[i])) return !1;\n            return !0;\n        }\n        if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;\n        if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();\n        if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();\n        if ((r = (o = Object.keys(t)).length) !== Object.keys(n).length) return !1;\n        for(i = r; 0 != i--;)if (!Object.prototype.hasOwnProperty.call(n, o[i])) return !1;\n        for(i = r; 0 != i--;){\n            var s = o[i];\n            if (!e(t[s], n[s])) return !1;\n        }\n        return !0;\n    }\n    return t != t && n != n;\n}, tl = ue(el), nl = class e extends Jc {\n    get chainId() {\n        return Vc(this, Qc);\n    }\n    get selectedAddress() {\n        return Vc(this, Xc);\n    }\n    isConnected() {\n        return this._state.isConnected;\n    }\n    async request(e) {\n        if (!e || \"object\" != typeof e || Array.isArray(e)) throw Xa({\n            message: is.errors.invalidRequestArgs(),\n            data: e\n        });\n        const { method: t, params: n } = e;\n        if (\"string\" != typeof t || 0 === t.length) throw Xa({\n            message: is.errors.invalidRequestMethod(),\n            data: e\n        });\n        if (void 0 !== n && !Array.isArray(n) && (\"object\" != typeof n || null === n)) throw Xa({\n            message: is.errors.invalidRequestParams(),\n            data: e\n        });\n        const r = null == n ? {\n            method: t\n        } : {\n            method: t,\n            params: n\n        };\n        return new Promise((e, t)=>{\n            this._rpcRequest(r, Kc(e, t));\n        });\n    }\n    _initializeState(e) {\n        if (this._state.initialized) throw new Error(\"Provider already initialized.\");\n        if (e) {\n            const { accounts: t, chainId: n, isUnlocked: r, networkVersion: i } = e;\n            this._handleConnect(n), this._handleChainChanged({\n                chainId: n,\n                networkVersion: i\n            }), this._handleUnlockStateChanged({\n                accounts: t,\n                isUnlocked: r\n            }), this._handleAccountsChanged(t);\n        }\n        this._state.initialized = !0, this.emit(\"_initialized\");\n    }\n    _rpcRequest(e, t) {\n        let n = t;\n        return Array.isArray(e) || (e.jsonrpc || (e.jsonrpc = \"2.0\"), \"eth_accounts\" !== e.method && \"eth_requestAccounts\" !== e.method || (n = (n, r)=>{\n            var _r_result;\n            this._handleAccountsChanged((_r_result = r.result) !== null && _r_result !== void 0 ? _r_result : [], \"eth_accounts\" === e.method), t(n, r);\n        })), this._rpcEngine.handle(e, n);\n    }\n    _handleConnect(e) {\n        this._state.isConnected || (this._state.isConnected = !0, this.emit(\"connect\", {\n            chainId: e\n        }), this._log.debug(is.info.connected(e)));\n    }\n    _handleDisconnect(e, t) {\n        if (this._state.isConnected || !this._state.isPermanentlyDisconnected && !e) {\n            let n;\n            this._state.isConnected = !1, e ? (n = new Ja(1013, t !== null && t !== void 0 ? t : is.errors.disconnected()), this._log.debug(n)) : (n = new Ja(1011, t !== null && t !== void 0 ? t : is.errors.permanentlyDisconnected()), this._log.error(n), Yc(this, Qc, null), this._state.accounts = null, Yc(this, Xc, null), this._state.isUnlocked = !1, this._state.isPermanentlyDisconnected = !0), this.emit(\"disconnect\", n);\n        }\n    }\n    _handleChainChanged() {\n        let { chainId: e } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        jc(e) ? (this._handleConnect(e), e !== Vc(this, Qc) && (Yc(this, Qc, e), this._state.initialized && this.emit(\"chainChanged\", Vc(this, Qc)))) : this._log.error(is.errors.invalidNetworkParams(), {\n            chainId: e\n        });\n    }\n    _handleAccountsChanged(e) {\n        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;\n        let n = e;\n        Array.isArray(e) || (this._log.error(\"MetaMask: Received invalid accounts parameter. Please report this bug.\", e), n = []);\n        for (const t of e)if (\"string\" != typeof t) {\n            this._log.error(\"MetaMask: Received non-string account. Please report this bug.\", e), n = [];\n            break;\n        }\n        if (!tl(this._state.accounts, n) && (t && null !== this._state.accounts && this._log.error(\"MetaMask: 'eth_accounts' unexpectedly updated accounts. Please report this bug.\", n), this._state.accounts = n, Vc(this, Xc) !== n[0] && Yc(this, Xc, n[0] || null), this._state.initialized)) {\n            const e = [\n                ...n\n            ];\n            this.emit(\"accountsChanged\", e);\n        }\n    }\n    _handleUnlockStateChanged() {\n        let { accounts: e, isUnlocked: t } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        \"boolean\" == typeof t ? t !== this._state.isUnlocked && (this._state.isUnlocked = t, this._handleAccountsChanged(e !== null && e !== void 0 ? e : [])) : this._log.error(\"MetaMask: Received invalid isUnlocked parameter. Please report this bug.\");\n    }\n    constructor({ logger: t = console, maxEventListeners: n = 100, rpcMiddleware: r = [] } = {}){\n        super(), Gc(this, Qc, void 0), Gc(this, Xc, void 0), this._log = t, this.setMaxListeners(n), this._state = {\n            ...e._defaultState\n        }, Yc(this, Xc, null), Yc(this, Qc, null), this._handleAccountsChanged = this._handleAccountsChanged.bind(this), this._handleConnect = this._handleConnect.bind(this), this._handleChainChanged = this._handleChainChanged.bind(this), this._handleDisconnect = this._handleDisconnect.bind(this), this._handleUnlockStateChanged = this._handleUnlockStateChanged.bind(this), this._rpcRequest = this._rpcRequest.bind(this), this.request = this.request.bind(this);\n        const i = new Nc;\n        r.forEach((e)=>i.push(e)), this._rpcEngine = i;\n    }\n};\nQc = new WeakMap, Xc = new WeakMap, nl._defaultState = {\n    accounts: null,\n    isConnected: !1,\n    isUnlocked: !1,\n    initialized: !1,\n    isPermanentlyDisconnected: !1\n};\nvar rl, il = nl, ol = {\n    exports: {}\n}, sl = lc.EventEmitter, al = he(le);\nrl = \"function\" == typeof Object.create ? function(e, t) {\n    e.super_ = t, e.prototype = Object.create(t.prototype, {\n        constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n        }\n    });\n} : function(e, t) {\n    e.super_ = t;\n    var n = function() {};\n    n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e;\n};\nvar cl = Object.getOwnPropertyDescriptors || function(e) {\n    for(var t = Object.keys(e), n = {}, r = 0; r < t.length; r++)n[t[r]] = Object.getOwnPropertyDescriptor(e, t[r]);\n    return n;\n}, ll = /%[sdj%]/g;\nfunction dl(e) {\n    if (!Al(e)) {\n        for(var t = [], n = 0; n < arguments.length; n++)t.push(gl(arguments[n]));\n        return t.join(\" \");\n    }\n    n = 1;\n    for(var r = arguments, i = r.length, o = String(e).replace(ll, function(e) {\n        if (\"%%\" === e) return \"%\";\n        if (n >= i) return e;\n        switch(e){\n            case \"%s\":\n                return String(r[n++]);\n            case \"%d\":\n                return Number(r[n++]);\n            case \"%j\":\n                try {\n                    return JSON.stringify(r[n++]);\n                } catch (e) {\n                    return \"[Circular]\";\n                }\n            default:\n                return e;\n        }\n    }), s = r[n]; n < i; s = r[++n])_l(s) || !Tl(s) ? o += \" \" + s : o += \" \" + gl(s);\n    return o;\n}\nfunction ul(e, t) {\n    if (Ml(l.process)) return function() {\n        return ul(e, t).apply(this, arguments);\n    };\n    if (!0 === ua.noDeprecation) return e;\n    var n = !1;\n    return function() {\n        if (!n) {\n            if (ua.throwDeprecation) throw new Error(t);\n            ua.traceDeprecation ? console.trace(t) : console.error(t), n = !0;\n        }\n        return e.apply(this, arguments);\n    };\n}\nvar hl, fl = {};\nfunction pl(e) {\n    if (Ml(hl) && (hl = ua.env.NODE_DEBUG || \"\"), e = e.toUpperCase(), !fl[e]) if (new RegExp(\"\\\\b\" + e + \"\\\\b\", \"i\").test(hl)) {\n        fl[e] = function() {\n            var t = dl.apply(null, arguments);\n            console.error(\"%s %d: %s\", e, 0, t);\n        };\n    } else fl[e] = function() {};\n    return fl[e];\n}\nfunction gl(e, t) {\n    var n = {\n        seen: [],\n        stylize: yl\n    };\n    return arguments.length >= 3 && (n.depth = arguments[2]), arguments.length >= 4 && (n.colors = arguments[3]), Sl(t) ? n.showHidden = t : t && jl(n, t), Ml(n.showHidden) && (n.showHidden = !1), Ml(n.depth) && (n.depth = 2), Ml(n.colors) && (n.colors = !1), Ml(n.customInspect) && (n.customInspect = !0), n.colors && (n.stylize = ml), vl(n, e, n.depth);\n}\nfunction ml(e, t) {\n    var n = gl.styles[t];\n    return n ? \"\u001b[\" + gl.colors[n][0] + \"m\" + e + \"\u001b[\" + gl.colors[n][1] + \"m\" : e;\n}\nfunction yl(e, t) {\n    return e;\n}\nfunction vl(e, t, n) {\n    if (e.customInspect && t && Ol(t.inspect) && t.inspect !== gl && (!t.constructor || t.constructor.prototype !== t)) {\n        var r = t.inspect(n, e);\n        return Al(r) || (r = vl(e, r, n)), r;\n    }\n    var i = function(e, t) {\n        if (Ml(t)) return e.stylize(\"undefined\", \"undefined\");\n        if (Al(t)) {\n            var n = \"'\" + JSON.stringify(t).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n            return e.stylize(n, \"string\");\n        }\n        if (kl(t)) return e.stylize(\"\" + t, \"number\");\n        if (Sl(t)) return e.stylize(\"\" + t, \"boolean\");\n        if (_l(t)) return e.stylize(\"null\", \"null\");\n    }(e, t);\n    if (i) return i;\n    var o = Object.keys(t), s = function(e) {\n        var t = {};\n        return e.forEach(function(e, n) {\n            t[e] = !0;\n        }), t;\n    }(o);\n    if (e.showHidden && (o = Object.getOwnPropertyNames(t)), Pl(t) && (o.indexOf(\"message\") >= 0 || o.indexOf(\"description\") >= 0)) return bl(t);\n    if (0 === o.length) {\n        if (Ol(t)) {\n            var a = t.name ? \": \" + t.name : \"\";\n            return e.stylize(\"[Function\" + a + \"]\", \"special\");\n        }\n        if (Il(t)) return e.stylize(RegExp.prototype.toString.call(t), \"regexp\");\n        if (Rl(t)) return e.stylize(Date.prototype.toString.call(t), \"date\");\n        if (Pl(t)) return bl(t);\n    }\n    var c, l = \"\", d = !1, u = [\n        \"{\",\n        \"}\"\n    ];\n    (El(t) && (d = !0, u = [\n        \"[\",\n        \"]\"\n    ]), Ol(t)) && (l = \" [Function\" + (t.name ? \": \" + t.name : \"\") + \"]\");\n    return Il(t) && (l = \" \" + RegExp.prototype.toString.call(t)), Rl(t) && (l = \" \" + Date.prototype.toUTCString.call(t)), Pl(t) && (l = \" \" + bl(t)), 0 !== o.length || d && 0 != t.length ? n < 0 ? Il(t) ? e.stylize(RegExp.prototype.toString.call(t), \"regexp\") : e.stylize(\"[Object]\", \"special\") : (e.seen.push(t), c = d ? function(e, t, n, r, i) {\n        for(var o = [], s = 0, a = t.length; s < a; ++s)Ul(t, String(s)) ? o.push(wl(e, t, n, r, String(s), !0)) : o.push(\"\");\n        return i.forEach(function(i) {\n            i.match(/^\\d+$/) || o.push(wl(e, t, n, r, i, !0));\n        }), o;\n    }(e, t, n, s, o) : o.map(function(r) {\n        return wl(e, t, n, s, r, d);\n    }), e.seen.pop(), function(e, t, n) {\n        var r = e.reduce(function(e, t) {\n            return t.indexOf(\"\\n\"), e + t.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1;\n        }, 0);\n        if (r > 60) return n[0] + (\"\" === t ? \"\" : t + \"\\n \") + \" \" + e.join(\",\\n  \") + \" \" + n[1];\n        return n[0] + t + \" \" + e.join(\", \") + \" \" + n[1];\n    }(c, l, u)) : u[0] + l + u[1];\n}\nfunction bl(e) {\n    return \"[\" + Error.prototype.toString.call(e) + \"]\";\n}\nfunction wl(e, t, n, r, i, o) {\n    var s, a, c;\n    if ((c = Object.getOwnPropertyDescriptor(t, i) || {\n        value: t[i]\n    }).get ? a = c.set ? e.stylize(\"[Getter/Setter]\", \"special\") : e.stylize(\"[Getter]\", \"special\") : c.set && (a = e.stylize(\"[Setter]\", \"special\")), Ul(r, i) || (s = \"[\" + i + \"]\"), a || (e.seen.indexOf(c.value) < 0 ? (a = _l(n) ? vl(e, c.value, null) : vl(e, c.value, n - 1)).indexOf(\"\\n\") > -1 && (a = o ? a.split(\"\\n\").map(function(e) {\n        return \"  \" + e;\n    }).join(\"\\n\").substr(2) : \"\\n\" + a.split(\"\\n\").map(function(e) {\n        return \"   \" + e;\n    }).join(\"\\n\")) : a = e.stylize(\"[Circular]\", \"special\")), Ml(s)) {\n        if (o && i.match(/^\\d+$/)) return a;\n        (s = JSON.stringify(\"\" + i)).match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/) ? (s = s.substr(1, s.length - 2), s = e.stylize(s, \"name\")) : (s = s.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\"), s = e.stylize(s, \"string\"));\n    }\n    return s + \": \" + a;\n}\nfunction El(e) {\n    return Array.isArray(e);\n}\n_c105 = El;\nfunction Sl(e) {\n    return \"boolean\" == typeof e;\n}\n_c106 = Sl;\nfunction _l(e) {\n    return null === e;\n}\nfunction Cl(e) {\n    return null == e;\n}\n_c107 = Cl;\nfunction kl(e) {\n    return \"number\" == typeof e;\n}\nfunction Al(e) {\n    return \"string\" == typeof e;\n}\n_c108 = Al;\nfunction xl(e) {\n    return \"symbol\" == typeof e;\n}\nfunction Ml(e) {\n    return void 0 === e;\n}\n_c109 = Ml;\nfunction Il(e) {\n    return Tl(e) && \"[object RegExp]\" === Dl(e);\n}\n_c110 = Il;\nfunction Tl(e) {\n    return \"object\" == typeof e && null !== e;\n}\n_c111 = Tl;\nfunction Rl(e) {\n    return Tl(e) && \"[object Date]\" === Dl(e);\n}\n_c112 = Rl;\nfunction Pl(e) {\n    return Tl(e) && (\"[object Error]\" === Dl(e) || e instanceof Error);\n}\n_c113 = Pl;\nfunction Ol(e) {\n    return \"function\" == typeof e;\n}\n_c114 = Ol;\nfunction Nl(e) {\n    return null === e || \"boolean\" == typeof e || \"number\" == typeof e || \"string\" == typeof e || \"symbol\" == typeof e || void 0 === e;\n}\n_c115 = Nl;\nfunction Ll(e) {\n    return C.isBuffer(e);\n}\n_c116 = Ll;\nfunction Dl(e) {\n    return Object.prototype.toString.call(e);\n}\n_c117 = Dl;\nfunction $l(e) {\n    return e < 10 ? \"0\" + e.toString(10) : e.toString(10);\n}\ngl.colors = {\n    bold: [\n        1,\n        22\n    ],\n    italic: [\n        3,\n        23\n    ],\n    underline: [\n        4,\n        24\n    ],\n    inverse: [\n        7,\n        27\n    ],\n    white: [\n        37,\n        39\n    ],\n    grey: [\n        90,\n        39\n    ],\n    black: [\n        30,\n        39\n    ],\n    blue: [\n        34,\n        39\n    ],\n    cyan: [\n        36,\n        39\n    ],\n    green: [\n        32,\n        39\n    ],\n    magenta: [\n        35,\n        39\n    ],\n    red: [\n        31,\n        39\n    ],\n    yellow: [\n        33,\n        39\n    ]\n}, gl.styles = {\n    special: \"cyan\",\n    number: \"yellow\",\n    boolean: \"yellow\",\n    undefined: \"grey\",\n    null: \"bold\",\n    string: \"green\",\n    date: \"magenta\",\n    regexp: \"red\"\n};\nvar Bl = [\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\"\n];\nfunction Kl() {\n    var e, t;\n    console.log(\"%s - %s\", (e = new Date, t = [\n        $l(e.getHours()),\n        $l(e.getMinutes()),\n        $l(e.getSeconds())\n    ].join(\":\"), [\n        e.getDate(),\n        Bl[e.getMonth()],\n        t\n    ].join(\" \")), dl.apply(null, arguments));\n}\n_c118 = Kl;\nfunction jl(e, t) {\n    if (!t || !Tl(t)) return e;\n    for(var n = Object.keys(t), r = n.length; r--;)e[n[r]] = t[n[r]];\n    return e;\n}\nfunction Ul(e, t) {\n    return Object.prototype.hasOwnProperty.call(e, t);\n}\n_c119 = Ul;\nvar Hl = \"undefined\" != typeof Symbol ? Symbol(\"util.promisify.custom\") : void 0;\nfunction Fl(e) {\n    if (\"function\" != typeof e) throw new TypeError('The \"original\" argument must be of type Function');\n    if (Hl && e[Hl]) {\n        var t;\n        if (\"function\" != typeof (t = e[Hl])) throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n        return Object.defineProperty(t, Hl, {\n            value: t,\n            enumerable: !1,\n            writable: !1,\n            configurable: !0\n        }), t;\n    }\n    function t() {\n        for(var t, n, r = new Promise(function(e, r) {\n            t = e, n = r;\n        }), i = [], o = 0; o < arguments.length; o++)i.push(arguments[o]);\n        i.push(function(e, r) {\n            e ? n(e) : t(r);\n        });\n        try {\n            e.apply(this, i);\n        } catch (e) {\n            n(e);\n        }\n        return r;\n    }\n    return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), Hl && Object.defineProperty(t, Hl, {\n        value: t,\n        enumerable: !1,\n        writable: !1,\n        configurable: !0\n    }), Object.defineProperties(t, cl(e));\n}\n_c120 = Fl;\nfunction zl(e, t) {\n    if (!e) {\n        var n = new Error(\"Promise was rejected with a falsy value\");\n        n.reason = e, e = n;\n    }\n    return t(e);\n}\nfunction ql(e) {\n    if (\"function\" != typeof e) throw new TypeError('The \"original\" argument must be of type Function');\n    function t() {\n        for(var t = [], n = 0; n < arguments.length; n++)t.push(arguments[n]);\n        var r = t.pop();\n        if (\"function\" != typeof r) throw new TypeError(\"The last argument must be of type Function\");\n        var i = this, o = function() {\n            return r.apply(i, arguments);\n        };\n        e.apply(this, t).then(function(e) {\n            ua.nextTick(o.bind(null, null, e));\n        }, function(e) {\n            ua.nextTick(zl.bind(null, e, o));\n        });\n    }\n    return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), Object.defineProperties(t, cl(e)), t;\n}\nFl.custom = Hl;\nvar Wl, Vl, Gl = {\n    inherits: rl,\n    _extend: jl,\n    log: Kl,\n    isBuffer: Ll,\n    isPrimitive: Nl,\n    isFunction: Ol,\n    isError: Pl,\n    isDate: Rl,\n    isObject: Tl,\n    isRegExp: Il,\n    isUndefined: Ml,\n    isSymbol: xl,\n    isString: Al,\n    isNumber: kl,\n    isNullOrUndefined: Cl,\n    isNull: _l,\n    isBoolean: Sl,\n    isArray: El,\n    inspect: gl,\n    deprecate: ul,\n    format: dl,\n    debuglog: pl,\n    promisify: Fl,\n    callbackify: ql\n}, Yl = he(Object.freeze({\n    __proto__: null,\n    _extend: jl,\n    callbackify: ql,\n    debuglog: pl,\n    default: Gl,\n    deprecate: ul,\n    format: dl,\n    inherits: rl,\n    inspect: gl,\n    isArray: El,\n    isBoolean: Sl,\n    isBuffer: Ll,\n    isDate: Rl,\n    isError: Pl,\n    isFunction: Ol,\n    isNull: _l,\n    isNullOrUndefined: Cl,\n    isNumber: kl,\n    isObject: Tl,\n    isPrimitive: Nl,\n    isRegExp: Il,\n    isString: Al,\n    isSymbol: xl,\n    isUndefined: Ml,\n    log: Kl,\n    promisify: Fl\n}));\nfunction Zl() {\n    if (Vl) return Wl;\n    function e(e, t) {\n        var n = Object.keys(e);\n        if (Object.getOwnPropertySymbols) {\n            var r = Object.getOwnPropertySymbols(e);\n            t && (r = r.filter(function(t) {\n                return Object.getOwnPropertyDescriptor(e, t).enumerable;\n            })), n.push.apply(n, r);\n        }\n        return n;\n    }\n    function t(t) {\n        for(var r = 1; r < arguments.length; r++){\n            var i = null != arguments[r] ? arguments[r] : {};\n            r % 2 ? e(Object(i), !0).forEach(function(e) {\n                n(t, e, i[e]);\n            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : e(Object(i)).forEach(function(e) {\n                Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e));\n            });\n        }\n        return t;\n    }\n    function n(e, t, n) {\n        return (t = i(t)) in e ? Object.defineProperty(e, t, {\n            value: n,\n            enumerable: !0,\n            configurable: !0,\n            writable: !0\n        }) : e[t] = n, e;\n    }\n    function r(e, t, n) {\n        return t && function(e, t) {\n            for(var n = 0; n < t.length; n++){\n                var r = t[n];\n                r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, i(r.key), r);\n            }\n        }(e.prototype, t), Object.defineProperty(e, \"prototype\", {\n            writable: !1\n        }), e;\n    }\n    function i(e) {\n        var t = function(e, t) {\n            if (\"object\" != typeof e || null === e) return e;\n            var n = e[Symbol.toPrimitive];\n            if (void 0 !== n) {\n                var r = n.call(e, t || \"default\");\n                if (\"object\" != typeof r) return r;\n                throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n            }\n            return (\"string\" === t ? String : Number)(e);\n        }(e, \"string\");\n        return \"symbol\" == typeof t ? t : String(t);\n    }\n    Vl = 1;\n    var o = al.Buffer, s = Yl.inspect, a = s && s.custom || \"inspect\";\n    return Wl = function() {\n        function e() {\n            !function(e, t) {\n                if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n            }(this, e), this.head = null, this.tail = null, this.length = 0;\n        }\n        return r(e, [\n            {\n                key: \"push\",\n                value: function(e) {\n                    var t = {\n                        data: e,\n                        next: null\n                    };\n                    this.length > 0 ? this.tail.next = t : this.head = t, this.tail = t, ++this.length;\n                }\n            },\n            {\n                key: \"unshift\",\n                value: function(e) {\n                    var t = {\n                        data: e,\n                        next: this.head\n                    };\n                    0 === this.length && (this.tail = t), this.head = t, ++this.length;\n                }\n            },\n            {\n                key: \"shift\",\n                value: function() {\n                    if (0 !== this.length) {\n                        var e = this.head.data;\n                        return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e;\n                    }\n                }\n            },\n            {\n                key: \"clear\",\n                value: function() {\n                    this.head = this.tail = null, this.length = 0;\n                }\n            },\n            {\n                key: \"join\",\n                value: function(e) {\n                    if (0 === this.length) return \"\";\n                    for(var t = this.head, n = \"\" + t.data; t = t.next;)n += e + t.data;\n                    return n;\n                }\n            },\n            {\n                key: \"concat\",\n                value: function(e) {\n                    if (0 === this.length) return o.alloc(0);\n                    for(var t, n, r, i = o.allocUnsafe(e >>> 0), s = this.head, a = 0; s;)t = s.data, n = i, r = a, o.prototype.copy.call(t, n, r), a += s.data.length, s = s.next;\n                    return i;\n                }\n            },\n            {\n                key: \"consume\",\n                value: function(e, t) {\n                    var n;\n                    return e < this.head.data.length ? (n = this.head.data.slice(0, e), this.head.data = this.head.data.slice(e)) : n = e === this.head.data.length ? this.shift() : t ? this._getString(e) : this._getBuffer(e), n;\n                }\n            },\n            {\n                key: \"first\",\n                value: function() {\n                    return this.head.data;\n                }\n            },\n            {\n                key: \"_getString\",\n                value: function(e) {\n                    var t = this.head, n = 1, r = t.data;\n                    for(e -= r.length; t = t.next;){\n                        var i = t.data, o = e > i.length ? i.length : e;\n                        if (o === i.length ? r += i : r += i.slice(0, e), 0 === (e -= o)) {\n                            o === i.length ? (++n, t.next ? this.head = t.next : this.head = this.tail = null) : (this.head = t, t.data = i.slice(o));\n                            break;\n                        }\n                        ++n;\n                    }\n                    return this.length -= n, r;\n                }\n            },\n            {\n                key: \"_getBuffer\",\n                value: function(e) {\n                    var t = o.allocUnsafe(e), n = this.head, r = 1;\n                    for(n.data.copy(t), e -= n.data.length; n = n.next;){\n                        var i = n.data, s = e > i.length ? i.length : e;\n                        if (i.copy(t, t.length - e, 0, s), 0 === (e -= s)) {\n                            s === i.length ? (++r, n.next ? this.head = n.next : this.head = this.tail = null) : (this.head = n, n.data = i.slice(s));\n                            break;\n                        }\n                        ++r;\n                    }\n                    return this.length -= r, t;\n                }\n            },\n            {\n                key: a,\n                value: function(e, n) {\n                    return s(this, t(t({}, n), {}, {\n                        depth: 0,\n                        customInspect: !1\n                    }));\n                }\n            }\n        ]), e;\n    }(), Wl;\n}\n_c121 = Zl;\nfunction Jl(e, t) {\n    Xl(e, t), Ql(e);\n}\n_c122 = Jl;\nfunction Ql(e) {\n    e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit(\"close\");\n}\n_c123 = Ql;\nfunction Xl(e, t) {\n    e.emit(\"error\", t);\n}\n_c124 = Xl;\nvar ed = {\n    destroy: function(e, t) {\n        var n = this, r = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;\n        return r || i ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, ua.nextTick(Xl, this, e)) : ua.nextTick(Xl, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(e) {\n            !t && e ? n._writableState ? n._writableState.errorEmitted ? ua.nextTick(Ql, n) : (n._writableState.errorEmitted = !0, ua.nextTick(Jl, n, e)) : ua.nextTick(Jl, n, e) : t ? (ua.nextTick(Ql, n), t(e)) : ua.nextTick(Ql, n);\n        }), this);\n    },\n    undestroy: function() {\n        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);\n    },\n    errorOrDestroy: function(e, t) {\n        var n = e._readableState, r = e._writableState;\n        n && n.autoDestroy || r && r.autoDestroy ? e.destroy(t) : e.emit(\"error\", t);\n    }\n}, td = {};\nvar nd = {};\nfunction rd(e, t, n) {\n    n || (n = Error);\n    var r = function(e) {\n        var n, r;\n        function i(n, r, i) {\n            return e.call(this, function(e, n, r) {\n                return \"string\" == typeof t ? t : t(e, n, r);\n            }(n, r, i)) || this;\n        }\n        return r = e, (n = i).prototype = Object.create(r.prototype), n.prototype.constructor = n, n.__proto__ = r, i;\n    }(n);\n    r.prototype.name = n.name, r.prototype.code = e, nd[e] = r;\n}\nfunction id(e, t) {\n    if (Array.isArray(e)) {\n        var n = e.length;\n        return e = e.map(function(e) {\n            return String(e);\n        }), n > 2 ? \"one of \".concat(t, \" \").concat(e.slice(0, n - 1).join(\", \"), \", or \") + e[n - 1] : 2 === n ? \"one of \".concat(t, \" \").concat(e[0], \" or \").concat(e[1]) : \"of \".concat(t, \" \").concat(e[0]);\n    }\n    return \"of \".concat(t, \" \").concat(String(e));\n}\nrd(\"ERR_INVALID_OPT_VALUE\", function(e, t) {\n    return 'The value \"' + t + '\" is invalid for option \"' + e + '\"';\n}, TypeError), rd(\"ERR_INVALID_ARG_TYPE\", function(e, t, n) {\n    var r, i, o;\n    if (\"string\" == typeof t && (i = \"not \", t.substr(0, i.length) === i) ? (r = \"must not be\", t = t.replace(/^not /, \"\")) : r = \"must be\", function(e, t, n) {\n        return (void 0 === n || n > e.length) && (n = e.length), e.substring(n - t.length, n) === t;\n    }(e, \" argument\")) o = \"The \".concat(e, \" \").concat(r, \" \").concat(id(t, \"type\"));\n    else {\n        var s = function(e, t, n) {\n            return \"number\" != typeof n && (n = 0), !(n + t.length > e.length) && -1 !== e.indexOf(t, n);\n        }(e, \".\") ? \"property\" : \"argument\";\n        o = 'The \"'.concat(e, '\" ').concat(s, \" \").concat(r, \" \").concat(id(t, \"type\"));\n    }\n    return o += \". Received type \".concat(typeof n);\n}, TypeError), rd(\"ERR_STREAM_PUSH_AFTER_EOF\", \"stream.push() after EOF\"), rd(\"ERR_METHOD_NOT_IMPLEMENTED\", function(e) {\n    return \"The \" + e + \" method is not implemented\";\n}), rd(\"ERR_STREAM_PREMATURE_CLOSE\", \"Premature close\"), rd(\"ERR_STREAM_DESTROYED\", function(e) {\n    return \"Cannot call \" + e + \" after a stream was destroyed\";\n}), rd(\"ERR_MULTIPLE_CALLBACK\", \"Callback called multiple times\"), rd(\"ERR_STREAM_CANNOT_PIPE\", \"Cannot pipe, not readable\"), rd(\"ERR_STREAM_WRITE_AFTER_END\", \"write after end\"), rd(\"ERR_STREAM_NULL_VALUES\", \"May not write null values to stream\", TypeError), rd(\"ERR_UNKNOWN_ENCODING\", function(e) {\n    return \"Unknown encoding: \" + e;\n}, TypeError), rd(\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\", \"stream.unshift() after end event\"), td.codes = nd;\nvar od = td.codes.ERR_INVALID_OPT_VALUE;\nvar sd, ad, cd, ld, dd = {\n    getHighWaterMark: function(e, t, n, r) {\n        var i = function(e, t, n) {\n            return null != e.highWaterMark ? e.highWaterMark : t ? e[n] : null;\n        }(t, r, n);\n        if (null != i) {\n            if (!isFinite(i) || Math.floor(i) !== i || i < 0) throw new od(r ? n : \"highWaterMark\", i);\n            return Math.floor(i);\n        }\n        return e.objectMode ? 16 : 16384;\n    }\n}, ud = \"function\" == typeof Object.create ? function(e, t) {\n    e.super_ = t, e.prototype = Object.create(t.prototype, {\n        constructor: {\n            value: e,\n            enumerable: !1,\n            writable: !0,\n            configurable: !0\n        }\n    });\n} : function(e, t) {\n    e.super_ = t;\n    var n = function() {};\n    n.prototype = t.prototype, e.prototype = new n, e.prototype.constructor = e;\n}, hd = he(Object.freeze({\n    __proto__: null,\n    default: ud\n})), fd = function(e, t) {\n    if (pd(\"noDeprecation\")) return e;\n    var n = !1;\n    return function() {\n        if (!n) {\n            if (pd(\"throwDeprecation\")) throw new Error(t);\n            pd(\"traceDeprecation\") ? console.trace(t) : console.warn(t), n = !0;\n        }\n        return e.apply(this, arguments);\n    };\n};\nfunction pd(e) {\n    try {\n        if (!de.localStorage) return !1;\n    } catch (e) {\n        return !1;\n    }\n    var t = de.localStorage[e];\n    return null != t && \"true\" === String(t).toLowerCase();\n}\nfunction gd() {\n    if (ad) return sd;\n    function e(e) {\n        var t = this;\n        this.next = null, this.entry = null, this.finish = function() {\n            !function(e, t, n) {\n                var r = e.entry;\n                e.entry = null;\n                for(; r;){\n                    var i = r.callback;\n                    t.pendingcb--, i(n), r = r.next;\n                }\n                t.corkedRequestsFree.next = e;\n            }(t, e);\n        };\n    }\n    var t;\n    ad = 1, sd = E, E.WritableState = w;\n    var n = {\n        deprecate: fd\n    }, r = sl, i = al.Buffer, o = (void 0 !== de ? de :  true ? window : 0).Uint8Array || function() {};\n    var s, a = ed, c = dd.getHighWaterMark, l = td.codes, d = l.ERR_INVALID_ARG_TYPE, u = l.ERR_METHOD_NOT_IMPLEMENTED, h = l.ERR_MULTIPLE_CALLBACK, f = l.ERR_STREAM_CANNOT_PIPE, p = l.ERR_STREAM_DESTROYED, g = l.ERR_STREAM_NULL_VALUES, m = l.ERR_STREAM_WRITE_AFTER_END, y = l.ERR_UNKNOWN_ENCODING, v = a.errorOrDestroy;\n    function b() {}\n    function w(n, r, i) {\n        t = t || md(), n = n || {}, \"boolean\" != typeof i && (i = r instanceof t), this.objectMode = !!n.objectMode, i && (this.objectMode = this.objectMode || !!n.writableObjectMode), this.highWaterMark = c(this, n, \"writableHighWaterMark\", i), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;\n        var o = !1 === n.decodeStrings;\n        this.decodeStrings = !o, this.defaultEncoding = n.defaultEncoding || \"utf8\", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(e) {\n            !function(e, t) {\n                var n = e._writableState, r = n.sync, i = n.writecb;\n                if (\"function\" != typeof i) throw new h;\n                if (function(e) {\n                    e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0;\n                }(n), t) !function(e, t, n, r, i) {\n                    --t.pendingcb, n ? (ua.nextTick(i, r), ua.nextTick(x, e, t), e._writableState.errorEmitted = !0, v(e, r)) : (i(r), e._writableState.errorEmitted = !0, v(e, r), x(e, t));\n                }(e, n, r, t, i);\n                else {\n                    var o = k(n) || e.destroyed;\n                    o || n.corked || n.bufferProcessing || !n.bufferedRequest || C(e, n), r ? ua.nextTick(_, e, n, o, i) : _(e, n, o, i);\n                }\n            }(r, e);\n        }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== n.emitClose, this.autoDestroy = !!n.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);\n    }\n    function E(e) {\n        var n = this instanceof (t = t || md());\n        if (!n && !s.call(E, this)) return new E(e);\n        this._writableState = new w(e, this, n), this.writable = !0, e && (\"function\" == typeof e.write && (this._write = e.write), \"function\" == typeof e.writev && (this._writev = e.writev), \"function\" == typeof e.destroy && (this._destroy = e.destroy), \"function\" == typeof e.final && (this._final = e.final)), r.call(this);\n    }\n    function S(e, t, n, r, i, o, s) {\n        t.writelen = r, t.writecb = s, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new p(\"write\")) : n ? e._writev(i, t.onwrite) : e._write(i, o, t.onwrite), t.sync = !1;\n    }\n    function _(e, t, n, r) {\n        n || function(e, t) {\n            0 === t.length && t.needDrain && (t.needDrain = !1, e.emit(\"drain\"));\n        }(e, t), t.pendingcb--, r(), x(e, t);\n    }\n    function C(t, n) {\n        n.bufferProcessing = !0;\n        var r = n.bufferedRequest;\n        if (t._writev && r && r.next) {\n            var i = n.bufferedRequestCount, o = new Array(i), s = n.corkedRequestsFree;\n            s.entry = r;\n            for(var a = 0, c = !0; r;)o[a] = r, r.isBuf || (c = !1), r = r.next, a += 1;\n            o.allBuffers = c, S(t, n, !0, n.length, o, \"\", s.finish), n.pendingcb++, n.lastBufferedRequest = null, s.next ? (n.corkedRequestsFree = s.next, s.next = null) : n.corkedRequestsFree = new e(n), n.bufferedRequestCount = 0;\n        } else {\n            for(; r;){\n                var l = r.chunk, d = r.encoding, u = r.callback;\n                if (S(t, n, !1, n.objectMode ? 1 : l.length, l, d, u), r = r.next, n.bufferedRequestCount--, n.writing) break;\n            }\n            null === r && (n.lastBufferedRequest = null);\n        }\n        n.bufferedRequest = r, n.bufferProcessing = !1;\n    }\n    function k(e) {\n        return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing;\n    }\n    function A(e, t) {\n        e._final(function(n) {\n            t.pendingcb--, n && v(e, n), t.prefinished = !0, e.emit(\"prefinish\"), x(e, t);\n        });\n    }\n    function x(e, t) {\n        var n = k(t);\n        if (n && (function(e, t) {\n            t.prefinished || t.finalCalled || (\"function\" != typeof e._final || t.destroyed ? (t.prefinished = !0, e.emit(\"prefinish\")) : (t.pendingcb++, t.finalCalled = !0, ua.nextTick(A, e, t)));\n        }(e, t), 0 === t.pendingcb && (t.finished = !0, e.emit(\"finish\"), t.autoDestroy))) {\n            var r = e._readableState;\n            (!r || r.autoDestroy && r.endEmitted) && e.destroy();\n        }\n        return n;\n    }\n    return hd(E, r), w.prototype.getBuffer = function() {\n        for(var e = this.bufferedRequest, t = []; e;)t.push(e), e = e.next;\n        return t;\n    }, function() {\n        try {\n            Object.defineProperty(w.prototype, \"buffer\", {\n                get: n.deprecate(function() {\n                    return this.getBuffer();\n                }, \"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.\", \"DEP0003\")\n            });\n        } catch (e) {}\n    }(), \"function\" == typeof Symbol && Symbol.hasInstance && \"function\" == typeof Function.prototype[Symbol.hasInstance] ? (s = Function.prototype[Symbol.hasInstance], Object.defineProperty(E, Symbol.hasInstance, {\n        value: function(e) {\n            return !!s.call(this, e) || this === E && e && e._writableState instanceof w;\n        }\n    })) : s = function(e) {\n        return e instanceof this;\n    }, E.prototype.pipe = function() {\n        v(this, new f);\n    }, E.prototype.write = function(e, t, n) {\n        var r, s = this._writableState, a = !1, c = !s.objectMode && (r = e, i.isBuffer(r) || r instanceof o);\n        return c && !i.isBuffer(e) && (e = function(e) {\n            return i.from(e);\n        }(e)), \"function\" == typeof t && (n = t, t = null), c ? t = \"buffer\" : t || (t = s.defaultEncoding), \"function\" != typeof n && (n = b), s.ending ? function(e, t) {\n            var n = new m;\n            v(e, n), ua.nextTick(t, n);\n        }(this, n) : (c || function(e, t, n, r) {\n            var i;\n            return null === n ? i = new g : \"string\" == typeof n || t.objectMode || (i = new d(\"chunk\", [\n                \"string\",\n                \"Buffer\"\n            ], n)), !i || (v(e, i), ua.nextTick(r, i), !1);\n        }(this, s, e, n)) && (s.pendingcb++, a = function(e, t, n, r, o, s) {\n            if (!n) {\n                var a = function(e, t, n) {\n                    e.objectMode || !1 === e.decodeStrings || \"string\" != typeof t || (t = i.from(t, n));\n                    return t;\n                }(t, r, o);\n                r !== a && (n = !0, o = \"buffer\", r = a);\n            }\n            var c = t.objectMode ? 1 : r.length;\n            t.length += c;\n            var l = t.length < t.highWaterMark;\n            l || (t.needDrain = !0);\n            if (t.writing || t.corked) {\n                var d = t.lastBufferedRequest;\n                t.lastBufferedRequest = {\n                    chunk: r,\n                    encoding: o,\n                    isBuf: n,\n                    callback: s,\n                    next: null\n                }, d ? d.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1;\n            } else S(e, t, !1, c, r, o, s);\n            return l;\n        }(this, s, c, e, t, n)), a;\n    }, E.prototype.cork = function() {\n        this._writableState.corked++;\n    }, E.prototype.uncork = function() {\n        var e = this._writableState;\n        e.corked && (e.corked--, e.writing || e.corked || e.bufferProcessing || !e.bufferedRequest || C(this, e));\n    }, E.prototype.setDefaultEncoding = function(e) {\n        if (\"string\" == typeof e && (e = e.toLowerCase()), !([\n            \"hex\",\n            \"utf8\",\n            \"utf-8\",\n            \"ascii\",\n            \"binary\",\n            \"base64\",\n            \"ucs2\",\n            \"ucs-2\",\n            \"utf16le\",\n            \"utf-16le\",\n            \"raw\"\n        ].indexOf((e + \"\").toLowerCase()) > -1)) throw new y(e);\n        return this._writableState.defaultEncoding = e, this;\n    }, Object.defineProperty(E.prototype, \"writableBuffer\", {\n        enumerable: !1,\n        get: function() {\n            return this._writableState && this._writableState.getBuffer();\n        }\n    }), Object.defineProperty(E.prototype, \"writableHighWaterMark\", {\n        enumerable: !1,\n        get: function() {\n            return this._writableState.highWaterMark;\n        }\n    }), E.prototype._write = function(e, t, n) {\n        n(new u(\"_write()\"));\n    }, E.prototype._writev = null, E.prototype.end = function(e, t, n) {\n        var r = this._writableState;\n        return \"function\" == typeof e ? (n = e, e = null, t = null) : \"function\" == typeof t && (n = t, t = null), null != e && this.write(e, t), r.corked && (r.corked = 1, this.uncork()), r.ending || function(e, t, n) {\n            t.ending = !0, x(e, t), n && (t.finished ? ua.nextTick(n) : e.once(\"finish\", n));\n            t.ended = !0, e.writable = !1;\n        }(this, r, n), this;\n    }, Object.defineProperty(E.prototype, \"writableLength\", {\n        enumerable: !1,\n        get: function() {\n            return this._writableState.length;\n        }\n    }), Object.defineProperty(E.prototype, \"destroyed\", {\n        enumerable: !1,\n        get: function() {\n            return void 0 !== this._writableState && this._writableState.destroyed;\n        },\n        set: function(e) {\n            this._writableState && (this._writableState.destroyed = e);\n        }\n    }), E.prototype.destroy = a.destroy, E.prototype._undestroy = a.undestroy, E.prototype._destroy = function(e, t) {\n        t(e);\n    }, sd;\n}\nfunction md() {\n    if (ld) return cd;\n    ld = 1;\n    var e = Object.keys || function(e) {\n        var t = [];\n        for(var n in e)t.push(n);\n        return t;\n    };\n    cd = s;\n    var t = Od(), n = gd();\n    hd(s, t);\n    for(var r = e(n.prototype), i = 0; i < r.length; i++){\n        var o = r[i];\n        s.prototype[o] || (s.prototype[o] = n.prototype[o]);\n    }\n    function s(e) {\n        if (!(this instanceof s)) return new s(e);\n        t.call(this, e), n.call(this, e), this.allowHalfOpen = !0, e && (!1 === e.readable && (this.readable = !1), !1 === e.writable && (this.writable = !1), !1 === e.allowHalfOpen && (this.allowHalfOpen = !1, this.once(\"end\", a)));\n    }\n    function a() {\n        this._writableState.ended || ua.nextTick(c, this);\n    }\n    function c(e) {\n        e.end();\n    }\n    return Object.defineProperty(s.prototype, \"writableHighWaterMark\", {\n        enumerable: !1,\n        get: function() {\n            return this._writableState.highWaterMark;\n        }\n    }), Object.defineProperty(s.prototype, \"writableBuffer\", {\n        enumerable: !1,\n        get: function() {\n            return this._writableState && this._writableState.getBuffer();\n        }\n    }), Object.defineProperty(s.prototype, \"writableLength\", {\n        enumerable: !1,\n        get: function() {\n            return this._writableState.length;\n        }\n    }), Object.defineProperty(s.prototype, \"destroyed\", {\n        enumerable: !1,\n        get: function() {\n            return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;\n        },\n        set: function(e) {\n            void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e);\n        }\n    }), cd;\n}\nvar yd = C.isEncoding || function(e) {\n    switch(e && e.toLowerCase()){\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n        case \"raw\":\n            return !0;\n        default:\n            return !1;\n    }\n};\nfunction vd(e) {\n    switch(this.encoding = (e || \"utf8\").toLowerCase().replace(/[-_]/, \"\"), function(e) {\n        if (e && !yd(e)) throw new Error(\"Unknown encoding: \" + e);\n    }(e), this.encoding){\n        case \"utf8\":\n            this.surrogateSize = 3;\n            break;\n        case \"ucs2\":\n        case \"utf16le\":\n            this.surrogateSize = 2, this.detectIncompleteChar = wd;\n            break;\n        case \"base64\":\n            this.surrogateSize = 3, this.detectIncompleteChar = Ed;\n            break;\n        default:\n            return void (this.write = bd);\n    }\n    this.charBuffer = new C(6), this.charReceived = 0, this.charLength = 0;\n}\nfunction bd(e) {\n    return e.toString(this.encoding);\n}\nfunction wd(e) {\n    this.charReceived = e.length % 2, this.charLength = this.charReceived ? 2 : 0;\n}\nfunction Ed(e) {\n    this.charReceived = e.length % 3, this.charLength = this.charReceived ? 3 : 0;\n}\n_c125 = Ed;\nvd.prototype.write = function(e) {\n    for(var t = \"\"; this.charLength;){\n        var n = e.length >= this.charLength - this.charReceived ? this.charLength - this.charReceived : e.length;\n        if (e.copy(this.charBuffer, this.charReceived, 0, n), this.charReceived += n, this.charReceived < this.charLength) return \"\";\n        if (e = e.slice(n, e.length), !((i = (t = this.charBuffer.slice(0, this.charLength).toString(this.encoding)).charCodeAt(t.length - 1)) >= 55296 && i <= 56319)) {\n            if (this.charReceived = this.charLength = 0, 0 === e.length) return t;\n            break;\n        }\n        this.charLength += this.surrogateSize, t = \"\";\n    }\n    this.detectIncompleteChar(e);\n    var r = e.length;\n    this.charLength && (e.copy(this.charBuffer, 0, e.length - this.charReceived, r), r -= this.charReceived);\n    var i;\n    r = (t += e.toString(this.encoding, 0, r)).length - 1;\n    if ((i = t.charCodeAt(r)) >= 55296 && i <= 56319) {\n        var o = this.surrogateSize;\n        return this.charLength += o, this.charReceived += o, this.charBuffer.copy(this.charBuffer, o, 0, o), e.copy(this.charBuffer, 0, 0, o), t.substring(0, r);\n    }\n    return t;\n}, vd.prototype.detectIncompleteChar = function(e) {\n    for(var t = e.length >= 3 ? 3 : e.length; t > 0; t--){\n        var n = e[e.length - t];\n        if (1 == t && n >> 5 == 6) {\n            this.charLength = 2;\n            break;\n        }\n        if (t <= 2 && n >> 4 == 14) {\n            this.charLength = 3;\n            break;\n        }\n        if (t <= 3 && n >> 3 == 30) {\n            this.charLength = 4;\n            break;\n        }\n    }\n    this.charReceived = t;\n}, vd.prototype.end = function(e) {\n    var t = \"\";\n    if (e && e.length && (t = this.write(e)), this.charReceived) {\n        var n = this.charReceived, r = this.charBuffer, i = this.encoding;\n        t += r.slice(0, n).toString(i);\n    }\n    return t;\n};\nvar Sd = he(Object.freeze({\n    __proto__: null,\n    StringDecoder: vd\n})), _d = td.codes.ERR_STREAM_PREMATURE_CLOSE;\nfunction Cd() {}\n_c126 = Cd;\nvar kd, Ad, xd, Md, Id, Td, Rd = function e(t, n, r) {\n    if (\"function\" == typeof n) return e(t, null, n);\n    n || (n = {}), r = function(e) {\n        var t = !1;\n        return function() {\n            if (!t) {\n                t = !0;\n                for(var n = arguments.length, r = new Array(n), i = 0; i < n; i++)r[i] = arguments[i];\n                e.apply(this, r);\n            }\n        };\n    }(r || Cd);\n    var i = n.readable || !1 !== n.readable && t.readable, o = n.writable || !1 !== n.writable && t.writable, s = function() {\n        t.writable || c();\n    }, a = t._writableState && t._writableState.finished, c = function() {\n        o = !1, a = !0, i || r.call(t);\n    }, l = t._readableState && t._readableState.endEmitted, d = function() {\n        i = !1, l = !0, o || r.call(t);\n    }, u = function(e) {\n        r.call(t, e);\n    }, h = function() {\n        var e;\n        return i && !l ? (t._readableState && t._readableState.ended || (e = new _d), r.call(t, e)) : o && !a ? (t._writableState && t._writableState.ended || (e = new _d), r.call(t, e)) : void 0;\n    }, f = function() {\n        t.req.on(\"finish\", c);\n    };\n    return !function(e) {\n        return e.setHeader && \"function\" == typeof e.abort;\n    }(t) ? o && !t._writableState && (t.on(\"end\", s), t.on(\"close\", s)) : (t.on(\"complete\", c), t.on(\"abort\", h), t.req ? f() : t.on(\"request\", f)), t.on(\"end\", d), t.on(\"finish\", c), !1 !== n.error && t.on(\"error\", u), t.on(\"close\", h), function() {\n        t.removeListener(\"complete\", c), t.removeListener(\"abort\", h), t.removeListener(\"request\", f), t.req && t.req.removeListener(\"finish\", c), t.removeListener(\"end\", s), t.removeListener(\"close\", s), t.removeListener(\"finish\", c), t.removeListener(\"end\", d), t.removeListener(\"error\", u), t.removeListener(\"close\", h);\n    };\n};\nfunction Pd() {\n    if (Ad) return kd;\n    var e;\n    function t(e, t, n) {\n        return (t = function(e) {\n            var t = function(e, t) {\n                if (\"object\" != typeof e || null === e) return e;\n                var n = e[Symbol.toPrimitive];\n                if (void 0 !== n) {\n                    var r = n.call(e, t || \"default\");\n                    if (\"object\" != typeof r) return r;\n                    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n                }\n                return (\"string\" === t ? String : Number)(e);\n            }(e, \"string\");\n            return \"symbol\" == typeof t ? t : String(t);\n        }(t)) in e ? Object.defineProperty(e, t, {\n            value: n,\n            enumerable: !0,\n            configurable: !0,\n            writable: !0\n        }) : e[t] = n, e;\n    }\n    Ad = 1;\n    var n = Rd, r = Symbol(\"lastResolve\"), i = Symbol(\"lastReject\"), o = Symbol(\"error\"), s = Symbol(\"ended\"), a = Symbol(\"lastPromise\"), c = Symbol(\"handlePromise\"), l = Symbol(\"stream\");\n    function d(e, t) {\n        return {\n            value: e,\n            done: t\n        };\n    }\n    function u(e) {\n        var t = e[r];\n        if (null !== t) {\n            var n = e[l].read();\n            null !== n && (e[a] = null, e[r] = null, e[i] = null, t(d(n, !1)));\n        }\n    }\n    function h(e) {\n        ua.nextTick(u, e);\n    }\n    var f = Object.getPrototypeOf(function() {}), p = Object.setPrototypeOf((t(e = {\n        get stream () {\n            return this[l];\n        },\n        next: function() {\n            var e = this, t = this[o];\n            if (null !== t) return Promise.reject(t);\n            if (this[s]) return Promise.resolve(d(void 0, !0));\n            if (this[l].destroyed) return new Promise(function(t, n) {\n                ua.nextTick(function() {\n                    e[o] ? n(e[o]) : t(d(void 0, !0));\n                });\n            });\n            var n, r = this[a];\n            if (r) n = new Promise(function(e, t) {\n                return function(n, r) {\n                    e.then(function() {\n                        t[s] ? n(d(void 0, !0)) : t[c](n, r);\n                    }, r);\n                };\n            }(r, this));\n            else {\n                var i = this[l].read();\n                if (null !== i) return Promise.resolve(d(i, !1));\n                n = new Promise(this[c]);\n            }\n            return this[a] = n, n;\n        }\n    }, Symbol.asyncIterator, function() {\n        return this;\n    }), t(e, \"return\", function() {\n        var e = this;\n        return new Promise(function(t, n) {\n            e[l].destroy(null, function(e) {\n                e ? n(e) : t(d(void 0, !0));\n            });\n        });\n    }), e), f);\n    return kd = function(e) {\n        var u, f = Object.create(p, (t(u = {}, l, {\n            value: e,\n            writable: !0\n        }), t(u, r, {\n            value: null,\n            writable: !0\n        }), t(u, i, {\n            value: null,\n            writable: !0\n        }), t(u, o, {\n            value: null,\n            writable: !0\n        }), t(u, s, {\n            value: e._readableState.endEmitted,\n            writable: !0\n        }), t(u, c, {\n            value: function(e, t) {\n                var n = f[l].read();\n                n ? (f[a] = null, f[r] = null, f[i] = null, e(d(n, !1))) : (f[r] = e, f[i] = t);\n            },\n            writable: !0\n        }), u));\n        return f[a] = null, n(e, function(e) {\n            if (e && \"ERR_STREAM_PREMATURE_CLOSE\" !== e.code) {\n                var t = f[i];\n                return null !== t && (f[a] = null, f[r] = null, f[i] = null, t(e)), void (f[o] = e);\n            }\n            var n = f[r];\n            null !== n && (f[a] = null, f[r] = null, f[i] = null, n(d(void 0, !0))), f[s] = !0;\n        }), e.on(\"readable\", h.bind(null, f)), f;\n    }, kd;\n}\n_c127 = Pd;\nfunction Od() {\n    if (Td) return Id;\n    var e;\n    Td = 1, Id = E, E.ReadableState = w, lc.EventEmitter;\n    var t = function(e, t) {\n        return e.listeners(t).length;\n    }, n = sl, r = al.Buffer, i = (void 0 !== de ? de :  true ? window : 0).Uint8Array || function() {};\n    var o, s = Yl;\n    o = s && s.debuglog ? s.debuglog(\"stream\") : function() {};\n    var a, c, l, d = Zl(), u = ed, h = dd.getHighWaterMark, f = td.codes, p = f.ERR_INVALID_ARG_TYPE, g = f.ERR_STREAM_PUSH_AFTER_EOF, m = f.ERR_METHOD_NOT_IMPLEMENTED, y = f.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;\n    hd(E, n);\n    var v = u.errorOrDestroy, b = [\n        \"error\",\n        \"close\",\n        \"destroy\",\n        \"pause\",\n        \"resume\"\n    ];\n    function w(t, n, r) {\n        e = e || md(), t = t || {}, \"boolean\" != typeof r && (r = n instanceof e), this.objectMode = !!t.objectMode, r && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = h(this, t, \"readableHighWaterMark\", r), this.buffer = new d, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.destroyed = !1, this.defaultEncoding = t.defaultEncoding || \"utf8\", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, t.encoding && (a || (a = Sd.StringDecoder), this.decoder = new a(t.encoding), this.encoding = t.encoding);\n    }\n    function E(t) {\n        if (e = e || md(), !(this instanceof E)) return new E(t);\n        var r = this instanceof e;\n        this._readableState = new w(t, this, r), this.readable = !0, t && (\"function\" == typeof t.read && (this._read = t.read), \"function\" == typeof t.destroy && (this._destroy = t.destroy)), n.call(this);\n    }\n    function S(e, t, n, s, a) {\n        o(\"readableAddChunk\", t);\n        var c, l = e._readableState;\n        if (null === t) l.reading = !1, function(e, t) {\n            if (o(\"onEofChunk\"), t.ended) return;\n            if (t.decoder) {\n                var n = t.decoder.end();\n                n && n.length && (t.buffer.push(n), t.length += t.objectMode ? 1 : n.length);\n            }\n            t.ended = !0, t.sync ? A(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, x(e)));\n        }(e, l);\n        else if (a || (c = function(e, t) {\n            var n;\n            o = t, r.isBuffer(o) || o instanceof i || \"string\" == typeof t || void 0 === t || e.objectMode || (n = new p(\"chunk\", [\n                \"string\",\n                \"Buffer\",\n                \"Uint8Array\"\n            ], t));\n            var o;\n            return n;\n        }(l, t)), c) v(e, c);\n        else if (l.objectMode || t && t.length > 0) if (\"string\" == typeof t || l.objectMode || Object.getPrototypeOf(t) === r.prototype || (t = function(e) {\n            return r.from(e);\n        }(t)), s) l.endEmitted ? v(e, new y) : _(e, l, t, !0);\n        else if (l.ended) v(e, new g);\n        else {\n            if (l.destroyed) return !1;\n            l.reading = !1, l.decoder && !n ? (t = l.decoder.write(t), l.objectMode || 0 !== t.length ? _(e, l, t, !1) : M(e, l)) : _(e, l, t, !1);\n        }\n        else s || (l.reading = !1, M(e, l));\n        return !l.ended && (l.length < l.highWaterMark || 0 === l.length);\n    }\n    function _(e, t, n, r) {\n        t.flowing && 0 === t.length && !t.sync ? (t.awaitDrain = 0, e.emit(\"data\", n)) : (t.length += t.objectMode ? 1 : n.length, r ? t.buffer.unshift(n) : t.buffer.push(n), t.needReadable && A(e)), M(e, t);\n    }\n    Object.defineProperty(E.prototype, \"destroyed\", {\n        enumerable: !1,\n        get: function() {\n            return void 0 !== this._readableState && this._readableState.destroyed;\n        },\n        set: function(e) {\n            this._readableState && (this._readableState.destroyed = e);\n        }\n    }), E.prototype.destroy = u.destroy, E.prototype._undestroy = u.undestroy, E.prototype._destroy = function(e, t) {\n        t(e);\n    }, E.prototype.push = function(e, t) {\n        var n, i = this._readableState;\n        return i.objectMode ? n = !0 : \"string\" == typeof e && ((t = t || i.defaultEncoding) !== i.encoding && (e = r.from(e, t), t = \"\"), n = !0), S(this, e, t, !1, n);\n    }, E.prototype.unshift = function(e) {\n        return S(this, e, null, !0, !1);\n    }, E.prototype.isPaused = function() {\n        return !1 === this._readableState.flowing;\n    }, E.prototype.setEncoding = function(e) {\n        a || (a = Sd.StringDecoder);\n        var t = new a(e);\n        this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;\n        for(var n = this._readableState.buffer.head, r = \"\"; null !== n;)r += t.write(n.data), n = n.next;\n        return this._readableState.buffer.clear(), \"\" !== r && this._readableState.buffer.push(r), this._readableState.length = r.length, this;\n    };\n    var C = 1073741824;\n    function k(e, t) {\n        return e <= 0 || 0 === t.length && t.ended ? 0 : t.objectMode ? 1 : e != e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = function(e) {\n            return e >= C ? e = C : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e;\n        }(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0));\n    }\n    function A(e) {\n        var t = e._readableState;\n        o(\"emitReadable\", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (o(\"emitReadable\", t.flowing), t.emittedReadable = !0, ua.nextTick(x, e));\n    }\n    function x(e) {\n        var t = e._readableState;\n        o(\"emitReadable_\", t.destroyed, t.length, t.ended), t.destroyed || !t.length && !t.ended || (e.emit(\"readable\"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, O(e);\n    }\n    function M(e, t) {\n        t.readingMore || (t.readingMore = !0, ua.nextTick(I, e, t));\n    }\n    function I(e, t) {\n        for(; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && 0 === t.length);){\n            var n = t.length;\n            if (o(\"maybeReadMore read 0\"), e.read(0), n === t.length) break;\n        }\n        t.readingMore = !1;\n    }\n    function T(e) {\n        var t = e._readableState;\n        t.readableListening = e.listenerCount(\"readable\") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount(\"data\") > 0 && e.resume();\n    }\n    function R(e) {\n        o(\"readable nexttick read 0\"), e.read(0);\n    }\n    function P(e, t) {\n        o(\"resume\", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit(\"resume\"), O(e), t.flowing && !t.reading && e.read(0);\n    }\n    function O(e) {\n        var t = e._readableState;\n        for(o(\"flow\", t.flowing); t.flowing && null !== e.read(););\n    }\n    function N(e, t) {\n        return 0 === t.length ? null : (t.objectMode ? n = t.buffer.shift() : !e || e >= t.length ? (n = t.decoder ? t.buffer.join(\"\") : 1 === t.buffer.length ? t.buffer.first() : t.buffer.concat(t.length), t.buffer.clear()) : n = t.buffer.consume(e, t.decoder), n);\n        var n;\n    }\n    function L(e) {\n        var t = e._readableState;\n        o(\"endReadable\", t.endEmitted), t.endEmitted || (t.ended = !0, ua.nextTick(D, t, e));\n    }\n    function D(e, t) {\n        if (o(\"endReadableNT\", e.endEmitted, e.length), !e.endEmitted && 0 === e.length && (e.endEmitted = !0, t.readable = !1, t.emit(\"end\"), e.autoDestroy)) {\n            var n = t._writableState;\n            (!n || n.autoDestroy && n.finished) && t.destroy();\n        }\n    }\n    function $(e, t) {\n        for(var n = 0, r = e.length; n < r; n++)if (e[n] === t) return n;\n        return -1;\n    }\n    return E.prototype.read = function(e) {\n        o(\"read\", e), e = parseInt(e, 10);\n        var t = this._readableState, n = e;\n        if (0 !== e && (t.emittedReadable = !1), 0 === e && t.needReadable && ((0 !== t.highWaterMark ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return o(\"read: emitReadable\", t.length, t.ended), 0 === t.length && t.ended ? L(this) : A(this), null;\n        if (0 === (e = k(e, t)) && t.ended) return 0 === t.length && L(this), null;\n        var r, i = t.needReadable;\n        return o(\"need readable\", i), (0 === t.length || t.length - e < t.highWaterMark) && o(\"length less than watermark\", i = !0), t.ended || t.reading ? o(\"reading or ended\", i = !1) : i && (o(\"do read\"), t.reading = !0, t.sync = !0, 0 === t.length && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = k(n, t))), null === (r = e > 0 ? N(e, t) : null) ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), 0 === t.length && (t.ended || (t.needReadable = !0), n !== e && t.ended && L(this)), null !== r && this.emit(\"data\", r), r;\n    }, E.prototype._read = function(e) {\n        v(this, new m(\"_read()\"));\n    }, E.prototype.pipe = function(e, n) {\n        var r = this, i = this._readableState;\n        switch(i.pipesCount){\n            case 0:\n                i.pipes = e;\n                break;\n            case 1:\n                i.pipes = [\n                    i.pipes,\n                    e\n                ];\n                break;\n            default:\n                i.pipes.push(e);\n        }\n        i.pipesCount += 1, o(\"pipe count=%d opts=%j\", i.pipesCount, n);\n        var s = (!n || !1 !== n.end) && e !== ua.stdout && e !== ua.stderr ? c : g;\n        function a(t, n) {\n            o(\"onunpipe\"), t === r && n && !1 === n.hasUnpiped && (n.hasUnpiped = !0, o(\"cleanup\"), e.removeListener(\"close\", f), e.removeListener(\"finish\", p), e.removeListener(\"drain\", l), e.removeListener(\"error\", h), e.removeListener(\"unpipe\", a), r.removeListener(\"end\", c), r.removeListener(\"end\", g), r.removeListener(\"data\", u), d = !0, !i.awaitDrain || e._writableState && !e._writableState.needDrain || l());\n        }\n        function c() {\n            o(\"onend\"), e.end();\n        }\n        i.endEmitted ? ua.nextTick(s) : r.once(\"end\", s), e.on(\"unpipe\", a);\n        var l = function(e) {\n            return function() {\n                var n = e._readableState;\n                o(\"pipeOnDrain\", n.awaitDrain), n.awaitDrain && n.awaitDrain--, 0 === n.awaitDrain && t(e, \"data\") && (n.flowing = !0, O(e));\n            };\n        }(r);\n        e.on(\"drain\", l);\n        var d = !1;\n        function u(t) {\n            o(\"ondata\");\n            var n = e.write(t);\n            o(\"dest.write\", n), !1 === n && ((1 === i.pipesCount && i.pipes === e || i.pipesCount > 1 && -1 !== $(i.pipes, e)) && !d && (o(\"false write response, pause\", i.awaitDrain), i.awaitDrain++), r.pause());\n        }\n        function h(n) {\n            o(\"onerror\", n), g(), e.removeListener(\"error\", h), 0 === t(e, \"error\") && v(e, n);\n        }\n        function f() {\n            e.removeListener(\"finish\", p), g();\n        }\n        function p() {\n            o(\"onfinish\"), e.removeListener(\"close\", f), g();\n        }\n        function g() {\n            o(\"unpipe\"), r.unpipe(e);\n        }\n        return r.on(\"data\", u), function(e, t, n) {\n            if (\"function\" == typeof e.prependListener) return e.prependListener(t, n);\n            e._events && e._events[t] ? Array.isArray(e._events[t]) ? e._events[t].unshift(n) : e._events[t] = [\n                n,\n                e._events[t]\n            ] : e.on(t, n);\n        }(e, \"error\", h), e.once(\"close\", f), e.once(\"finish\", p), e.emit(\"pipe\", r), i.flowing || (o(\"pipe resume\"), r.resume()), e;\n    }, E.prototype.unpipe = function(e) {\n        var t = this._readableState, n = {\n            hasUnpiped: !1\n        };\n        if (0 === t.pipesCount) return this;\n        if (1 === t.pipesCount) return e && e !== t.pipes || (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit(\"unpipe\", this, n)), this;\n        if (!e) {\n            var r = t.pipes, i = t.pipesCount;\n            t.pipes = null, t.pipesCount = 0, t.flowing = !1;\n            for(var o = 0; o < i; o++)r[o].emit(\"unpipe\", this, {\n                hasUnpiped: !1\n            });\n            return this;\n        }\n        var s = $(t.pipes, e);\n        return -1 === s || (t.pipes.splice(s, 1), t.pipesCount -= 1, 1 === t.pipesCount && (t.pipes = t.pipes[0]), e.emit(\"unpipe\", this, n)), this;\n    }, E.prototype.on = function(e, t) {\n        var r = n.prototype.on.call(this, e, t), i = this._readableState;\n        return \"data\" === e ? (i.readableListening = this.listenerCount(\"readable\") > 0, !1 !== i.flowing && this.resume()) : \"readable\" === e && (i.endEmitted || i.readableListening || (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, o(\"on readable\", i.length, i.reading), i.length ? A(this) : i.reading || ua.nextTick(R, this))), r;\n    }, E.prototype.addListener = E.prototype.on, E.prototype.removeListener = function(e, t) {\n        var r = n.prototype.removeListener.call(this, e, t);\n        return \"readable\" === e && ua.nextTick(T, this), r;\n    }, E.prototype.removeAllListeners = function(e) {\n        var t = n.prototype.removeAllListeners.apply(this, arguments);\n        return \"readable\" !== e && void 0 !== e || ua.nextTick(T, this), t;\n    }, E.prototype.resume = function() {\n        var e = this._readableState;\n        return e.flowing || (o(\"resume\"), e.flowing = !e.readableListening, function(e, t) {\n            t.resumeScheduled || (t.resumeScheduled = !0, ua.nextTick(P, e, t));\n        }(this, e)), e.paused = !1, this;\n    }, E.prototype.pause = function() {\n        return o(\"call pause flowing=%j\", this._readableState.flowing), !1 !== this._readableState.flowing && (o(\"pause\"), this._readableState.flowing = !1, this.emit(\"pause\")), this._readableState.paused = !0, this;\n    }, E.prototype.wrap = function(e) {\n        var t = this, n = this._readableState, r = !1;\n        for(var i in e.on(\"end\", function() {\n            if (o(\"wrapped end\"), n.decoder && !n.ended) {\n                var e = n.decoder.end();\n                e && e.length && t.push(e);\n            }\n            t.push(null);\n        }), e.on(\"data\", function(i) {\n            (o(\"wrapped data\"), n.decoder && (i = n.decoder.write(i)), n.objectMode && null == i) || (n.objectMode || i && i.length) && (t.push(i) || (r = !0, e.pause()));\n        }), e)void 0 === this[i] && \"function\" == typeof e[i] && (this[i] = function(t) {\n            return function() {\n                return e[t].apply(e, arguments);\n            };\n        }(i));\n        for(var s = 0; s < b.length; s++)e.on(b[s], this.emit.bind(this, b[s]));\n        return this._read = function(t) {\n            o(\"wrapped _read\", t), r && (r = !1, e.resume());\n        }, this;\n    }, \"function\" == typeof Symbol && (E.prototype[Symbol.asyncIterator] = function() {\n        return void 0 === c && (c = Pd()), c(this);\n    }), Object.defineProperty(E.prototype, \"readableHighWaterMark\", {\n        enumerable: !1,\n        get: function() {\n            return this._readableState.highWaterMark;\n        }\n    }), Object.defineProperty(E.prototype, \"readableBuffer\", {\n        enumerable: !1,\n        get: function() {\n            return this._readableState && this._readableState.buffer;\n        }\n    }), Object.defineProperty(E.prototype, \"readableFlowing\", {\n        enumerable: !1,\n        get: function() {\n            return this._readableState.flowing;\n        },\n        set: function(e) {\n            this._readableState && (this._readableState.flowing = e);\n        }\n    }), E._fromList = N, Object.defineProperty(E.prototype, \"readableLength\", {\n        enumerable: !1,\n        get: function() {\n            return this._readableState.length;\n        }\n    }), \"function\" == typeof Symbol && (E.from = function(e, t) {\n        return void 0 === l && (l = Md ? xd : (Md = 1, xd = function() {\n            throw new Error(\"Readable.from is not available in the browser\");\n        })), l(E, e, t);\n    }), Id;\n}\n_c128 = Od;\nvar Nd = Hd, Ld = td.codes, Dd = Ld.ERR_METHOD_NOT_IMPLEMENTED, $d = Ld.ERR_MULTIPLE_CALLBACK, Bd = Ld.ERR_TRANSFORM_ALREADY_TRANSFORMING, Kd = Ld.ERR_TRANSFORM_WITH_LENGTH_0, jd = md();\nfunction Ud(e, t) {\n    var n = this._transformState;\n    n.transforming = !1;\n    var r = n.writecb;\n    if (null === r) return this.emit(\"error\", new $d);\n    n.writechunk = null, n.writecb = null, null != t && this.push(t), r(e);\n    var i = this._readableState;\n    i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);\n}\n_c129 = Ud;\nfunction Hd(e) {\n    if (!(this instanceof Hd)) return new Hd(e);\n    jd.call(this, e), this._transformState = {\n        afterTransform: Ud.bind(this),\n        needTransform: !1,\n        transforming: !1,\n        writecb: null,\n        writechunk: null,\n        writeencoding: null\n    }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (\"function\" == typeof e.transform && (this._transform = e.transform), \"function\" == typeof e.flush && (this._flush = e.flush)), this.on(\"prefinish\", Fd);\n}\n_c130 = Hd;\nfunction Fd() {\n    var e = this;\n    \"function\" != typeof this._flush || this._readableState.destroyed ? zd(this, null, null) : this._flush(function(t, n) {\n        zd(e, t, n);\n    });\n}\n_c131 = Fd;\nfunction zd(e, t, n) {\n    if (t) return e.emit(\"error\", t);\n    if (null != n && e.push(n), e._writableState.length) throw new Kd;\n    if (e._transformState.transforming) throw new Bd;\n    return e.push(null);\n}\nhd(Hd, jd), Hd.prototype.push = function(e, t) {\n    return this._transformState.needTransform = !1, jd.prototype.push.call(this, e, t);\n}, Hd.prototype._transform = function(e, t, n) {\n    n(new Dd(\"_transform()\"));\n}, Hd.prototype._write = function(e, t, n) {\n    var r = this._transformState;\n    if (r.writecb = n, r.writechunk = e, r.writeencoding = t, !r.transforming) {\n        var i = this._readableState;\n        (r.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);\n    }\n}, Hd.prototype._read = function(e) {\n    var t = this._transformState;\n    null === t.writechunk || t.transforming ? t.needTransform = !0 : (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform));\n}, Hd.prototype._destroy = function(e, t) {\n    jd.prototype._destroy.call(this, e, function(e) {\n        t(e);\n    });\n};\nvar qd, Wd = Gd, Vd = Nd;\nfunction Gd(e) {\n    if (!(this instanceof Gd)) return new Gd(e);\n    Vd.call(this, e);\n}\n_c132 = Gd;\nhd(Gd, Vd), Gd.prototype._transform = function(e, t, n) {\n    n(null, e);\n};\nvar Yd = td.codes, Zd = Yd.ERR_MISSING_ARGS, Jd = Yd.ERR_STREAM_DESTROYED;\nfunction Qd(e) {\n    if (e) throw e;\n}\n_c133 = Qd;\nfunction Xd(e) {\n    e();\n}\n_c134 = Xd;\nfunction eu(e, t) {\n    return e.pipe(t);\n}\nvar tu = function() {\n    for(var e = arguments.length, t = new Array(e), n = 0; n < e; n++)t[n] = arguments[n];\n    var r, i = function(e) {\n        return e.length ? \"function\" != typeof e[e.length - 1] ? Qd : e.pop() : Qd;\n    }(t);\n    if (Array.isArray(t[0]) && (t = t[0]), t.length < 2) throw new Zd(\"streams\");\n    var o = t.map(function(e, n) {\n        var s = n < t.length - 1;\n        return function(e, t, n, r) {\n            r = function(e) {\n                var t = !1;\n                return function() {\n                    t || (t = !0, e.apply(void 0, arguments));\n                };\n            }(r);\n            var i = !1;\n            e.on(\"close\", function() {\n                i = !0;\n            }), void 0 === qd && (qd = Rd), qd(e, {\n                readable: t,\n                writable: n\n            }, function(e) {\n                if (e) return r(e);\n                i = !0, r();\n            });\n            var o = !1;\n            return function(t) {\n                if (!i && !o) return o = !0, function(e) {\n                    return e.setHeader && \"function\" == typeof e.abort;\n                }(e) ? e.abort() : \"function\" == typeof e.destroy ? e.destroy() : void r(t || new Jd(\"pipe\"));\n            };\n        }(e, s, n > 0, function(e) {\n            r || (r = e), e && o.forEach(Xd), s || (o.forEach(Xd), i(r));\n        });\n    });\n    return t.reduce(eu);\n};\n!function(e, t) {\n    (t = ol.exports = Od()).Stream = t, t.Readable = t, t.Writable = gd(), t.Duplex = md(), t.Transform = Nd, t.PassThrough = Wd, t.finished = Rd, t.pipeline = tu;\n}(0, ol.exports);\nvar nu = ol.exports;\nfunction ru() {\n    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    const t = {}, n = new nu.Duplex({\n        objectMode: !0,\n        read: ()=>{},\n        write: function(n, o, s) {\n            let a = null;\n            try {\n                !n.id ? function(n) {\n                    (e === null || e === void 0 ? void 0 : e.retryOnMessage) && n.method === e.retryOnMessage && Object.values(t).forEach((param)=>{\n                        let { req: e, retryCount: n = 0 } = param;\n                        if (!e.id) return;\n                        if (n >= 3) throw new Error('StreamMiddleware - Retry limit exceeded for request id \"'.concat(e.id, '\"'));\n                        const r = t[e.id];\n                        r && (r.retryCount = n + 1), i(e);\n                    });\n                    r.emit(\"notification\", n);\n                }(n) : function(e) {\n                    const { id: n } = e;\n                    if (null === n) return;\n                    const r = t[n];\n                    if (!r) return void console.warn('StreamMiddleware - Unknown response id \"'.concat(n, '\"'));\n                    delete t[n], Object.assign(r.res, e), setTimeout(r.end);\n                }(n);\n            } catch (e) {\n                a = e;\n            }\n            s(a);\n        }\n    }), r = new Pc;\n    return {\n        events: r,\n        middleware: (e, n, r, o)=>{\n            t[e.id] = {\n                req: e,\n                res: n,\n                next: r,\n                end: o\n            }, i(e);\n        },\n        stream: n\n    };\n    function i(e) {\n        n.push(e);\n    }\n}\nvar iu = {}, ou = {\n    exports: {}\n}, su = function e(t, n) {\n    if (t && n) return e(t)(n);\n    if (\"function\" != typeof t) throw new TypeError(\"need wrapper function\");\n    return Object.keys(t).forEach(function(e) {\n        r[e] = t[e];\n    }), r;\n    function r() {\n        for(var e = new Array(arguments.length), n = 0; n < e.length; n++)e[n] = arguments[n];\n        var r = t.apply(this, e), i = e[e.length - 1];\n        return \"function\" == typeof r && r !== i && Object.keys(i).forEach(function(e) {\n            r[e] = i[e];\n        }), r;\n    }\n};\nvar au = su;\nfunction cu(e) {\n    var t = function() {\n        return t.called ? t.value : (t.called = !0, t.value = e.apply(this, arguments));\n    };\n    return t.called = !1, t;\n}\nfunction lu(e) {\n    var t = function() {\n        if (t.called) throw new Error(t.onceError);\n        return t.called = !0, t.value = e.apply(this, arguments);\n    }, n = e.name || \"Function wrapped with `once`\";\n    return t.onceError = n + \" shouldn't be called more than once\", t.called = !1, t;\n}\nou.exports = au(cu), ou.exports.strict = au(lu), cu.proto = cu(function() {\n    Object.defineProperty(Function.prototype, \"once\", {\n        value: function() {\n            return cu(this);\n        },\n        configurable: !0\n    }), Object.defineProperty(Function.prototype, \"onceStrict\", {\n        value: function() {\n            return lu(this);\n        },\n        configurable: !0\n    });\n});\nvar du = ou.exports, uu = {};\nObject.defineProperty(uu, \"__esModule\", {\n    value: !0\n}), uu.Substream = void 0;\nconst hu = nu;\nclass fu extends hu.Duplex {\n    _read() {}\n    _write(e, t, n) {\n        this._parent.push({\n            name: this._name,\n            data: e\n        }), n();\n    }\n    constructor({ parent: e, name: t }){\n        super({\n            objectMode: !0\n        }), this._parent = e, this._name = t;\n    }\n}\nuu.Substream = fu;\nvar pu = de && de.__importDefault || function(e) {\n    return e && e.__esModule ? e : {\n        default: e\n    };\n};\nObject.defineProperty(iu, \"__esModule\", {\n    value: !0\n}), iu.ObjectMultiplex = void 0;\nconst gu = nu, mu = pu(du), yu = uu, vu = Symbol(\"IGNORE_SUBSTREAM\");\nlet bu = class extends gu.Duplex {\n    createStream(e) {\n        if (this.destroyed) throw new Error('ObjectMultiplex - parent stream for name \"'.concat(e, '\" already destroyed'));\n        if (this._readableState.ended || this._writableState.ended) throw new Error('ObjectMultiplex - parent stream for name \"'.concat(e, '\" already ended'));\n        if (!e) throw new Error(\"ObjectMultiplex - name must not be empty\");\n        if (this._substreams[e]) throw new Error('ObjectMultiplex - Substream for name \"'.concat(e, '\" already exists'));\n        const t = new yu.Substream({\n            parent: this,\n            name: e\n        });\n        return this._substreams[e] = t, function(e, t) {\n            const n = (0, mu.default)(t);\n            (0, gu.finished)(e, {\n                readable: !1\n            }, n), (0, gu.finished)(e, {\n                writable: !1\n            }, n);\n        }(this, (e)=>t.destroy(e || void 0)), t;\n    }\n    ignoreStream(e) {\n        if (!e) throw new Error(\"ObjectMultiplex - name must not be empty\");\n        if (this._substreams[e]) throw new Error('ObjectMultiplex - Substream for name \"'.concat(e, '\" already exists'));\n        this._substreams[e] = vu;\n    }\n    _read() {}\n    _write(e, t, n) {\n        const { name: r, data: i } = e;\n        if (!r) return console.warn('ObjectMultiplex - malformed chunk without name \"'.concat(e, '\"')), n();\n        const o = this._substreams[r];\n        return o ? (o !== vu && o.push(i), n()) : (console.warn('ObjectMultiplex - orphaned data for stream \"'.concat(r, '\"')), n());\n    }\n    constructor(e = {}){\n        super(Object.assign(Object.assign({}, e), {\n            objectMode: !0\n        })), this._substreams = {};\n    }\n};\niu.ObjectMultiplex = bu;\nvar wu = ue(iu.ObjectMultiplex);\nconst Eu = (e)=>null !== e && \"object\" == typeof e && \"function\" == typeof e.pipe;\n_c135 = Eu;\nEu.writable = (e)=>Eu(e) && !1 !== e.writable && \"function\" == typeof e._write && \"object\" == typeof e._writableState, Eu.readable = (e)=>Eu(e) && !1 !== e.readable && \"function\" == typeof e._read && \"object\" == typeof e._readableState, Eu.duplex = (e)=>Eu.writable(e) && Eu.readable(e), Eu.transform = (e)=>Eu.duplex(e) && \"function\" == typeof e._transform;\nvar Su, _u = Eu, Cu = class extends il {\n    async _initializeStateAsync() {\n        let e;\n        try {\n            e = await this.request({\n                method: \"metamask_getProviderState\"\n            });\n        } catch (e) {\n            this._log.error(\"MetaMask: Failed to get initial state. Please report this bug.\", e);\n        }\n        this._initializeState(e);\n    }\n    _handleStreamDisconnect(e, t) {\n        let n = 'MetaMask: Lost connection to \"'.concat(e, '\".');\n        (t === null || t === void 0 ? void 0 : t.stack) && (n += \"\\n\".concat(t.stack)), this._log.warn(n), this.listenerCount(\"error\") > 0 && this.emit(\"error\", n), this._handleDisconnect(!1, t ? t.message : void 0);\n    }\n    _handleChainChanged() {\n        let { chainId: e, networkVersion: t } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        jc(e) && ((e)=>Boolean(e) && \"string\" == typeof e)(t) ? \"loading\" === t ? this._handleDisconnect(!0) : super._handleChainChanged({\n            chainId: e\n        }) : this._log.error(is.errors.invalidNetworkParams(), {\n            chainId: e,\n            networkVersion: t\n        });\n    }\n    constructor(e, { jsonRpcStreamName: t, logger: n = console, maxEventListeners: r = 100, rpcMiddleware: i = [] }){\n        if (super({\n            logger: n,\n            maxEventListeners: r,\n            rpcMiddleware: i\n        }), !_u.duplex(e)) throw new Error(is.errors.invalidDuplexStream());\n        this._handleStreamDisconnect = this._handleStreamDisconnect.bind(this);\n        const o = new wu;\n        nu.pipeline(e, o, e, this._handleStreamDisconnect.bind(this, \"MetaMask\")), this._jsonRpcConnection = ru({\n            retryOnMessage: \"METAMASK_EXTENSION_CONNECT_CAN_RETRY\"\n        }), nu.pipeline(this._jsonRpcConnection.stream, o.createStream(t), this._jsonRpcConnection.stream, this._handleStreamDisconnect.bind(this, \"MetaMask RpcProvider\")), this._rpcEngine.push(this._jsonRpcConnection.middleware), this._jsonRpcConnection.events.on(\"notification\", (t)=>{\n            const { method: n, params: r } = t;\n            \"metamask_accountsChanged\" === n ? this._handleAccountsChanged(r) : \"metamask_unlockStateChanged\" === n ? this._handleUnlockStateChanged(r) : \"metamask_chainChanged\" === n ? this._handleChainChanged(r) : Dc.includes(n) ? this.emit(\"message\", {\n                type: n,\n                data: r\n            }) : \"METAMASK_STREAM_FAILURE\" === n && e.destroy(new Error(is.errors.permanentlyDisconnected()));\n        });\n    }\n}, ku = class extends Cu {\n    get chainId() {\n        return this._sentWarnings.chainId || (this._log.warn(is.warnings.chainIdDeprecation), this._sentWarnings.chainId = !0), super.chainId;\n    }\n    get networkVersion() {\n        return this._sentWarnings.networkVersion || (this._log.warn(is.warnings.networkVersionDeprecation), this._sentWarnings.networkVersion = !0), Vc(this, Su);\n    }\n    get selectedAddress() {\n        return this._sentWarnings.selectedAddress || (this._log.warn(is.warnings.selectedAddressDeprecation), this._sentWarnings.selectedAddress = !0), super.selectedAddress;\n    }\n    sendAsync(e, t) {\n        this._rpcRequest(e, t);\n    }\n    addListener(e, t) {\n        return this._warnOfDeprecation(e), super.addListener(e, t);\n    }\n    on(e, t) {\n        return this._warnOfDeprecation(e), super.on(e, t);\n    }\n    once(e, t) {\n        return this._warnOfDeprecation(e), super.once(e, t);\n    }\n    prependListener(e, t) {\n        return this._warnOfDeprecation(e), super.prependListener(e, t);\n    }\n    prependOnceListener(e, t) {\n        return this._warnOfDeprecation(e), super.prependOnceListener(e, t);\n    }\n    _handleDisconnect(e, t) {\n        super._handleDisconnect(e, t), Vc(this, Su) && !e && Yc(this, Su, null);\n    }\n    _warnOfDeprecation(e) {\n        var _this__sentWarnings;\n        !1 === ((_this__sentWarnings = this._sentWarnings) === null || _this__sentWarnings === void 0 ? void 0 : _this__sentWarnings.events[e]) && (this._log.warn(is.warnings.events[e]), this._sentWarnings.events[e] = !0);\n    }\n    async enable() {\n        return this._sentWarnings.enable || (this._log.warn(is.warnings.enableDeprecation), this._sentWarnings.enable = !0), new Promise((e, t)=>{\n            try {\n                this._rpcRequest({\n                    method: \"eth_requestAccounts\",\n                    params: []\n                }, Kc(e, t));\n            } catch (e) {\n                t(e);\n            }\n        });\n    }\n    send(e, t) {\n        return this._sentWarnings.send || (this._log.warn(is.warnings.sendDeprecation), this._sentWarnings.send = !0), \"string\" != typeof e || t && !Array.isArray(t) ? e && \"object\" == typeof e && \"function\" == typeof t ? this._rpcRequest(e, t) : this._sendSync(e) : new Promise((n, r)=>{\n            try {\n                this._rpcRequest({\n                    method: e,\n                    params: t\n                }, Kc(n, r, !1));\n            } catch (e) {\n                r(e);\n            }\n        });\n    }\n    _sendSync(e) {\n        let t;\n        switch(e.method){\n            case \"eth_accounts\":\n                t = this.selectedAddress ? [\n                    this.selectedAddress\n                ] : [];\n                break;\n            case \"eth_coinbase\":\n                var _this_selectedAddress;\n                t = (_this_selectedAddress = this.selectedAddress) !== null && _this_selectedAddress !== void 0 ? _this_selectedAddress : null;\n                break;\n            case \"eth_uninstallFilter\":\n                this._rpcRequest(e, Uc), t = !0;\n                break;\n            case \"net_version\":\n                var _Vc;\n                t = (_Vc = Vc(this, Su)) !== null && _Vc !== void 0 ? _Vc : null;\n                break;\n            default:\n                throw new Error(is.errors.unsupportedSync(e.method));\n        }\n        return {\n            id: e.id,\n            jsonrpc: e.jsonrpc,\n            result: t\n        };\n    }\n    _getExperimentalApi() {\n        var _this = this;\n        return new Proxy({\n            isUnlocked: async ()=>(this._state.initialized || await new Promise((e)=>{\n                    this.on(\"_initialized\", ()=>e());\n                }), this._state.isUnlocked),\n            requestBatch: async (e)=>{\n                if (!Array.isArray(e)) throw Xa({\n                    message: \"Batch requests must be made with an array of request objects.\",\n                    data: e\n                });\n                return new Promise((t, n)=>{\n                    this._rpcRequest(e, Kc(t, n));\n                });\n            }\n        }, {\n            get: function(e, t) {\n                for(var _len = arguments.length, n = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n                    n[_key - 2] = arguments[_key];\n                }\n                return _this._sentWarnings.experimentalMethods || (_this._log.warn(is.warnings.experimentalMethods), _this._sentWarnings.experimentalMethods = !0), Reflect.get(e, t, ...n);\n            }\n        });\n    }\n    _handleChainChanged() {\n        let { chainId: e, networkVersion: t } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        super._handleChainChanged({\n            chainId: e,\n            networkVersion: t\n        }), this._state.isConnected && t !== Vc(this, Su) && (Yc(this, Su, t), this._state.initialized && this.emit(\"networkChanged\", Vc(this, Su)));\n    }\n    constructor(e, { jsonRpcStreamName: t = \"metamask-provider\", logger: n = console, maxEventListeners: r = 100, shouldSendMetadata: i } = {}){\n        if (super(e, {\n            jsonRpcStreamName: t,\n            logger: n,\n            maxEventListeners: r,\n            rpcMiddleware: $c(n)\n        }), this._sentWarnings = {\n            chainId: !1,\n            networkVersion: !1,\n            selectedAddress: !1,\n            enable: !1,\n            experimentalMethods: !1,\n            send: !1,\n            events: {\n                close: !1,\n                data: !1,\n                networkChanged: !1,\n                notification: !1\n            }\n        }, Gc(this, Su, void 0), this._initializeStateAsync(), Yc(this, Su, null), this.isMetaMask = !0, this._sendSync = this._sendSync.bind(this), this.enable = this.enable.bind(this), this.send = this.send.bind(this), this.sendAsync = this.sendAsync.bind(this), this._warnOfDeprecation = this._warnOfDeprecation.bind(this), this._metamask = this._getExperimentalApi(), this._jsonRpcConnection.events.on(\"notification\", (e)=>{\n            const { method: t } = e;\n            Dc.includes(t) && (this.emit(\"data\", e), this.emit(\"notification\", e.params.result));\n        }), i) if (\"complete\" === document.readyState) Hc(this._rpcEngine, this._log);\n        else {\n            const e = ()=>{\n                Hc(this._rpcEngine, this._log), window.removeEventListener(\"DOMContentLoaded\", e);\n            };\n            window.addEventListener(\"DOMContentLoaded\", e);\n        }\n    }\n};\nSu = new WeakMap;\nconst Au = debug__WEBPACK_IMPORTED_MODULE_1___default()(\"MM_SDK\");\nlet xu;\nAu.color = \"#FFAC1C\";\nvar Mu = {}, Iu = {};\nObject.defineProperty(Iu, \"__esModule\", {\n    value: !0\n}), Iu.EthereumProviderError = Iu.EthereumRpcError = void 0;\nconst Tu = $a;\nclass Ru extends Error {\n    serialize() {\n        const e = {\n            code: this.code,\n            message: this.message\n        };\n        return void 0 !== this.data && (e.data = this.data), this.stack && (e.stack = this.stack), e;\n    }\n    toString() {\n        return Tu.default(this.serialize(), Pu, 2);\n    }\n    constructor(e, t, n){\n        if (!Number.isInteger(e)) throw new Error('\"code\" must be an integer.');\n        if (!t || \"string\" != typeof t) throw new Error('\"message\" must be a nonempty string.');\n        super(t), this.code = e, void 0 !== n && (this.data = n);\n    }\n}\nIu.EthereumRpcError = Ru;\nfunction Pu(e, t) {\n    if (\"[Circular]\" !== t) return t;\n}\n_c136 = Pu;\nIu.EthereumProviderError = class extends Ru {\n    constructor(e, t, n){\n        if (!function(e) {\n            return Number.isInteger(e) && e >= 1e3 && e <= 4999;\n        }(e)) throw new Error('\"code\" must be an integer such that: 1000 <= code <= 4999');\n        super(e, t, n);\n    }\n};\nvar Ou = {}, Nu = {};\nObject.defineProperty(Nu, \"__esModule\", {\n    value: !0\n}), Nu.errorValues = Nu.errorCodes = void 0, Nu.errorCodes = {\n    rpc: {\n        invalidInput: -32e3,\n        resourceNotFound: -32001,\n        resourceUnavailable: -32002,\n        transactionRejected: -32003,\n        methodNotSupported: -32004,\n        limitExceeded: -32005,\n        parse: -32700,\n        invalidRequest: -32600,\n        methodNotFound: -32601,\n        invalidParams: -32602,\n        internal: -32603\n    },\n    provider: {\n        userRejectedRequest: 4001,\n        unauthorized: 4100,\n        unsupportedMethod: 4200,\n        disconnected: 4900,\n        chainDisconnected: 4901\n    }\n}, Nu.errorValues = {\n    \"-32700\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.\"\n    },\n    \"-32600\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The JSON sent is not a valid Request object.\"\n    },\n    \"-32601\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"The method does not exist / is not available.\"\n    },\n    \"-32602\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Invalid method parameter(s).\"\n    },\n    \"-32603\": {\n        standard: \"JSON RPC 2.0\",\n        message: \"Internal JSON-RPC error.\"\n    },\n    \"-32000\": {\n        standard: \"EIP-1474\",\n        message: \"Invalid input.\"\n    },\n    \"-32001\": {\n        standard: \"EIP-1474\",\n        message: \"Resource not found.\"\n    },\n    \"-32002\": {\n        standard: \"EIP-1474\",\n        message: \"Resource unavailable.\"\n    },\n    \"-32003\": {\n        standard: \"EIP-1474\",\n        message: \"Transaction rejected.\"\n    },\n    \"-32004\": {\n        standard: \"EIP-1474\",\n        message: \"Method not supported.\"\n    },\n    \"-32005\": {\n        standard: \"EIP-1474\",\n        message: \"Request limit exceeded.\"\n    },\n    4001: {\n        standard: \"EIP-1193\",\n        message: \"User rejected the request.\"\n    },\n    4100: {\n        standard: \"EIP-1193\",\n        message: \"The requested account and/or method has not been authorized by the user.\"\n    },\n    4200: {\n        standard: \"EIP-1193\",\n        message: \"The requested method is not supported by this Ethereum provider.\"\n    },\n    4900: {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from all chains.\"\n    },\n    4901: {\n        standard: \"EIP-1193\",\n        message: \"The provider is disconnected from the specified chain.\"\n    }\n}, function(e) {\n    Object.defineProperty(e, \"__esModule\", {\n        value: !0\n    }), e.serializeError = e.isValidCode = e.getMessageFromCode = e.JSON_RPC_SERVER_ERROR_MESSAGE = void 0;\n    const t = Nu, n = Iu, r = t.errorCodes.rpc.internal, i = \"Unspecified error message. This is a bug, please report it.\", o = {\n        code: r,\n        message: s(r)\n    };\n    function s(n) {\n        let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : i;\n        if (Number.isInteger(n)) {\n            const r = n.toString();\n            if (d(t.errorValues, r)) return t.errorValues[r].message;\n            if (c(n)) return e.JSON_RPC_SERVER_ERROR_MESSAGE;\n        }\n        return r;\n    }\n    function a(e) {\n        if (!Number.isInteger(e)) return !1;\n        const n = e.toString();\n        return !!t.errorValues[n] || !!c(e);\n    }\n    function c(e) {\n        return e >= -32099 && e <= -32e3;\n    }\n    function l(e) {\n        return e && \"object\" == typeof e && !Array.isArray(e) ? Object.assign({}, e) : e;\n    }\n    function d(e, t) {\n        return Object.prototype.hasOwnProperty.call(e, t);\n    }\n    e.JSON_RPC_SERVER_ERROR_MESSAGE = \"Unspecified server error.\", e.getMessageFromCode = s, e.isValidCode = a, e.serializeError = function(e) {\n        let { fallbackError: t = o, shouldIncludeStack: r = !1 } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        var i, c;\n        if (!t || !Number.isInteger(t.code) || \"string\" != typeof t.message) throw new Error(\"Must provide fallback error with integer number code and string message.\");\n        if (e instanceof n.EthereumRpcError) return e.serialize();\n        const u = {};\n        if (e && \"object\" == typeof e && !Array.isArray(e) && d(e, \"code\") && a(e.code)) {\n            const t = e;\n            u.code = t.code, t.message && \"string\" == typeof t.message ? (u.message = t.message, d(t, \"data\") && (u.data = t.data)) : (u.message = s(u.code), u.data = {\n                originalError: l(e)\n            });\n        } else {\n            u.code = t.code;\n            const n = null === (i = e) || void 0 === i ? void 0 : i.message;\n            u.message = n && \"string\" == typeof n ? n : t.message, u.data = {\n                originalError: l(e)\n            };\n        }\n        const h = null === (c = e) || void 0 === c ? void 0 : c.stack;\n        return r && e && h && \"string\" == typeof h && (u.stack = h), u;\n    };\n}(Ou);\nvar Lu = {};\nObject.defineProperty(Lu, \"__esModule\", {\n    value: !0\n}), Lu.ethErrors = void 0;\nconst Du = Iu, $u = Ou, Bu = Nu;\nfunction Ku(e, t) {\n    const [n, r] = Uu(t);\n    return new Du.EthereumRpcError(e, n || $u.getMessageFromCode(e), r);\n}\n_c137 = Ku;\nfunction ju(e, t) {\n    const [n, r] = Uu(t);\n    return new Du.EthereumProviderError(e, n || $u.getMessageFromCode(e), r);\n}\nfunction Uu(e) {\n    if (e) {\n        if (\"string\" == typeof e) return [\n            e\n        ];\n        if (\"object\" == typeof e && !Array.isArray(e)) {\n            const { message: t, data: n } = e;\n            if (t && \"string\" != typeof t) throw new Error(\"Must specify string message.\");\n            return [\n                t || void 0,\n                n\n            ];\n        }\n    }\n    return [];\n}\n_c138 = Uu;\nLu.ethErrors = {\n    rpc: {\n        parse: (e)=>Ku(Bu.errorCodes.rpc.parse, e),\n        invalidRequest: (e)=>Ku(Bu.errorCodes.rpc.invalidRequest, e),\n        invalidParams: (e)=>Ku(Bu.errorCodes.rpc.invalidParams, e),\n        methodNotFound: (e)=>Ku(Bu.errorCodes.rpc.methodNotFound, e),\n        internal: (e)=>Ku(Bu.errorCodes.rpc.internal, e),\n        server: (e)=>{\n            if (!e || \"object\" != typeof e || Array.isArray(e)) throw new Error(\"Ethereum RPC Server errors must provide single object argument.\");\n            const { code: t } = e;\n            if (!Number.isInteger(t) || t > -32005 || t < -32099) throw new Error('\"code\" must be an integer such that: -32099 <= code <= -32005');\n            return Ku(t, e);\n        },\n        invalidInput: (e)=>Ku(Bu.errorCodes.rpc.invalidInput, e),\n        resourceNotFound: (e)=>Ku(Bu.errorCodes.rpc.resourceNotFound, e),\n        resourceUnavailable: (e)=>Ku(Bu.errorCodes.rpc.resourceUnavailable, e),\n        transactionRejected: (e)=>Ku(Bu.errorCodes.rpc.transactionRejected, e),\n        methodNotSupported: (e)=>Ku(Bu.errorCodes.rpc.methodNotSupported, e),\n        limitExceeded: (e)=>Ku(Bu.errorCodes.rpc.limitExceeded, e)\n    },\n    provider: {\n        userRejectedRequest: (e)=>ju(Bu.errorCodes.provider.userRejectedRequest, e),\n        unauthorized: (e)=>ju(Bu.errorCodes.provider.unauthorized, e),\n        unsupportedMethod: (e)=>ju(Bu.errorCodes.provider.unsupportedMethod, e),\n        disconnected: (e)=>ju(Bu.errorCodes.provider.disconnected, e),\n        chainDisconnected: (e)=>ju(Bu.errorCodes.provider.chainDisconnected, e),\n        custom: (e)=>{\n            if (!e || \"object\" != typeof e || Array.isArray(e)) throw new Error(\"Ethereum Provider custom errors must provide single object argument.\");\n            const { code: t, message: n, data: r } = e;\n            if (!n || \"string\" != typeof n) throw new Error('\"message\" must be a nonempty string');\n            return new Du.EthereumProviderError(t, n, r);\n        }\n    }\n}, function(e) {\n    Object.defineProperty(e, \"__esModule\", {\n        value: !0\n    }), e.getMessageFromCode = e.serializeError = e.EthereumProviderError = e.EthereumRpcError = e.ethErrors = e.errorCodes = void 0;\n    const t = Iu;\n    Object.defineProperty(e, \"EthereumRpcError\", {\n        enumerable: !0,\n        get: function() {\n            return t.EthereumRpcError;\n        }\n    }), Object.defineProperty(e, \"EthereumProviderError\", {\n        enumerable: !0,\n        get: function() {\n            return t.EthereumProviderError;\n        }\n    });\n    const n = Ou;\n    Object.defineProperty(e, \"serializeError\", {\n        enumerable: !0,\n        get: function() {\n            return n.serializeError;\n        }\n    }), Object.defineProperty(e, \"getMessageFromCode\", {\n        enumerable: !0,\n        get: function() {\n            return n.getMessageFromCode;\n        }\n    });\n    const r = Lu;\n    Object.defineProperty(e, \"ethErrors\", {\n        enumerable: !0,\n        get: function() {\n            return r.ethErrors;\n        }\n    });\n    const i = Nu;\n    Object.defineProperty(e, \"errorCodes\", {\n        enumerable: !0,\n        get: function() {\n            return i.errorCodes;\n        }\n    });\n}(Mu);\nvar Hu = {\n    exports: {}\n};\nHu.exports = function(e) {\n    var t = {};\n    function n(r) {\n        if (t[r]) return t[r].exports;\n        var i = t[r] = {\n            i: r,\n            l: !1,\n            exports: {}\n        };\n        return e[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports;\n    }\n    return n.m = e, n.c = t, n.d = function(e, t, r) {\n        n.o(e, t) || Object.defineProperty(e, t, {\n            enumerable: !0,\n            get: r\n        });\n    }, n.r = function(e) {\n        \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n            value: \"Module\"\n        }), Object.defineProperty(e, \"__esModule\", {\n            value: !0\n        });\n    }, n.t = function(e, t) {\n        if (1 & t && (e = n(e)), 8 & t) return e;\n        if (4 & t && \"object\" == typeof e && e && e.__esModule) return e;\n        var r = Object.create(null);\n        if (n.r(r), Object.defineProperty(r, \"default\", {\n            enumerable: !0,\n            value: e\n        }), 2 & t && \"string\" != typeof e) for(var i in e)n.d(r, i, (function(t) {\n            return e[t];\n        }).bind(null, i));\n        return r;\n    }, n.n = function(e) {\n        var t = e && e.__esModule ? function() {\n            return e.default;\n        } : function() {\n            return e;\n        };\n        return n.d(t, \"a\", t), t;\n    }, n.o = function(e, t) {\n        return Object.prototype.hasOwnProperty.call(e, t);\n    }, n.p = \"\", n(n.s = 90);\n}({\n    17: function(e, t, n) {\n        t.__esModule = !0, t.default = void 0;\n        var r = n(18), i = function() {\n            function e() {}\n            return e.getFirstMatch = function(e, t) {\n                var n = t.match(e);\n                return n && n.length > 0 && n[1] || \"\";\n            }, e.getSecondMatch = function(e, t) {\n                var n = t.match(e);\n                return n && n.length > 1 && n[2] || \"\";\n            }, e.matchAndReturnConst = function(e, t, n) {\n                if (e.test(t)) return n;\n            }, e.getWindowsVersionName = function(e) {\n                switch(e){\n                    case \"NT\":\n                        return \"NT\";\n                    case \"XP\":\n                    case \"NT 5.1\":\n                        return \"XP\";\n                    case \"NT 5.0\":\n                        return \"2000\";\n                    case \"NT 5.2\":\n                        return \"2003\";\n                    case \"NT 6.0\":\n                        return \"Vista\";\n                    case \"NT 6.1\":\n                        return \"7\";\n                    case \"NT 6.2\":\n                        return \"8\";\n                    case \"NT 6.3\":\n                        return \"8.1\";\n                    case \"NT 10.0\":\n                        return \"10\";\n                    default:\n                        return;\n                }\n            }, e.getMacOSVersionName = function(e) {\n                var t = e.split(\".\").splice(0, 2).map(function(e) {\n                    return parseInt(e, 10) || 0;\n                });\n                if (t.push(0), 10 === t[0]) switch(t[1]){\n                    case 5:\n                        return \"Leopard\";\n                    case 6:\n                        return \"Snow Leopard\";\n                    case 7:\n                        return \"Lion\";\n                    case 8:\n                        return \"Mountain Lion\";\n                    case 9:\n                        return \"Mavericks\";\n                    case 10:\n                        return \"Yosemite\";\n                    case 11:\n                        return \"El Capitan\";\n                    case 12:\n                        return \"Sierra\";\n                    case 13:\n                        return \"High Sierra\";\n                    case 14:\n                        return \"Mojave\";\n                    case 15:\n                        return \"Catalina\";\n                    default:\n                        return;\n                }\n            }, e.getAndroidVersionName = function(e) {\n                var t = e.split(\".\").splice(0, 2).map(function(e) {\n                    return parseInt(e, 10) || 0;\n                });\n                if (t.push(0), !(1 === t[0] && t[1] < 5)) return 1 === t[0] && t[1] < 6 ? \"Cupcake\" : 1 === t[0] && t[1] >= 6 ? \"Donut\" : 2 === t[0] && t[1] < 2 ? \"Eclair\" : 2 === t[0] && 2 === t[1] ? \"Froyo\" : 2 === t[0] && t[1] > 2 ? \"Gingerbread\" : 3 === t[0] ? \"Honeycomb\" : 4 === t[0] && t[1] < 1 ? \"Ice Cream Sandwich\" : 4 === t[0] && t[1] < 4 ? \"Jelly Bean\" : 4 === t[0] && t[1] >= 4 ? \"KitKat\" : 5 === t[0] ? \"Lollipop\" : 6 === t[0] ? \"Marshmallow\" : 7 === t[0] ? \"Nougat\" : 8 === t[0] ? \"Oreo\" : 9 === t[0] ? \"Pie\" : void 0;\n            }, e.getVersionPrecision = function(e) {\n                return e.split(\".\").length;\n            }, e.compareVersions = function(t, n, r) {\n                void 0 === r && (r = !1);\n                var i = e.getVersionPrecision(t), o = e.getVersionPrecision(n), s = Math.max(i, o), a = 0, c = e.map([\n                    t,\n                    n\n                ], function(t) {\n                    var n = s - e.getVersionPrecision(t), r = t + new Array(n + 1).join(\".0\");\n                    return e.map(r.split(\".\"), function(e) {\n                        return new Array(20 - e.length).join(\"0\") + e;\n                    }).reverse();\n                });\n                for(r && (a = s - Math.min(i, o)), s -= 1; s >= a;){\n                    if (c[0][s] > c[1][s]) return 1;\n                    if (c[0][s] === c[1][s]) {\n                        if (s === a) return 0;\n                        s -= 1;\n                    } else if (c[0][s] < c[1][s]) return -1;\n                }\n            }, e.map = function(e, t) {\n                var n, r = [];\n                if (Array.prototype.map) return Array.prototype.map.call(e, t);\n                for(n = 0; n < e.length; n += 1)r.push(t(e[n]));\n                return r;\n            }, e.find = function(e, t) {\n                var n, r;\n                if (Array.prototype.find) return Array.prototype.find.call(e, t);\n                for(n = 0, r = e.length; n < r; n += 1){\n                    var i = e[n];\n                    if (t(i, n)) return i;\n                }\n            }, e.assign = function(e) {\n                for(var t, n, r = e, i = arguments.length, o = new Array(i > 1 ? i - 1 : 0), s = 1; s < i; s++)o[s - 1] = arguments[s];\n                if (Object.assign) return Object.assign.apply(Object, [\n                    e\n                ].concat(o));\n                var a = function() {\n                    var e = o[t];\n                    \"object\" == typeof e && null !== e && Object.keys(e).forEach(function(t) {\n                        r[t] = e[t];\n                    });\n                };\n                for(t = 0, n = o.length; t < n; t += 1)a();\n                return e;\n            }, e.getBrowserAlias = function(e) {\n                return r.BROWSER_ALIASES_MAP[e];\n            }, e.getBrowserTypeByAlias = function(e) {\n                return r.BROWSER_MAP[e] || \"\";\n            }, e;\n        }();\n        t.default = i, e.exports = t.default;\n    },\n    18: function(e, t, n) {\n        t.__esModule = !0, t.ENGINE_MAP = t.OS_MAP = t.PLATFORMS_MAP = t.BROWSER_MAP = t.BROWSER_ALIASES_MAP = void 0, t.BROWSER_ALIASES_MAP = {\n            \"Amazon Silk\": \"amazon_silk\",\n            \"Android Browser\": \"android\",\n            Bada: \"bada\",\n            BlackBerry: \"blackberry\",\n            Chrome: \"chrome\",\n            Chromium: \"chromium\",\n            Electron: \"electron\",\n            Epiphany: \"epiphany\",\n            Firefox: \"firefox\",\n            Focus: \"focus\",\n            Generic: \"generic\",\n            \"Google Search\": \"google_search\",\n            Googlebot: \"googlebot\",\n            \"Internet Explorer\": \"ie\",\n            \"K-Meleon\": \"k_meleon\",\n            Maxthon: \"maxthon\",\n            \"Microsoft Edge\": \"edge\",\n            \"MZ Browser\": \"mz\",\n            \"NAVER Whale Browser\": \"naver\",\n            Opera: \"opera\",\n            \"Opera Coast\": \"opera_coast\",\n            PhantomJS: \"phantomjs\",\n            Puffin: \"puffin\",\n            QupZilla: \"qupzilla\",\n            QQ: \"qq\",\n            QQLite: \"qqlite\",\n            Safari: \"safari\",\n            Sailfish: \"sailfish\",\n            \"Samsung Internet for Android\": \"samsung_internet\",\n            SeaMonkey: \"seamonkey\",\n            Sleipnir: \"sleipnir\",\n            Swing: \"swing\",\n            Tizen: \"tizen\",\n            \"UC Browser\": \"uc\",\n            Vivaldi: \"vivaldi\",\n            \"WebOS Browser\": \"webos\",\n            WeChat: \"wechat\",\n            \"Yandex Browser\": \"yandex\",\n            Roku: \"roku\"\n        }, t.BROWSER_MAP = {\n            amazon_silk: \"Amazon Silk\",\n            android: \"Android Browser\",\n            bada: \"Bada\",\n            blackberry: \"BlackBerry\",\n            chrome: \"Chrome\",\n            chromium: \"Chromium\",\n            electron: \"Electron\",\n            epiphany: \"Epiphany\",\n            firefox: \"Firefox\",\n            focus: \"Focus\",\n            generic: \"Generic\",\n            googlebot: \"Googlebot\",\n            google_search: \"Google Search\",\n            ie: \"Internet Explorer\",\n            k_meleon: \"K-Meleon\",\n            maxthon: \"Maxthon\",\n            edge: \"Microsoft Edge\",\n            mz: \"MZ Browser\",\n            naver: \"NAVER Whale Browser\",\n            opera: \"Opera\",\n            opera_coast: \"Opera Coast\",\n            phantomjs: \"PhantomJS\",\n            puffin: \"Puffin\",\n            qupzilla: \"QupZilla\",\n            qq: \"QQ Browser\",\n            qqlite: \"QQ Browser Lite\",\n            safari: \"Safari\",\n            sailfish: \"Sailfish\",\n            samsung_internet: \"Samsung Internet for Android\",\n            seamonkey: \"SeaMonkey\",\n            sleipnir: \"Sleipnir\",\n            swing: \"Swing\",\n            tizen: \"Tizen\",\n            uc: \"UC Browser\",\n            vivaldi: \"Vivaldi\",\n            webos: \"WebOS Browser\",\n            wechat: \"WeChat\",\n            yandex: \"Yandex Browser\"\n        }, t.PLATFORMS_MAP = {\n            tablet: \"tablet\",\n            mobile: \"mobile\",\n            desktop: \"desktop\",\n            tv: \"tv\"\n        }, t.OS_MAP = {\n            WindowsPhone: \"Windows Phone\",\n            Windows: \"Windows\",\n            MacOS: \"macOS\",\n            iOS: \"iOS\",\n            Android: \"Android\",\n            WebOS: \"WebOS\",\n            BlackBerry: \"BlackBerry\",\n            Bada: \"Bada\",\n            Tizen: \"Tizen\",\n            Linux: \"Linux\",\n            ChromeOS: \"Chrome OS\",\n            PlayStation4: \"PlayStation 4\",\n            Roku: \"Roku\"\n        }, t.ENGINE_MAP = {\n            EdgeHTML: \"EdgeHTML\",\n            Blink: \"Blink\",\n            Trident: \"Trident\",\n            Presto: \"Presto\",\n            Gecko: \"Gecko\",\n            WebKit: \"WebKit\"\n        };\n    },\n    90: function(e, t, n) {\n        t.__esModule = !0, t.default = void 0;\n        var r, i = (r = n(91)) && r.__esModule ? r : {\n            default: r\n        }, o = n(18);\n        function s(e, t) {\n            for(var n = 0; n < t.length; n++){\n                var r = t[n];\n                r.enumerable = r.enumerable || !1, r.configurable = !0, \"value\" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);\n            }\n        }\n        var a = function() {\n            function e() {}\n            var t, n, r;\n            return e.getParser = function(e, t) {\n                if (void 0 === t && (t = !1), \"string\" != typeof e) throw new Error(\"UserAgent should be a string\");\n                return new i.default(e, t);\n            }, e.parse = function(e) {\n                return new i.default(e).getResult();\n            }, t = e, r = [\n                {\n                    key: \"BROWSER_MAP\",\n                    get: function() {\n                        return o.BROWSER_MAP;\n                    }\n                },\n                {\n                    key: \"ENGINE_MAP\",\n                    get: function() {\n                        return o.ENGINE_MAP;\n                    }\n                },\n                {\n                    key: \"OS_MAP\",\n                    get: function() {\n                        return o.OS_MAP;\n                    }\n                },\n                {\n                    key: \"PLATFORMS_MAP\",\n                    get: function() {\n                        return o.PLATFORMS_MAP;\n                    }\n                }\n            ], (n = null) && s(t.prototype, n), r && s(t, r), e;\n        }();\n        t.default = a, e.exports = t.default;\n    },\n    91: function(e, t, n) {\n        t.__esModule = !0, t.default = void 0;\n        var r = c(n(92)), i = c(n(93)), o = c(n(94)), s = c(n(95)), a = c(n(17));\n        function c(e) {\n            return e && e.__esModule ? e : {\n                default: e\n            };\n        }\n        var l = function() {\n            function e(e, t) {\n                if (void 0 === t && (t = !1), null == e || \"\" === e) throw new Error(\"UserAgent parameter can't be empty\");\n                this._ua = e, this.parsedResult = {}, !0 !== t && this.parse();\n            }\n            var t = e.prototype;\n            return t.getUA = function() {\n                return this._ua;\n            }, t.test = function(e) {\n                return e.test(this._ua);\n            }, t.parseBrowser = function() {\n                var e = this;\n                this.parsedResult.browser = {};\n                var t = a.default.find(r.default, function(t) {\n                    if (\"function\" == typeof t.test) return t.test(e);\n                    if (t.test instanceof Array) return t.test.some(function(t) {\n                        return e.test(t);\n                    });\n                    throw new Error(\"Browser's test function is not valid\");\n                });\n                return t && (this.parsedResult.browser = t.describe(this.getUA())), this.parsedResult.browser;\n            }, t.getBrowser = function() {\n                return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();\n            }, t.getBrowserName = function(e) {\n                return e ? String(this.getBrowser().name).toLowerCase() || \"\" : this.getBrowser().name || \"\";\n            }, t.getBrowserVersion = function() {\n                return this.getBrowser().version;\n            }, t.getOS = function() {\n                return this.parsedResult.os ? this.parsedResult.os : this.parseOS();\n            }, t.parseOS = function() {\n                var e = this;\n                this.parsedResult.os = {};\n                var t = a.default.find(i.default, function(t) {\n                    if (\"function\" == typeof t.test) return t.test(e);\n                    if (t.test instanceof Array) return t.test.some(function(t) {\n                        return e.test(t);\n                    });\n                    throw new Error(\"Browser's test function is not valid\");\n                });\n                return t && (this.parsedResult.os = t.describe(this.getUA())), this.parsedResult.os;\n            }, t.getOSName = function(e) {\n                var t = this.getOS().name;\n                return e ? String(t).toLowerCase() || \"\" : t || \"\";\n            }, t.getOSVersion = function() {\n                return this.getOS().version;\n            }, t.getPlatform = function() {\n                return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();\n            }, t.getPlatformType = function(e) {\n                void 0 === e && (e = !1);\n                var t = this.getPlatform().type;\n                return e ? String(t).toLowerCase() || \"\" : t || \"\";\n            }, t.parsePlatform = function() {\n                var e = this;\n                this.parsedResult.platform = {};\n                var t = a.default.find(o.default, function(t) {\n                    if (\"function\" == typeof t.test) return t.test(e);\n                    if (t.test instanceof Array) return t.test.some(function(t) {\n                        return e.test(t);\n                    });\n                    throw new Error(\"Browser's test function is not valid\");\n                });\n                return t && (this.parsedResult.platform = t.describe(this.getUA())), this.parsedResult.platform;\n            }, t.getEngine = function() {\n                return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();\n            }, t.getEngineName = function(e) {\n                return e ? String(this.getEngine().name).toLowerCase() || \"\" : this.getEngine().name || \"\";\n            }, t.parseEngine = function() {\n                var e = this;\n                this.parsedResult.engine = {};\n                var t = a.default.find(s.default, function(t) {\n                    if (\"function\" == typeof t.test) return t.test(e);\n                    if (t.test instanceof Array) return t.test.some(function(t) {\n                        return e.test(t);\n                    });\n                    throw new Error(\"Browser's test function is not valid\");\n                });\n                return t && (this.parsedResult.engine = t.describe(this.getUA())), this.parsedResult.engine;\n            }, t.parse = function() {\n                return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;\n            }, t.getResult = function() {\n                return a.default.assign({}, this.parsedResult);\n            }, t.satisfies = function(e) {\n                var t = this, n = {}, r = 0, i = {}, o = 0;\n                if (Object.keys(e).forEach(function(t) {\n                    var s = e[t];\n                    \"string\" == typeof s ? (i[t] = s, o += 1) : \"object\" == typeof s && (n[t] = s, r += 1);\n                }), r > 0) {\n                    var s = Object.keys(n), c = a.default.find(s, function(e) {\n                        return t.isOS(e);\n                    });\n                    if (c) {\n                        var l = this.satisfies(n[c]);\n                        if (void 0 !== l) return l;\n                    }\n                    var d = a.default.find(s, function(e) {\n                        return t.isPlatform(e);\n                    });\n                    if (d) {\n                        var u = this.satisfies(n[d]);\n                        if (void 0 !== u) return u;\n                    }\n                }\n                if (o > 0) {\n                    var h = Object.keys(i), f = a.default.find(h, function(e) {\n                        return t.isBrowser(e, !0);\n                    });\n                    if (void 0 !== f) return this.compareVersion(i[f]);\n                }\n            }, t.isBrowser = function(e, t) {\n                void 0 === t && (t = !1);\n                var n = this.getBrowserName().toLowerCase(), r = e.toLowerCase(), i = a.default.getBrowserTypeByAlias(r);\n                return t && i && (r = i.toLowerCase()), r === n;\n            }, t.compareVersion = function(e) {\n                var t = [\n                    0\n                ], n = e, r = !1, i = this.getBrowserVersion();\n                if (\"string\" == typeof i) return \">\" === e[0] || \"<\" === e[0] ? (n = e.substr(1), \"=\" === e[1] ? (r = !0, n = e.substr(2)) : t = [], \">\" === e[0] ? t.push(1) : t.push(-1)) : \"=\" === e[0] ? n = e.substr(1) : \"~\" === e[0] && (r = !0, n = e.substr(1)), t.indexOf(a.default.compareVersions(i, n, r)) > -1;\n            }, t.isOS = function(e) {\n                return this.getOSName(!0) === String(e).toLowerCase();\n            }, t.isPlatform = function(e) {\n                return this.getPlatformType(!0) === String(e).toLowerCase();\n            }, t.isEngine = function(e) {\n                return this.getEngineName(!0) === String(e).toLowerCase();\n            }, t.is = function(e, t) {\n                return void 0 === t && (t = !1), this.isBrowser(e, t) || this.isOS(e) || this.isPlatform(e);\n            }, t.some = function(e) {\n                var t = this;\n                return void 0 === e && (e = []), e.some(function(e) {\n                    return t.is(e);\n                });\n            }, e;\n        }();\n        t.default = l, e.exports = t.default;\n    },\n    92: function(e, t, n) {\n        t.__esModule = !0, t.default = void 0;\n        var r, i = (r = n(17)) && r.__esModule ? r : {\n            default: r\n        }, o = /version\\/(\\d+(\\.?_?\\d+)+)/i, s = [\n            {\n                test: [\n                    /googlebot/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Googlebot\"\n                    }, n = i.default.getFirstMatch(/googlebot\\/(\\d+(\\.\\d+))/i, e) || i.default.getFirstMatch(o, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /opera/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Opera\"\n                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:opera)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /opr\\/|opios/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Opera\"\n                    }, n = i.default.getFirstMatch(/(?:opr|opios)[\\s/](\\S+)/i, e) || i.default.getFirstMatch(o, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /SamsungBrowser/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Samsung Internet for Android\"\n                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:SamsungBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /Whale/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"NAVER Whale Browser\"\n                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:whale)[\\s/](\\d+(?:\\.\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /MZBrowser/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"MZ Browser\"\n                    }, n = i.default.getFirstMatch(/(?:MZBrowser)[\\s/](\\d+(?:\\.\\d+)+)/i, e) || i.default.getFirstMatch(o, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /focus/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Focus\"\n                    }, n = i.default.getFirstMatch(/(?:focus)[\\s/](\\d+(?:\\.\\d+)+)/i, e) || i.default.getFirstMatch(o, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /swing/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Swing\"\n                    }, n = i.default.getFirstMatch(/(?:swing)[\\s/](\\d+(?:\\.\\d+)+)/i, e) || i.default.getFirstMatch(o, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /coast/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Opera Coast\"\n                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:coast)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /opt\\/\\d+(?:.?_?\\d+)+/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Opera Touch\"\n                    }, n = i.default.getFirstMatch(/(?:opt)[\\s/](\\d+(\\.?_?\\d+)+)/i, e) || i.default.getFirstMatch(o, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /yabrowser/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Yandex Browser\"\n                    }, n = i.default.getFirstMatch(/(?:yabrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i, e) || i.default.getFirstMatch(o, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /ucbrowser/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"UC Browser\"\n                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:ucbrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /Maxthon|mxios/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Maxthon\"\n                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:Maxthon|mxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /epiphany/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Epiphany\"\n                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:epiphany)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /puffin/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Puffin\"\n                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:puffin)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /sleipnir/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Sleipnir\"\n                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:sleipnir)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /k-meleon/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"K-Meleon\"\n                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/(?:k-meleon)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /micromessenger/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"WeChat\"\n                    }, n = i.default.getFirstMatch(/(?:micromessenger)[\\s/](\\d+(\\.?_?\\d+)+)/i, e) || i.default.getFirstMatch(o, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /qqbrowser/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: /qqbrowserlite/i.test(e) ? \"QQ Browser Lite\" : \"QQ Browser\"\n                    }, n = i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\\d+(\\.?_?\\d+)+)/i, e) || i.default.getFirstMatch(o, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /msie|trident/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Internet Explorer\"\n                    }, n = i.default.getFirstMatch(/(?:msie |rv:)(\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /\\sedg\\//i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Microsoft Edge\"\n                    }, n = i.default.getFirstMatch(/\\sedg\\/(\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /edg([ea]|ios)/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Microsoft Edge\"\n                    }, n = i.default.getSecondMatch(/edg([ea]|ios)\\/(\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /vivaldi/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Vivaldi\"\n                    }, n = i.default.getFirstMatch(/vivaldi\\/(\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /seamonkey/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"SeaMonkey\"\n                    }, n = i.default.getFirstMatch(/seamonkey\\/(\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /sailfish/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Sailfish\"\n                    }, n = i.default.getFirstMatch(/sailfish\\s?browser\\/(\\d+(\\.\\d+)?)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /silk/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Amazon Silk\"\n                    }, n = i.default.getFirstMatch(/silk\\/(\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /phantom/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"PhantomJS\"\n                    }, n = i.default.getFirstMatch(/phantomjs\\/(\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /slimerjs/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"SlimerJS\"\n                    }, n = i.default.getFirstMatch(/slimerjs\\/(\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /blackberry|\\bbb\\d+/i,\n                    /rim\\stablet/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"BlackBerry\"\n                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/blackberry[\\d]+\\/(\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /(web|hpw)[o0]s/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"WebOS Browser\"\n                    }, n = i.default.getFirstMatch(o, e) || i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\\/(\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /bada/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Bada\"\n                    }, n = i.default.getFirstMatch(/dolfin\\/(\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /tizen/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Tizen\"\n                    }, n = i.default.getFirstMatch(/(?:tizen\\s?)?browser\\/(\\d+(\\.?_?\\d+)+)/i, e) || i.default.getFirstMatch(o, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /qupzilla/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"QupZilla\"\n                    }, n = i.default.getFirstMatch(/(?:qupzilla)[\\s/](\\d+(\\.?_?\\d+)+)/i, e) || i.default.getFirstMatch(o, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /firefox|iceweasel|fxios/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Firefox\"\n                    }, n = i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /electron/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Electron\"\n                    }, n = i.default.getFirstMatch(/(?:electron)\\/(\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /MiuiBrowser/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Miui\"\n                    }, n = i.default.getFirstMatch(/(?:MiuiBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /chromium/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Chromium\"\n                    }, n = i.default.getFirstMatch(/(?:chromium)[\\s/](\\d+(\\.?_?\\d+)+)/i, e) || i.default.getFirstMatch(o, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /chrome|crios|crmo/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Chrome\"\n                    }, n = i.default.getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /GSA/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Google Search\"\n                    }, n = i.default.getFirstMatch(/(?:GSA)\\/(\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: function(e) {\n                    var t = !e.test(/like android/i), n = e.test(/android/i);\n                    return t && n;\n                },\n                describe: function(e) {\n                    var t = {\n                        name: \"Android Browser\"\n                    }, n = i.default.getFirstMatch(o, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /playstation 4/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"PlayStation 4\"\n                    }, n = i.default.getFirstMatch(o, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /safari|applewebkit/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: \"Safari\"\n                    }, n = i.default.getFirstMatch(o, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /.*/i\n                ],\n                describe: function(e) {\n                    var t = -1 !== e.search(\"\\\\(\") ? /^(.*)\\/(.*)[ \\t]\\((.*)/ : /^(.*)\\/(.*) /;\n                    return {\n                        name: i.default.getFirstMatch(t, e),\n                        version: i.default.getSecondMatch(t, e)\n                    };\n                }\n            }\n        ];\n        t.default = s, e.exports = t.default;\n    },\n    93: function(e, t, n) {\n        t.__esModule = !0, t.default = void 0;\n        var r, i = (r = n(17)) && r.__esModule ? r : {\n            default: r\n        }, o = n(18), s = [\n            {\n                test: [\n                    /Roku\\/DVP/\n                ],\n                describe: function(e) {\n                    var t = i.default.getFirstMatch(/Roku\\/DVP-(\\d+\\.\\d+)/i, e);\n                    return {\n                        name: o.OS_MAP.Roku,\n                        version: t\n                    };\n                }\n            },\n            {\n                test: [\n                    /windows phone/i\n                ],\n                describe: function(e) {\n                    var t = i.default.getFirstMatch(/windows phone (?:os)?\\s?(\\d+(\\.\\d+)*)/i, e);\n                    return {\n                        name: o.OS_MAP.WindowsPhone,\n                        version: t\n                    };\n                }\n            },\n            {\n                test: [\n                    /windows /i\n                ],\n                describe: function(e) {\n                    var t = i.default.getFirstMatch(/Windows ((NT|XP)( \\d\\d?.\\d)?)/i, e), n = i.default.getWindowsVersionName(t);\n                    return {\n                        name: o.OS_MAP.Windows,\n                        version: t,\n                        versionName: n\n                    };\n                }\n            },\n            {\n                test: [\n                    /Macintosh(.*?) FxiOS(.*?)\\//\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: o.OS_MAP.iOS\n                    }, n = i.default.getSecondMatch(/(Version\\/)(\\d[\\d.]+)/, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /macintosh/i\n                ],\n                describe: function(e) {\n                    var t = i.default.getFirstMatch(/mac os x (\\d+(\\.?_?\\d+)+)/i, e).replace(/[_\\s]/g, \".\"), n = i.default.getMacOSVersionName(t), r = {\n                        name: o.OS_MAP.MacOS,\n                        version: t\n                    };\n                    return n && (r.versionName = n), r;\n                }\n            },\n            {\n                test: [\n                    /(ipod|iphone|ipad)/i\n                ],\n                describe: function(e) {\n                    var t = i.default.getFirstMatch(/os (\\d+([_\\s]\\d+)*) like mac os x/i, e).replace(/[_\\s]/g, \".\");\n                    return {\n                        name: o.OS_MAP.iOS,\n                        version: t\n                    };\n                }\n            },\n            {\n                test: function(e) {\n                    var t = !e.test(/like android/i), n = e.test(/android/i);\n                    return t && n;\n                },\n                describe: function(e) {\n                    var t = i.default.getFirstMatch(/android[\\s/-](\\d+(\\.\\d+)*)/i, e), n = i.default.getAndroidVersionName(t), r = {\n                        name: o.OS_MAP.Android,\n                        version: t\n                    };\n                    return n && (r.versionName = n), r;\n                }\n            },\n            {\n                test: [\n                    /(web|hpw)[o0]s/i\n                ],\n                describe: function(e) {\n                    var t = i.default.getFirstMatch(/(?:web|hpw)[o0]s\\/(\\d+(\\.\\d+)*)/i, e), n = {\n                        name: o.OS_MAP.WebOS\n                    };\n                    return t && t.length && (n.version = t), n;\n                }\n            },\n            {\n                test: [\n                    /blackberry|\\bbb\\d+/i,\n                    /rim\\stablet/i\n                ],\n                describe: function(e) {\n                    var t = i.default.getFirstMatch(/rim\\stablet\\sos\\s(\\d+(\\.\\d+)*)/i, e) || i.default.getFirstMatch(/blackberry\\d+\\/(\\d+([_\\s]\\d+)*)/i, e) || i.default.getFirstMatch(/\\bbb(\\d+)/i, e);\n                    return {\n                        name: o.OS_MAP.BlackBerry,\n                        version: t\n                    };\n                }\n            },\n            {\n                test: [\n                    /bada/i\n                ],\n                describe: function(e) {\n                    var t = i.default.getFirstMatch(/bada\\/(\\d+(\\.\\d+)*)/i, e);\n                    return {\n                        name: o.OS_MAP.Bada,\n                        version: t\n                    };\n                }\n            },\n            {\n                test: [\n                    /tizen/i\n                ],\n                describe: function(e) {\n                    var t = i.default.getFirstMatch(/tizen[/\\s](\\d+(\\.\\d+)*)/i, e);\n                    return {\n                        name: o.OS_MAP.Tizen,\n                        version: t\n                    };\n                }\n            },\n            {\n                test: [\n                    /linux/i\n                ],\n                describe: function() {\n                    return {\n                        name: o.OS_MAP.Linux\n                    };\n                }\n            },\n            {\n                test: [\n                    /CrOS/\n                ],\n                describe: function() {\n                    return {\n                        name: o.OS_MAP.ChromeOS\n                    };\n                }\n            },\n            {\n                test: [\n                    /PlayStation 4/\n                ],\n                describe: function(e) {\n                    var t = i.default.getFirstMatch(/PlayStation 4[/\\s](\\d+(\\.\\d+)*)/i, e);\n                    return {\n                        name: o.OS_MAP.PlayStation4,\n                        version: t\n                    };\n                }\n            }\n        ];\n        t.default = s, e.exports = t.default;\n    },\n    94: function(e, t, n) {\n        t.__esModule = !0, t.default = void 0;\n        var r, i = (r = n(17)) && r.__esModule ? r : {\n            default: r\n        }, o = n(18), s = [\n            {\n                test: [\n                    /googlebot/i\n                ],\n                describe: function() {\n                    return {\n                        type: \"bot\",\n                        vendor: \"Google\"\n                    };\n                }\n            },\n            {\n                test: [\n                    /huawei/i\n                ],\n                describe: function(e) {\n                    var t = i.default.getFirstMatch(/(can-l01)/i, e) && \"Nova\", n = {\n                        type: o.PLATFORMS_MAP.mobile,\n                        vendor: \"Huawei\"\n                    };\n                    return t && (n.model = t), n;\n                }\n            },\n            {\n                test: [\n                    /nexus\\s*(?:7|8|9|10).*/i\n                ],\n                describe: function() {\n                    return {\n                        type: o.PLATFORMS_MAP.tablet,\n                        vendor: \"Nexus\"\n                    };\n                }\n            },\n            {\n                test: [\n                    /ipad/i\n                ],\n                describe: function() {\n                    return {\n                        type: o.PLATFORMS_MAP.tablet,\n                        vendor: \"Apple\",\n                        model: \"iPad\"\n                    };\n                }\n            },\n            {\n                test: [\n                    /Macintosh(.*?) FxiOS(.*?)\\//\n                ],\n                describe: function() {\n                    return {\n                        type: o.PLATFORMS_MAP.tablet,\n                        vendor: \"Apple\",\n                        model: \"iPad\"\n                    };\n                }\n            },\n            {\n                test: [\n                    /kftt build/i\n                ],\n                describe: function() {\n                    return {\n                        type: o.PLATFORMS_MAP.tablet,\n                        vendor: \"Amazon\",\n                        model: \"Kindle Fire HD 7\"\n                    };\n                }\n            },\n            {\n                test: [\n                    /silk/i\n                ],\n                describe: function() {\n                    return {\n                        type: o.PLATFORMS_MAP.tablet,\n                        vendor: \"Amazon\"\n                    };\n                }\n            },\n            {\n                test: [\n                    /tablet(?! pc)/i\n                ],\n                describe: function() {\n                    return {\n                        type: o.PLATFORMS_MAP.tablet\n                    };\n                }\n            },\n            {\n                test: function(e) {\n                    var t = e.test(/ipod|iphone/i), n = e.test(/like (ipod|iphone)/i);\n                    return t && !n;\n                },\n                describe: function(e) {\n                    var t = i.default.getFirstMatch(/(ipod|iphone)/i, e);\n                    return {\n                        type: o.PLATFORMS_MAP.mobile,\n                        vendor: \"Apple\",\n                        model: t\n                    };\n                }\n            },\n            {\n                test: [\n                    /nexus\\s*[0-6].*/i,\n                    /galaxy nexus/i\n                ],\n                describe: function() {\n                    return {\n                        type: o.PLATFORMS_MAP.mobile,\n                        vendor: \"Nexus\"\n                    };\n                }\n            },\n            {\n                test: [\n                    /[^-]mobi/i\n                ],\n                describe: function() {\n                    return {\n                        type: o.PLATFORMS_MAP.mobile\n                    };\n                }\n            },\n            {\n                test: function(e) {\n                    return \"blackberry\" === e.getBrowserName(!0);\n                },\n                describe: function() {\n                    return {\n                        type: o.PLATFORMS_MAP.mobile,\n                        vendor: \"BlackBerry\"\n                    };\n                }\n            },\n            {\n                test: function(e) {\n                    return \"bada\" === e.getBrowserName(!0);\n                },\n                describe: function() {\n                    return {\n                        type: o.PLATFORMS_MAP.mobile\n                    };\n                }\n            },\n            {\n                test: function(e) {\n                    return \"windows phone\" === e.getBrowserName();\n                },\n                describe: function() {\n                    return {\n                        type: o.PLATFORMS_MAP.mobile,\n                        vendor: \"Microsoft\"\n                    };\n                }\n            },\n            {\n                test: function(e) {\n                    var t = Number(String(e.getOSVersion()).split(\".\")[0]);\n                    return \"android\" === e.getOSName(!0) && t >= 3;\n                },\n                describe: function() {\n                    return {\n                        type: o.PLATFORMS_MAP.tablet\n                    };\n                }\n            },\n            {\n                test: function(e) {\n                    return \"android\" === e.getOSName(!0);\n                },\n                describe: function() {\n                    return {\n                        type: o.PLATFORMS_MAP.mobile\n                    };\n                }\n            },\n            {\n                test: function(e) {\n                    return \"macos\" === e.getOSName(!0);\n                },\n                describe: function() {\n                    return {\n                        type: o.PLATFORMS_MAP.desktop,\n                        vendor: \"Apple\"\n                    };\n                }\n            },\n            {\n                test: function(e) {\n                    return \"windows\" === e.getOSName(!0);\n                },\n                describe: function() {\n                    return {\n                        type: o.PLATFORMS_MAP.desktop\n                    };\n                }\n            },\n            {\n                test: function(e) {\n                    return \"linux\" === e.getOSName(!0);\n                },\n                describe: function() {\n                    return {\n                        type: o.PLATFORMS_MAP.desktop\n                    };\n                }\n            },\n            {\n                test: function(e) {\n                    return \"playstation 4\" === e.getOSName(!0);\n                },\n                describe: function() {\n                    return {\n                        type: o.PLATFORMS_MAP.tv\n                    };\n                }\n            },\n            {\n                test: function(e) {\n                    return \"roku\" === e.getOSName(!0);\n                },\n                describe: function() {\n                    return {\n                        type: o.PLATFORMS_MAP.tv\n                    };\n                }\n            }\n        ];\n        t.default = s, e.exports = t.default;\n    },\n    95: function(e, t, n) {\n        t.__esModule = !0, t.default = void 0;\n        var r, i = (r = n(17)) && r.__esModule ? r : {\n            default: r\n        }, o = n(18), s = [\n            {\n                test: function(e) {\n                    return \"microsoft edge\" === e.getBrowserName(!0);\n                },\n                describe: function(e) {\n                    if (/\\sedg\\//i.test(e)) return {\n                        name: o.ENGINE_MAP.Blink\n                    };\n                    var t = i.default.getFirstMatch(/edge\\/(\\d+(\\.?_?\\d+)+)/i, e);\n                    return {\n                        name: o.ENGINE_MAP.EdgeHTML,\n                        version: t\n                    };\n                }\n            },\n            {\n                test: [\n                    /trident/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: o.ENGINE_MAP.Trident\n                    }, n = i.default.getFirstMatch(/trident\\/(\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: function(e) {\n                    return e.test(/presto/i);\n                },\n                describe: function(e) {\n                    var t = {\n                        name: o.ENGINE_MAP.Presto\n                    }, n = i.default.getFirstMatch(/presto\\/(\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: function(e) {\n                    var t = e.test(/gecko/i), n = e.test(/like gecko/i);\n                    return t && !n;\n                },\n                describe: function(e) {\n                    var t = {\n                        name: o.ENGINE_MAP.Gecko\n                    }, n = i.default.getFirstMatch(/gecko\\/(\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            },\n            {\n                test: [\n                    /(apple)?webkit\\/537\\.36/i\n                ],\n                describe: function() {\n                    return {\n                        name: o.ENGINE_MAP.Blink\n                    };\n                }\n            },\n            {\n                test: [\n                    /(apple)?webkit/i\n                ],\n                describe: function(e) {\n                    var t = {\n                        name: o.ENGINE_MAP.WebKit\n                    }, n = i.default.getFirstMatch(/webkit\\/(\\d+(\\.?_?\\d+)+)/i, e);\n                    return n && (t.version = n), t;\n                }\n            }\n        ];\n        t.default = s, e.exports = t.default;\n    }\n});\nvar Fu = ue(Hu.exports);\nconst zu = {\n    Initialized: \"initialized\",\n    DisplayURI: \"display_uri\",\n    ProviderUpdate: \"provider_update\",\n    ConnectWithResponse: \"connectWithResponse\",\n    ConnectionStatus: \"connection_status\",\n    ServiceStatus: \"service_status\"\n};\nclass qu {\n    static init(e) {\n        var t;\n        return Au(\"[Ethereum: init()] Initializing Ethereum service\"), this.instance = new qu(e), null === (t = this.instance) || void 0 === t ? void 0 : t.provider;\n    }\n    static destroy() {}\n    static getInstance() {\n        var e;\n        if (!(null === (e = this.instance) || void 0 === e ? void 0 : e.provider)) throw new Error(\"Ethereum instance not intiialized - call Ethereum.factory first.\");\n        return this.instance;\n    }\n    static getProvider() {\n        var e;\n        if (!(null === (e = this.instance) || void 0 === e ? void 0 : e.provider)) throw new Error(\"Ethereum instance not intiialized - call Ethereum.factory first.\");\n        return this.instance.provider;\n    }\n    constructor({ shouldSetOnWindow: e, connectionStream: t, shouldSendMetadata: n = !1, shouldShimWeb3: r, sdkInstance: i }){\n        const o = new Gu({\n            connectionStream: t,\n            shouldSendMetadata: n,\n            shouldSetOnWindow: e,\n            shouldShimWeb3: r,\n            autoRequestAccounts: !1\n        }), s = new Proxy(o, {\n            deleteProperty: ()=>!0\n        });\n        if (this.provider = s, this.sdkInstance = i, e && \"undefined\" != \"object\") try {\n            a = o, window.ethereum = a, window.dispatchEvent(new Event(\"ethereum#initialized\"));\n        } catch (e) {\n            Au(\"[Ethereum] Unable to set global provider - window.ethereum may be read-only\", e);\n        }\n        var a;\n        if (r && \"undefined\" != \"object\") try {\n            !function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : console;\n                let n = !1, r = !1;\n                if (!window.web3) {\n                    const i = \"__isMetaMaskShim__\";\n                    let o = {\n                        currentProvider: e\n                    };\n                    Object.defineProperty(o, i, {\n                        value: !0,\n                        enumerable: !0,\n                        configurable: !1,\n                        writable: !1\n                    }), o = new Proxy(o, {\n                        get: function(o, s) {\n                            for(var _len = arguments.length, a = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n                                a[_key - 2] = arguments[_key];\n                            }\n                            return \"currentProvider\" !== s || n ? \"currentProvider\" === s || s === i || r || (r = !0, t.error(\"MetaMask no longer injects web3. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3\"), e.request({\n                                method: \"metamask_logWeb3ShimUsage\"\n                            }).catch((e)=>{\n                                t.debug(\"MetaMask: Failed to log web3 shim usage.\", e);\n                            })) : (n = !0, t.warn(\"You are accessing the MetaMask window.web3.currentProvider shim. This property is deprecated; use window.ethereum instead. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3\")), Reflect.get(o, s, ...a);\n                        },\n                        set: function() {\n                            for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n                                e[_key] = arguments[_key];\n                            }\n                            return t.warn(\"You are accessing the MetaMask window.web3 shim. This object is deprecated; use window.ethereum instead. For details, see: https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3\"), Reflect.set(...e);\n                        }\n                    }), Object.defineProperty(window, \"web3\", {\n                        value: o,\n                        enumerable: !1,\n                        configurable: !0,\n                        writable: !0\n                    });\n                }\n            }(this.provider);\n        } catch (e) {\n            Au(\"[Ethereum] Unable to shim web3 - window.web3 may be read-only\", e);\n        }\n        this.provider.on(\"display_uri\", (e)=>{\n            this.sdkInstance.emit(zu.DisplayURI, e);\n        }), this.provider.on(\"_initialized\", ()=>{\n            const e = {\n                chainId: this.provider.getChainId(),\n                isConnected: this.provider.isConnected(),\n                isMetaMask: this.provider.isMetaMask,\n                selectedAddress: this.provider.getSelectedAddress(),\n                networkVersion: this.provider.getNetworkVersion()\n            };\n            this.sdkInstance.emit(zu.Initialized, e), Au(\"[Ethereum: constructor()] provider initialized\", e);\n        });\n    }\n}\nclass Wu {\n    openDeeplink(e, t, n) {\n        return function(e, t, n, r) {\n            const { state: i } = e;\n            Au(\"[PlatfformManager: openDeeplink()] universalLink --> \".concat(t)), Au(\"[PlatfformManager: openDeeplink()] deepLink --> \".concat(n));\n            try {\n                if (i.preferredOpenLink) return void i.preferredOpenLink(i.useDeeplink ? n : t, r);\n                if (Au(\"[PlatfformManager: openDeeplink()] open link now useDeepLink=\".concat(i.useDeeplink, \" link=\").concat(i.useDeeplink ? n : t)), i.useDeeplink)  true && (window.location.href = n);\n                else if (\"undefined\" != typeof document) {\n                    const e = document.createElement(\"a\");\n                    e.href = t, e.target = \"_self\", e.rel = \"noreferrer noopener\", e.click();\n                }\n            } catch (e) {\n                console.log(\"[PlatfformManager: openDeeplink()] can't open link\", e);\n            }\n        }(this, e, t, n);\n    }\n    isReactNative() {\n        var e;\n        return this.isNotBrowser() && \"undefined\" != \"object\" && (null === window || void 0 === window ? void 0 : window.navigator) && \"ReactNative\" === (null === (e = window.navigator) || void 0 === e ? void 0 : e.product);\n    }\n    isMetaMaskInstalled() {\n        return function() {\n            const e = qu.getProvider() || (null === window || void 0 === window ? void 0 : window.ethereum);\n            return Au(\"[PlatfformManager: isMetaMaskInstalled()] isMetaMask=\".concat(null == e ? void 0 : e.isMetaMask, \" isConnected=\").concat(null == e ? void 0 : e.isConnected())), (null == e ? void 0 : e.isMetaMask) && (null == e ? void 0 : e.isConnected());\n        }();\n    }\n    isDesktopWeb() {\n        return this.isBrowser() && !this.isMobileWeb();\n    }\n    isMobile() {\n        var e, t;\n        const n = Fu.parse(window.navigator.userAgent);\n        return \"mobile\" === (null === (e = null == n ? void 0 : n.platform) || void 0 === e ? void 0 : e.type) || \"tablet\" === (null === (t = null == n ? void 0 : n.platform) || void 0 === t ? void 0 : t.type);\n    }\n    isSecure() {\n        return this.isReactNative() || this.isMobileWeb();\n    }\n    isMetaMaskMobileWebView() {\n        return  true && Boolean(window.ReactNativeWebView) && Boolean(navigator.userAgent.endsWith(\"MetaMaskMobile\"));\n    }\n    isMobileWeb() {\n        return this.state.platformType === Uo.MobileWeb;\n    }\n    static isNotBrowser() {\n        var e;\n        return  false || !(null === window || void 0 === window ? void 0 : window.navigator) || void 0 !== l && \"ReactNative\" === (null === (e = null == l ? void 0 : l.navigator) || void 0 === e ? void 0 : e.product) || \"ReactNative\" === (null === navigator || void 0 === navigator ? void 0 : navigator.product);\n    }\n    isNotBrowser() {\n        return Wu.isNotBrowser();\n    }\n    static isBrowser() {\n        return !this.isNotBrowser();\n    }\n    isBrowser() {\n        return Wu.isBrowser();\n    }\n    isNodeJS() {\n        return this.isNotBrowser() && !this.isReactNative();\n    }\n    isUseDeepLink() {\n        return this.state.useDeeplink;\n    }\n    getPlatformType() {\n        return function(e) {\n            const { state: t } = e;\n            return t.platformType ? t.platformType : e.isReactNative() ? Uo.ReactNative : e.isNotBrowser() ? Uo.NonBrowser : e.isMetaMaskMobileWebView() ? Uo.MetaMaskMobileWebview : e.isMobile() ? Uo.MobileWeb : Uo.DesktopWeb;\n        }(this);\n    }\n    constructor({ useDeepLink: e, preferredOpenLink: t, debug: n = !1 }){\n        this.state = {\n            platformType: void 0,\n            useDeeplink: !1,\n            preferredOpenLink: void 0,\n            debug: !1\n        }, this.state.platformType = this.getPlatformType(), this.state.useDeeplink = e, this.state.preferredOpenLink = t, this.state.debug = n;\n    }\n}\nconst Vu = (e)=>c(void 0, void 0, void 0, function*() {\n        if (Wu.isBrowser()) {\n            const { StorageManagerWeb: t } = yield Promise.resolve().then(function() {\n                return of;\n            });\n            return new t(e);\n        }\n        const t = {\n            persistChannelConfig: ()=>c(void 0, void 0, void 0, function*() {}),\n            getPersistedChannelConfig: ()=>c(void 0, void 0, void 0, function*() {}),\n            persistAccounts: ()=>c(void 0, void 0, void 0, function*() {}),\n            getCachedAccounts: ()=>c(void 0, void 0, void 0, function*() {\n                    return [];\n                }),\n            persistChainId: ()=>c(void 0, void 0, void 0, function*() {}),\n            getCachedChainId: ()=>c(void 0, void 0, void 0, function*() {}),\n            terminate: ()=>c(void 0, void 0, void 0, function*() {})\n        };\n        return Promise.resolve(t);\n    });\n_c139 = Vu;\nclass Gu extends ku {\n    forceInitializeState() {\n        return c(this, void 0, void 0, function*() {\n            return Au(\"[SDKProvider: forceInitializeState()] autoRequestAccounts=\".concat(this.state.autoRequestAccounts)), this._initializeStateAsync();\n        });\n    }\n    _setConnected() {\n        Au(\"[SDKProvider: _setConnected()] Setting connected state\"), this._state.isConnected = !0;\n    }\n    getState() {\n        return this._state;\n    }\n    getSDKProviderState() {\n        return this.state;\n    }\n    getSelectedAddress() {\n        var e;\n        const { accounts: t } = this._state;\n        return t && 0 !== t.length ? (null === (e = t[0]) || void 0 === e ? void 0 : e.toLowerCase()) || \"\" : (Au(\"[SDKProvider: getSelectedAddress] No accounts found\"), null);\n    }\n    getChainId() {\n        return this.state.chainId;\n    }\n    getNetworkVersion() {\n        return this.state.networkVersion;\n    }\n    setSDKProviderState(e) {\n        this.state = Object.assign(Object.assign({}, this.state), e);\n    }\n    handleAccountsChanged(e, t) {\n        return this._handleAccountsChanged(e, t);\n    }\n    handleDisconnect(param) {\n        let { terminate: e = !1 } = param;\n        !function(param) {\n            let { terminate: e = !1, instance: t } = param;\n            const { state: n } = t;\n            Au(\"[SDKProvider: handleDisconnect()] cleaning up provider state terminate=\".concat(e), t), e && (t._state.accounts = null, t._state.isUnlocked = !1, t._state.isPermanentlyDisconnected = !0, t._state.initialized = !1), t._handleAccountsChanged([]), t._state.isConnected = !1, t.emit(\"disconnect\", Mu.ethErrors.provider.disconnected()), n.providerStateRequested = !1;\n        }({\n            terminate: e,\n            instance: this\n        });\n    }\n    _initializeStateAsync() {\n        return c(this, void 0, void 0, function*() {\n            return function(e) {\n                var t, n;\n                return c(this, void 0, void 0, function*() {\n                    void 0 === e.state && (e.state = {\n                        accounts: null,\n                        autoRequestAccounts: !1,\n                        providerStateRequested: !1,\n                        chainId: \"\"\n                    });\n                    const { state: r } = e;\n                    let i;\n                    if (r.providerStateRequested) Au(\"[SDKProvider: initializeStateAsync()] initialization already in progress\");\n                    else {\n                        let o;\n                        r.providerStateRequested = !0;\n                        let s = null, a = !1, c = !1;\n                        const l = yield Vu({\n                            enabled: !0\n                        });\n                        if (l) {\n                            const e = yield l.getPersistedChannelConfig({});\n                            a = null !== (t = null == e ? void 0 : e.relayPersistence) && void 0 !== t && t, o = yield l.getCachedChainId();\n                            const n = yield l.getCachedAccounts();\n                            n.length > 0 && (s = n[0]);\n                        }\n                        if (Au(\"[SDKProvider: initializeStateAsync()] relayPersistence=\".concat(a), {\n                            relayPersistence: a,\n                            cachedChainId: o,\n                            cachedSelectedAddress: s\n                        }), a) if (o && s) i = {\n                            accounts: [\n                                s\n                            ],\n                            chainId: o,\n                            isUnlocked: !1\n                        }, c = !0;\n                        else try {\n                            i = yield e.request({\n                                method: \"metamask_getProviderState\"\n                            });\n                        } catch (t) {\n                            return e._log.error(\"MetaMask: Failed to get initial state. Please report this bug.\", t), void (r.providerStateRequested = !1);\n                        }\n                        if (0 === (null === (n = null == i ? void 0 : i.accounts) || void 0 === n ? void 0 : n.length)) if (e.getSelectedAddress()) i.accounts = [\n                            e.getSelectedAddress()\n                        ];\n                        else {\n                            Au(\"[SDKProvider: initializeStateAsync()] Fetch accounts remotely.\");\n                            const t = yield e.request({\n                                method: \"eth_requestAccounts\",\n                                params: []\n                            });\n                            i.accounts = t;\n                        }\n                        e._initializeState(i), r.providerStateRequested = !1, c && (e._state.isConnected = !0, e.emit(\"connect\", {\n                            chainId: null == i ? void 0 : i.chainId\n                        }));\n                    }\n                });\n            }(this);\n        });\n    }\n    _initializeState(e) {\n        return Au(\"[SDKProvider: _initializeState()]\", e), function(e, t, n) {\n            return Au(\"[SDKProvider: initializeState()] set state._initialized to false\"), e._state.initialized = !1, t(n);\n        }(this, super._initializeState.bind(this), e);\n    }\n    _handleChainChanged() {\n        let { chainId: e, networkVersion: t } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        this.state.chainId = e, this.state.networkVersion = t, function(param) {\n            let { instance: e, chainId: t, networkVersion: r, superHandleChainChanged: i } = param;\n            Au(\"[SDKProvider: handleChainChanged()] chainId=\".concat(t, \" networkVersion=\").concat(r));\n            let o = r;\n            r || (Au(\"[SDKProvider: handleChainChanged()] forced network version to prevent provider error\"), o = \"1\"), t !== xu && (_metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.track(\"sdk_used_chain\", {\n                caip_chain_id: \"eip155:\".concat(parseInt(null != t ? t : \"0x1\", 16))\n            }), xu = t), e._state.isConnected = !0, e.emit(\"connect\", {\n                chainId: t\n            }), i({\n                chainId: t,\n                networkVersion: o\n            });\n        }({\n            instance: this,\n            chainId: e,\n            networkVersion: t,\n            superHandleChainChanged: super._handleChainChanged.bind(this)\n        });\n    }\n    constructor({ connectionStream: e, shouldSendMetadata: t, autoRequestAccounts: n = !1 }){\n        super(e, {\n            logger: console,\n            maxEventListeners: 100,\n            shouldSendMetadata: t\n        }), this.state = {\n            accounts: null,\n            autoRequestAccounts: !1,\n            providerStateRequested: !1,\n            chainId: \"\",\n            networkVersion: \"\"\n        }, Au(\"[SDKProvider: constructor()] autoRequestAccounts=\".concat(n)), this.state.autoRequestAccounts = n;\n    }\n}\nvar Yu, Zu = {\n    name: \"@metamask/sdk\",\n    version: \"0.33.1\",\n    description: \"\",\n    homepage: \"https://github.com/MetaMask/metamask-sdk#readme\",\n    bugs: {\n        url: \"https://github.com/MetaMask/metamask-sdk/issues\"\n    },\n    repository: {\n        type: \"git\",\n        url: \"https://github.com/MetaMask/metamask-sdk\",\n        directory: \"packages/sdk\"\n    },\n    main: \"dist/node/cjs/metamask-sdk.js\",\n    module: \"dist/browser/es/metamask-sdk.js\",\n    browser: \"dist/browser/es/metamask-sdk.js\",\n    unpkg: \"dist/browser/umd/metamask-sdk.js\",\n    \"react-native\": \"dist/react-native/es/metamask-sdk.js\",\n    types: \"dist/types/src/index.d.ts\",\n    sideEffects: !1,\n    files: [\n        \"/dist\"\n    ],\n    scripts: {\n        \"build:types\": \"tsc --project tsconfig.build.json --emitDeclarationOnly --outDir dist/types\",\n        build: \"yarn build:types && rollup -c --bundleConfigAsCjs\",\n        \"build:clean\": \"yarn clean && yarn build\",\n        \"build:post-tsc\": \"echo 'N/A'\",\n        \"build:pre-tsc\": \"echo 'N/A'\",\n        typecheck: \"tsc --noEmit\",\n        clean: \"rimraf ./dist\",\n        size: \"node bundle-size && size-limit\",\n        lint: \"yarn lint:eslint && yarn lint:misc --check\",\n        \"lint:changelog\": \"../../scripts/validate-changelog.sh @metamask/sdk\",\n        \"lint:eslint\": \"eslint . --cache --ext js,ts\",\n        \"lint:fix\": \"yarn lint:eslint --fix && yarn lint:misc --write\",\n        \"lint:misc\": \"prettier '**/*.json' '**/*.md' '!CHANGELOG.md' --ignore-path ../../.gitignore\",\n        prepack: \"../../scripts/prepack.sh\",\n        \"publish:preview\": \"yarn npm publish --tag preview\",\n        reset: \"yarn clean && rimraf ./node_modules/\",\n        test: 'jest --testPathIgnorePatterns \"/e2e/\"',\n        \"test:coverage\": 'jest --coverage --testPathIgnorePatterns \"/e2e/\"',\n        \"test:e2e\": 'jest --testPathPattern \"/e2e/\"',\n        \"test:ci\": 'jest --coverage --passWithNoTests --setupFilesAfterEnv ./jest-preload.js --testPathIgnorePatterns \"/e2e/\"',\n        \"test:dev\": 'jest -c ./jest.config.ts --detectOpenHandles  --testPathIgnorePatterns \"/e2e/\"',\n        watch: \"rollup -c -w\",\n        dev: 'concurrently \"tsc --watch\" \"rollup -c -w --bundleConfigAsCjs\"',\n        \"build:dev\": \"yarn build:types && NODE_ENV=dev rollup -c --bundleConfigAsCjs\"\n    },\n    dependencies: {\n        \"@babel/runtime\": \"^7.26.0\",\n        \"@metamask/onboarding\": \"^1.0.1\",\n        \"@metamask/providers\": \"16.1.0\",\n        \"@metamask/sdk-analytics\": \"workspace:*\",\n        \"@metamask/sdk-communication-layer\": \"workspace:*\",\n        \"@metamask/sdk-install-modal-web\": \"workspace:*\",\n        \"@paulmillr/qr\": \"^0.2.1\",\n        bowser: \"^2.9.0\",\n        \"cross-fetch\": \"^4.0.0\",\n        debug: \"4.3.4\",\n        eciesjs: \"^0.4.11\",\n        \"eth-rpc-errors\": \"^4.0.3\",\n        eventemitter2: \"^6.4.9\",\n        \"obj-multiplex\": \"^1.0.0\",\n        pump: \"^3.0.0\",\n        \"readable-stream\": \"^3.6.2\",\n        \"socket.io-client\": \"^4.5.1\",\n        tslib: \"^2.6.0\",\n        util: \"^0.12.4\",\n        uuid: \"^8.3.2\"\n    },\n    devDependencies: {\n        \"@jest/globals\": \"^29.3.1\",\n        \"@lavamoat/allow-scripts\": \"^2.3.1\",\n        \"@metamask/auto-changelog\": \"3.1.0\",\n        \"@metamask/eslint-config\": \"^6.0.0\",\n        \"@metamask/eslint-config-nodejs\": \"^6.0.0\",\n        \"@metamask/eslint-config-typescript\": \"^6.0.0\",\n        \"@react-native-async-storage/async-storage\": \"^1.19.6\",\n        \"@rollup/plugin-alias\": \"^5.1.1\",\n        \"@rollup/plugin-commonjs\": \"^25.0.7\",\n        \"@rollup/plugin-json\": \"^6.0.0\",\n        \"@rollup/plugin-node-resolve\": \"^15.0.2\",\n        \"@rollup/plugin-replace\": \"^6.0.1\",\n        \"@rollup/plugin-terser\": \"^0.4.1\",\n        \"@size-limit/preset-big-lib\": \"^11.0.2\",\n        \"@types/dom-screen-wake-lock\": \"^1.0.2\",\n        \"@types/node\": \"^20.1.3\",\n        \"@types/pump\": \"^1.1.1\",\n        \"@types/qrcode-terminal\": \"^0.12.0\",\n        \"@types/uuid\": \"^10.0.0\",\n        \"@typescript-eslint/eslint-plugin\": \"^4.26.0\",\n        \"@typescript-eslint/parser\": \"^4.26.0\",\n        \"browserify-zlib\": \"^0.2.0\",\n        buffer: \"^6.0.3\",\n        concurrently: \"^9.1.2\",\n        \"crypto-browserify\": \"^3.12.0\",\n        eslint: \"^7.30.0\",\n        \"eslint-config-prettier\": \"^8.3.0\",\n        \"eslint-plugin-import\": \"^2.23.4\",\n        \"eslint-plugin-jest\": \"^24.4.0\",\n        \"eslint-plugin-jsdoc\": \"^36.1.0\",\n        \"eslint-plugin-node\": \"^11.1.0\",\n        \"eslint-plugin-prettier\": \"^3.4.0\",\n        \"https-browserify\": \"^1.0.0\",\n        jest: \"^29.3.1\",\n        \"jest-environment-jsdom\": \"^29.3.1\",\n        prettier: \"^2.3.0\",\n        process: \"^0.11.10\",\n        rimraf: \"^4.4.0\",\n        rollup: \"^4.26.0\",\n        \"rollup-plugin-analyzer\": \"^4.0.0\",\n        \"rollup-plugin-jscc\": \"^2.0.0\",\n        \"rollup-plugin-natives\": \"^0.7.5\",\n        \"rollup-plugin-node-builtins\": \"^2.1.2\",\n        \"rollup-plugin-polyfill-node\": \"^0.13.0\",\n        \"rollup-plugin-sizes\": \"^1.0.6\",\n        \"rollup-plugin-typescript2\": \"^0.31.2\",\n        \"rollup-plugin-visualizer\": \"^5.12.0\",\n        \"size-limit\": \"^11.0.2\",\n        \"stream-browserify\": \"^3.0.0\",\n        \"stream-http\": \"^3.2.0\",\n        \"ts-jest\": \"^29.0.3\",\n        \"ts-node\": \"^10.9.1\",\n        typescript: \"^4.3.2\",\n        url: \"^0.11.0\",\n        webpack: \"^5.0.0\"\n    },\n    publishConfig: {\n        access: \"public\",\n        registry: \"https://registry.npmjs.org/\"\n    },\n    lavamoat: {\n        allowScripts: {\n            \"eciesjs>secp256k1\": !1,\n            \"socket.io-client>engine.io-client>ws>bufferutil\": !1,\n            \"socket.io-client>engine.io-client>ws>utf-8-validate\": !1,\n            \"@metamask/sdk-communication-layer>bufferutil\": !1,\n            \"@metamask/sdk-communication-layer>eciesjs>secp256k1\": !1,\n            \"@metamask/sdk-communication-layer>utf-8-validate\": !1\n        }\n    }\n};\n!function(e) {\n    e.INPAGE = \"metamask-inpage\", e.CONTENT_SCRIPT = \"metamask-contentscript\", e.PROVIDER = \"metamask-provider\";\n}(Yu || (Yu = {}));\nconst Ju = \"direct\", Qu = \"https://metamask.app.link/connect\", Xu = \"metamask://connect\", eh = {\n    NAME: \"MetaMask\",\n    RDNS: [\n        \"io.metamask\",\n        \"io.metamask.flask\"\n    ]\n}, th = /(?:^[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}$)|(?:^0{8}-0{4}-0{4}-0{4}-0{12}$)/u, nh = {\n    METAMASK_GETPROVIDERSTATE: \"metamask_getProviderState\",\n    METAMASK_CONNECTSIGN: \"metamask_connectSign\",\n    METAMASK_CONNECTWITH: \"metamask_connectWith\",\n    METAMASK_OPEN: \"metamask_open\",\n    METAMASK_BATCH: \"metamask_batch\",\n    PERSONAL_SIGN: \"personal_sign\",\n    WALLET_REQUESTPERMISSIONS: \"wallet_requestPermissions\",\n    WALLET_REVOKEPERMISSIONS: \"wallet_revokePermissions\",\n    WALLET_GETPERMISSIONS: \"wallet_getPermissions\",\n    WALLET_WATCHASSET: \"wallet_watchAsset\",\n    WALLET_ADDETHEREUMCHAIN: \"wallet_addEthereumChain\",\n    WALLET_SWITCHETHETHEREUMCHAIN: \"wallet_switchEthereumChain\",\n    ETH_REQUESTACCOUNTS: \"eth_requestAccounts\",\n    ETH_ACCOUNTS: \"eth_accounts\",\n    ETH_CHAINID: \"eth_chainId\",\n    ETH_SENDTRANSACTION: \"eth_sendTransaction\",\n    ETH_SIGNTYPEDDATA: \"eth_signTypedData\",\n    ETH_SIGNTYPEDDATA_V3: \"eth_signTypedData_v3\",\n    ETH_SIGNTYPEDDATA_V4: \"eth_signTypedData_v4\",\n    ETH_SIGNTRANSACTION: \"eth_signTransaction\",\n    ETH_SIGN: \"eth_sign\",\n    PERSONAL_EC_RECOVER: \"personal_ecRecover\"\n}, rh = {\n    [nh.ETH_REQUESTACCOUNTS]: !0,\n    [nh.ETH_SENDTRANSACTION]: !0,\n    [nh.ETH_SIGNTRANSACTION]: !0,\n    [nh.ETH_SIGN]: !0,\n    [nh.PERSONAL_SIGN]: !0,\n    [nh.ETH_ACCOUNTS]: !1,\n    [nh.ETH_CHAINID]: !1,\n    [nh.PERSONAL_SIGN]: !0,\n    [nh.ETH_SIGNTYPEDDATA]: !0,\n    [nh.ETH_SIGNTYPEDDATA_V3]: !0,\n    [nh.ETH_SIGNTYPEDDATA_V4]: !0,\n    [nh.WALLET_REQUESTPERMISSIONS]: !0,\n    [nh.WALLET_GETPERMISSIONS]: !0,\n    [nh.WALLET_WATCHASSET]: !0,\n    [nh.WALLET_ADDETHEREUMCHAIN]: !0,\n    [nh.WALLET_SWITCHETHETHEREUMCHAIN]: !0,\n    [nh.METAMASK_CONNECTSIGN]: !0,\n    [nh.METAMASK_CONNECTWITH]: !0,\n    [nh.PERSONAL_EC_RECOVER]: !0,\n    [nh.METAMASK_BATCH]: !0,\n    [nh.METAMASK_OPEN]: !0\n}, ih = Object.keys(rh).filter((e)=>!0 === rh[e]).map((e)=>e.toLowerCase()), oh = [\n    \"eth_signTypedData\",\n    \"eth_signTypedData_v3\",\n    \"eth_signTypedData_v4\",\n    \"eth_sign\"\n].map((e)=>e.toLowerCase()), sh = \".sdk-comm\", ah = \"providerType\", ch = \".MMSDK_cached_address\", lh = \".MMSDK_cached_chainId\", dh = {\n    CHAIN_CHANGED: \"chainChanged\",\n    ACCOUNTS_CHANGED: \"accountsChanged\",\n    DISCONNECT: \"disconnect\",\n    CONNECT: \"connect\",\n    CONNECTED: \"connected\"\n}, uh = 1e6;\nvar hh;\n!function(e) {\n    e.TERMINATE = \"terminate\", e.EXTENSION = \"extension\", e.INITIALIZED = \"initialized\";\n}(hh || (hh = {}));\nconst fh =  true && window.localStorage;\nfunction ph(param) {\n    let { instance: e, msg: t } = param;\n    return c(this, void 0, void 0, function*() {\n        if (e._initialized || (Au(\"[MetaMaskSDK: connectAndSign()] provider not ready -- wait for init()\"), yield e.init()), Au(\"[MetaMaskSDK: connectAndSign()] activeProvider=\".concat(e.activeProvider)), !e.activeProvider) throw new Error(\"SDK state invalid -- undefined provider\");\n        const n = /^0x([0-9A-Fa-f]{2})*$/u.test(t) ? t : function(e) {\n            let t;\n            if (void 0 !== C) t = C.from(e, \"utf8\").toString(\"hex\");\n            else if (\"undefined\" != typeof TextEncoder) {\n                const n = (new TextEncoder).encode(e);\n                t = Array.from(n).map((e)=>e.toString(16).padStart(2, \"0\")).join(\"\");\n            } else {\n                if (\"object\" != typeof l || !(\"Buffer\" in l)) throw new Error(\"Unable to convert string to hex: No available method.\");\n                t = l.Buffer.from(e, \"utf8\").toString(\"hex\");\n            }\n            return \"0x\".concat(t);\n        }(t);\n        return e.activeProvider.request({\n            method: nh.METAMASK_CONNECTWITH,\n            params: [\n                {\n                    method: nh.PERSONAL_SIGN,\n                    params: [\n                        n\n                    ]\n                }\n            ]\n        });\n    });\n}\nfunction gh(e) {\n    var t, n;\n    return c(this, void 0, void 0, function*() {\n        Au(\"[MetaMaskSDK: connectWithExtensionProvider()] \", e), e.sdkProvider = e.activeProvider, e.activeProvider = window.extension, window.ethereum = window.extension;\n        try {\n            const e = yield null === (t = window.extension) || void 0 === t ? void 0 : t.request({\n                method: \"eth_requestAccounts\"\n            });\n            Au(\"[MetaMaskSDK: connectWithExtensionProvider()] accounts=\".concat(e));\n        } catch (e) {\n            return void console.warn(\"[MetaMaskSDK: connectWithExtensionProvider()] can't request accounts error\", e);\n        }\n        localStorage.setItem(ah, \"extension\"), e.extensionActive = !0, e.emit(zu.ProviderUpdate, hh.EXTENSION), e.options.enableAnalytics && (null === (n = e.analytics) || void 0 === n || n.send({\n            event: Ao.SDK_USE_EXTENSION\n        }));\n    });\n}\nfunction mh(e) {\n    let t;\n    if (void 0 !== C) t = C.from(e, \"utf8\").toString(\"base64\");\n    else if (\"function\" == typeof btoa) t = btoa(encodeURIComponent(e).replace(/%([0-9A-F]{2})/gu, (e, t)=>String.fromCharCode(parseInt(t, 16))));\n    else {\n        if (\"object\" != typeof l || !(\"Buffer\" in l)) throw new Error(\"Unable to base64 encode: No available method.\");\n        t = l.Buffer.from(e, \"utf8\").toString(\"base64\");\n    }\n    return t;\n}\nfunction yh(e, t, n, r) {\n    var i, o, s, a, l, d, u, h, f, p, g, m, y, v, b, w, E, S, _, k;\n    return c(this, void 0, void 0, function*() {\n        const n = null === (i = e.state.remote) || void 0 === i ? void 0 : i.isReady(), c = null === (o = e.state.remote) || void 0 === o ? void 0 : o.isConnected(), A = null === (s = e.state.remote) || void 0 === s ? void 0 : s.isPaused(), x = qu.getProvider(), M = null === (a = e.state.remote) || void 0 === a ? void 0 : a.getChannelId(), I = null === (l = e.state.remote) || void 0 === l ? void 0 : l.isAuthorized(), { deeplinkProtocol: T } = e.state, { method: R, data: P, triggeredInstaller: O } = ((e)=>{\n            var t, n, r, i;\n            let o;\n            C.isBuffer(e) ? (o = e.toJSON(), o._isBuffer = !0) : o = e;\n            const s = null === (t = null == o ? void 0 : o.data) || void 0 === t ? void 0 : t.method;\n            let a = !1;\n            return \"object\" == typeof (null === (n = null == o ? void 0 : o.data) || void 0 === n ? void 0 : n.params) && !0 === (null === (i = null === (r = null == o ? void 0 : o.data) || void 0 === r ? void 0 : r.params) || void 0 === i ? void 0 : i.__triggeredInstaller) && (a = !0, o.data.params = o.data.params.wrappedParams), {\n                method: s,\n                data: o,\n                triggeredInstaller: a\n            };\n        })(t);\n        if (Au(\"[RCPMS: write()] method='\".concat(R, \"' isRemoteReady=\").concat(n, \" channelId=\").concat(M, \" isSocketConnected=\").concat(c, \" isRemotePaused=\").concat(A, \" providerConnected=\").concat(x.isConnected()), t), !M) return R !== nh.METAMASK_GETPROVIDERSTATE && Au(\"[RCPMS: write()] \".concat(R, \" --> channelId is undefined\")), r(new Error(\"disconnected\"));\n        Au(\"[RCPMS: write()] remote.isPaused()=\".concat(null === (d = e.state.remote) || void 0 === d ? void 0 : d.isPaused(), \" authorized=\").concat(I, \" ready=\").concat(n, \" socketConnected=\").concat(c), t);\n        const N = null === (u = e.state.platformManager) || void 0 === u ? void 0 : u.isSecure(), L = null !== (f = null === (h = e.state.platformManager) || void 0 === h ? void 0 : h.isMobileWeb()) && void 0 !== f && f, D = null !== (g = null === (p = e.state.remote) || void 0 === p ? void 0 : p.hasDeeplinkProtocol()) && void 0 !== g && g && L && I;\n        try {\n            if (!O) {\n                const t = JSON.stringify(null == P ? void 0 : P.data);\n                if (t.length > uh) return r(new Error(\"Message size \".concat(t.length, \" exceeds maximum allowed size of 1000000 bytes\")));\n                null === (m = e.state.remote) || void 0 === m || m.sendMessage(null == P ? void 0 : P.data).then(()=>{\n                    Au(\"[RCPMS: _write()] \".concat(R, \" sent successfully\"));\n                }).catch((e)=>{\n                    Au(\"[RCPMS: _write()] error sending message\", e);\n                });\n            }\n            if (!N) return Au(\"[RCPMS: _write()] unsecure platform for method \".concat(R, \" -- return callback\")), r();\n            if (O) return Au(\"[RCPMS: _write()] prevent deeplink -- installation completed separately.\"), r();\n            const t = null !== (b = null === (v = null === (y = e.state.remote) || void 0 === y ? void 0 : y.getKeyInfo()) || void 0 === v ? void 0 : v.ecies.public) && void 0 !== b ? b : \"\";\n            let n = encodeURI(\"channelId=\".concat(M, \"&pubkey=\").concat(t, \"&comm=socket&t=d&v=2\"));\n            if (D) {\n                const t = JSON.stringify(null == P ? void 0 : P.data), i = null === (w = e.state.remote) || void 0 === w ? void 0 : w.encrypt(t);\n                if (!i) return Au(\"[RCPMS: _write()] error encrypting message\"), r(new Error(\"RemoteCommunicationPostMessageStream - disconnected\"));\n                n += \"&scheme=\".concat(T, \"&rpc=\").concat(mh(i));\n            }\n            if (!(null === (E = e.state.platformManager) || void 0 === E ? void 0 : E.isMetaMaskInstalled())) return Au(\"[RCPMS: _write()] prevent deeplink until installation is completed.\"), r();\n            rh[R] ? (Au(\"[RCPMS: _write()] redirect link for '\".concat(R, \"' socketConnected=\").concat(c, \" connect?\").concat(n)), null === (S = e.state.platformManager) || void 0 === S || S.openDeeplink(\"\".concat(Qu, \"?\").concat(n), \"\".concat(Xu, \"?\").concat(n), \"_self\")) : (null === (_ = e.state.remote) || void 0 === _ ? void 0 : _.isPaused()) ? (Au(\"[RCPMS: _write()] MM is PAUSED! deeplink with connect! targetMethod=\".concat(R)), null === (k = e.state.platformManager) || void 0 === k || k.openDeeplink(\"\".concat(Qu, \"?redirect=true&\").concat(n), \"\".concat(Xu, \"?redirect=true&\").concat(n), \"_self\")) : Au(\"[RCPMS: _write()] method \".concat(R, \" doesn't need redirect.\"));\n        } catch (e) {\n            return Au(\"[RCPMS: _write()] error sending message\", e), r(new Error(\"RemoteCommunicationPostMessageStream - disconnected\"));\n        }\n        return r();\n    });\n}\nclass vh extends nu.Duplex {\n    _write(e, t, n) {\n        return c(this, void 0, void 0, function*() {\n            return yh(this, e, 0, n);\n        });\n    }\n    _read() {}\n    _onMessage(e) {\n        return function(e, t) {\n            try {\n                if (Au(\"[RCPMS: onMessage()] message\", t), !t || \"object\" != typeof t) return;\n                if (\"object\" != typeof (null == t ? void 0 : t.data)) return;\n                if (!(null == t ? void 0 : t.name)) return void Au(\"[RCPMS: onMessage()] ignore message without name\", t);\n                if ((null == t ? void 0 : t.name) !== Yu.PROVIDER) return void Au(\"[RCPMS: onMessage()] ignore message with wrong name message=\".concat(t));\n                if (C.isBuffer(t)) {\n                    const n = C.from(t);\n                    e.push(n);\n                } else e.push(t);\n            } catch (e) {\n                Au(\"[RCPMS: onMessage()] ignore message error err=\".concat(e));\n            }\n        }(this, e);\n    }\n    start() {}\n    constructor({ name: e, remote: t, deeplinkProtocol: n, platformManager: r }){\n        super({\n            objectMode: !0\n        }), this.state = {\n            _name: null,\n            remote: null,\n            deeplinkProtocol: !1,\n            platformManager: null\n        }, this.state._name = e, this.state.remote = t, this.state.deeplinkProtocol = n, this.state.platformManager = r, this._onMessage = this._onMessage.bind(this), this.state.remote.on(So.MESSAGE, this._onMessage);\n    }\n}\nlet bh = 1;\nconst wh = (e)=>new Promise((t)=>{\n        setTimeout(()=>{\n            t(!0);\n        }, e);\n    }), Eh = (param)=>{\n    let { checkInstallationOnAllCalls: t = !1, communicationLayerPreference: n, injectProvider: r, shouldShimWeb3: i, platformManager: o, installer: s, sdk: a, remoteConnection: l, debug: d } = param;\n    return c(void 0, void 0, void 0, function*() {\n        var u, h;\n        const f = ((param)=>{\n            let { name: e, remoteConnection: t } = param;\n            if (!t || !(null == t ? void 0 : t.getConnector())) throw new Error(\"Missing remote connection parameter\");\n            return new vh({\n                name: e,\n                remote: null == t ? void 0 : t.getConnector(),\n                deeplinkProtocol: null == t ? void 0 : t.state.deeplinkProtocol,\n                platformManager: null == t ? void 0 : t.getPlatformManager()\n            });\n        })({\n            name: Yu.INPAGE,\n            target: Yu.CONTENT_SCRIPT,\n            platformManager: o,\n            communicationLayerPreference: n,\n            remoteConnection: l\n        }), p = o.getPlatformType(), g = a.options.dappMetadata, m = \"Sdk/Javascript SdkVersion/\".concat(Zu.version, \" Platform/\").concat(p, \" dApp/\").concat(null !== (u = g.url) && void 0 !== u ? u : g.name, \" dAppTitle/\").concat(g.name);\n        let y = null, v = null;\n        const b = null === (h = a.options.storage) || void 0 === h ? void 0 : h.storageManager;\n        if (b) {\n            try {\n                const e = yield b.getCachedAccounts();\n                e.length > 0 && (y = e[0]);\n            } catch (e) {\n                console.error(\"[initializeMobileProvider] failed to get cached addresses: \".concat(e));\n            }\n            try {\n                const e = yield b.getCachedChainId();\n                e && (v = e);\n            } catch (e) {\n                console.error(\"[initializeMobileProvider] failed to parse cached chainId: \".concat(e));\n            }\n        }\n        Au(\"[initializeMobileProvider] cachedAccountAddress: \".concat(y, \", cachedChainId: \").concat(v));\n        const w = !(!r || p === Uo.NonBrowser || p === Uo.ReactNative), E = qu.init({\n            shouldSetOnWindow: w,\n            connectionStream: f,\n            shouldShimWeb3: i,\n            sdkInstance: a\n        });\n        let S = !1;\n        const _ = (e)=>{\n            S = e;\n        }, C = ()=>S, k = (n, r, i, d)=>c(void 0, void 0, void 0, function*() {\n                var u, h, f, p, g, w, E, k, A;\n                const x = qu.getProvider();\n                if (S) {\n                    x.emit(\"display_uri\", (null == l ? void 0 : l.state.qrcodeLink) || \"\"), null == l || l.showActiveModal();\n                    let e = C();\n                    for(; e;){\n                        const t = C(), n = null == l ? void 0 : l.isAuthorized();\n                        e = t && !n, Au(\"[initializeMobileProvider: sendRequest()] waiting for initialization to complete - initializing: \".concat(t, \" authorized: \").concat(n)), yield wh(1e3);\n                    }\n                    return Au(\"[initializeMobileProvider: sendRequest()] initial method completed -- prevent installation and call provider\"), i(...r);\n                }\n                const M = o.isMetaMaskInstalled(), I = null == l ? void 0 : l.isConnected();\n                let T = null, R = null, P = null;\n                if (T = null !== (u = x.getSelectedAddress()) && void 0 !== u ? u : y, P = x.getChainId() || v, T && b && T !== y && b.persistAccounts([\n                    T\n                ]).catch((e)=>{\n                    console.error(\"[initializeMobileProvider] failed to persist account: \".concat(e));\n                }), P && (v = P, b && b.persistChainId(P).catch((e)=>{\n                    console.error(\"[initializeMobileProvider] failed to persist chainId: \".concat(e));\n                })), Au(\"[initializeMobileProvider: sendRequest()]\", {\n                    selectedAddress: T,\n                    chainId: P\n                }), d && Au(\"[initializeMobileProvider: sendRequest()] method=\".concat(n, \" ongoing=\").concat(S, \" selectedAddress=\").concat(T, \" isInstalled=\").concat(M, \" checkInstallationOnAllCalls=\").concat(t, \" socketConnected=\").concat(I)), T && n.toLowerCase() === nh.ETH_ACCOUNTS.toLowerCase()) return [\n                    T\n                ];\n                if (P && n.toLowerCase() === nh.ETH_CHAINID.toLowerCase()) return P;\n                const O = [\n                    nh.ETH_REQUESTACCOUNTS,\n                    nh.WALLET_REQUESTPERMISSIONS,\n                    nh.METAMASK_CONNECTSIGN,\n                    nh.METAMASK_CONNECTWITH\n                ], N = !rh[n], L = null === (h = a.options.readonlyRPCMap) || void 0 === h ? void 0 : h[P];\n                if (L && N) try {\n                    const t = null === (f = null == r ? void 0 : r[0]) || void 0 === f ? void 0 : f.params, i = yield ((param)=>{\n                        let { rpcEndpoint: t, method: n, sdkInfo: r, params: i } = param;\n                        return c(void 0, void 0, void 0, function*() {\n                            const o = JSON.stringify({\n                                jsonrpc: \"2.0\",\n                                method: n,\n                                params: i,\n                                id: (bh += 1, bh)\n                            }), s = {\n                                Accept: \"application/json\",\n                                \"Content-Type\": \"application/json\"\n                            };\n                            let a;\n                            t.includes(\"infura\") && (s[\"Metamask-Sdk-Info\"] = r);\n                            try {\n                                a = yield cross_fetch__WEBPACK_IMPORTED_MODULE_0___default()(t, {\n                                    method: \"POST\",\n                                    headers: s,\n                                    body: o\n                                });\n                            } catch (e) {\n                                throw e instanceof Error ? new Error(\"Failed to fetch from RPC: \".concat(e.message)) : new Error(\"Failed to fetch from RPC: \".concat(e));\n                            }\n                            if (!a.ok) throw new Error(\"Server responded with a status of \".concat(a.status));\n                            return (yield a.json()).result;\n                        });\n                    })({\n                        rpcEndpoint: L,\n                        sdkInfo: m,\n                        method: n,\n                        params: t || []\n                    });\n                    return d && Au(\"initializeProvider::ReadOnlyRPCResponse \".concat(i)), i;\n                } catch (e) {\n                    console.warn(\"[initializeMobileProvider: sendRequest()] method=\".concat(n, \" readOnlyRPCRequest failed:\"), e);\n                }\n                if ((!M || M && !I) && n !== nh.METAMASK_GETPROVIDERSTATE) {\n                    const e = (null === (p = null == r ? void 0 : r[0]) || void 0 === p ? void 0 : p.params) || [];\n                    if (-1 !== O.indexOf(n) || t) {\n                        _(!0);\n                        const t = n === nh.METAMASK_CONNECTWITH, o = \"\".concat(Date.now());\n                        try {\n                            yield s.start({\n                                wait: !1,\n                                connectWith: t ? {\n                                    method: n,\n                                    id: o,\n                                    params: e\n                                } : void 0\n                            }), yield new Promise((e, t)=>{\n                                (null == l ? void 0 : l.isAuthorized()) && (Au(\"[initializeMobileProvider: sendRequest()] already authorized\"), e(!0)), null == l || l.getConnector().once(So.AUTHORIZED, ()=>{\n                                    e(!0);\n                                }), a.once(So.PROVIDER_UPDATE, (e)=>{\n                                    Au(\"[initializeMobileProvider: sendRequest()] PROVIDER_UPDATE --- remote provider request interupted type=\".concat(e)), e === hh.EXTENSION ? t(So.PROVIDER_UPDATE) : t(new Error(\"Connection Terminated\"));\n                                });\n                            });\n                        } catch (t) {\n                            if (hh.EXTENSION === t) {\n                                if (Au(\"[initializeMobileProvider: sendRequest()] extension provider detect: re-create \".concat(n, \" on the active provider\")), n.toLowerCase() === nh.METAMASK_CONNECTSIGN.toLowerCase()) {\n                                    const t = yield null === (g = a.getProvider()) || void 0 === g ? void 0 : g.request({\n                                        method: nh.ETH_REQUESTACCOUNTS,\n                                        params: []\n                                    });\n                                    if (!t.length) throw new Error(\"SDK state invalid -- undefined accounts\");\n                                    const n = yield null === (w = a.getProvider()) || void 0 === w ? void 0 : w.request({\n                                        method: nh.PERSONAL_SIGN,\n                                        params: [\n                                            e[0],\n                                            t[0]\n                                        ]\n                                    });\n                                    return a.emit(zu.ConnectWithResponse, n), n;\n                                }\n                                if (n.toLowerCase() === nh.METAMASK_CONNECTWITH.toLowerCase()) {\n                                    const [t] = e, n = yield ((param)=>{\n                                        let { method: e, sdk: t, params: n } = param;\n                                        return c(void 0, void 0, void 0, function*() {\n                                            var r, i, o, s;\n                                            if (!t.isExtensionActive()) throw new Error(\"SDK state invalid -- extension is not active\");\n                                            Au(\"[MetaMaskProvider: extensionConnectWithOverwrite()] Overwriting request method\", e, n);\n                                            const a = yield null === (r = t.getProvider()) || void 0 === r ? void 0 : r.request({\n                                                method: nh.ETH_REQUESTACCOUNTS,\n                                                params: []\n                                            });\n                                            if (!a.length) throw new Error(\"SDK state invalid -- undefined accounts\");\n                                            if ((null == e ? void 0 : e.toLowerCase()) === nh.PERSONAL_SIGN.toLowerCase()) {\n                                                const r = {\n                                                    method: e,\n                                                    params: [\n                                                        n[0],\n                                                        a[0]\n                                                    ]\n                                                };\n                                                return yield null === (i = t.getProvider()) || void 0 === i ? void 0 : i.request(r);\n                                            }\n                                            if ((null == e ? void 0 : e.toLowerCase()) === nh.ETH_SENDTRANSACTION.toLowerCase()) {\n                                                const r = {\n                                                    method: e,\n                                                    params: [\n                                                        Object.assign(Object.assign({}, n[0]), {\n                                                            from: a[0]\n                                                        })\n                                                    ]\n                                                };\n                                                return yield null === (o = t.getProvider()) || void 0 === o ? void 0 : o.request(r);\n                                            }\n                                            return oh.includes(e.toLowerCase()) ? (console.warn(\"MetaMaskSDK connectWith method=\".concat(e, \" -- not handled by the extension -- call separately\")), a) : yield null === (s = t.getProvider()) || void 0 === s ? void 0 : s.request({\n                                                method: e,\n                                                params: n\n                                            });\n                                        });\n                                    })({\n                                        method: t.method,\n                                        sdk: a,\n                                        params: t.params\n                                    });\n                                    return a.emit(zu.ConnectWithResponse, n), n;\n                                }\n                                return Au(\"[initializeMobileProvider: sendRequest()] sending '\".concat(n, \"' on active provider\"), e), yield null === (E = a.getProvider()) || void 0 === E ? void 0 : E.request({\n                                    method: n,\n                                    params: e\n                                });\n                            }\n                            if (t === So.REJECTED) throw null == l || l.closeModal(), null === (k = a.getProvider()) || void 0 === k || k.handleDisconnect({\n                                terminate: !1\n                            }), Object.assign(new Error(\"User rejected connection\"), {\n                                code: 4001\n                            });\n                            throw Au(\"[initializeMobileProvider: sendRequest()] failed to start installer: \".concat(t)), t;\n                        } finally{\n                            _(!1);\n                        }\n                        if (n === nh.ETH_REQUESTACCOUNTS) return R = yield new Promise((e)=>{\n                            const t = setInterval(()=>{\n                                const { accounts: n } = x.getState();\n                                n && (clearInterval(t), e(n));\n                            }, 100);\n                        }), Au(\"[initializeMobileProvider: sendRequest()] selectedAddress: \".concat(T, \" --- SKIP rpc call\")), R;\n                        if (n === nh.METAMASK_CONNECTWITH) try {\n                            let e = 0;\n                            const t = 5, n = (param)=>{\n                                let { resolve: n, reject: r } = param;\n                                e += 1;\n                                const i = null == l ? void 0 : l.getConnector().getRPCMethodTracker(), s = null == i ? void 0 : i[o];\n                                return Au(\"TRACKER: update method \".concat(o), s), (null == s ? void 0 : s.result) ? (Au(\"[initializeMobileProvider: sendRequest()] found result\", s.result), a.emit(zu.ConnectWithResponse, s.result), void n(s.result)) : (null == s ? void 0 : s.error) ? (Au(\"[initializeMobileProvider: sendRequest()] found error\", s.error), void r(s.error)) : e >= t ? (Au(\"[initializeMobileProvider: sendRequest()] max message count reached without result\"), void r(new Error(\"Max message count reached without result\"))) : void Au(\"[initializeMobileProvider: sendRequest()] not found yet, need to wait for next update\");\n                            };\n                            let r, i;\n                            const s = yield new Promise((e, t)=>{\n                                const s = null == l ? void 0 : l.getConnector().getRPCMethodTracker();\n                                Au(\"TRACKER: method \".concat(o), s), (null == s ? void 0 : s[o].result) ? (Au(\"[initializeMobileProvider: sendRequest()] found result\", null == s ? void 0 : s[o].result), e(null == s ? void 0 : s[o].result)) : (null == s ? void 0 : s[o].error) && (Au(\"[initializeMobileProvider: sendRequest()] found error\", null == s ? void 0 : s[o].error), t(null == s ? void 0 : s[o].error)), i = ()=>n({\n                                        resolve: e,\n                                        reject: t\n                                    }), r = null == l ? void 0 : l.getConnector().on(So.RPC_UPDATE, i);\n                            });\n                            return i && (null == r || r.off(So.RPC_UPDATE, i)), Au(\"TRACKER: result\", s), s;\n                        } catch (e) {\n                            throw Au(\"[initializeMobileProvider: sendRequest()] error:\", e), e;\n                        }\n                        r[0] && \"object\" == typeof r[0] && (r[0].params = {\n                            __triggeredInstaller: !0,\n                            wrappedParams: r[0].params\n                        });\n                        return i(...r);\n                    }\n                    if (o.isSecure() && rh[n]) return i(...r);\n                    if (a.isExtensionActive()) return Au(\"[initializeMobileProvider: sendRequest()] EXTENSION active - redirect request '\".concat(n, \"' to it\"), r, e), yield null === (A = a.getProvider()) || void 0 === A ? void 0 : A.request({\n                        method: n,\n                        params: e\n                    });\n                    throw Au(\"[initializeMobileProvider: sendRequest()] method=\".concat(n, \" --- skip --- not connected/installed\")), new Error(\"MetaMask is not connected/installed, please call eth_requestAccounts to connect first.\");\n                }\n                try {\n                    const e = yield i(...r);\n                    if (Au(\"[initializeMobileProvider: sendRequest()] method=\".concat(n, \" rpcResponse\"), e), n === nh.WALLET_REQUESTPERMISSIONS) {\n                        const t = e.reduce((e, t)=>{\n                            var n;\n                            if (\"eth_accounts\" === t.parentCapability) {\n                                const r = null === (n = t.caveats.find((e)=>\"restrictReturnedAccounts\" === e.type)) || void 0 === n ? void 0 : n.value;\n                                r && e.push(...r);\n                            }\n                            return e;\n                        }, []);\n                        Au(\"[initializeMobileProvider: sendRequest()] accountsToPersist:\", t), t.length > 0 && (x.handleAccountsChanged(t, !1), null == b || b.persistAccounts(t));\n                    }\n                    return e;\n                } catch (e) {\n                    throw console.error(\"[initializeMobileProvider: sendRequest()] error:\", e), e;\n                }\n            }), { request: A } = E;\n        E.request = function() {\n            for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n                e[_key] = arguments[_key];\n            }\n            return c(void 0, void 0, void 0, function*() {\n                return k(null == e ? void 0 : e[0].method, e, A, d);\n            });\n        };\n        const { send: x } = E;\n        return E.send = function() {\n            for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n                e[_key] = arguments[_key];\n            }\n            return c(void 0, void 0, void 0, function*() {\n                return k(null == e ? void 0 : e[0], e, x, d);\n            });\n        }, Au(\"[initializeMobileProvider: sendRequest()] metamaskStream.start()\"), f.start(), E;\n    });\n};\nfunction Sh(e) {\n    var t, n, r, i;\n    return c(this, void 0, void 0, function*() {\n        const { options: o } = e, s = {\n            communicationLayerPreference: null !== (t = o.communicationLayerPreference) && void 0 !== t ? t : jo.SOCKET,\n            platformManager: e.platformManager,\n            sdk: e,\n            checkInstallationOnAllCalls: o.checkInstallationOnAllCalls,\n            injectProvider: null === (n = o.injectProvider) || void 0 === n || n,\n            shouldShimWeb3: null === (r = o.shouldShimWeb3) || void 0 === r || r,\n            extensionOnly: null === (i = o.extensionOnly) || void 0 === i || i,\n            installer: e.installer,\n            remoteConnection: e.remoteConnection,\n            debug: e.debug\n        }, a = yield Eh(s);\n        e.activeProvider = a, function(e) {\n            var t, n, r, i;\n            null === (n = null === (t = e.remoteConnection) || void 0 === t ? void 0 : t.getConnector()) || void 0 === n || n.on(zu.ConnectionStatus, (t)=>{\n                e.emit(zu.ConnectionStatus, t);\n            }), null === (i = null === (r = e.remoteConnection) || void 0 === r ? void 0 : r.getConnector()) || void 0 === i || i.on(zu.ServiceStatus, (t)=>{\n                e.emit(zu.ServiceStatus, t);\n            });\n        }(e);\n    });\n}\n_c140 = Sh;\nconst _h = \"sdk\";\nclass Ch {\n    send(param) {\n        let { event: e, params: t } = param;\n        if (!this.enabled) return;\n        const n = Object.assign(Object.assign({\n            id: _h,\n            event: e,\n            sdkVersion: Zu.version\n        }, this.originatorInfo), {\n            params: t\n        });\n        Au(\"[Analytics: send()] event: \".concat(e), n), lo(n, this.serverURL).catch((e)=>{\n            Au(\"[Analytics: send()] error: \".concat(e));\n        });\n    }\n    constructor({ serverUrl: e, enabled: t, originatorInfo: n }){\n        this.serverURL = fo, this.serverURL = e, this.originatorInfo = n, this.enabled = null == t || t;\n    }\n}\nconst kh = ()=>{\n    if (\"undefined\" == typeof document) return;\n    let e;\n    const t = document.getElementsByTagName(\"link\");\n    for(let n = 0; n < t.length; n++)\"icon\" !== t[n].getAttribute(\"rel\") && \"shortcut icon\" !== t[n].getAttribute(\"rel\") || (e = t[n].getAttribute(\"href\"));\n    return e;\n}, Ah = 163400;\nfunction xh(e) {\n    var t, n, r;\n    const { dappMetadata: i } = e, o = function(param) {\n        let { url: e, name: t } = param;\n        var n;\n        const r = e + t, i = mh(r);\n        if (!localStorage) return \"\";\n        let o = null !== (n = localStorage.getItem(i)) && void 0 !== n ? n : \"\";\n        if (!o) {\n            o = (0,uuid__WEBPACK_IMPORTED_MODULE_5__.v4)();\n            try {\n                localStorage.setItem(i, o);\n            } catch (e) {\n                return \"\";\n            }\n        }\n        return o;\n    }({\n        url: null !== (t = null == i ? void 0 : i.url) && void 0 !== t ? t : \"no_url\",\n        name: null !== (n = null == i ? void 0 : i.name) && void 0 !== n ? n : \"no_name\"\n    }), a = null === (r = e.platformManager) || void 0 === r ? void 0 : r.getPlatformType(), c = a === Uo.DesktopWeb, l = a === Uo.MetaMaskMobileWebview;\n    let d = \"N/A\";\n    return c ? d = \"extension\" : l && (d = \"mobile\"), {\n        id: o,\n        from: d\n    };\n}\nconst Mh = (e, t, r)=>{\n    if (bo(e)) {\n        if (r || t && \"object\" == typeof t && null !== t && \"error\" in t) {\n            const i = r || (null == t ? void 0 : t.error);\n            i && 4001 === i.code ? _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.track(\"sdk_action_rejected\", {\n                action: e\n            }) : _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.track(\"sdk_action_failed\", {\n                action: e\n            });\n        } else _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.track(\"sdk_action_succeeded\", {\n            action: e\n        });\n    }\n}, Ih = (param)=>{\n    let { provider: e, sdkInstance: t } = param;\n    if (\"state\" in e) throw new Error(\"INVALID EXTENSION PROVIDER\");\n    return new Proxy(e, {\n        get: (r, i)=>\"request\" === i ? function(e) {\n                var i, o;\n                return c(this, void 0, void 0, function*() {\n                    Au(\"[wrapExtensionProvider()] Overwriting request method\", e);\n                    const { method: s, params: a } = e, l = ih.includes(s.toLowerCase()), { id: d, from: u } = xh(t);\n                    if (l && (null === (i = t.analytics) || void 0 === i || i.send({\n                        event: Ao.SDK_RPC_REQUEST,\n                        params: {\n                            method: s,\n                            from: u,\n                            id: d\n                        }\n                    })), bo(s) && _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.track(\"sdk_action_requested\", {\n                        action: s\n                    }), s === nh.METAMASK_BATCH && Array.isArray(a)) return ((param)=>{\n                        let { target: e, args: t, trackEvent: n, sdkInstance: r } = param;\n                        return c(void 0, void 0, void 0, function*() {\n                            var i, o;\n                            if (\"metamask_batch\" !== t.method) throw new Error(\"Invalid usage\");\n                            const s = [], a = null !== (i = null == t ? void 0 : t.params) && void 0 !== i ? i : [];\n                            for (const t of a){\n                                const n = yield null == e ? void 0 : e.request({\n                                    method: t.method,\n                                    params: t.params\n                                });\n                                s.push(n);\n                            }\n                            const { id: c, from: l } = xh(r);\n                            n && (null === (o = r.analytics) || void 0 === o || o.send({\n                                event: Ao.SDK_RPC_REQUEST_DONE,\n                                params: {\n                                    method: t.method,\n                                    from: l,\n                                    id: c\n                                }\n                            }));\n                            for (const e of s)Mh(t.method, e, null);\n                            return s;\n                        });\n                    })({\n                        target: r,\n                        args: e,\n                        trackEvent: l,\n                        sdkInstance: t\n                    });\n                    if (s.toLowerCase() === nh.METAMASK_CONNECTSIGN.toLowerCase() && Array.isArray(a)) return ((param)=>{\n                        let { target: e, params: t } = param;\n                        return c(void 0, void 0, void 0, function*() {\n                            let n, r = null;\n                            try {\n                                const r = yield e.request({\n                                    method: nh.ETH_REQUESTACCOUNTS,\n                                    params: []\n                                });\n                                if (!r.length) throw new Error(\"SDK state invalid -- undefined accounts\");\n                                return n = yield e.request({\n                                    method: nh.PERSONAL_SIGN,\n                                    params: [\n                                        t[0],\n                                        r[0]\n                                    ]\n                                }), n;\n                            } catch (e) {\n                                throw r = e, e;\n                            } finally{\n                                Mh(nh.PERSONAL_SIGN, n, r);\n                            }\n                        });\n                    })({\n                        target: r,\n                        params: a\n                    });\n                    if (s.toLowerCase() === nh.METAMASK_CONNECTWITH.toLowerCase() && Array.isArray(a)) return ((param)=>{\n                        let { target: e, params: t } = param;\n                        return c(void 0, void 0, void 0, function*() {\n                            const [n] = t, r = n.method, i = n.params;\n                            let o, s = null;\n                            try {\n                                const t = yield e.request({\n                                    method: nh.ETH_REQUESTACCOUNTS,\n                                    params: []\n                                });\n                                if (!Array.isArray(t) || !t.length) throw new Error(\"SDK state invalid -- undefined accounts\");\n                                return (null == r ? void 0 : r.toLowerCase()) === nh.PERSONAL_SIGN.toLowerCase() ? (o = yield e.request({\n                                    method: r,\n                                    params: [\n                                        i[0],\n                                        t[0]\n                                    ]\n                                }), o) : (null == r ? void 0 : r.toLowerCase()) === nh.ETH_SENDTRANSACTION.toLowerCase() ? (o = yield e.request({\n                                    method: r,\n                                    params: [\n                                        Object.assign(Object.assign({}, i[0]), {\n                                            from: t[0]\n                                        })\n                                    ]\n                                }), o) : oh.includes(r.toLowerCase()) ? (console.warn(\"MetaMaskSDK connectWith method=\".concat(r, \" -- not handled by the extension -- call separately\")), o = t, o) : (o = yield e.request({\n                                    method: r,\n                                    params: i\n                                }), o);\n                            } catch (e) {\n                                throw s = e, e;\n                            } finally{\n                                Mh(r, o, s);\n                            }\n                        });\n                    })({\n                        target: r,\n                        params: a\n                    });\n                    let h, f = null;\n                    try {\n                        return h = yield r.request(e), h;\n                    } catch (e) {\n                        throw f = e, e;\n                    } finally{\n                        l && (null === (o = t.analytics) || void 0 === o || o.send({\n                            event: Ao.SDK_RPC_REQUEST_DONE,\n                            params: {\n                                method: s,\n                                from: u,\n                                id: d\n                            }\n                        })), Mh(s, h, f);\n                    }\n                });\n            } : \"getChainId\" === i ? function() {\n                return e.chainId;\n            } : \"getNetworkVersion\" === i ? function() {\n                return e.networkVersion;\n            } : \"getSelectedAddress\" === i ? function() {\n                return e.selectedAddress;\n            } : \"isConnected\" === i ? function() {\n                return e._state.isConnected;\n            } : r[i]\n    });\n};\nvar Th;\nfunction Rh(param) {\n    let { mustBeMetaMask: e, sdkInstance: t } = param;\n    return c(this, void 0, void 0, function*() {\n        if (false) {}\n        try {\n            const e = yield new Promise((e, t)=>{\n                const n = setTimeout(()=>{\n                    t(new Error(\"eip6963RequestProvider timed out\"));\n                }, 500);\n                window.addEventListener(Th.Announce, (t)=>{\n                    const r = t, { detail: { info: i, provider: o } = {} } = r, { name: s, rdns: a, uuid: c } = null != i ? i : {};\n                    th.test(c) && s.startsWith(eh.NAME) && eh.RDNS.includes(a) && (clearTimeout(n), e(o));\n                }), window.dispatchEvent(new Event(Th.Request));\n            });\n            return Ih({\n                provider: e,\n                sdkInstance: t\n            });\n        } catch (n) {\n            if (!e && window.ethereum) return Ih({\n                provider: window.ethereum,\n                sdkInstance: t\n            });\n            throw new Error(\"Provider not found\");\n        }\n    });\n}\n_c141 = Rh;\n!function(e) {\n    e.Announce = \"eip6963:announceProvider\", e.Request = \"eip6963:requestProvider\";\n}(Th || (Th = {}));\nconst Ph = (e)=>c(void 0, void 0, void 0, function*() {\n        const { options: t } = e, { infuraAPIKey: n } = t;\n        if (!n) return;\n        const r = {\n            \"0x1\": \"https://mainnet.infura.io/v3/\".concat(n),\n            \"0x5\": \"https://goerli.infura.io/v3/\".concat(n),\n            \"0xaa36a7\": \"https://sepolia.infura.io/v3/\".concat(n),\n            \"0xe708\": \"https://linea-mainnet.infura.io/v3/\".concat(n),\n            \"0xe704\": \"https://linea-goerli.infura.io/v3/\".concat(n),\n            \"0x89\": \"https://polygon-mainnet.infura.io/v3/\".concat(n),\n            \"0x13881\": \"https://polygon-mumbai.infura.io/v3/\".concat(n),\n            \"0x45\": \"https://optimism-mainnet.infura.io/v3/\".concat(n),\n            \"0x1a4\": \"https://optimism-goerli.infura.io/v3/\".concat(n),\n            \"0xa4b1\": \"https://arbitrum-mainnet.infura.io/v3/\".concat(n),\n            \"0x66eed\": \"https://arbitrum-goerli.infura.io/v3/\".concat(n),\n            \"0x2a15c308d\": \"https://palm-mainnet.infura.io/v3/\".concat(n),\n            \"0x2a15c3083\": \"https://palm-testnet.infura.io/v3/\".concat(n),\n            \"0xa86a\": \"https://avalanche-mainnet.infura.io/v3/\".concat(n),\n            \"0xa869\": \"https://avalanche-fuji.infura.io/v3/\".concat(n),\n            \"0x4e454152\": \"https://aurora-mainnet.infura.io/v3/\".concat(n),\n            \"0x4e454153\": \"https://aurora-testnet.infura.io/v3/\".concat(n),\n            \"0x534e5f4d41494e\": \"https://starknet-mainnet.infura.io/v3/\".concat(n),\n            \"0x534e5f474f45524c49\": \"https://starknet-goerli.infura.io/v3/\".concat(n),\n            \"0x534e5f474f45524c4932\": \"https://starknet-goerli2.infura.io/v3/\".concat(n),\n            \"0xa4ec\": \"https://celo-mainnet.infura.io/v3/\".concat(n),\n            \"0xaef3\": \"https://celo-alfajores.infura.io/v3/\".concat(n)\n        };\n        e.options.readonlyRPCMap ? e.options.readonlyRPCMap = Object.assign(Object.assign({}, e.options.readonlyRPCMap), r) : e.options.readonlyRPCMap = r;\n    });\n_c142 = Ph;\nconst Oh = (e)=>c(void 0, void 0, void 0, function*() {\n        const { options: t } = e, { readonlyRPCMap: n } = t;\n        if (n) try {\n            Au(\"[MetaMaskSDK: setupReadOnlyRPCProviders()] Setting up Readonly RPC Providers\", n), e.setReadOnlyRPCCalls(!0);\n        } catch (e) {\n            throw new Error(\"Invalid Infura Settings\");\n        }\n    });\n_c143 = Oh;\nfunction Nh(e, t, n, r) {\n    return new (n || (n = Promise))(function(t, i) {\n        function o(e) {\n            try {\n                a(r.next(e));\n            } catch (e) {\n                i(e);\n            }\n        }\n        function s(e) {\n            try {\n                a(r.throw(e));\n            } catch (e) {\n                i(e);\n            }\n        }\n        function a(e) {\n            var r;\n            e.done ? t(e.value) : (r = e.value, r instanceof n ? r : new n(function(e) {\n                e(r);\n            })).then(o, s);\n        }\n        a((r = r.apply(e, [])).next());\n    });\n}\n_c144 = Nh;\nfunction Lh(e, t) {\n    var n, r, i, o, s = {\n        label: 0,\n        sent: function() {\n            if (1 & i[0]) throw i[1];\n            return i[1];\n        },\n        trys: [],\n        ops: []\n    };\n    return o = {\n        next: a(0),\n        throw: a(1),\n        return: a(2)\n    }, \"function\" == typeof Symbol && (o[Symbol.iterator] = function() {\n        return this;\n    }), o;\n    function a(o) {\n        return function(a) {\n            return function(o) {\n                if (n) throw new TypeError(\"Generator is already executing.\");\n                for(; s;)try {\n                    if (n = 1, r && (i = 2 & o[0] ? r.return : o[0] ? r.throw || ((i = r.return) && i.call(r), 0) : r.next) && !(i = i.call(r, o[1])).done) return i;\n                    switch(r = 0, i && (o = [\n                        2 & o[0],\n                        i.value\n                    ]), o[0]){\n                        case 0:\n                        case 1:\n                            i = o;\n                            break;\n                        case 4:\n                            return s.label++, {\n                                value: o[1],\n                                done: !1\n                            };\n                        case 5:\n                            s.label++, r = o[1], o = [\n                                0\n                            ];\n                            continue;\n                        case 7:\n                            o = s.ops.pop(), s.trys.pop();\n                            continue;\n                        default:\n                            if (!(i = s.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {\n                                s = 0;\n                                continue;\n                            }\n                            if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {\n                                s.label = o[1];\n                                break;\n                            }\n                            if (6 === o[0] && s.label < i[1]) {\n                                s.label = i[1], i = o;\n                                break;\n                            }\n                            if (i && s.label < i[2]) {\n                                s.label = i[2], s.ops.push(o);\n                                break;\n                            }\n                            i[2] && s.ops.pop(), s.trys.pop();\n                            continue;\n                    }\n                    o = t.call(e, s);\n                } catch (e) {\n                    o = [\n                        6,\n                        e\n                    ], r = 0;\n                } finally{\n                    n = i = 0;\n                }\n                if (5 & o[0]) throw o[1];\n                return {\n                    value: o[0] ? o[1] : void 0,\n                    done: !0\n                };\n            }([\n                o,\n                a\n            ]);\n        };\n    }\n}\n_c145 = Lh;\nvar Dh = \"INSTALLED\", $h = \"NOT_INSTALLED\", Bh = \"REGISTERED\", Kh = \"REGISTERING\", jh = \"RELOADING\", Uh = {\n    CHROME: \"https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn\",\n    FIREFOX: \"https://addons.mozilla.org/firefox/addon/ether-metamask/\",\n    DEFAULT: \"https://metamask.io\"\n}, Hh = \"REGISTRATION_IN_PROGRESS\", Fh = \"FORWARDER_ID\", zh = function() {\n    function e(t) {\n        var n = void 0 === t ? {} : t, r = n.forwarderOrigin, i = void 0 === r ? \"https://fwd.metamask.io\" : r, o = n.forwarderMode, s = void 0 === o ? e.FORWARDER_MODE.INJECT : o;\n        this.forwarderOrigin = i, this.forwarderMode = s, this.state = e.isMetaMaskInstalled() ? Dh : $h;\n        var a = e._detectBrowser();\n        this.downloadUrl = a ? Uh[a] : Uh.DEFAULT, this._onMessage = this._onMessage.bind(this), this._onMessageFromForwarder = this._onMessageFromForwarder.bind(this), this._openForwarder = this._openForwarder.bind(this), this._openDownloadPage = this._openDownloadPage.bind(this), this.startOnboarding = this.startOnboarding.bind(this), this.stopOnboarding = this.stopOnboarding.bind(this), window.addEventListener(\"message\", this._onMessage), s === e.FORWARDER_MODE.INJECT && \"true\" === sessionStorage.getItem(Hh) && e._injectForwarder(this.forwarderOrigin);\n    }\n    return e.prototype._onMessage = function(e) {\n        if (e.origin === this.forwarderOrigin) return \"metamask:reload\" === e.data.type ? this._onMessageFromForwarder(e) : void console.debug(\"Unknown message from '\" + e.origin + \"' with data \" + JSON.stringify(e.data));\n    }, e.prototype._onMessageUnknownStateError = function(e) {\n        throw new Error(\"Unknown state: '\" + e + \"'\");\n    }, e.prototype._onMessageFromForwarder = function(t) {\n        return Nh(this, 0, void 0, function() {\n            return Lh(this, function(n) {\n                switch(n.label){\n                    case 0:\n                        switch(this.state){\n                            case jh:\n                                return [\n                                    3,\n                                    1\n                                ];\n                            case $h:\n                                return [\n                                    3,\n                                    2\n                                ];\n                            case Dh:\n                                return [\n                                    3,\n                                    3\n                                ];\n                            case Kh:\n                                return [\n                                    3,\n                                    5\n                                ];\n                            case Bh:\n                                return [\n                                    3,\n                                    6\n                                ];\n                        }\n                        return [\n                            3,\n                            7\n                        ];\n                    case 1:\n                        return console.debug(\"Ignoring message while reloading\"), [\n                            3,\n                            8\n                        ];\n                    case 2:\n                        return console.debug(\"Reloading now to register with MetaMask\"), this.state = jh, location.reload(), [\n                            3,\n                            8\n                        ];\n                    case 3:\n                        return console.debug(\"Registering with MetaMask\"), this.state = Kh, [\n                            4,\n                            e._register()\n                        ];\n                    case 4:\n                        return n.sent(), this.state = Bh, t.source.postMessage({\n                            type: \"metamask:registrationCompleted\"\n                        }, t.origin), this.stopOnboarding(), [\n                            3,\n                            8\n                        ];\n                    case 5:\n                        return console.debug(\"Already registering - ignoring reload message\"), [\n                            3,\n                            8\n                        ];\n                    case 6:\n                        return console.debug(\"Already registered - ignoring reload message\"), [\n                            3,\n                            8\n                        ];\n                    case 7:\n                        this._onMessageUnknownStateError(this.state), n.label = 8;\n                    case 8:\n                        return [\n                            2\n                        ];\n                }\n            });\n        });\n    }, e.prototype.startOnboarding = function() {\n        sessionStorage.setItem(Hh, \"true\"), this._openDownloadPage(), this._openForwarder();\n    }, e.prototype.stopOnboarding = function() {\n        \"true\" === sessionStorage.getItem(Hh) && (this.forwarderMode === e.FORWARDER_MODE.INJECT && (console.debug(\"Removing forwarder\"), e._removeForwarder()), sessionStorage.setItem(Hh, \"false\"));\n    }, e.prototype._openForwarder = function() {\n        this.forwarderMode === e.FORWARDER_MODE.OPEN_TAB ? window.open(this.forwarderOrigin, \"_blank\") : e._injectForwarder(this.forwarderOrigin);\n    }, e.prototype._openDownloadPage = function() {\n        window.open(this.downloadUrl, \"_blank\");\n    }, e.isMetaMaskInstalled = function() {\n        return Boolean(window.ethereum && window.ethereum.isMetaMask);\n    }, e._register = function() {\n        return window.ethereum.request({\n            method: \"wallet_registerOnboarding\"\n        });\n    }, e._injectForwarder = function(e) {\n        var t = document.body, n = document.createElement(\"iframe\");\n        n.setAttribute(\"height\", \"0\"), n.setAttribute(\"width\", \"0\"), n.setAttribute(\"style\", \"display: none;\"), n.setAttribute(\"src\", e), n.setAttribute(\"id\", Fh), t.insertBefore(n, t.children[0]);\n    }, e._removeForwarder = function() {\n        var e;\n        null === (e = document.getElementById(Fh)) || void 0 === e || e.remove();\n    }, e._detectBrowser = function() {\n        var e = Fu.parse(window.navigator.userAgent);\n        return \"Firefox\" === e.browser.name ? \"FIREFOX\" : [\n            \"Chrome\",\n            \"Chromium\"\n        ].includes(e.browser.name || \"\") ? \"CHROME\" : null;\n    }, e.FORWARDER_MODE = {\n        INJECT: \"INJECT\",\n        OPEN_TAB: \"OPEN_TAB\"\n    }, e;\n}();\nfunction qh(e, param) {\n    let { wait: t = !1 } = param;\n    return c(this, void 0, void 0, function*() {\n        return Au(\"[MetamaskInstaller: startInstaller()] wait=\".concat(t)), t && (yield wh(1e3)), yield e.checkInstallation();\n    });\n}\nclass Wh {\n    startDesktopOnboarding() {\n        return function() {\n            return c(this, void 0, void 0, function*() {\n                Au(\"[MetamaskInstaller: startDesktopOnboarding() starting desktop onboarding\"), window.ethereum && (window.ethereum = void 0), (new zh).startOnboarding();\n            });\n        }();\n    }\n    redirectToProperInstall() {\n        return c(this, void 0, void 0, function*() {\n            return function(e) {\n                var t, n;\n                return c(this, void 0, void 0, function*() {\n                    const { state: r } = e, i = null === (t = r.platformManager) || void 0 === t ? void 0 : t.getPlatformType();\n                    if (Au(\"[MetamaskInstaller: redirectToProperInstall()] platform=\".concat(i)), i === Uo.MetaMaskMobileWebview) return !1;\n                    r.isInstalling = !0;\n                    try {\n                        yield null === (n = r.remote) || void 0 === n ? void 0 : n.startConnection({\n                            connectWith: r.connectWith\n                        }), r.isInstalling = !1, r.hasInstalled = !0;\n                    } catch (e) {\n                        throw r.isInstalling = !1, e;\n                    }\n                    return !0;\n                });\n            }(this);\n        });\n    }\n    checkInstallation() {\n        return c(this, void 0, void 0, function*() {\n            return function(e) {\n                var t;\n                return c(this, void 0, void 0, function*() {\n                    const { state: n } = e, r = null === (t = n.platformManager) || void 0 === t ? void 0 : t.isMetaMaskInstalled();\n                    return Au(\"[MetamaskInstaller: checkInstallation()] isInstalled=\".concat(r)), !!r || (yield e.redirectToProperInstall());\n                });\n            }(this);\n        });\n    }\n    start(param) {\n        let { wait: e = !1, connectWith: t } = param;\n        return c(this, void 0, void 0, function*() {\n            this.state.connectWith = t, Au(\"[MetaMaskInstaller: start()] wait=\".concat(e), t), yield qh(this, {\n                wait: e\n            });\n        });\n    }\n    constructor({ remote: e, preferDesktop: t, platformManager: n, debug: r = !1 }){\n        this.state = {\n            isInstalling: !1,\n            hasInstalled: !1,\n            resendRequest: null,\n            preferDesktop: !1,\n            platformManager: null,\n            remote: null,\n            debug: !1,\n            connectWith: void 0\n        }, this.state.remote = e, this.state.preferDesktop = t, this.state.platformManager = n, this.state.debug = r;\n    }\n}\nclass Vh {\n    loadComponent(e) {\n        return c(this, void 0, void 0, function*() {\n            if (!this.defined[e]) {\n                this.defined[e] = !0;\n                try {\n                    const e = yield Promise.resolve().then(function() {\n                        return Pp;\n                    });\n                    console.log(\"loader\", e), e.defineCustomElements();\n                } catch (t) {\n                    console.error(\"Failed to load \".concat(e, \" modal:\"), t);\n                }\n            }\n        });\n    }\n    renderInstallModal(e) {\n        var t;\n        return c(this, void 0, void 0, function*() {\n            this.debug && console.debug(\"ModalLoader: renderInstallModal\", e), this.containers.install = e.parentElement, yield this.loadComponent(\"install\");\n            const n = document.createElement(\"mm-install-modal\");\n            n.link = e.link, n.preferDesktop = e.preferDesktop, n.sdkVersion = null !== (t = e.sdkVersion) && void 0 !== t ? t : this.sdkVersion, n.addEventListener(\"close\", (param)=>{\n                let { detail: { shouldTerminate: t } } = param;\n                return e.onClose(t);\n            }), n.addEventListener(\"startDesktopOnboarding\", e.metaMaskInstaller.startDesktopOnboarding), n.addEventListener(\"trackAnalytics\", (t)=>{\n                var n;\n                return null === (n = e.onAnalyticsEvent) || void 0 === n ? void 0 : n.call(e, t.detail);\n            }), e.parentElement.appendChild(n);\n        });\n    }\n    renderSelectModal(e) {\n        var t;\n        return c(this, void 0, void 0, function*() {\n            this.containers.select = e.parentElement, yield this.loadComponent(\"select\");\n            const n = document.createElement(\"mm-select-modal\");\n            n.link = e.link, n.sdkVersion = null !== (t = e.sdkVersion) && void 0 !== t ? t : this.sdkVersion, n.preferDesktop = e.preferDesktop, n.addEventListener(\"close\", (param)=>{\n                let { detail: { shouldTerminate: t } } = param;\n                return e.onClose(t);\n            }), n.addEventListener(\"connectWithExtension\", e.connectWithExtension), e.parentElement.appendChild(n), setTimeout(()=>this.updateQRCode(e.link), 100);\n        });\n    }\n    renderPendingModal(e) {\n        var t;\n        return c(this, void 0, void 0, function*() {\n            this.containers.pending = e.parentElement, yield this.loadComponent(\"pending\");\n            const n = document.createElement(\"mm-pending-modal\");\n            n.sdkVersion = null !== (t = e.sdkVersion) && void 0 !== t ? t : this.sdkVersion, n.displayOTP = e.displayOTP, n.addEventListener(\"close\", e.onClose), n.addEventListener(\"updateOTPValue\", (param)=>{\n                let { detail: { otpValue: t } } = param;\n                return e.updateOTPValue(t);\n            }), e.onDisconnect && n.addEventListener(\"disconnect\", e.onDisconnect), e.parentElement.appendChild(n);\n        });\n    }\n    updateOTPValue(e) {\n        const t = ()=>{\n            var t;\n            const n = null === (t = this.containers.pending) || void 0 === t ? void 0 : t.querySelector(\"mm-pending-modal\");\n            return !!n && (n.otpCode = e, !0);\n        };\n        setTimeout(()=>{\n            t();\n        }, 800);\n    }\n    updateQRCode(e) {\n        var t, n;\n        const r = null === (t = this.containers.install) || void 0 === t ? void 0 : t.querySelector(\"mm-install-modal\");\n        if (r) r.link = e;\n        else {\n            const t = null === (n = this.containers.select) || void 0 === n ? void 0 : n.querySelector(\"mm-select-modal\");\n            t && (t.link = e);\n        }\n    }\n    unmount() {\n        Object.entries(this.containers).forEach((param)=>{\n            let [e, t] = param;\n            var n;\n            null === (n = null == t ? void 0 : t.parentNode) || void 0 === n || n.removeChild(t), this.containers[e] = void 0;\n        });\n    }\n    constructor({ debug: e, sdkVersion: t }){\n        this.containers = {\n            install: void 0,\n            pending: void 0,\n            select: void 0\n        }, this.defined = {\n            install: !1,\n            pending: !1,\n            select: !1\n        }, this.debug = null != e && e, this.sdkVersion = t;\n    }\n}\nconst Gh = (param)=>{\n    let { link: e, debug: t, installer: n, terminate: r, connectWithExtension: i, preferDesktop: o, onAnalyticsEvent: s } = param;\n    let a = null, c = null;\n    Au(\"[UI: InstallModal-web: sdkWebInstallModal()] ################## Installing Modal #################\"), Au(\"[UI: InstallModal-web: sdkWebInstallModal()] link=\".concat(e)), Au('[UI: InstallModal-web: sdkWebInstallModal()] npx uri-scheme open \"'.concat(e, '\" --ios')), Au('[UI: InstallModal-web: sdkWebInstallModal()] npx uri-scheme open \"'.concat(e, '\" --android')), Au('[UI: InstallModal-web: sdkWebInstallModal()] adb shell am start -a android.intent.action.VIEW -d \"'.concat(e, '\"'));\n    const l = (e)=>{\n        var t;\n        Au(\"[UI: InstallModal-web: sdkWebInstallModal()] installModal-web unmounting install modal -- shouldTerminate:\", e, c), (null == c ? void 0 : c.parentNode) && (null === (t = c.parentNode) || void 0 === t || t.removeChild(c)), c = null, a = null, !0 === e && (null == r || r());\n    };\n    return {\n        mount: (r)=>{\n            if (Au(\"[UI: InstallModal-web: sdkWebInstallModal()] installModal-web mounting install modal\", c), c) return c.style.display = \"block\", void (null == a || a.updateQRCode(r));\n            a = new Vh({\n                debug: t,\n                sdkVersion: Zu.version\n            }), c = document.createElement(\"div\"), document.body.appendChild(c), window.extension ? a.renderSelectModal({\n                parentElement: c,\n                connectWithExtension: ()=>{\n                    l(), null == i || i();\n                },\n                onClose: l,\n                link: e,\n                preferDesktop: null != o && o\n            }).catch((e)=>{\n                console.error(e);\n            }) : a.renderInstallModal({\n                parentElement: c,\n                preferDesktop: null != o && o,\n                link: e,\n                metaMaskInstaller: n,\n                onClose: l,\n                onAnalyticsEvent: s\n            }).catch((e)=>{\n                console.error(\"[UI: InstallModal-web: sdkWebInstallModal()]\", e);\n            });\n        },\n        unmount: l\n    };\n}, Yh = (param)=>{\n    let { onDisconnect: e, debug: t } = param;\n    let n = null, r = null;\n    const i = ()=>{\n        Au(\"[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web unmount\", n), (null == n ? void 0 : n.parentNode) && n.parentNode.removeChild(n), n = null, r = null;\n    }, o = (e)=>{\n        Au(\"[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web updateOTPValue\", e), r && r.updateOTPValue(e);\n    }, s = function() {\n        let { displayOTP: s } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {\n            displayOTP: !0\n        };\n        Au(\"[UI: pendingModal-web: sdkWebPendingModal()] pendingModal-web mount\", n), n ? n.style.display = \"block\" : (r = new Vh({\n            debug: t,\n            sdkVersion: Zu.version\n        }), n = document.createElement(\"div\"), document.body.appendChild(n), r.renderPendingModal({\n            parentElement: n,\n            onClose: i,\n            onDisconnect: e,\n            updateOTPValue: o,\n            displayOTP: s\n        }).catch((e)=>{\n            console.error(\"[UI: pendingModal-web: sdkWebPendingModal()]\", e);\n        }));\n    };\n    return s(), {\n        mount: s,\n        unmount: i,\n        updateOTPValue: o\n    };\n};\nfunction Zh(e, t) {\n    var n, r, i, o;\n    e.connector || (Au(\"[RemoteConnection: initializeConnector()] initialize connector\"), e.connector = new ts({\n        anonId: t.anonId,\n        platformType: t.platformManager.getPlatformType(),\n        communicationLayerPreference: t.communicationLayerPreference,\n        transports: t.transports,\n        dappMetadata: Object.assign(Object.assign({}, t.dappMetadata), {\n            source: t._source\n        }),\n        analytics: t.enableAnalytics,\n        communicationServerUrl: t.communicationServerUrl,\n        sdkVersion: Zu.version,\n        context: \"dapp\",\n        ecies: t.ecies,\n        storage: t.storage,\n        logging: t.logging\n    }), t.timer && (Au(\"[RemoteConnection: initializeConnector()] reset background timer\", t.timer), null === (r = null === (n = t.timer) || void 0 === n ? void 0 : n.stopBackgroundTimer) || void 0 === r || r.call(n), null === (o = null === (i = t.timer) || void 0 === i ? void 0 : i.runBackgroundTimer) || void 0 === o || o.call(i, ()=>!1, 1e4)));\n}\n_c146 = Zh;\nfunction Jh(e) {\n    e.listeners.forEach((param)=>{\n        let { event: t, handler: n } = param;\n        var r;\n        null === (r = e.connector) || void 0 === r || r.off(t, n);\n    }), e.listeners = [];\n}\n_c147 = Jh;\nfunction Qh(e, t, r) {\n    return c(this, void 0, void 0, function*() {\n        const i = setTimeout(()=>{\n            _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.track(\"sdk_connection_failed\", {\n                transport_type: \"websocket\"\n            });\n        }, 6e4);\n        return new Promise((n, o)=>{\n            if (!e.connector) return void o(new Error(\"No connector available\"));\n            Au(\"[RemoteConnection: connectWithModalInstaller()]\", {\n                state: e,\n                options: t,\n                linkParams: r\n            });\n            const s = \"\".concat(e.useDeeplink ? Xu : Qu, \"?\").concat(r);\n            !function(e, t, n) {\n                var r, i, o, s;\n                e.installModal = null === (i = (r = t.modals).install) || void 0 === i ? void 0 : i.call(r, {\n                    link: n,\n                    preferDesktop: e.preferDesktop,\n                    installer: t.getMetaMaskInstaller(),\n                    terminate: ()=>{\n                        Au(\"[RemoteConnection: showInstallModal() => terminate()] terminate connection\"), t.sdk.terminate().catch((e)=>{\n                            console.warn(\"[MMSDK] failed to terminate connection\", e);\n                        });\n                    },\n                    debug: e.developerMode,\n                    connectWithExtension: ()=>{\n                        var e;\n                        return null === (e = t.connectWithExtensionProvider) || void 0 === e || e.call(t), !1;\n                    },\n                    onAnalyticsEvent: (param)=>{\n                        let { event: n, params: r } = param;\n                        var i, o, s;\n                        const a = Object.assign(Object.assign({}, r), {\n                            sdkVersion: t.sdk.getVersion(),\n                            dappId: null === (i = t.dappMetadata) || void 0 === i ? void 0 : i.name,\n                            source: t._source,\n                            url: null === (o = t.dappMetadata) || void 0 === o ? void 0 : o.url\n                        });\n                        null === (s = e.analytics) || void 0 === s || s.send({\n                            event: n,\n                            params: a\n                        });\n                    }\n                }), null === (s = null === (o = e.installModal) || void 0 === o ? void 0 : o.mount) || void 0 === s || s.call(o, n);\n            }(e, t, s), t.sdk.once(So.PROVIDER_UPDATE, (e)=>c(this, void 0, void 0, function*() {\n                    if (Au(\"[RemoteConnection: connectWithModalInstaller()] once provider_update -- resolving startConnection promise\"), e === hh.TERMINATE) {\n                        const e = {\n                            code: 4001,\n                            message: \"User rejected the request.\"\n                        };\n                        return clearTimeout(i), void o(e);\n                    }\n                    o(e);\n                })), e.connector.once(So.AUTHORIZED, ()=>{\n                clearTimeout(i), n();\n            }), e.connector.once(So.REJECTED, ()=>{\n                clearTimeout(i), o(So.REJECTED);\n            }), e.connector.once(So.CLIENTS_READY, ()=>c(this, void 0, void 0, function*() {\n                    Au(\"[RemoteConnection: connectWithModalInstaller()] once clients_ready -- resolving startConnection promise\"), clearTimeout(i), n();\n                }));\n        });\n    });\n}\n_c148 = Qh;\nfunction Xh(e, t) {\n    function n(t, n) {\n        var r;\n        null === (r = e.connector) || void 0 === r || r.on(t, n), e.listeners.push({\n            event: t,\n            handler: n\n        });\n    }\n    e.connector && (Jh(e), n(So.WALLET_INIT, (param)=>{\n        let { accounts: e, chainId: t } = param;\n        return c(this, void 0, void 0, function*() {\n            Au(\"[RemoteConnection: setupListeners() => EventType.WALLET_INIT] 'wallet_init' accounts=\".concat(e, \" chainId=\").concat(t));\n            const n = qu.getProvider();\n            n._setConnected();\n            const r = {\n                accounts: e,\n                chainId: t,\n                isUnlocked: !1\n            };\n            n._initializeState(r), n.emit(\"chainChanged\", t), n.emit(\"accountsChanged\", e);\n        });\n    }), n(So.AUTHORIZED, ()=>c(this, void 0, void 0, function*() {\n            var t, n, r, i;\n            try {\n                Au(\"[RemoteConnection: setupListeners() => EventType.AUTHORIZED] 'authorized' closing modals\", e.pendingModal, e.installModal);\n                const o = qu.getProvider();\n                o._setConnected(), null === (n = null === (t = e.pendingModal) || void 0 === t ? void 0 : t.unmount) || void 0 === n || n.call(t), null === (i = null === (r = e.installModal) || void 0 === r ? void 0 : r.unmount) || void 0 === i || i.call(r, !1), e.otpAnswer = void 0, e.authorized = !0, Au(\"[RemoteConnection: setupListeners() => EventType.AUTHORIZED] 'authorized' provider.state\", o.getState()), yield o.forceInitializeState();\n            } catch (e) {}\n        })), n(So.TERMINATE, ()=>{\n        var t, n, r, i, o;\n        null === (n = null === (t = e.pendingModal) || void 0 === t ? void 0 : t.unmount) || void 0 === n || n.call(t), null === (i = null === (r = e.installModal) || void 0 === r ? void 0 : r.unmount) || void 0 === i || i.call(r, !0), e.pendingModal = void 0, e.installModal = void 0, e.otpAnswer = void 0, null === (o = e.connector) || void 0 === o || o.disconnect({\n            terminate: !0\n        }), e.authorized = !1;\n        qu.getProvider().handleDisconnect({\n            terminate: !0\n        }), Jh(e), Au(\"[RemoteConnection: setupListeners()] All listeners cleaned up\");\n    }));\n}\n_c149 = Xh;\nfunction ef(e, t) {\n    let { initialCheck: r, connectWith: i } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    var o, s, a, l, d, u, h, f, p, g, m, y, v, b, w, E, S, _, C;\n    return c(this, void 0, void 0, function*() {\n        try {\n            if (Zh(e, t), !e.connector) throw new Error(\"no connector defined\");\n            Xh(e);\n            const k = qu.getProvider();\n            e.authorized = !1, k.emit(\"connecting\");\n            const A = yield null === (o = e.connector) || void 0 === o ? void 0 : o.originatorSessionConnect();\n            Au(\"[RemoteConnection: startConnection()] after originatorSessionConnect initialCheck=\".concat(r), A);\n            let x = null !== (s = null == A ? void 0 : A.channelId) && void 0 !== s ? s : \"\", M = null !== (l = null === (a = e.connector.getKeyInfo()) || void 0 === a ? void 0 : a.ecies.public) && void 0 !== l ? l : \"\", I = null !== (u = null === (d = e.connector.getKeyInfo()) || void 0 === d ? void 0 : d.ecies.private) && void 0 !== u ? u : \"\";\n            if (r && !A) return Promise.resolve();\n            if (!A && !r) {\n                const t = yield e.connector.generateChannelIdConnect();\n                x = null !== (h = t.channelId) && void 0 !== h ? h : \"\", M = null !== (f = t.pubKey) && void 0 !== f ? f : \"\", I = null !== (p = t.privKey) && void 0 !== p ? p : \"\";\n                const n = Date.now();\n                null === (g = e.connector.state.storageManager) || void 0 === g || g.persistChannelConfig({\n                    channelId: x,\n                    localKey: I,\n                    lastActive: n,\n                    validUntil: n + go\n                });\n            }\n            if (r && (null == A ? void 0 : A.channelId)) return (null === (m = e.connector) || void 0 === m ? void 0 : m.isConnected()) || (Au(\"[RemoteConnection: startConnection()] reconnecting to channel initialCheck=\".concat(r), A), yield null === (y = e.connector) || void 0 === y ? void 0 : y.connectToChannel({\n                channelId: x\n            })), Promise.resolve();\n            A && !(null === (v = e.connector) || void 0 === v ? void 0 : v.isConnected()) && (Au(\"[RemoteConnection: startConnection()] reconnecting to channel\", A), yield null === (b = e.connector) || void 0 === b ? void 0 : b.connectToChannel({\n                channelId: x\n            }));\n            const T = (null === (w = e.platformManager) || void 0 === w ? void 0 : w.isSecure()) ? \"\" : \"&t=q\", R = Zu.version, { iconUrl: P, name: O, url: N, scheme: L } = t.dappMetadata || {}, D = null === (E = e.platformManager) || void 0 === E ? void 0 : E.getPlatformType();\n            let $ = \"N/A\";\n             true && window.location && window.location.hostname ? $ = window.location.hostname : void 0 !== O ? $ = O : void 0 !== N && ($ = N);\n            const B = {\n                url: null != N ? N : \"\",\n                title: null != O ? O : \"\",\n                icon: P,\n                scheme: null != L ? L : \"\",\n                apiVersion: R,\n                dappId: $ || N || \"N/A\",\n                anonId: t.anonId,\n                platform: null != D ? D : \"\",\n                source: null !== (S = t._source) && void 0 !== S ? S : \"\"\n            }, K = mh(JSON.stringify(B));\n            let j = \"channelId=\".concat(x, \"&v=2&comm=\").concat(null !== (_ = e.communicationLayerPreference) && void 0 !== _ ? _ : \"\", \"&pubkey=\").concat(M).concat(T, \"&originatorInfo=\").concat(K);\n            if (i) {\n                j += \"&rpc=\".concat(mh(JSON.stringify(i)));\n                const t = e.connector.getRPCMethodTracker();\n                t && (t[\"\".concat(i.id)] = Object.assign(Object.assign({}, i), {\n                    id: \"\".concat(i.id),\n                    timestamp: Date.now()\n                }));\n            }\n            const U = encodeURI(j), H = \"\".concat(e.useDeeplink ? Xu : Qu, \"?\").concat(j);\n            if (e.qrcodeLink = H, e.developerMode && Au(\"[RemoteConnection: startConnection()] qrcodeLink=\".concat(U)), k.emit(\"display_uri\", H), _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.track(\"sdk_connection_initiated\", {\n                transport_type: \"websocket\"\n            }), null === (C = e.platformManager) || void 0 === C ? void 0 : C.isSecure()) {\n                const t = setTimeout(()=>{\n                    _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.track(\"sdk_connection_failed\", {\n                        transport_type: \"websocket\"\n                    });\n                }, 6e4);\n                return yield function(e, t) {\n                    var n, r;\n                    return c(this, void 0, void 0, function*() {\n                        const i = \"\".concat(Qu, \"?\").concat(t), o = \"\".concat(Xu, \"?\").concat(t);\n                        null === (r = null === (n = e.platformManager) || void 0 === n ? void 0 : n.openDeeplink) || void 0 === r || r.call(n, i, o, \"_self\");\n                    });\n                }(e, U), new Promise((n, r)=>{\n                    var i, o, s;\n                    if (null === (i = e.connector) || void 0 === i ? void 0 : i.isAuthorized()) return clearTimeout(t), void n();\n                    null === (o = e.connector) || void 0 === o || o.once(So.AUTHORIZED, ()=>{\n                        clearTimeout(t), n();\n                    }), null === (s = e.connector) || void 0 === s || s.once(So.REJECTED, ()=>{\n                        clearTimeout(t), r(So.REJECTED);\n                    });\n                });\n            }\n            return Qh(e, t, U);\n        } catch (e) {\n            throw console.error(\"[startConnection] error\", e), e;\n        }\n    });\n}\nclass tf {\n    startConnection(e) {\n        return c(this, void 0, void 0, function*() {\n            return ef(this.state, this.options, e);\n        });\n    }\n    initRemoteCommunication(param) {\n        let { sdkInstance: e } = param;\n        var t, n, r;\n        return c(this, void 0, void 0, function*() {\n            const i = yield null === (n = null === (t = e.options.storage) || void 0 === t ? void 0 : t.storageManager) || void 0 === n ? void 0 : n.getPersistedChannelConfig();\n            if (!this.options.ecies) {\n                const e = {\n                    privateKey: null == i ? void 0 : i.localKey\n                };\n                this.options.ecies = e;\n            }\n            Zh(this.state, this.options), yield null === (r = this.getConnector()) || void 0 === r ? void 0 : r.initFromDappStorage(), Xh(this.state, this.options);\n        });\n    }\n    showActiveModal() {\n        return function(e) {\n            var t, n, r, i;\n            e.authorized ? Au(\"[RemoteConnection: showActiveModal()] already authorized\") : e.pendingModal ? null === (n = (t = e.pendingModal).mount) || void 0 === n || n.call(t) : e.installModal && (null === (i = (r = e.installModal).mount) || void 0 === i || i.call(r, e.qrcodeLink || \"\"));\n        }(this.state);\n    }\n    closeModal() {\n        var e, t, n, r;\n        null === (t = null === (e = this.state.pendingModal) || void 0 === e ? void 0 : e.unmount) || void 0 === t || t.call(e), null === (r = null === (n = this.state.installModal) || void 0 === n ? void 0 : n.unmount) || void 0 === r || r.call(n, !1);\n    }\n    getUniversalLink() {\n        if (!this.state.qrcodeLink) throw new Error(\"connection not started. run startConnection() first.\");\n        return this.state.qrcodeLink;\n    }\n    getChannelConfig() {\n        var e;\n        return null === (e = this.state.connector) || void 0 === e ? void 0 : e.getChannelConfig();\n    }\n    getKeyInfo() {\n        var e;\n        return null === (e = this.state.connector) || void 0 === e ? void 0 : e.getKeyInfo();\n    }\n    getConnector() {\n        if (!this.state.connector) throw new Error(\"invalid remote connector\");\n        return this.state.connector;\n    }\n    getPlatformManager() {\n        if (!this.state.platformManager) throw new Error(\"PlatformManager not available\");\n        return this.state.platformManager;\n    }\n    isConnected() {\n        var e;\n        return (null === (e = this.state.connector) || void 0 === e ? void 0 : e.isReady()) || !1;\n    }\n    isAuthorized() {\n        var e;\n        return (null === (e = this.state.connector) || void 0 === e ? void 0 : e.isAuthorized()) || !1;\n    }\n    isPaused() {\n        var e;\n        return null === (e = this.state.connector) || void 0 === e ? void 0 : e.isPaused();\n    }\n    disconnect(e) {\n        var t, n, r;\n        Au(\"[RemoteConnection: disconnect()]\", e), (null == e ? void 0 : e.terminate) && (qu.getProvider().handleDisconnect({\n            terminate: !0\n        }), null === (n = null === (t = this.state.pendingModal) || void 0 === t ? void 0 : t.unmount) || void 0 === n || n.call(t), this.state.otpAnswer = void 0), null === (r = this.state.connector) || void 0 === r || r.disconnect(e), function(e) {\n            Au(\"[RemoteConnection: cleanupConnector()] cleaning up connector\"), e.connector && (Jh(e), e.connector.disconnect({\n                terminate: !0\n            }).catch((e)=>{\n                Au(\"[RemoteConnection: cleanupConnector()] error disconnecting connector\", e);\n            }));\n        }(this.state);\n    }\n    constructor(e){\n        var t, n, r;\n        this.state = {\n            connector: void 0,\n            qrcodeLink: void 0,\n            analytics: void 0,\n            developerMode: !1,\n            authorized: !1,\n            reconnection: !1,\n            preferDesktop: !1,\n            deeplinkProtocol: !1,\n            listeners: [],\n            communicationLayerPreference: void 0,\n            platformManager: void 0,\n            pendingModal: void 0,\n            installModal: void 0,\n            otpAnswer: void 0\n        }, this.options = e;\n        const i = !0 === (null === (t = e.logging) || void 0 === t ? void 0 : t.developerMode) || !0 === (null === (n = e.logging) || void 0 === n ? void 0 : n.sdk);\n        this.state.developerMode = i, this.state.analytics = e.analytics, this.state.preferDesktop = null !== (r = e.preferDesktop) && void 0 !== r && r, this.state.useDeeplink = e.sdk.options.useDeeplink, this.state.communicationLayerPreference = e.communicationLayerPreference, this.state.platformManager = e.platformManager, e.modals.install || (e.modals.install = Gh), e.modals.otp || (e.modals.otp = Yh);\n    }\n}\nfunction nf(e) {\n    var r, i, o, s, a, l, d, u, h, f, p;\n    return c(this, void 0, void 0, function*() {\n        const { options: g } = e;\n        if (g.logging = null !== (r = g.logging) && void 0 !== r ? r : {}, g.communicationLayerPreference = null !== (i = g.communicationLayerPreference) && void 0 !== i ? i : jo.SOCKET, void 0 !== g.enableDebug && (debug__WEBPACK_IMPORTED_MODULE_1___default().enable(\"MM_SDK\"), console.warn(\"enableDebug is removed. Please use enableAnalytics instead.\")), g.enableAnalytics = null === (o = g.enableAnalytics) || void 0 === o || o, g.injectProvider = null === (s = g.injectProvider) || void 0 === s || s, g.shouldShimWeb3 = null === (a = g.shouldShimWeb3) || void 0 === a || a, g.extensionOnly = null === (l = g.extensionOnly) || void 0 === l || l, g.useDeeplink = null === (d = g.useDeeplink) || void 0 === d || d, g.storage = null !== (u = g.storage) && void 0 !== u ? u : {\n            enabled: !0\n        }, g.headless) {\n            debug__WEBPACK_IMPORTED_MODULE_1___default()(\"[MetaMaskSDK: performSDKInitialization()] headless mode enabled\");\n            const e = ()=>{}, n = {\n                install: ()=>({\n                        mount: e,\n                        unmount: e\n                    })\n            }, r = {\n                installer: e\n            };\n            g.modals = n, g.ui = r;\n        }\n        const m = !0 === (null === (h = g.logging) || void 0 === h ? void 0 : h.developerMode);\n        e.debug = (null === (f = g.logging) || void 0 === f ? void 0 : f.sdk) || m, Au(\"[MetaMaskSDK: performSDKInitialization()] options\", e.options);\n        const y = Object.assign({}, g.logging);\n        m && (y.sdk = !0, y.eciesLayer = !0, y.keyExchangeLayer = !0, y.remoteLayer = !0, y.serviceLayer = !0, y.plaintext = !0), yield function(e) {\n            var t;\n            return c(this, void 0, void 0, function*() {\n                const { options: n } = e;\n                e.platformManager = new Wu({\n                    useDeepLink: null !== (t = n.useDeeplink) && void 0 !== t && t,\n                    preferredOpenLink: n.openDeeplink,\n                    debug: e.debug\n                });\n            });\n        }(e), yield function(e) {\n            var t, n, r, i, o;\n            return c(this, void 0, void 0, function*() {\n                const { options: s } = e, a = null === (t = e.platformManager) || void 0 === t ? void 0 : t.getPlatformType();\n                e.analytics = new Ch({\n                    serverUrl: null !== (n = s.communicationServerUrl) && void 0 !== n ? n : fo,\n                    enabled: s.enableAnalytics,\n                    originatorInfo: {\n                        url: null !== (r = s.dappMetadata.url) && void 0 !== r ? r : \"\",\n                        title: null !== (i = s.dappMetadata.name) && void 0 !== i ? i : \"\",\n                        dappId: e.getDappId(),\n                        platform: null != a ? a : \"\",\n                        source: null !== (o = s._source) && void 0 !== o ? o : \"\",\n                        anonId: \"\"\n                    }\n                });\n            });\n        }(e), yield function(e) {\n            var t, r, i;\n            return c(this, void 0, void 0, function*() {\n                if (!e.options.enableAnalytics) return;\n                if (!(null === (t = e.platformManager) || void 0 === t ? void 0 : t.isBrowser()) && !(null === (r = e.platformManager) || void 0 === r ? void 0 : r.isReactNative())) return;\n                const o = e.getVersion(), s = e.getDappId(), a = yield e.getAnonId(), c = null === (i = e.platformManager) || void 0 === i ? void 0 : i.getPlatformType(), l = e.options._source;\n                _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.setGlobalProperty(\"sdk_version\", o), _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.setGlobalProperty(\"dapp_id\", s), _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.setGlobalProperty(\"anon_id\", a), _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.setGlobalProperty(\"platform\", c), _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.setGlobalProperty(\"integration_type\", l), _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.enable(), _metamask_sdk_analytics__WEBPACK_IMPORTED_MODULE_2__.analytics.track(\"sdk_initialized\", {});\n            });\n        }(e), yield function(e) {\n            var t;\n            return c(this, void 0, void 0, function*() {\n                const { options: n } = e;\n                !0 !== (null === (t = n.storage) || void 0 === t ? void 0 : t.enabled) || n.storage.storageManager || (n.storage.storageManager = yield Vu(n.storage));\n            });\n        }(e), yield function(e) {\n            return c(this, void 0, void 0, function*() {\n                const { options: t } = e, n = /^(http|https):\\/\\/[^\\s]*$/;\n                if (t.dappMetadata) {\n                    t.dappMetadata.iconUrl && !n.test(t.dappMetadata.iconUrl) && (console.warn(\"Invalid dappMetadata.iconUrl: URL must start with http:// or https://\"), t.dappMetadata.iconUrl = void 0), t.dappMetadata.base64Icon && t.dappMetadata.base64Icon.length > Ah && (console.warn(\"Invalid dappMetadata.base64Icon: Base64-encoded icon string length must be less than 163400 characters\"), t.dappMetadata.base64Icon = void 0), t.dappMetadata.url && !n.test(t.dappMetadata.url) && console.warn(\"Invalid dappMetadata.url: URL must start with http:// or https://\");\n                    const e = kh();\n                    if (e && !t.dappMetadata.iconUrl && !t.dappMetadata.base64Icon) {\n                        const n = \"\".concat(window.location.protocol, \"//\").concat(window.location.host).concat(e);\n                        t.dappMetadata.iconUrl = n;\n                    }\n                }\n                e.dappMetadata = t.dappMetadata;\n            });\n        }(e), yield Ph(e), yield Oh(e);\n        const { metamaskBrowserExtension: v, preferExtension: b, shouldReturn: w } = yield function(e) {\n            var t, n, r, i;\n            return c(this, void 0, void 0, function*() {\n                const { options: o } = e;\n                let s, a = !1, l = !1;\n                if ( true && window.ethereum && !(null === (t = e.platformManager) || void 0 === t ? void 0 : t.isMetaMaskMobileWebView())) {\n                    a = \"extension\" === localStorage.getItem(ah);\n                    try {\n                        s = yield Rh({\n                            mustBeMetaMask: !0,\n                            sdkInstance: e\n                        }), window.extension = s, s.on(dh.CHAIN_CHANGED, (t)=>{\n                            Au(\"[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE chainChanged chainId=\".concat(t)), Boolean(e.sdkProvider) && e.getMobileProvider().emit(dh.CHAIN_CHANGED, t);\n                        }), s.on(dh.ACCOUNTS_CHANGED, (t)=>c(this, void 0, void 0, function*() {\n                                var n;\n                                Au(\"[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE accountsChanged accounts=\".concat(t));\n                                const r = Boolean(e.sdkProvider), i = Boolean(e.extensionActive);\n                                if (r && e.getMobileProvider().emit(dh.ACCOUNTS_CHANGED, t), i && 0 === (null == t ? void 0 : t.length) && 0 === (yield null === (n = e.getProvider()) || void 0 === n ? void 0 : n.request({\n                                    method: nh.WALLET_GETPERMISSIONS,\n                                    params: []\n                                })).length) try {\n                                    yield e.terminate();\n                                } catch (e) {\n                                    Au(\"[MetaMaskSDK: setupExtensionPreferences()] error terminating on permissions revoked\", e);\n                                }\n                            })), s.on(dh.DISCONNECT, (t)=>{\n                            Au(\"[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE disconnect error=\".concat(t)), Boolean(e.sdkProvider) && e.getMobileProvider().emit(dh.DISCONNECT, t);\n                        }), s.on(dh.CONNECT, (t)=>{\n                            Au(\"[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE connect args=\".concat(t)), Boolean(e.sdkProvider) && e.getMobileProvider().emit(dh.CONNECT, t);\n                        }), s.on(dh.CONNECTED, (t)=>{\n                            Au(\"[MetaMaskSDK: setupExtensionPreferences()] PROPAGATE connected\", t), Boolean(e.sdkProvider) && e.getMobileProvider().emit(dh.CONNECTED, t);\n                        });\n                    } catch (e) {\n                        window.extension = void 0;\n                    }\n                } else (null === (n = e.platformManager) || void 0 === n ? void 0 : n.isMetaMaskMobileWebView()) && (null === (r = e.analytics) || void 0 === r || r.send({\n                    event: Ao.SDK_USE_INAPP_BROWSER\n                }), e.activeProvider = Ih({\n                    provider: window.ethereum,\n                    sdkInstance: e\n                }), e._initialized = !0, l = !0);\n                return s && o.extensionOnly && (Au(\"[MetaMaskSDK: setupExtensionPreferences()] EXTENSION ONLY --- prevent sdk initialization\"), null === (i = e.analytics) || void 0 === i || i.send({\n                    event: Ao.SDK_USE_EXTENSION\n                }), e.activeProvider = s, e.extensionActive = !0, e.extension = s, e._initialized = !0, l = !0), {\n                    preferExtension: a,\n                    shouldReturn: l,\n                    metamaskBrowserExtension: s\n                };\n            });\n        }(e);\n        if (w) Au(\"[MetaMaskSDK: performSDKInitialization()] shouldReturn=true --- prevent sdk initialization\");\n        else {\n            yield function(e, t) {\n                var n, r, i, o, s;\n                return c(this, void 0, void 0, function*() {\n                    const { options: a } = e, c = Object.assign({}, a.logging);\n                    e.remoteConnection = new tf({\n                        anonId: yield e.getAnonId(),\n                        preferDesktop: null !== (n = a.preferDesktop) && void 0 !== n && n,\n                        communicationLayerPreference: null !== (r = a.communicationLayerPreference) && void 0 !== r ? r : jo.SOCKET,\n                        analytics: e.analytics,\n                        dappMetadata: a.dappMetadata,\n                        _source: a._source,\n                        enableAnalytics: null === (i = a.enableAnalytics) || void 0 === i || i,\n                        timer: a.timer,\n                        sdk: e,\n                        platformManager: e.platformManager,\n                        transports: a.transports,\n                        communicationServerUrl: a.communicationServerUrl,\n                        storage: null !== (o = a.storage) && void 0 !== o ? o : {\n                            enabled: !0\n                        },\n                        getMetaMaskInstaller: ()=>{\n                            if (!e.installer) throw new Error(\"Invalid SDK status -- installer not initialized\");\n                            return e.installer;\n                        },\n                        logging: c,\n                        connectWithExtensionProvider: void 0 === t ? void 0 : ()=>gh(e),\n                        modals: Object.assign(Object.assign({}, a.modals), {\n                            onPendingModalDisconnect: e.terminate.bind(e)\n                        })\n                    }), yield e.remoteConnection.initRemoteCommunication({\n                        sdkInstance: e\n                    }), e.installer = new Wh({\n                        remote: e.remoteConnection,\n                        preferDesktop: null !== (s = a.preferDesktop) && void 0 !== s && s,\n                        platformManager: e.platformManager,\n                        debug: e.debug\n                    });\n                });\n            }(e, v), yield Sh(e), yield function(e, t) {\n                var n, r;\n                return c(this, void 0, void 0, function*() {\n                    const { options: i } = e;\n                    t ? (Au(\"[MetaMaskSDK: handleAutoAndExtensionConnections()] preferExtension is detected -- connect with it.\"), null === (n = e.analytics) || void 0 === n || n.send({\n                        event: Ao.SDK_EXTENSION_UTILIZED\n                    }), gh(e).catch((e)=>{\n                        console.warn(\"Can't connect with MetaMask extension...\", e), localStorage.removeItem(ah);\n                    })) : i.checkInstallationImmediately && ((null === (r = e.platformManager) || void 0 === r ? void 0 : r.isDesktopWeb()) ? (Au(\"[MetaMaskSDK: handleAutoAndExtensionConnections()] checkInstallationImmediately\"), e.connect().catch((e)=>{\n                        Au(\"[MetaMaskSDK: handleAutoAndExtensionConnections()] checkInstallationImmediately --- IGNORED --- error on autoconnect _err=\".concat(e));\n                    })) : console.warn(\"[handleAutoAndExtensionConnections()] checkInstallationImmediately --- IGNORED --- only for web desktop\")), e._initialized = !0;\n                });\n            }(e, b);\n            try {\n                yield null === (p = e.remoteConnection) || void 0 === p ? void 0 : p.startConnection({\n                    initialCheck: !0\n                });\n            } catch (e) {\n                console.error(\"[MetaMaskSDK: setupRemoteConnectionAndInstaller()] Error while checking installation\", e);\n            }\n            e.emit(zu.ProviderUpdate, hh.INITIALIZED);\n        }\n    });\n}\nclass rf extends (eventemitter2__WEBPACK_IMPORTED_MODULE_3___default()) {\n    init() {\n        return c(this, void 0, void 0, function*() {\n            return function(e) {\n                var t;\n                return c(this, void 0, void 0, function*() {\n                    if ( true && (null === (t = window.mmsdk) || void 0 === t ? void 0 : t.isInitialized())) return Au(\"[MetaMaskSDK: initializeMetaMaskSDK()] already initialized\"), Promise.resolve(window.mmsdk);\n                    if (e._initialized) return Au(\"[MetaMaskSDK: initializeMetaMaskSDK()] already initialized\"), e.sdkInitPromise;\n                    if (e.sdkInitPromise) return Au(\"[MetaMaskSDK: initializeMetaMaskSDK()] already initializing\"), e.sdkInitPromise;\n                    try {\n                        e.sdkInitPromise = nf(e), yield e.sdkInitPromise;\n                    } catch (e) {\n                        throw console.error(e), e;\n                    }\n                    return e.sdkInitPromise;\n                });\n            }(this);\n        });\n    }\n    isExtensionActive() {\n        return this.extensionActive;\n    }\n    checkExtensionAvailability() {\n        var e;\n        return  true && Boolean(null === (e = window.ethereum) || void 0 === e ? void 0 : e.isMetaMask);\n    }\n    connect() {\n        return c(this, void 0, void 0, function*() {\n            return function(e) {\n                return c(this, void 0, void 0, function*() {\n                    if (e._initialized || (Au(\"[MetaMaskSDK: connect()] provider not ready -- wait for init()\"), yield e.init()), Au(\"[MetaMaskSDK: connect()] isExtensionActive=\".concat(e.isExtensionActive(), \" activeProvider\"), e.activeProvider), !e.activeProvider) throw new Error(\"SDK state invalid -- undefined provider\");\n                    const t = e.activeProvider.getSelectedAddress();\n                    return t ? [\n                        t\n                    ] : e.activeProvider.request({\n                        method: nh.ETH_REQUESTACCOUNTS,\n                        params: []\n                    });\n                });\n            }(this);\n        });\n    }\n    connectAndSign(param) {\n        let { msg: e } = param;\n        return c(this, void 0, void 0, function*() {\n            return ph({\n                instance: this,\n                msg: e\n            });\n        });\n    }\n    connectWith(e) {\n        return c(this, void 0, void 0, function*() {\n            return function(param) {\n                let { instance: e, rpc: t } = param;\n                return c(this, void 0, void 0, function*() {\n                    if (e._initialized || (Au(\"[MetaMaskSDK: connectWith()] provider not ready -- wait for init()\"), yield e.init()), Au(\"[MetaMaskSDK: connectWith()] method: \".concat(t.method, \" rpc=\").concat(t)), !e.activeProvider) throw new Error(\"SDK state invalid -- undefined provider\");\n                    return e.activeProvider.request({\n                        method: nh.METAMASK_CONNECTWITH,\n                        params: [\n                            t\n                        ]\n                    });\n                });\n            }({\n                instance: this,\n                rpc: e\n            });\n        });\n    }\n    resume() {\n        return function(e) {\n            var t, n, r;\n            return c(this, void 0, void 0, function*() {\n                if (!(null === (n = null === (t = e.remoteConnection) || void 0 === t ? void 0 : t.getConnector()) || void 0 === n ? void 0 : n.isReady())) return Au(\"[MetaMaskSDK: resume()] channel is not ready -- starting connection\"), void (null === (r = e.remoteConnection) || void 0 === r || r.startConnection());\n                Au(\"[MetaMaskSDK: resume()] channel is ready\");\n            });\n        }(this);\n    }\n    disconnect() {\n        return console.warn(\"MetaMaskSDK.disconnect() is deprecated, use terminate()\"), this.terminate();\n    }\n    isAuthorized() {\n        var e;\n        null === (e = this.remoteConnection) || void 0 === e || e.isAuthorized();\n    }\n    terminate() {\n        return function(e) {\n            var t, n, r;\n            return c(this, void 0, void 0, function*() {\n                if (!(null === (t = e.platformManager) || void 0 === t ? void 0 : t.isMetaMaskMobileWebView())) {\n                    if (fh && (window.localStorage.removeItem(ah), window.localStorage.removeItem(lh), window.localStorage.removeItem(ch)), e.extensionActive) {\n                        try {\n                            yield null === (n = e.activeProvider) || void 0 === n ? void 0 : n.request({\n                                method: nh.WALLET_REVOKEPERMISSIONS,\n                                params: [\n                                    {\n                                        eth_accounts: {}\n                                    }\n                                ]\n                            });\n                        } catch (e) {\n                            Au(\"[MetaMaskSDK: terminate()] error revoking permissions\", e);\n                        }\n                        return e.options.extensionOnly ? (e.emit(zu.ProviderUpdate, hh.TERMINATE), void Au(\"[MetaMaskSDK: terminate()] extensionOnly --- prevent switching providers\")) : (e.activeProvider = e.sdkProvider, window.ethereum = e.activeProvider, e.extensionActive = !1, void e.emit(zu.ProviderUpdate, hh.TERMINATE));\n                    }\n                    e.emit(zu.ProviderUpdate, hh.TERMINATE), Au(\"[MetaMaskSDK: terminate()] remoteConnection=\".concat(e.remoteConnection)), null === (r = e.remoteConnection) || void 0 === r || r.disconnect({\n                        terminate: !0,\n                        sendMessage: !0\n                    });\n                }\n            });\n        }(this);\n    }\n    isInitialized() {\n        return this._initialized;\n    }\n    setReadOnlyRPCCalls(e) {\n        this.readonlyRPCCalls = e;\n    }\n    hasReadOnlyRPCCalls() {\n        return this.readonlyRPCCalls;\n    }\n    getProvider() {\n        if (this.activeProvider) return this.activeProvider;\n        console.warn(\"MetaMaskSDK: No active provider found\");\n    }\n    getMobileProvider() {\n        if (!this.sdkProvider) throw new Error(\"SDK state invalid -- undefined mobile provider\");\n        return this.sdkProvider;\n    }\n    getUniversalLink() {\n        var e;\n        const t = null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getUniversalLink();\n        if (!t) throw new Error(\"No Universal Link available, please call eth_requestAccounts first.\");\n        return t;\n    }\n    getChannelId() {\n        var e, t;\n        return null === (t = null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getChannelConfig()) || void 0 === t ? void 0 : t.channelId;\n    }\n    getRPCHistory() {\n        var e, t;\n        return null === (t = null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getConnector()) || void 0 === t ? void 0 : t.getRPCMethodTracker();\n    }\n    getVersion() {\n        return Zu.version;\n    }\n    getDappId() {\n        var e, t, n, r;\n        return  false || void 0 === window.location ? null !== (r = null !== (t = null === (e = this.options.dappMetadata) || void 0 === e ? void 0 : e.name) && void 0 !== t ? t : null === (n = this.options.dappMetadata) || void 0 === n ? void 0 : n.url) && void 0 !== r ? r : \"N/A\" : window.location.hostname;\n    }\n    getAnonId() {\n        var e, t;\n        return c(this, void 0, void 0, function*() {\n            if (this._anonId) return this._anonId;\n            let n;\n            return n = (null === (e = this.platformManager) || void 0 === e ? void 0 : e.isBrowser()) ? this.getBrowserAnonId() : (null === (t = this.platformManager) || void 0 === t ? void 0 : t.isReactNative()) ? yield this.getReactNativeAnonId() : (0,uuid__WEBPACK_IMPORTED_MODULE_5__.v4)(), this._anonId = n, n;\n        });\n    }\n    getBrowserAnonId() {\n        const e = this.ANON_ID_STORAGE_KEY;\n        try {\n            const t = localStorage.getItem(e);\n            if (t) return t;\n            const n = (0,uuid__WEBPACK_IMPORTED_MODULE_5__.v4)();\n            return localStorage.setItem(e, n), n;\n        } catch (e) {\n            return console.error(\"[MetaMaskSDK: getBrowserAnonId()] LocalStorage access error:\", e), (0,uuid__WEBPACK_IMPORTED_MODULE_5__.v4)();\n        }\n    }\n    getReactNativeAnonId() {\n        return c(this, void 0, void 0, function*() {\n            const e = this.ANON_ID_STORAGE_KEY;\n            try {\n                const t = (__webpack_require__(/*! @react-native-async-storage/async-storage */ \"(pages-dir-browser)/./emptyModule.js\")[\"default\"]), n = yield t.getItem(e);\n                if (n) return n;\n                const r = (0,uuid__WEBPACK_IMPORTED_MODULE_5__.v4)();\n                return yield t.setItem(e, r), r;\n            } catch (e) {\n                return console.error(\"[MetaMaskSDK: getReactNativeAnonId()] Error accessing AsyncStorage:\", e), (0,uuid__WEBPACK_IMPORTED_MODULE_5__.v4)();\n            }\n        });\n    }\n    getWalletStatus() {\n        var e, t;\n        return null === (t = null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getConnector()) || void 0 === t ? void 0 : t.getConnectionStatus();\n    }\n    _getChannelConfig() {\n        var e;\n        return null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getChannelConfig();\n    }\n    _ping() {\n        var e, t;\n        null === (t = null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getConnector()) || void 0 === t || t.ping();\n    }\n    _keyCheck() {\n        var e, t;\n        null === (t = null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getConnector()) || void 0 === t || t.keyCheck();\n    }\n    _getServiceStatus() {\n        var e, t;\n        return null === (t = null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getConnector()) || void 0 === t ? void 0 : t.getServiceStatus();\n    }\n    _getRemoteConnection() {\n        return this.remoteConnection;\n    }\n    _getDappMetadata() {\n        return this.dappMetadata;\n    }\n    _getKeyInfo() {\n        var e;\n        return null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getKeyInfo();\n    }\n    _resetKeys() {\n        var e, t;\n        null === (t = null === (e = this.remoteConnection) || void 0 === e ? void 0 : e.getConnector()) || void 0 === t || t.resetKeys();\n    }\n    _getConnection() {\n        return this.remoteConnection;\n    }\n    emit(e, t) {\n        return super.emit(e, t);\n    }\n    on(e, t) {\n        return super.on(e, t);\n    }\n    constructor(e = {\n        storage: {\n            enabled: !0\n        },\n        injectProvider: !0,\n        forceInjectProvider: !1,\n        enableAnalytics: !0,\n        shouldShimWeb3: !0,\n        useDeeplink: !0,\n        extensionOnly: !0,\n        headless: !1,\n        dappMetadata: {\n            name: \"\",\n            url: \"\",\n            iconUrl: \"\"\n        },\n        _source: Ju,\n        i18nOptions: {\n            enabled: !1\n        }\n    }){\n        var n, r, i;\n        super(), this.extensionActive = !1, this._initialized = !1, this.sdkInitPromise = void 0, this.debug = !1, this.readonlyRPCCalls = !1, this.availableLanguages = [\n            \"en\"\n        ], this.ANON_ID_STORAGE_KEY = \"mm-sdk-anon-id\", debug__WEBPACK_IMPORTED_MODULE_1___default().disable();\n        const o = !0 === (null === (n = e.logging) || void 0 === n ? void 0 : n.developerMode);\n        if (((null === (r = e.logging) || void 0 === r ? void 0 : r.sdk) || o) && debug__WEBPACK_IMPORTED_MODULE_1___default().enable(\"MM_SDK\"), Au(\"[MetaMaskSDK: constructor()]: begin.\"), this.setMaxListeners(50), !(null === (i = e.dappMetadata) || void 0 === i ? void 0 : i.url)) {\n            if ( false || \"undefined\" == typeof document) throw new Error(\"You must provide dAppMetadata url\");\n            e.dappMetadata = Object.assign(Object.assign({}, e.dappMetadata), {\n                url: \"\".concat(window.location.protocol, \"//\").concat(window.location.host)\n            });\n        }\n        this.options = e, this.options._source || (e._source = Ju), this.init().then(()=>{\n            Au(\"[MetaMaskSDK: constructor()]: initialized successfully.\"),  true && (window.mmsdk = this);\n        }).catch((e)=>{\n            console.error(\"[MetaMaskSDK: constructor()] error during initialization\", e);\n        });\n    }\n}\nvar of = Object.freeze({\n    __proto__: null,\n    StorageManagerWeb: class {\n        persistChannelConfig(e) {\n            return c(this, void 0, void 0, function*() {\n                const t = JSON.stringify(e);\n                Au(\"[StorageManagerWeb: persistChannelConfig()] enabled=\".concat(this.enabled), e), localStorage.setItem(sh, t);\n            });\n        }\n        getPersistedChannelConfig() {\n            return c(this, void 0, void 0, function*() {\n                let e;\n                try {\n                    if (Au(\"[StorageManagerWeb: getPersistedChannelConfig()] enabled=\".concat(this.enabled)), e = localStorage.getItem(sh), Au(\"[StorageManagerWeb: getPersistedChannelConfig()]\", e), !e) return;\n                    const t = JSON.parse(e);\n                    return Au(\"[StorageManagerWeb: getPersistedChannelConfig()] channelConfig\", t), t;\n                } catch (e) {\n                    return void console.error(\"[StorageManagerWeb: getPersistedChannelConfig()] Can't find existing channel config\", e);\n                }\n            });\n        }\n        persistAccounts(e) {\n            return c(this, void 0, void 0, function*() {\n                Au(\"[StorageManagerWeb: persistAccounts()] enabled=\".concat(this.enabled), e);\n                const t = JSON.stringify(e);\n                localStorage.setItem(ch, t);\n            });\n        }\n        getCachedAccounts() {\n            return c(this, void 0, void 0, function*() {\n                try {\n                    const e = localStorage.getItem(ch);\n                    return e ? JSON.parse(e) : [];\n                } catch (e) {\n                    throw console.error(\"[StorageManagerWeb: getCachedAccounts()] Error reading cached accounts\", e), e;\n                }\n            });\n        }\n        persistChainId(e) {\n            return c(this, void 0, void 0, function*() {\n                Au(\"[StorageManagerWeb: persistChainId()] enabled=\".concat(this.enabled), e), localStorage.setItem(lh, e);\n            });\n        }\n        getCachedChainId() {\n            return c(this, void 0, void 0, function*() {\n                try {\n                    const e = localStorage.getItem(lh);\n                    return null != e ? e : void 0;\n                } catch (e) {\n                    throw console.error(\"[StorageManagerWeb: getCachedChainId()] Error reading cached chainId\", e), e;\n                }\n            });\n        }\n        terminate() {\n            return c(this, void 0, void 0, function*() {\n                Au(\"[StorageManagerWeb: terminate()] enabled=\".concat(this.enabled)), localStorage.removeItem(sh);\n            });\n        }\n        constructor({ enabled: e } = {\n            enabled: !1\n        }){\n            this.enabled = !1, this.enabled = e;\n        }\n    }\n});\nconst sf = \"hydrated\", af = !1, cf = !1, lf = !0;\nvar df = Object.defineProperty, uf = new WeakMap, hf = (e)=>uf.get(e), ff = (e, t)=>uf.set(t.$lazyInstance$ = e, t), pf = (e, t)=>t in e, gf = (e, t)=>(0, console.error)(e, t), mf = new Map, yf = new Map, vf = \"slot-fb{display:contents}slot-fb[hidden]{display:none}\", bf =  true ? window : 0, wf = bf.document || {\n    head: {}\n}, Ef = {\n    $flags$: 0,\n    $resourcesUrl$: \"\",\n    jmp: (e)=>e(),\n    raf: (e)=>requestAnimationFrame(e),\n    ael: (e, t, n, r)=>e.addEventListener(t, n, r),\n    rel: (e, t, n, r)=>e.removeEventListener(t, n, r),\n    ce: (e, t)=>new CustomEvent(e, t)\n}, Sf = (()=>{\n    try {\n        return new CSSStyleSheet, \"function\" == typeof (new CSSStyleSheet).replaceSync;\n    } catch (e) {}\n    return !1;\n})(), _f = !1, Cf = [], kf = [], Af = (e, t)=>(t)=>{\n        e.push(t), _f || (_f = !0, 4 & Ef.$flags$ ? If(Mf) : Ef.raf(Mf));\n    }, xf = (e)=>{\n    for(let t = 0; t < e.length; t++)try {\n        e[t](performance.now());\n    } catch (e) {\n        gf(e);\n    }\n    e.length = 0;\n}, Mf = ()=>{\n    xf(Cf), xf(kf), (_f = Cf.length > 0) && Ef.raf(Mf);\n}, If = (e)=>((e)=>Promise.resolve(e))().then(e), Tf = Af(kf), Rf = {}, Pf = (e)=>\"object\" === (e = typeof e) || \"function\" === e;\nfunction Of(e) {\n    var t, n, r;\n    return null != (r = null == (n = null == (t = e.head) ? void 0 : t.querySelector('meta[name=\"csp-nonce\"]')) ? void 0 : n.getAttribute(\"content\")) ? r : void 0;\n}\n_c150 = Of;\n((e, t)=>{\n    for(var n in t)df(e, n, {\n        get: t[n],\n        enumerable: !0\n    });\n})({}, {\n    err: ()=>Lf,\n    map: ()=>Df,\n    ok: ()=>Nf,\n    unwrap: ()=>Kf,\n    unwrapErr: ()=>jf\n});\nvar Nf = (e)=>({\n        isOk: !0,\n        isErr: !1,\n        value: e\n    }), Lf = (e)=>({\n        isOk: !1,\n        isErr: !0,\n        value: e\n    });\nfunction Df(e, t) {\n    if (e.isOk) {\n        const n = t(e.value);\n        return n instanceof Promise ? n.then((e)=>Nf(e)) : Nf(n);\n    }\n    if (e.isErr) {\n        const t = e.value;\n        return Lf(t);\n    }\n    throw \"should never get here\";\n}\n_c151 = Df;\nvar $f, Bf, Kf = (e)=>{\n    if (e.isOk) return e.value;\n    throw e.value;\n}, jf = (e)=>{\n    if (e.isErr) return e.value;\n    throw e.value;\n}, Uf = function(e, t) {\n    for(var _len = arguments.length, n = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n        n[_key - 2] = arguments[_key];\n    }\n    let r = null, i = !1, o = !1;\n    const s = [], a = (t)=>{\n        for(let n = 0; n < t.length; n++)r = t[n], Array.isArray(r) ? a(r) : null != r && \"boolean\" != typeof r && ((i = \"function\" != typeof e && !Pf(r)) && (r = String(r)), i && o ? s[s.length - 1].$text$ += r : s.push(i ? Hf(null, r) : r), o = i);\n    };\n    if (a(n), t) {\n        const e = t.className || t.class;\n        e && (t.class = \"object\" != typeof e ? e : Object.keys(e).filter((t)=>e[t]).join(\" \"));\n    }\n    if (\"function\" == typeof e) return e(null === t ? {} : t, s, zf);\n    const c = Hf(e, null);\n    return c.$attrs$ = t, s.length > 0 && (c.$children$ = s), c;\n}, Hf = (e, t)=>{\n    const n = {\n        $flags$: 0,\n        $tag$: e,\n        $text$: t,\n        $elm$: null,\n        $children$: null,\n        $attrs$: null\n    };\n    return n;\n}, Ff = {}, zf = {\n    forEach: (e, t)=>e.map(qf).forEach(t),\n    map: (e, t)=>e.map(qf).map(t).map(Wf)\n}, qf = (e)=>({\n        vattrs: e.$attrs$,\n        vchildren: e.$children$,\n        vkey: e.$key$,\n        vname: e.$name$,\n        vtag: e.$tag$,\n        vtext: e.$text$\n    }), Wf = (e)=>{\n    if (\"function\" == typeof e.vtag) {\n        const t = {\n            ...e.vattrs\n        };\n        return e.vkey && (t.key = e.vkey), e.vname && (t.name = e.vname), Uf(e.vtag, t, ...e.vchildren || []);\n    }\n    const t = Hf(e.vtag, e.vtext);\n    return t.$attrs$ = e.vattrs, t.$children$ = e.vchildren, t.$key$ = e.vkey, t.$name$ = e.vname, t;\n}, Vf = (e)=>hf(e).$hostElement$, Gf = (e, t, n)=>{\n    const r = Vf(e);\n    return {\n        emit: (e)=>Yf(r, t, {\n                bubbles: !!(4 & n),\n                composed: !!(2 & n),\n                cancelable: !!(1 & n),\n                detail: e\n            })\n    };\n}, Yf = (e, t, n)=>{\n    const r = Ef.ce(t, n);\n    return e.dispatchEvent(r), r;\n}, Zf = new WeakMap, Jf = (e)=>{\n    const t = e.$cmpMeta$, n = e.$hostElement$, r = t.$flags$, i = (t.$tagName$, ()=>{}), o = ((e, t, n)=>{\n        var r;\n        const i = Qf(t), o = yf.get(i);\n        if (e = 11 === e.nodeType ? e : wf, o) if (\"string\" == typeof o) {\n            e = e.head || e;\n            let n, s = Zf.get(e);\n            if (s || Zf.set(e, s = new Set), !s.has(i)) {\n                {\n                    n = wf.createElement(\"style\"), n.innerHTML = o;\n                    const i = null != (r = Ef.$nonce$) ? r : Of(wf);\n                    if (null != i && n.setAttribute(\"nonce\", i), !(1 & t.$flags$)) if (\"HEAD\" === e.nodeName) {\n                        const t = e.querySelectorAll(\"link[rel=preconnect]\"), r = t.length > 0 ? t[t.length - 1].nextSibling : e.querySelector(\"style\");\n                        e.insertBefore(n, r);\n                    } else if (\"host\" in e) if (Sf) {\n                        const t = new CSSStyleSheet;\n                        t.replaceSync(o), e.adoptedStyleSheets = [\n                            t,\n                            ...e.adoptedStyleSheets\n                        ];\n                    } else {\n                        const t = e.querySelector(\"style\");\n                        t ? t.innerHTML = o + t.innerHTML : e.prepend(n);\n                    }\n                    else e.append(n);\n                    1 & t.$flags$ && \"HEAD\" !== e.nodeName && e.insertBefore(n, null);\n                }\n                4 & t.$flags$ && (n.innerHTML += vf), s && s.add(i);\n            }\n        } else e.adoptedStyleSheets.includes(o) || (e.adoptedStyleSheets = [\n            ...e.adoptedStyleSheets,\n            o\n        ]);\n        return i;\n    })(n.shadowRoot ? n.shadowRoot : n.getRootNode(), t);\n    10 & r && 2 & r && (n[\"s-sc\"] = o, n.classList.add(o + \"-h\")), i();\n}, Qf = (e, t)=>\"sc-\" + e.$tagName$, Xf = (e, t, n, r, i, o)=>{\n    if (n !== r) {\n        let s = pf(e, t), a = t.toLowerCase();\n        if (\"class\" === t) {\n            const t = e.classList, i = tp(n), o = tp(r);\n            t.remove(...i.filter((e)=>e && !o.includes(e))), t.add(...o.filter((e)=>e && !i.includes(e)));\n        } else if (\"style\" === t) {\n            for(const t in n)r && null != r[t] || (t.includes(\"-\") ? e.style.removeProperty(t) : e.style[t] = \"\");\n            for(const t in r)n && r[t] === n[t] || (t.includes(\"-\") ? e.style.setProperty(t, r[t]) : e.style[t] = r[t]);\n        } else if (s || \"o\" !== t[0] || \"n\" !== t[1]) {\n            const a = Pf(r);\n            if ((s || a && null !== r) && !i) try {\n                if (e.tagName.includes(\"-\")) e[t] = r;\n                else {\n                    const i = null == r ? \"\" : r;\n                    \"list\" === t ? s = !1 : null != n && e[t] == i || (\"function\" == typeof e.__lookupSetter__(t) ? e[t] = i : e.setAttribute(t, i));\n                }\n            } catch (e) {}\n            null == r || !1 === r ? !1 === r && \"\" !== e.getAttribute(t) || e.removeAttribute(t) : (!s || 4 & o || i) && !a && (r = !0 === r ? \"\" : r, e.setAttribute(t, r));\n        } else if (t = \"-\" === t[2] ? t.slice(3) : pf(bf, a) ? a.slice(2) : a[2] + t.slice(3), n || r) {\n            const i = t.endsWith(np);\n            t = t.replace(rp, \"\"), n && Ef.rel(e, t, n, i), r && Ef.ael(e, t, r, i);\n        }\n    }\n}, ep = /\\s/, tp = (e)=>e ? e.split(ep) : [], np = \"Capture\", rp = new RegExp(np + \"$\"), ip = (e, t, n)=>{\n    const r = 11 === t.$elm$.nodeType && t.$elm$.host ? t.$elm$.host : t.$elm$, i = e && e.$attrs$ || Rf, o = t.$attrs$ || Rf;\n    for (const e of op(Object.keys(i)))e in o || Xf(r, e, i[e], void 0, n, t.$flags$);\n    for (const e of op(Object.keys(o)))Xf(r, e, i[e], o[e], n, t.$flags$);\n};\nfunction op(e) {\n    return e.includes(\"ref\") ? [\n        ...e.filter((e)=>\"ref\" !== e),\n        \"ref\"\n    ] : e;\n}\nvar sp = !1, ap = !1, cp = (e, t, n, r)=>{\n    const i = t.$children$[n];\n    let o, s, a = 0;\n    if (null !== i.$text$) o = i.$elm$ = wf.createTextNode(i.$text$);\n    else {\n        ap || (ap = \"svg\" === i.$tag$), o = i.$elm$ = wf.createElementNS(ap ? \"http://www.w3.org/2000/svg\" : \"http://www.w3.org/1999/xhtml\", !sp && cf && 2 & i.$flags$ ? \"slot-fb\" : i.$tag$), ap && \"foreignObject\" === i.$tag$ && (ap = !1), ip(null, i, ap);\n        if (!!o.getRootNode().querySelector(\"body\") && af && ((e)=>null != e)($f) && o[\"s-si\"] !== $f && o.classList.add(o[\"s-si\"] = $f), i.$children$) for(a = 0; a < i.$children$.length; ++a)s = cp(e, i, a), s && o.appendChild(s);\n        \"svg\" === i.$tag$ ? ap = !1 : \"foreignObject\" === o.tagName && (ap = !0);\n    }\n    return o[\"s-hn\"] = Bf, o;\n}, lp = (e, t, n, r, i, o)=>{\n    let s, a = e;\n    for(a.shadowRoot && a.tagName === Bf && (a = a.shadowRoot); i <= o; ++i)r[i] && (s = cp(null, n, i), s && (r[i].$elm$ = s, fp(a, s, t)));\n}, dp = (e, t, n)=>{\n    for(let r = t; r <= n; ++r){\n        const t = e[r];\n        if (t) {\n            const e = t.$elm$;\n            e && e.remove();\n        }\n    }\n}, up = function(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n    return e.$tag$ === t.$tag$;\n}, hp = function(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n    const r = t.$elm$ = e.$elm$, i = e.$children$, o = t.$children$, s = t.$tag$, a = t.$text$;\n    null === a ? (ip(e, t, ap = \"svg\" === s || \"foreignObject\" !== s && ap), null !== i && null !== o ? function(e, t, n, r) {\n        let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;\n        let o, s = 0, a = 0, c = t.length - 1, l = t[0], d = t[c], u = r.length - 1, h = r[0], f = r[u];\n        for(; s <= c && a <= u;)null == l ? l = t[++s] : null == d ? d = t[--c] : null == h ? h = r[++a] : null == f ? f = r[--u] : up(l, h, i) ? (hp(l, h, i), l = t[++s], h = r[++a]) : up(d, f, i) ? (hp(d, f, i), d = t[--c], f = r[--u]) : up(l, f, i) ? (hp(l, f, i), fp(e, l.$elm$, d.$elm$.nextSibling), l = t[++s], f = r[--u]) : up(d, h, i) ? (hp(d, h, i), fp(e, d.$elm$, l.$elm$), d = t[--c], h = r[++a]) : (o = cp(t && t[a], n, a), h = r[++a], o && fp(l.$elm$.parentNode, o, l.$elm$));\n        s > c ? lp(e, null == r[u + 1] ? null : r[u + 1].$elm$, n, r, a, u) : a > u && dp(t, s, c);\n    }(r, i, t, o, n) : null !== o ? (null !== e.$text$ && (r.textContent = \"\"), lp(r, null, t, o, 0, o.length - 1)) : !n && lf && null !== i && dp(i, 0, i.length - 1), ap && \"svg\" === s && (ap = !1)) : e.$text$ !== a && (r.data = a);\n}, fp = (e, t, n)=>null == e ? void 0 : e.insertBefore(t, n), pp = function(e, t) {\n    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n    const r = e.$hostElement$, i = e.$cmpMeta$, o = e.$vnode$ || Hf(null, null), s = (a = t) && a.$tag$ === Ff ? t : Uf(null, null, t);\n    var a;\n    if (Bf = r.tagName, n && s.$attrs$) for (const e of Object.keys(s.$attrs$))r.hasAttribute(e) && ![\n        \"key\",\n        \"ref\",\n        \"style\",\n        \"class\"\n    ].includes(e) && (s.$attrs$[e] = r[e]);\n    s.$tag$ = null, s.$flags$ |= 4, e.$vnode$ = s, s.$elm$ = o.$elm$ = r.shadowRoot || r, $f = r[\"s-sc\"], sp = 0 != (1 & i.$flags$), hp(o, s, n);\n}, gp = (e, t)=>{\n    t && !e.$onRenderResolve$ && t[\"s-p\"] && t[\"s-p\"].push(new Promise((t)=>e.$onRenderResolve$ = t));\n}, mp = (e, t)=>{\n    if (e.$flags$ |= 16, 4 & e.$flags$) return void (e.$flags$ |= 512);\n    gp(e, e.$ancestorComponent$);\n    return Tf(()=>yp(e, t));\n}, yp = (e, t)=>{\n    const n = e.$hostElement$, r = (e.$cmpMeta$.$tagName$, ()=>{}), i = e.$lazyInstance$;\n    if (!i) throw new Error(\"Can't render component <\".concat(n.tagName.toLowerCase(), \" /> with invalid Stencil runtime! Make sure this imported component is compiled with a `externalRuntime: true` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime\"));\n    return r(), vp(undefined, ()=>wp(e, i, t));\n}, vp = (e, t)=>bp(e) ? e.then(t).catch((e)=>{\n        console.error(e), t();\n    }) : t(), bp = (e)=>e instanceof Promise || e && e.then && \"function\" == typeof e.then, wp = async (e, t, n)=>{\n    var r;\n    const i = e.$hostElement$, o = (e.$cmpMeta$.$tagName$, ()=>{}), s = i[\"s-rc\"];\n    n && Jf(e);\n    const a = (e.$cmpMeta$.$tagName$, ()=>{});\n    Ep(e, t, i, n), s && (s.map((e)=>e()), i[\"s-rc\"] = void 0), a(), o();\n    {\n        const t = null != (r = i[\"s-p\"]) ? r : [], n = ()=>Sp(e);\n        0 === t.length ? n() : (Promise.all(t).then(n), e.$flags$ |= 4, t.length = 0);\n    }\n}, Ep = (e, t, n, r)=>{\n    try {\n        t = t.render(), e.$flags$ &= -17, e.$flags$ |= 2, pp(e, t, r);\n    } catch (t) {\n        gf(t, e.$hostElement$);\n    }\n    return null;\n}, Sp = (e)=>{\n    e.$cmpMeta$.$tagName$;\n    const t = e.$hostElement$, n = ()=>{}, r = e.$lazyInstance$, i = e.$ancestorComponent$;\n    64 & e.$flags$ ? n() : (e.$flags$ |= 64, kp(t), Cp(r, \"componentDidLoad\"), n(), e.$onReadyResolve$(t), i || _p()), e.$onRenderResolve$ && (e.$onRenderResolve$(), e.$onRenderResolve$ = void 0), 512 & e.$flags$ && If(()=>mp(e, !1)), e.$flags$ &= -517;\n}, _p = (e)=>{\n    kp(wf.documentElement), If(()=>Yf(bf, \"appload\", {\n            detail: {\n                namespace: \"sdk-install-modal-web\"\n            }\n        }));\n}, Cp = (e, t, n)=>{\n    if (e && e[t]) try {\n        return e[t](n);\n    } catch (e) {\n        gf(e);\n    }\n}, kp = (e)=>{\n    var t;\n    return e.classList.add(null != (t = sf) ? t : \"hydrated\");\n}, Ap = (e, t, n, r)=>{\n    const i = hf(e);\n    if (!i) throw new Error(\"Couldn't find host element for \\\"\".concat(r.$tagName$, '\" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/ionic-team/stencil/issues/5457).'));\n    const o = i.$hostElement$, s = i.$instanceValues$.get(t), a = i.$flags$, c = i.$lazyInstance$;\n    var l, d;\n    l = n, d = r.$members$[t][0], n = null == l || Pf(l) ? l : 4 & d ? \"false\" !== l && (\"\" === l || !!l) : 1 & d ? String(l) : l;\n    const u = Number.isNaN(s) && Number.isNaN(n);\n    if ((!(8 & a) || void 0 === s) && n !== s && !u && (i.$instanceValues$.set(t, n), c)) {\n        if (r.$watchers$ && 128 & a) {\n            const e = r.$watchers$[t];\n            e && e.map((e)=>{\n                try {\n                    c[e](n, s, t);\n                } catch (e) {\n                    gf(e, o);\n                }\n            });\n        }\n        2 == (18 & a) && mp(i, !1);\n    }\n}, xp = (e, t, n)=>{\n    var r, i;\n    const o = e.prototype;\n    if (t.$members$ || t.$watchers$ || e.watchers) {\n        e.watchers && !t.$watchers$ && (t.$watchers$ = e.watchers);\n        const s = Object.entries(null != (r = t.$members$) ? r : {});\n        if (s.map((param)=>{\n            let [e, [r]] = param;\n            (31 & r || 2 & n && 32 & r) && Object.defineProperty(o, e, {\n                get () {\n                    return t = e, hf(this).$instanceValues$.get(t);\n                    var t;\n                },\n                set (n) {\n                    Ap(this, e, n, t);\n                },\n                configurable: !0,\n                enumerable: !0\n            });\n        }), 1 & n) {\n            const n = new Map;\n            o.attributeChangedCallback = function(e, r, i) {\n                Ef.jmp(()=>{\n                    var s;\n                    const a = n.get(e);\n                    if (this.hasOwnProperty(a)) i = this[a], delete this[a];\n                    else {\n                        if (o.hasOwnProperty(a) && \"number\" == typeof this[a] && this[a] == i) return;\n                        if (null == a) {\n                            const n = hf(this), o = null == n ? void 0 : n.$flags$;\n                            if (o && !(8 & o) && 128 & o && i !== r) {\n                                const o = n.$lazyInstance$, a = null == (s = t.$watchers$) ? void 0 : s[e];\n                                null == a || a.forEach((t)=>{\n                                    null != o[t] && o[t].call(o, i, r, e);\n                                });\n                            }\n                            return;\n                        }\n                    }\n                    this[a] = (null !== i || \"boolean\" != typeof this[a]) && i;\n                });\n            }, e.observedAttributes = Array.from(new Set([\n                ...Object.keys(null != (i = t.$watchers$) ? i : {}),\n                ...s.filter((param)=>{\n                    let [e, t] = param;\n                    return 15 & t[0];\n                }).map((param)=>{\n                    let [e, t] = param;\n                    const r = t[1] || e;\n                    return n.set(r, e), r;\n                })\n            ]));\n        }\n    }\n    return e;\n}, Mp = async (e, t, n, r)=>{\n    let i;\n    if (0 == (32 & t.$flags$)) {\n        t.$flags$ |= 32;\n        if (n.$lazyBundleId$) {\n            const e = ((e, t, n)=>{\n                const r = e.$tagName$.replace(/-/g, \"_\"), i = e.$lazyBundleId$;\n                if (!i) return;\n                const o = mf.get(i);\n                if (o) return o[r];\n                {\n                    const e = (e)=>(mf.set(i, e), e[r]);\n                    if (\"mm-install-modal_3\" === i) return Promise.resolve().then(function() {\n                        return yg;\n                    }).then(e, gf);\n                }\n                return import(/* webpackIgnore: true */ /* @vite-ignore */ /* webpackInclude: /\\.entry\\.js$/ */ /* webpackExclude: /\\.system\\.entry\\.js$/ */ /* webpackMode: \"lazy\" */ \"./\".concat(i, \".entry.js\")).then((e)=>(mf.set(i, e), e[r]), gf);\n            })(n);\n            if (e && \"then\" in e) {\n                const t = ()=>{};\n                i = await e, t();\n            } else i = e;\n            if (!i) throw new Error('Constructor for \"'.concat(n.$tagName$, \"#\").concat(t.$modeName$, '\" was not found'));\n            i.isProxied || (n.$watchers$ = i.watchers, xp(i, n, 2), i.isProxied = !0);\n            const r = (n.$tagName$, ()=>{});\n            t.$flags$ |= 8;\n            try {\n                new i(t);\n            } catch (e) {\n                gf(e);\n            }\n            t.$flags$ &= -9, t.$flags$ |= 128, r(), Ip(t.$lazyInstance$);\n        } else {\n            i = e.constructor;\n            const n = e.localName;\n            customElements.whenDefined(n).then(()=>t.$flags$ |= 128);\n        }\n        if (i && i.style) {\n            let e;\n            \"string\" == typeof i.style && (e = i.style);\n            const t = Qf(n);\n            if (!yf.has(t)) {\n                const r = (n.$tagName$, ()=>{});\n                ((e, t, n)=>{\n                    let r = yf.get(e);\n                    Sf && n ? (r = r || new CSSStyleSheet, \"string\" == typeof r ? r = t : r.replaceSync(t)) : r = t, yf.set(e, r);\n                })(t, e, !!(1 & n.$flags$)), r();\n            }\n        }\n    }\n    const o = t.$ancestorComponent$, s = ()=>mp(t, !0);\n    o && o[\"s-rc\"] ? o[\"s-rc\"].push(s) : s();\n}, Ip = (e)=>{\n    Cp(e, \"connectedCallback\");\n}, Tp = (e)=>{\n    Cp(e, \"disconnectedCallback\");\n}, Rp = function(e) {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    var n;\n    const r = ()=>{}, i = [], o = t.exclude || [], s = bf.customElements, a = wf.head, c = a.querySelector(\"meta[charset]\"), l = wf.createElement(\"style\"), d = [];\n    let u, h = !0;\n    Object.assign(Ef, t), Ef.$resourcesUrl$ = new URL(t.resourcesUrl || \"./\", wf.baseURI).href;\n    let f = !1;\n    if (e.map((e)=>{\n        e[1].map((t)=>{\n            var n;\n            const r = {\n                $flags$: t[0],\n                $tagName$: t[1],\n                $members$: t[2],\n                $listeners$: t[3]\n            };\n            4 & r.$flags$ && (f = !0), r.$members$ = t[2], r.$watchers$ = null != (n = t[4]) ? n : {};\n            const a = r.$tagName$, c = class extends HTMLElement {\n                connectedCallback() {\n                    hf(this), this.hasRegisteredEventListeners || (this.hasRegisteredEventListeners = !0), u && (clearTimeout(u), u = null), h ? d.push(this) : Ef.jmp(()=>((e)=>{\n                            if (0 == (1 & Ef.$flags$)) {\n                                const t = hf(e), n = t.$cmpMeta$, r = (n.$tagName$, ()=>{});\n                                if (1 & t.$flags$) (null == t ? void 0 : t.$lazyInstance$) ? Ip(t.$lazyInstance$) : (null == t ? void 0 : t.$onReadyPromise$) && t.$onReadyPromise$.then(()=>Ip(t.$lazyInstance$));\n                                else {\n                                    t.$flags$ |= 1;\n                                    {\n                                        let n = e;\n                                        for(; n = n.parentNode || n.host;)if (n[\"s-p\"]) {\n                                            gp(t, t.$ancestorComponent$ = n);\n                                            break;\n                                        }\n                                    }\n                                    n.$members$ && Object.entries(n.$members$).map((param)=>{\n                                        let [t, [n]] = param;\n                                        if (31 & n && e.hasOwnProperty(t)) {\n                                            const n = e[t];\n                                            delete e[t], e[t] = n;\n                                        }\n                                    }), Mp(e, t, n);\n                                }\n                                r();\n                            }\n                        })(this));\n                }\n                disconnectedCallback() {\n                    Ef.jmp(()=>(async (e)=>{\n                            if (0 == (1 & Ef.$flags$)) {\n                                const t = hf(e);\n                                (null == t ? void 0 : t.$lazyInstance$) ? Tp(t.$lazyInstance$) : (null == t ? void 0 : t.$onReadyPromise$) && t.$onReadyPromise$.then(()=>Tp(t.$lazyInstance$));\n                            }\n                        })(this));\n                }\n                componentOnReady() {\n                    return hf(this).$onReadyPromise$;\n                }\n                constructor(e){\n                    if (super(e), this.hasRegisteredEventListeners = !1, ((e, t)=>{\n                        const n = {\n                            $flags$: 0,\n                            $hostElement$: e,\n                            $cmpMeta$: t,\n                            $instanceValues$: new Map\n                        };\n                        n.$onReadyPromise$ = new Promise((e)=>n.$onReadyResolve$ = e), e[\"s-p\"] = [], e[\"s-rc\"] = [], uf.set(e, n);\n                    })(e = this, r), 1 & r.$flags$) if (e.shadowRoot) {\n                        if (\"open\" !== e.shadowRoot.mode) throw new Error(\"Unable to re-use existing shadow root for \".concat(r.$tagName$, \"! Mode is set to \").concat(e.shadowRoot.mode, \" but Stencil only supports open shadow roots.\"));\n                    } else e.attachShadow({\n                        mode: \"open\"\n                    });\n                }\n            };\n            r.$lazyBundleId$ = e[0], o.includes(a) || s.get(a) || (i.push(a), s.define(a, xp(c, r, 1)));\n        });\n    }), i.length > 0 && (f && (l.textContent += vf), l.textContent += i.sort() + \"{visibility:hidden}.hydrated{visibility:inherit}\", l.innerHTML.length)) {\n        l.setAttribute(\"data-styles\", \"\");\n        const e = null != (n = Ef.$nonce$) ? n : Of(wf);\n        null != e && l.setAttribute(\"nonce\", e), a.insertBefore(l, c ? c.nextSibling : a.firstChild);\n    }\n    h = !1, d.length ? d.map((e)=>e.connectedCallback()) : Ef.jmp(()=>u = setTimeout(_p, 30)), r();\n};\n!function() {\n    if ( true && void 0 !== window.Reflect && void 0 !== window.customElements) {\n        var e = HTMLElement;\n        window.HTMLElement = function() {\n            return Reflect.construct(e, [], this.constructor);\n        }, HTMLElement.prototype = e.prototype, HTMLElement.prototype.constructor = HTMLElement, Object.setPrototypeOf(HTMLElement, e);\n    }\n}();\nvar Pp = Object.freeze({\n    __proto__: null,\n    defineCustomElements: async (e, t)=>{\n        if (true) return await void 0, Rp([\n            [\n                \"mm-install-modal_3\",\n                [\n                    [\n                        1,\n                        \"mm-install-modal\",\n                        {\n                            link: [\n                                1\n                            ],\n                            sdkVersion: [\n                                1,\n                                \"sdk-version\"\n                            ],\n                            preferDesktop: [\n                                4,\n                                \"prefer-desktop\"\n                            ],\n                            tab: [\n                                32\n                            ],\n                            isDefaultTab: [\n                                32\n                            ],\n                            translationsLoaded: [\n                                32\n                            ]\n                        },\n                        null,\n                        {\n                            preferDesktop: [\n                                \"updatePreferDesktop\"\n                            ]\n                        }\n                    ],\n                    [\n                        1,\n                        \"mm-pending-modal\",\n                        {\n                            displayOTP: [\n                                4,\n                                \"display-o-t-p\"\n                            ],\n                            sdkVersion: [\n                                1,\n                                \"sdk-version\"\n                            ],\n                            otpCode: [\n                                1,\n                                \"otp-code\"\n                            ],\n                            translationsLoaded: [\n                                32\n                            ]\n                        }\n                    ],\n                    [\n                        1,\n                        \"mm-select-modal\",\n                        {\n                            link: [\n                                1\n                            ],\n                            sdkVersion: [\n                                1,\n                                \"sdk-version\"\n                            ],\n                            preferDesktop: [\n                                4,\n                                \"prefer-desktop\"\n                            ],\n                            tab: [\n                                32\n                            ],\n                            isDefaultTab: [\n                                32\n                            ],\n                            translationsLoaded: [\n                                32\n                            ]\n                        },\n                        null,\n                        {\n                            preferDesktop: [\n                                \"updatePreferDesktop\"\n                            ]\n                        }\n                    ]\n                ]\n            ]\n        ], t);\n    },\n    setNonce: (e)=>Ef.$nonce$ = e\n});\nconst Op = {\n    fontFamily: \"Roboto, sans-serif\"\n}, Np = (param, t)=>{\n    let { className: e } = param;\n    return Uf(\"div\", {\n        style: Op,\n        class: e\n    }, t);\n}, Lp = (param)=>{\n    let { Icon: e, text: t } = param;\n    return Uf(\"div\", {\n        class: \"flexContainer\",\n        style: {\n            padding: \"6\",\n            flexDirection: \"row\"\n        }\n    }, Uf(\"div\", {\n        class: \"flexItem1\"\n    }, Uf(e, null)), Uf(\"div\", {\n        class: \"flexItem11\"\n    }, Uf(\"span\", {\n        style: {\n            lineHeight: \"2\",\n            color: \"black\"\n        }\n    }, t)));\n}, Dp = ()=>Uf(\"svg\", {\n        width: \"20\",\n        height: \"18\",\n        viewBox: \"0 0 20 18\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, Uf(\"path\", {\n        d: \"M20.0002 7.9702V10.0302C20.0002 10.5802 19.5602 11.0302 19.0002 11.0502H17.0402C15.9602 11.0502 14.9702 10.2602 14.8802 9.1802C14.8202 8.5502 15.0602 7.9602 15.4802 7.5502C15.8502 7.1702 16.3602 6.9502 16.9202 6.9502H19.0002C19.5602 6.9702 20.0002 7.4202 20.0002 7.9702Z\",\n        fill: \"#037DD6\"\n    }), Uf(\"path\", {\n        d: \"M18.47 12.55H17.04C15.14 12.55 13.54 11.12 13.38 9.3C13.29 8.26 13.67 7.22 14.43 6.48C15.07 5.82 15.96 5.45 16.92 5.45H18.47C18.76 5.45 19 5.21 18.97 4.92C18.75 2.49 17.14 0.83 14.75 0.55C14.51 0.51 14.26 0.5 14 0.5H5C4.72 0.5 4.45 0.52 4.19 0.56C1.64 0.88 0 2.78 0 5.5V12.5C0 15.26 2.24 17.5 5 17.5H14C16.8 17.5 18.73 15.75 18.97 13.08C19 12.79 18.76 12.55 18.47 12.55ZM11 6.75H5C4.59 6.75 4.25 6.41 4.25 6C4.25 5.59 4.59 5.25 5 5.25H11C11.41 5.25 11.75 5.59 11.75 6C11.75 6.41 11.41 6.75 11 6.75Z\",\n        fill: \"#037DD6\"\n    })), $p = ()=>Uf(\"svg\", {\n        width: \"20\",\n        height: \"18\",\n        viewBox: \"0 0 20 18\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, Uf(\"path\", {\n        d: \"M14.44 0.0999756C12.63 0.0999756 11.01 0.979976 10 2.32998C8.99 0.979976 7.37 0.0999756 5.56 0.0999756C2.49 0.0999756 0 2.59998 0 5.68998C0 6.87998 0.19 7.97998 0.52 8.99998C2.1 14 6.97 16.99 9.38 17.81C9.72 17.93 10.28 17.93 10.62 17.81C13.03 16.99 17.9 14 19.48 8.99998C19.81 7.97998 20 6.87998 20 5.68998C20 2.59998 17.51 0.0999756 14.44 0.0999756Z\",\n        fill: \"#037DD6\"\n    })), Bp = ()=>Uf(\"svg\", {\n        width: \"20\",\n        height: \"20\",\n        viewBox: \"0 0 20 20\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, Uf(\"path\", {\n        d: \"M16.28 7.53V6.28C16.28 3.58 15.63 0 10 0C4.37 0 3.72 3.58 3.72 6.28V7.53C0.92 7.88 0 9.3 0 12.79V14.65C0 18.75 1.25 20 5.35 20H14.65C18.75 20 20 18.75 20 14.65V12.79C20 9.3 19.08 7.88 16.28 7.53ZM10 16.74C8.33 16.74 6.98 15.38 6.98 13.72C6.98 12.05 8.34 10.7 10 10.7C11.66 10.7 13.02 12.06 13.02 13.72C13.02 15.39 11.67 16.74 10 16.74ZM5.35 7.44C5.27 7.44 5.2 7.44 5.12 7.44V6.28C5.12 3.35 5.95 1.4 10 1.4C14.05 1.4 14.88 3.35 14.88 6.28V7.45C14.8 7.45 14.73 7.45 14.65 7.45H5.35V7.44Z\",\n        fill: \"#037DD6\"\n    })), Kp = ()=>Uf(\"svg\", {\n        width: \"20\",\n        height: \"20\",\n        viewBox: \"0 0 24 24\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, Uf(\"path\", {\n        d: \"M16.4405 8.8999C20.0405 9.2099 21.5105 11.0599 21.5105 15.1099V15.2399C21.5105 19.7099 19.7205 21.4999 15.2505 21.4999H8.74047C4.27047 21.4999 2.48047 19.7099 2.48047 15.2399V15.1099C2.48047 11.0899 3.93047 9.2399 7.47047 8.9099\",\n        stroke: \"white\",\n        \"stroke-width\": \"1.5\",\n        \"stroke-linecap\": \"round\",\n        \"stroke-linejoin\": \"round\"\n    }), Uf(\"path\", {\n        d: \"M12 2V14.88\",\n        stroke: \"white\",\n        \"stroke-width\": \"1.5\",\n        \"stroke-linecap\": \"round\",\n        \"stroke-linejoin\": \"round\"\n    }), Uf(\"path\", {\n        d: \"M15.3504 12.6499L12.0004 15.9999L8.65039 12.6499\",\n        stroke: \"white\",\n        \"stroke-width\": \"1.5\",\n        \"stroke-linecap\": \"round\",\n        \"stroke-linejoin\": \"round\"\n    }));\nfunction jp(param) {\n    let { version: e } = param;\n    return Uf(\"div\", {\n        style: {\n            textAlign: \"center\",\n            color: \"#BBC0C5\",\n            fontSize: \"12\"\n        }\n    }, \"SDK Version \", e ? \"v\".concat(e) : \"unknown\");\n}\nconst Up = ()=>Uf(\"svg\", {\n        width: \"14\",\n        height: \"14\",\n        viewBox: \"0 0 16 16\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, Uf(\"rect\", {\n        width: \"16\",\n        height: \"16\",\n        fill: \"white\"\n    }), Uf(\"path\", {\n        \"fill-rule\": \"evenodd\",\n        \"clip-rule\": \"evenodd\",\n        d: \"M2.40554 2.40554C2.94627 1.86482 3.82296 1.86482 4.36369 2.40554L8 6.04186L11.6363 2.40554C12.177 1.86482 13.0537 1.86482 13.5945 2.40554C14.1352 2.94627 14.1352 3.82296 13.5945 4.36369L9.95814 8L13.5945 11.6363C14.1352 12.177 14.1352 13.0537 13.5945 13.5945C13.0537 14.1352 12.177 14.1352 11.6363 13.5945L8 9.95814L4.36369 13.5945C3.82296 14.1352 2.94627 14.1352 2.40554 13.5945C1.86482 13.0537 1.86482 12.177 2.40554 11.6363L6.04186 8L2.40554 4.36369C1.86482 3.82296 1.86482 2.94627 2.40554 2.40554Z\",\n        fill: \"#BBC0C5\"\n    })), Hp = ()=>Uf(\"svg\", {\n        width: \"120\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        fill: \"none\",\n        viewBox: \"0 0 127 63\"\n    }, Uf(\"path\", {\n        fill: \"currentColor\",\n        d: \"M71.554 48.607v13.81h-7.072v-9.568l-8.059.945c-1.77.205-2.548.79-2.548 1.864 0 1.575 1.478 2.239 4.648 2.239 1.932 0 4.073-.29 5.963-.79l-3.66 5.225c-1.479.332-2.92.496-4.44.496-6.414 0-10.074-2.57-10.074-7.132 0-4.023 2.877-6.136 9.416-6.884l8.638-1.012c-.467-2.532-2.362-3.633-6.13-3.633-3.537 0-7.443.912-10.937 2.613l1.111-6.18c3.248-1.369 6.95-2.074 10.69-2.074 8.226 0 12.461 3.444 12.461 10.075l-.008.005ZM7.938 31.315.208 62.416h7.73l3.836-15.628 6.65 8.039h8.06l6.65-8.039 3.836 15.628h7.73l-7.73-31.105-14.518 17.388L7.934 31.311l.004.004ZM36.97.21 22.452 17.598 7.938.21.208 31.315h7.73l3.836-15.628 6.65 8.039h8.06l6.65-8.039 3.836 15.628h7.73L36.97.21Zm53.17 48.107-6.25-.912c-1.562-.247-2.178-.747-2.178-1.617 0-1.41 1.52-2.032 4.647-2.032 3.62 0 6.868.747 10.283 2.364l-.862-6.094c-2.757-.995-5.922-1.491-9.212-1.491-7.688 0-11.886 2.696-11.886 7.547 0 3.776 2.303 5.889 7.196 6.636l6.335.954c1.603.248 2.261.87 2.261 1.865 0 1.41-1.478 2.074-4.481 2.074-3.948 0-8.225-.953-11.72-2.654l.7 6.094c3.003 1.122 6.91 1.785 10.57 1.785 7.896 0 12.007-2.78 12.007-7.715 0-3.94-2.303-6.057-7.4-6.8l-.01-.004ZM100.3 34.09v28.325h7.071V34.091H100.3Zm15.334 15.595 9.833-10.744h-8.8l-9.296 11.114 9.912 12.356h8.925l-10.574-12.73v.004Zm-16.321-25.09c0 4.56 3.66 7.13 10.074 7.13 1.52 0 2.961-.167 4.44-.495l3.66-5.225c-1.89.496-4.031.79-5.963.79-3.166 0-4.648-.664-4.648-2.239 0-1.079.783-1.659 2.549-1.864l8.058-.945v9.567h7.072v-13.81c0-6.635-4.236-10.075-12.461-10.075-3.744 0-7.442.705-10.691 2.075l-1.112 6.178c3.495-1.701 7.401-2.613 10.937-2.613 3.769 0 5.664 1.1 6.13 3.633l-8.637 1.013c-6.539.747-9.417 2.86-9.417 6.883l.009-.004Zm-19.779-1.492c0 5.725 3.29 8.627 9.787 8.627 2.59 0 4.732-.416 6.785-1.37l.903-6.261c-1.974 1.2-3.99 1.822-6.005 1.822-3.044 0-4.402-1.243-4.402-4.023v-8.295h10.732V7.84H86.601V2.948l-13.448 7.174v3.482h6.372V23.1l.008.004Zm-6.95-2.612v1.411H53.47c.862 2.873 3.423 4.187 7.97 4.187 3.62 0 6.993-.747 9.992-2.196l-.862 6.056c-2.757 1.16-6.251 1.785-9.829 1.785-9.5 0-14.68-4.23-14.68-12.066 0-7.838 5.264-12.235 13.406-12.235s13.119 4.771 13.119 13.062l-.005-.004ZM53.378 17.09h12.086c-.637-2.751-2.732-4.188-6.08-4.188-3.349 0-5.335 1.399-6.006 4.188Z\"\n    }));\nfunction Fp(e, t) {\n    return e.toString(2).padStart(t, \"0\");\n}\n_c152 = Fp;\nfunction zp(e, t) {\n    const n = e % t;\n    return n >= 0 ? n : t + n;\n}\nfunction qp(e, t) {\n    return new Array(e).fill(t);\n}\nfunction Wp() {\n    for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n        e[_key] = arguments[_key];\n    }\n    let t = 0;\n    for (const n of e)t = Math.max(t, n.length);\n    const n = [];\n    for(let r = 0; r < t; r++)for (const t of e)r >= t.length || n.push(t[r]);\n    return new Uint8Array(n);\n}\n_c153 = Wp;\nfunction Vp(e, t, n) {\n    if (n < 0 || n + t.length > e.length) return !1;\n    for(let r = 0; r < t.length; r++)if (t[r] !== e[n + r]) return !1;\n    return !0;\n}\n_c154 = Vp;\nfunction Gp(e) {\n    return {\n        has: (t)=>e.includes(t),\n        decode: (t)=>{\n            if (!Array.isArray(t) || t.length && \"string\" != typeof t[0]) throw new Error(\"alphabet.decode input should be array of strings\");\n            return t.map((t)=>{\n                if (\"string\" != typeof t) throw new Error(\"alphabet.decode: not string element=\".concat(t));\n                const n = e.indexOf(t);\n                if (-1 === n) throw new Error('Unknown letter: \"'.concat(t, '\". Allowed: ').concat(e));\n                return n;\n            });\n        },\n        encode: (t)=>{\n            if (!Array.isArray(t) || t.length && \"number\" != typeof t[0]) throw new Error(\"alphabet.encode input should be an array of numbers\");\n            return t.map((t)=>{\n                if (function(e) {\n                    if (!Number.isSafeInteger(e)) throw new Error(\"Wrong integer: \".concat(e));\n                }(t), t < 0 || t >= e.length) throw new Error(\"Digit index outside alphabet: \".concat(t, \" (alphabet: \").concat(e.length, \")\"));\n                return e[t];\n            });\n        }\n    };\n}\n_c155 = Gp;\nclass Yp {\n    static size(e, t) {\n        if (\"number\" == typeof e && (e = {\n            height: e,\n            width: e\n        }), !Number.isSafeInteger(e.height) && e.height !== 1 / 0) throw new Error(\"Bitmap: wrong height=\".concat(e.height, \" (\").concat(typeof e.height, \")\"));\n        if (!Number.isSafeInteger(e.width) && e.width !== 1 / 0) throw new Error(\"Bitmap: wrong width=\".concat(e.width, \" (\").concat(typeof e.width, \")\"));\n        return void 0 !== t && (e = {\n            width: Math.min(e.width, t.width),\n            height: Math.min(e.height, t.height)\n        }), e;\n    }\n    static fromString(e) {\n        const t = (e = e.replace(/^\\n+/g, \"\").replace(/\\n+$/g, \"\")).split(\"\\n\"), n = t.length, r = new Array(n);\n        let i;\n        for (const e of t){\n            const t = e.split(\"\").map((e)=>{\n                if (\"X\" === e) return !0;\n                if (\" \" === e) return !1;\n                if (\"?\" !== e) throw new Error(\"Bitmap.fromString: unknown symbol=\".concat(e));\n            });\n            if (i && t.length !== i) throw new Error(\"Bitmap.fromString different row sizes: width=\".concat(i, \" cur=\").concat(t.length));\n            i = t.length, r.push(t);\n        }\n        return i || (i = 0), new Yp({\n            height: n,\n            width: i\n        }, r);\n    }\n    point(e) {\n        return this.data[e.y][e.x];\n    }\n    isInside(e) {\n        return 0 <= e.x && e.x < this.width && 0 <= e.y && e.y < this.height;\n    }\n    size(e) {\n        if (!e) return {\n            height: this.height,\n            width: this.width\n        };\n        const { x: t, y: n } = this.xy(e);\n        return {\n            height: this.height - n,\n            width: this.width - t\n        };\n    }\n    xy(e) {\n        if (\"number\" == typeof e && (e = {\n            x: e,\n            y: e\n        }), !Number.isSafeInteger(e.x)) throw new Error(\"Bitmap: wrong x=\".concat(e.x));\n        if (!Number.isSafeInteger(e.y)) throw new Error(\"Bitmap: wrong y=\".concat(e.y));\n        return e.x = zp(e.x, this.width), e.y = zp(e.y, this.height), e;\n    }\n    rect(e, t, n) {\n        const { x: r, y: i } = this.xy(e), { height: o, width: s } = Yp.size(t, this.size({\n            x: r,\n            y: i\n        }));\n        for(let e = 0; e < o; e++)for(let t = 0; t < s; t++)this.data[i + e][r + t] = \"function\" == typeof n ? n({\n            x: t,\n            y: e\n        }, this.data[i + e][r + t]) : n;\n        return this;\n    }\n    rectRead(e, t, n) {\n        return this.rect(e, t, (e, t)=>(n(e, t), t));\n    }\n    hLine(e, t, n) {\n        return this.rect(e, {\n            width: t,\n            height: 1\n        }, n);\n    }\n    vLine(e, t, n) {\n        return this.rect(e, {\n            width: 1,\n            height: t\n        }, n);\n    }\n    border() {\n        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2, t = arguments.length > 1 ? arguments[1] : void 0;\n        const n = this.height + 2 * e, r = this.width + 2 * e, i = qp(e, t), o = Array.from({\n            length: e\n        }, ()=>qp(r, t));\n        return new Yp({\n            height: n,\n            width: r\n        }, [\n            ...o,\n            ...this.data.map((e)=>[\n                    ...i,\n                    ...e,\n                    ...i\n                ]),\n            ...o\n        ]);\n    }\n    embed(e, t) {\n        return this.rect(e, t.size(), (param)=>{\n            let { x: e, y: n } = param;\n            return t.data[n][e];\n        });\n    }\n    rectSlice(e) {\n        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.size();\n        const n = new Yp(Yp.size(t, this.size(this.xy(e))));\n        return this.rect(e, t, (param, r)=>{\n            let { x: e, y: t } = param;\n            return n.data[t][e] = r;\n        }), n;\n    }\n    inverse() {\n        const { height: e, width: t } = this;\n        return new Yp({\n            height: t,\n            width: e\n        }).rect({\n            x: 0,\n            y: 0\n        }, 1 / 0, (param)=>{\n            let { x: e, y: t } = param;\n            return this.data[e][t];\n        });\n    }\n    scale(e) {\n        if (!Number.isSafeInteger(e) || e > 1024) throw new Error(\"Wrong scale factor: \".concat(e));\n        const { height: t, width: n } = this;\n        return new Yp({\n            height: e * t,\n            width: e * n\n        }).rect({\n            x: 0,\n            y: 0\n        }, 1 / 0, (param)=>{\n            let { x: t, y: n } = param;\n            return this.data[Math.floor(n / e)][Math.floor(t / e)];\n        });\n    }\n    clone() {\n        return new Yp(this.size()).rect({\n            x: 0,\n            y: 0\n        }, this.size(), (param)=>{\n            let { x: e, y: t } = param;\n            return this.data[t][e];\n        });\n    }\n    assertDrawn() {\n        this.rectRead(0, 1 / 0, (e, t)=>{\n            if (\"boolean\" != typeof t) throw new Error(\"Invalid color type=\" + typeof t);\n        });\n    }\n    toString() {\n        return this.data.map((e)=>e.map((e)=>void 0 === e ? \"?\" : e ? \"X\" : \" \").join(\"\")).join(\"\\n\");\n    }\n    toASCII() {\n        const { height: e, width: t, data: n } = this;\n        let r = \"\";\n        for(let i = 0; i < e; i += 2){\n            for(let o = 0; o < t; o++){\n                const t = n[i][o], s = i + 1 >= e || n[i + 1][o];\n                t || s ? !t && s ? r += \"\" : t && !s ? r += \"\" : t && s && (r += \" \") : r += \"\";\n            }\n            r += \"\\n\";\n        }\n        return r;\n    }\n    toTerm() {\n        const e = \"\u001b[0m\", t = \"\\x1b[1;47m  \".concat(e), n = \"\\x1b[40m  \".concat(e);\n        return this.data.map((e)=>e.map((e)=>e ? n : t).join(\"\")).join(\"\\n\");\n    }\n    toSVG() {\n        let e = '<svg xmlns:svg=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 '.concat(this.width, \" \").concat(this.height, '\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">');\n        return this.rectRead(0, 1 / 0, (param, r)=>{\n            let { x: t, y: n } = param;\n            r && (e += '<rect x=\"'.concat(t, '\" y=\"').concat(n, '\" width=\"1\" height=\"1\" />'));\n        }), e += \"</svg>\", e;\n    }\n    toGIF() {\n        const e = (e)=>[\n                255 & e,\n                e >>> 8 & 255\n            ], t = [\n            ...e(this.width),\n            ...e(this.height)\n        ], n = [];\n        this.rectRead(0, 1 / 0, (e, t)=>n.push(+(!0 === t)));\n        const r = 126, i = [\n            71,\n            73,\n            70,\n            56,\n            55,\n            97,\n            ...t,\n            246,\n            0,\n            0,\n            255,\n            255,\n            255,\n            ...qp(381, 0),\n            44,\n            0,\n            0,\n            0,\n            0,\n            ...t,\n            0,\n            7\n        ], o = Math.floor(n.length / r);\n        for(let e = 0; e < o; e++)i.push(127, 128, ...n.slice(r * e, r * (e + 1)).map((e)=>+e));\n        return i.push(n.length % r + 1, 128, ...n.slice(o * r).map((e)=>+e)), i.push(1, 129, 0, 59), new Uint8Array(i);\n    }\n    toImage() {\n        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;\n        const { height: t, width: n } = this.size(), r = new Uint8Array(t * n * (e ? 3 : 4));\n        let i = 0;\n        for(let o = 0; o < t; o++)for(let t = 0; t < n; t++){\n            const n = this.data[o][t] ? 0 : 255;\n            r[i++] = n, r[i++] = n, r[i++] = n, e || (r[i++] = 255);\n        }\n        return {\n            height: t,\n            width: n,\n            data: r\n        };\n    }\n    constructor(e, t){\n        const { height: n, width: r } = Yp.size(e);\n        this.data = t || Array.from({\n            length: n\n        }, ()=>qp(r, void 0)), this.height = n, this.width = r;\n    }\n}\nconst Zp = [\n    \"low\",\n    \"medium\",\n    \"quartile\",\n    \"high\"\n], Jp = [\n    \"numeric\",\n    \"alphanumeric\",\n    \"byte\",\n    \"kanji\",\n    \"eci\"\n], Qp = [\n    26,\n    44,\n    70,\n    100,\n    134,\n    172,\n    196,\n    242,\n    292,\n    346,\n    404,\n    466,\n    532,\n    581,\n    655,\n    733,\n    815,\n    901,\n    991,\n    1085,\n    1156,\n    1258,\n    1364,\n    1474,\n    1588,\n    1706,\n    1828,\n    1921,\n    2051,\n    2185,\n    2323,\n    2465,\n    2611,\n    2761,\n    2876,\n    3034,\n    3196,\n    3362,\n    3532,\n    3706\n], Xp = {\n    low: [\n        7,\n        10,\n        15,\n        20,\n        26,\n        18,\n        20,\n        24,\n        30,\n        18,\n        20,\n        24,\n        26,\n        30,\n        22,\n        24,\n        28,\n        30,\n        28,\n        28,\n        28,\n        28,\n        30,\n        30,\n        26,\n        28,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30\n    ],\n    medium: [\n        10,\n        16,\n        26,\n        18,\n        24,\n        16,\n        18,\n        22,\n        22,\n        26,\n        30,\n        22,\n        22,\n        24,\n        24,\n        28,\n        28,\n        26,\n        26,\n        26,\n        26,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28,\n        28\n    ],\n    quartile: [\n        13,\n        22,\n        18,\n        26,\n        18,\n        24,\n        18,\n        22,\n        20,\n        24,\n        28,\n        26,\n        24,\n        20,\n        30,\n        24,\n        28,\n        28,\n        26,\n        30,\n        28,\n        30,\n        30,\n        30,\n        30,\n        28,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30\n    ],\n    high: [\n        17,\n        28,\n        22,\n        16,\n        22,\n        28,\n        26,\n        26,\n        24,\n        28,\n        24,\n        28,\n        22,\n        24,\n        24,\n        30,\n        28,\n        28,\n        26,\n        28,\n        30,\n        24,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30,\n        30\n    ]\n}, eg = {\n    low: [\n        1,\n        1,\n        1,\n        1,\n        1,\n        2,\n        2,\n        2,\n        2,\n        4,\n        4,\n        4,\n        4,\n        4,\n        6,\n        6,\n        6,\n        6,\n        7,\n        8,\n        8,\n        9,\n        9,\n        10,\n        12,\n        12,\n        12,\n        13,\n        14,\n        15,\n        16,\n        17,\n        18,\n        19,\n        19,\n        20,\n        21,\n        22,\n        24,\n        25\n    ],\n    medium: [\n        1,\n        1,\n        1,\n        2,\n        2,\n        4,\n        4,\n        4,\n        5,\n        5,\n        5,\n        8,\n        9,\n        9,\n        10,\n        10,\n        11,\n        13,\n        14,\n        16,\n        17,\n        17,\n        18,\n        20,\n        21,\n        23,\n        25,\n        26,\n        28,\n        29,\n        31,\n        33,\n        35,\n        37,\n        38,\n        40,\n        43,\n        45,\n        47,\n        49\n    ],\n    quartile: [\n        1,\n        1,\n        2,\n        2,\n        4,\n        4,\n        6,\n        6,\n        8,\n        8,\n        8,\n        10,\n        12,\n        16,\n        12,\n        17,\n        16,\n        18,\n        21,\n        20,\n        23,\n        23,\n        25,\n        27,\n        29,\n        34,\n        34,\n        35,\n        38,\n        40,\n        43,\n        45,\n        48,\n        51,\n        53,\n        56,\n        59,\n        62,\n        65,\n        68\n    ],\n    high: [\n        1,\n        1,\n        2,\n        4,\n        4,\n        4,\n        5,\n        6,\n        8,\n        8,\n        11,\n        11,\n        16,\n        16,\n        18,\n        16,\n        19,\n        21,\n        25,\n        25,\n        25,\n        34,\n        30,\n        32,\n        35,\n        37,\n        40,\n        42,\n        45,\n        48,\n        51,\n        54,\n        57,\n        60,\n        63,\n        66,\n        70,\n        74,\n        77,\n        81\n    ]\n}, tg = {\n    size: {\n        encode: (e)=>21 + 4 * (e - 1),\n        decode: (e)=>(e - 17) / 4\n    },\n    sizeType: (e)=>Math.floor((e + 7) / 17),\n    alignmentPatterns (e) {\n        if (1 === e) return [];\n        const t = tg.size.encode(e) - 6 - 1, n = t - 6, r = Math.ceil(n / 28);\n        let i = Math.floor(n / r);\n        i % 2 ? i += 1 : n % r * 2 >= r && (i += 2);\n        const o = [\n            6\n        ];\n        for(let e = 1; e < r; e++)o.push(t - (r - e) * i);\n        return o.push(t), o;\n    },\n    ECCode: {\n        low: 1,\n        medium: 0,\n        quartile: 3,\n        high: 2\n    },\n    formatMask: 21522,\n    formatBits (e, t) {\n        const n = tg.ECCode[e] << 3 | t;\n        let r = n;\n        for(let e = 0; e < 10; e++)r = r << 1 ^ 1335 * (r >> 9);\n        return (n << 10 | r) ^ tg.formatMask;\n    },\n    versionBits (e) {\n        let t = e;\n        for(let e = 0; e < 12; e++)t = t << 1 ^ 7973 * (t >> 11);\n        return e << 12 | t;\n    },\n    alphabet: {\n        numeric: Gp(\"0123456789\"),\n        alphanumerc: Gp(\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:\")\n    },\n    lengthBits: (e, t)=>({\n            numeric: [\n                10,\n                12,\n                14\n            ],\n            alphanumeric: [\n                9,\n                11,\n                13\n            ],\n            byte: [\n                8,\n                16,\n                16\n            ],\n            kanji: [\n                8,\n                10,\n                12\n            ],\n            eci: [\n                0,\n                0,\n                0\n            ]\n        })[t][tg.sizeType(e)],\n    modeBits: {\n        numeric: \"0001\",\n        alphanumeric: \"0010\",\n        byte: \"0100\",\n        kanji: \"1000\",\n        eci: \"0111\"\n    },\n    capacity (e, t) {\n        const n = Qp[e - 1], r = Xp[t][e - 1], i = eg[t][e - 1], o = Math.floor(n / i) - r, s = i - n % i;\n        return {\n            words: r,\n            numBlocks: i,\n            shortBlocks: s,\n            blockLen: o,\n            capacity: 8 * (n - r * i),\n            total: (r + o) * i + i - s\n        };\n    }\n}, ng = [\n    (e, t)=>(e + t) % 2 == 0,\n    (e, t)=>t % 2 == 0,\n    (e, t)=>e % 3 == 0,\n    (e, t)=>(e + t) % 3 == 0,\n    (e, t)=>(Math.floor(t / 2) + Math.floor(e / 3)) % 2 == 0,\n    (e, t)=>e * t % 2 + e * t % 3 == 0,\n    (e, t)=>(e * t % 2 + e * t % 3) % 2 == 0,\n    (e, t)=>((e + t) % 2 + e * t % 3) % 2 == 0\n], rg = {\n    tables: ((e)=>{\n        const t = qp(256, 0), n = qp(256, 0);\n        for(let e = 0, r = 1; e < 256; e++)t[e] = r, n[r] = e, r <<= 1, 256 & r && (r ^= 285);\n        return {\n            exp: t,\n            log: n\n        };\n    })(),\n    exp: (e)=>rg.tables.exp[e],\n    log (e) {\n        if (0 === e) throw new Error(\"GF.log: wrong arg=\".concat(e));\n        return rg.tables.log[e] % 255;\n    },\n    mul: (e, t)=>0 === e || 0 === t ? 0 : rg.tables.exp[(rg.tables.log[e] + rg.tables.log[t]) % 255],\n    add: (e, t)=>e ^ t,\n    pow: (e, t)=>rg.tables.exp[rg.tables.log[e] * t % 255],\n    inv (e) {\n        if (0 === e) throw new Error(\"GF.inverse: wrong arg=\".concat(e));\n        return rg.tables.exp[255 - rg.tables.log[e]];\n    },\n    polynomial (e) {\n        if (0 == e.length) throw new Error(\"GF.polymomial: wrong length\");\n        if (0 !== e[0]) return e;\n        let t = 0;\n        for(; t < e.length - 1 && 0 == e[t]; t++);\n        return e.slice(t);\n    },\n    monomial (e, t) {\n        if (e < 0) throw new Error(\"GF.monomial: wrong degree=\".concat(e));\n        if (0 == t) return [\n            0\n        ];\n        let n = qp(e + 1, 0);\n        return n[0] = t, rg.polynomial(n);\n    },\n    degree: (e)=>e.length - 1,\n    coefficient: (e, t)=>e[rg.degree(e) - t],\n    mulPoly (e, t) {\n        if (0 === e[0] || 0 === t[0]) return [\n            0\n        ];\n        const n = qp(e.length + t.length - 1, 0);\n        for(let r = 0; r < e.length; r++)for(let i = 0; i < t.length; i++)n[r + i] = rg.add(n[r + i], rg.mul(e[r], t[i]));\n        return rg.polynomial(n);\n    },\n    mulPolyScalar (e, t) {\n        if (0 == t) return [\n            0\n        ];\n        if (1 == t) return e;\n        const n = qp(e.length, 0);\n        for(let r = 0; r < e.length; r++)n[r] = rg.mul(e[r], t);\n        return rg.polynomial(n);\n    },\n    mulPolyMonomial (e, t, n) {\n        if (t < 0) throw new Error(\"GF.mulPolyMonomial: wrong degree\");\n        if (0 == n) return [\n            0\n        ];\n        const r = qp(e.length + t, 0);\n        for(let t = 0; t < e.length; t++)r[t] = rg.mul(e[t], n);\n        return rg.polynomial(r);\n    },\n    addPoly (e, t) {\n        if (0 === e[0]) return t;\n        if (0 === t[0]) return e;\n        let n = e, r = t;\n        n.length > r.length && ([n, r] = [\n            r,\n            n\n        ]);\n        let i = qp(r.length, 0), o = r.length - n.length, s = r.slice(0, o);\n        for(let e = 0; e < s.length; e++)i[e] = s[e];\n        for(let e = o; e < r.length; e++)i[e] = rg.add(n[e - o], r[e]);\n        return rg.polynomial(i);\n    },\n    remainderPoly (e, t) {\n        const n = Array.from(e);\n        for(let r = 0; r < e.length - t.length + 1; r++){\n            const e = n[r];\n            if (0 !== e) for(let i = 1; i < t.length; i++)0 !== t[i] && (n[r + i] = rg.add(n[r + i], rg.mul(t[i], e)));\n        }\n        return n.slice(e.length - t.length + 1, n.length);\n    },\n    divisorPoly (e) {\n        let t = [\n            1\n        ];\n        for(let n = 0; n < e; n++)t = rg.mulPoly(t, [\n            1,\n            rg.pow(2, n)\n        ]);\n        return t;\n    },\n    evalPoly (e, t) {\n        if (0 == t) return rg.coefficient(e, 0);\n        let n = e[0];\n        for(let r = 1; r < e.length; r++)n = rg.add(rg.mul(t, n), e[r]);\n        return n;\n    },\n    euclidian (e, t, n) {\n        rg.degree(e) < rg.degree(t) && ([e, t] = [\n            t,\n            e\n        ]);\n        let r = e, i = t, o = [\n            0\n        ], s = [\n            1\n        ];\n        for(; 2 * rg.degree(i) >= n;){\n            let e = r, t = o;\n            if (r = i, o = s, 0 === r[0]) throw new Error(\"rLast[0] === 0\");\n            i = e;\n            let n = [\n                0\n            ];\n            const a = rg.inv(r[0]);\n            for(; rg.degree(i) >= rg.degree(r) && 0 !== i[0];){\n                const e = rg.degree(i) - rg.degree(r), t = rg.mul(i[0], a);\n                n = rg.addPoly(n, rg.monomial(e, t)), i = rg.addPoly(i, rg.mulPolyMonomial(r, e, t));\n            }\n            if (n = rg.mulPoly(n, o), s = rg.addPoly(n, t), rg.degree(i) >= rg.degree(r)) throw new Error(\"Division failed r: \".concat(i, \", rLast: \").concat(r));\n        }\n        const a = rg.coefficient(s, 0);\n        if (0 == a) throw new Error(\"sigmaTilde(0) was zero\");\n        const c = rg.inv(a);\n        return [\n            rg.mulPolyScalar(s, c),\n            rg.mulPolyScalar(i, c)\n        ];\n    }\n};\nfunction ig(e, t) {\n    const { words: n, shortBlocks: r, numBlocks: i, blockLen: o, total: s } = tg.capacity(e, t), a = (c = n, {\n        encode (e) {\n            const t = rg.divisorPoly(c), n = Array.from(e);\n            return n.push(...t.slice(0, -1).fill(0)), Uint8Array.from(rg.remainderPoly(n, t));\n        },\n        decode (e) {\n            const t = e.slice(), n = rg.polynomial(Array.from(e));\n            let r = qp(c, 0), i = !1;\n            for(let e = 0; e < c; e++){\n                const t = rg.evalPoly(n, rg.exp(e));\n                r[r.length - 1 - e] = t, 0 !== t && (i = !0);\n            }\n            if (!i) return t;\n            r = rg.polynomial(r);\n            const o = rg.monomial(c, 1), [s, a] = rg.euclidian(o, r, c), l = qp(rg.degree(s), 0);\n            let d = 0;\n            for(let e = 1; e < 256 && d < l.length; e++)0 === rg.evalPoly(s, e) && (l[d++] = rg.inv(e));\n            if (d !== l.length) throw new Error(\"RS.decode: wrong errors number\");\n            for(let e = 0; e < l.length; e++){\n                const n = t.length - 1 - rg.log(l[e]);\n                if (n < 0) throw new Error(\"RS.decode: wrong error location\");\n                const r = rg.inv(l[e]);\n                let i = 1;\n                for(let t = 0; t < l.length; t++)e !== t && (i = rg.mul(i, rg.add(1, rg.mul(l[t], r))));\n                t[n] = rg.add(t[n], rg.mul(rg.evalPoly(a, r), rg.inv(i)));\n            }\n            return t;\n        }\n    });\n    var c;\n    return {\n        encode (e) {\n            const t = [], n = [];\n            for(let s = 0; s < i; s++){\n                const i = o + (s < r ? 0 : 1);\n                t.push(e.subarray(0, i)), n.push(a.encode(e.subarray(0, i))), e = e.subarray(i);\n            }\n            const s = Wp(...t), c = Wp(...n), l = new Uint8Array(s.length + c.length);\n            return l.set(s), l.set(c, s.length), l;\n        },\n        decode (e) {\n            if (e.length !== s) throw new Error(\"interleave.decode: len(data)=\".concat(e.length, \", total=\").concat(s));\n            const t = [];\n            for(let e = 0; e < i; e++){\n                const i = e < r;\n                t.push(new Uint8Array(n + o + (i ? 0 : 1)));\n            }\n            let c = 0;\n            for(let n = 0; n < o; n++)for(let r = 0; r < i; r++)t[r][n] = e[c++];\n            for(let n = r; n < i; n++)t[n][o] = e[c++];\n            for(let s = o; s < o + n; s++)for(let n = 0; n < i; n++){\n                const i = n < r;\n                t[n][s + (i ? 0 : 1)] = e[c++];\n            }\n            const l = [];\n            for (const e of t)l.push(...Array.from(a.decode(e)).slice(0, -n));\n            return Uint8Array.from(l);\n        }\n    };\n}\nfunction og(e, t, n, r) {\n    let i = \"\", o = n.length;\n    if (\"numeric\" === r) {\n        const e = tg.alphabet.numeric.decode(n.split(\"\")), t = e.length;\n        for(let n = 0; n < t - 2; n += 3)i += Fp(100 * e[n] + 10 * e[n + 1] + e[n + 2], 10);\n        t % 3 == 1 ? i += Fp(e[t - 1], 4) : t % 3 == 2 && (i += Fp(10 * e[t - 2] + e[t - 1], 7));\n    } else if (\"alphanumeric\" === r) {\n        const e = tg.alphabet.alphanumerc.decode(n.split(\"\")), t = e.length;\n        for(let n = 0; n < t - 1; n += 2)i += Fp(45 * e[n] + e[n + 1], 11);\n        t % 2 == 1 && (i += Fp(e[t - 1], 6));\n    } else {\n        if (\"byte\" !== r) throw new Error(\"encode: unsupported type\");\n        {\n            const e = function(e) {\n                if (\"string\" != typeof e) throw new Error(\"utf8ToBytes expected string, got \" + typeof e);\n                return new Uint8Array((new TextEncoder).encode(e));\n            }(n);\n            o = e.length, i = Array.from(e).map((e)=>Fp(e, 8)).join(\"\");\n        }\n    }\n    const { capacity: s } = tg.capacity(e, t), a = Fp(o, tg.lengthBits(e, r));\n    let c = tg.modeBits[r] + a + i;\n    if (c.length > s) throw new Error(\"Capacity overflow\");\n    c += \"0\".repeat(Math.min(4, Math.max(0, s - c.length))), c.length % 8 && (c += \"0\".repeat(8 - c.length % 8));\n    const l = \"1110110000010001\";\n    for(let e = 0; c.length !== s; e++)c += l[e % 16];\n    const d = Uint8Array.from(c.match(/(.{8})/g).map((e)=>Number(\"0b\".concat(e))));\n    return ig(e, t).encode(d);\n}\nfunction sg(e, t, n, r) {\n    let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;\n    const o = function(e, t, n) {\n        let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;\n        const i = tg.size.encode(e);\n        let o = new Yp(i + 2);\n        const s = new Yp(3).rect(0, 3, !0).border(1, !1).border(1, !0).border(1, !1);\n        o = o.embed(0, s).embed({\n            x: -s.width,\n            y: 0\n        }, s).embed({\n            x: 0,\n            y: -s.height\n        }, s), o = o.rectSlice(1, i);\n        const a = new Yp(1).rect(0, 1, !0).border(1, !1).border(1, !0), c = tg.alignmentPatterns(e);\n        for (const e of c)for (const t of c)void 0 === o.data[e][t] && o.embed({\n            x: t - 2,\n            y: e - 2\n        }, a);\n        o = o.hLine({\n            x: 0,\n            y: 6\n        }, 1 / 0, (param, t)=>{\n            let { x: e } = param;\n            return void 0 === t ? e % 2 == 0 : t;\n        }).vLine({\n            x: 6,\n            y: 0\n        }, 1 / 0, (param, t)=>{\n            let { y: e } = param;\n            return void 0 === t ? e % 2 == 0 : t;\n        });\n        {\n            const e = tg.formatBits(t, n), s = (t)=>!r && 1 == (e >> t & 1);\n            for(let e = 0; e < 6; e++)o.data[e][8] = s(e);\n            for(let e = 6; e < 8; e++)o.data[e + 1][8] = s(e);\n            for(let e = 8; e < 15; e++)o.data[i - 15 + e][8] = s(e);\n            for(let e = 0; e < 8; e++)o.data[8][i - e - 1] = s(e);\n            for(let e = 8; e < 9; e++)o.data[8][15 - e - 1 + 1] = s(e);\n            for(let e = 9; e < 15; e++)o.data[8][15 - e - 1] = s(e);\n            o.data[i - 8][8] = !r;\n        }\n        if (e >= 7) {\n            const t = tg.versionBits(e);\n            for(let e = 0; e < 18; e += 1){\n                const n = !r && 1 == (t >> e & 1), s = Math.floor(e / 3), a = e % 3 + i - 8 - 3;\n                o.data[s][a] = n, o.data[a][s] = n;\n            }\n        }\n        return o;\n    }(e, t, r, i);\n    let s = 0;\n    const a = 8 * n.length;\n    if (function(e, t, n) {\n        const r = e.height, i = ng[t];\n        let o = -1, s = r - 1;\n        for(let t = r - 1; t > 0; t -= 2){\n            for(6 == t && (t = 5);; s += o){\n                for(let r = 0; r < 2; r += 1){\n                    const o = t - r;\n                    void 0 === e.data[s][o] && n(o, s, i(o, s));\n                }\n                if (s + o < 0 || s + o >= r) break;\n            }\n            o = -o;\n        }\n    }(o, r, (e, t, r)=>{\n        let i = !1;\n        s < a && (i = 0 != (n[s >>> 3] >> (7 - s & 7) & 1), s++), o.data[t][e] = i !== r;\n    }), s !== a) throw new Error(\"QR: bytes left after draw\");\n    return o;\n}\nfunction ag(e) {\n    const t = e.inverse(), n = (e)=>{\n        let t = 0;\n        for(let n, r = 0, i = 1; r < e.length; r++)n === e[r] && (i++, r !== e.length - 1) || (i >= 5 && (t += i - 5 + 3), n = e[r], i = 1);\n        return t;\n    };\n    let r = 0;\n    e.data.forEach((e)=>r += n(e)), t.data.forEach((e)=>r += n(e));\n    let i = 0, o = e.data;\n    const s = e.width - 1, a = e.height - 1;\n    for(let e = 0; e < s; e++)for(let t = 0; t < a; t++){\n        const n = e + 1, r = t + 1;\n        o[e][t] === o[n][t] && o[n][t] === o[e][r] && o[n][t] === o[n][r] && (i += 3);\n    }\n    const c = (e)=>{\n        const t = [\n            !0,\n            !1,\n            !0,\n            !0,\n            !0,\n            !1,\n            !0\n        ], n = [\n            !1,\n            !1,\n            !1,\n            !1\n        ], r = [\n            ...t,\n            ...n\n        ], i = [\n            ...n,\n            ...t\n        ];\n        let o = 0;\n        for(let t = 0; t < e.length; t++)Vp(e, r, t) && (o += 40), Vp(e, i, t) && (o += 40);\n        return o;\n    };\n    let l = 0;\n    for (const t of e.data)l += c(t);\n    for (const e of t.data)l += c(e);\n    let d = 0;\n    e.rectRead(0, 1 / 0, (e, t)=>d += t ? 1 : 0);\n    const u = d / (e.height * e.width) * 100, h = 10 * Math.floor(Math.abs(u - 50) / 5);\n    return r + i + l + h;\n}\nfunction cg(e) {\n    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"raw\", n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const r = void 0 !== n.ecc ? n.ecc : \"medium\";\n    !function(e) {\n        if (!Zp.includes(e)) throw new Error(\"Invalid error correction mode=\".concat(e, \". Expected: \").concat(Zp));\n    }(r);\n    const i = void 0 !== n.encoding ? n.encoding : function(e) {\n        let t = \"numeric\";\n        for (let n of e)if (!tg.alphabet.numeric.has(n) && (t = \"alphanumeric\", !tg.alphabet.alphanumerc.has(n))) return \"byte\";\n        return t;\n    }(e);\n    !function(e) {\n        if (!Jp.includes(e)) throw new Error(\"Encoding: invalid mode=\".concat(e, \". Expected: \").concat(Jp));\n        if (\"kanji\" === e || \"eci\" === e) throw new Error(\"Encoding: \".concat(e, \" is not supported (yet?).\"));\n    }(i), void 0 !== n.mask && function(e) {\n        if (![\n            0,\n            1,\n            2,\n            3,\n            4,\n            5,\n            6,\n            7\n        ].includes(e) || !ng[e]) throw new Error(\"Invalid mask=\".concat(e, \". Expected number [0..7]\"));\n    }(n.mask);\n    let o, s = n.version, a = new Error(\"Unknown error\");\n    if (void 0 !== s) !function(e) {\n        if (!Number.isSafeInteger(e) || e < 1 || e > 40) throw new Error(\"Invalid version=\".concat(e, \". Expected number [1..40]\"));\n    }(s), o = og(s, r, e, i);\n    else for(let t = 1; t <= 40; t++)try {\n        o = og(t, r, e, i), s = t;\n        break;\n    } catch (e) {\n        a = e;\n    }\n    if (!s || !o) throw a;\n    let c = function(e, t, n, r) {\n        if (void 0 === r) {\n            const i = function() {\n                let e, t = 1 / 0;\n                return {\n                    add (n, r) {\n                        n >= t || (e = r, t = n);\n                    },\n                    get: ()=>e,\n                    score: ()=>t\n                };\n            }();\n            for(let r = 0; r < ng.length; r++)i.add(ag(sg(e, t, n, r, !0)), r);\n            r = i.get();\n        }\n        if (void 0 === r) throw new Error(\"Cannot find mask\");\n        return sg(e, t, n, r);\n    }(s, r, o, n.mask);\n    c.assertDrawn();\n    const l = void 0 === n.border ? 2 : n.border;\n    if (!Number.isSafeInteger(l)) throw new Error(\"Wrong border type=\" + typeof l);\n    if (c = c.border(l, !1), void 0 !== n.scale && (c = c.scale(n.scale)), \"raw\" === t) return c.data;\n    if (\"ascii\" === t) return c.toASCII();\n    if (\"svg\" === t) return c.toSVG();\n    if (\"gif\" === t) return c.toGIF();\n    if (\"term\" === t) return c.toTerm();\n    throw new Error(\"Unknown output: \".concat(t));\n}\nconst lg = {\n    DESKTOP: \"Desktop\",\n    MOBILE: \"Mobile\",\n    META_MASK_MOBILE_APP: \"MetaMask mobile app\",\n    SCAN_TO_CONNECT: \"Scan to connect and sign with\",\n    CONNECT_WITH_EXTENSION: \"Connect With MetaMask Extension\",\n    INSTALL_MODAL: {\n        TRUSTED_BY_USERS: \"Trusted by over 30 million users to buy, store, send and swap crypto securely\",\n        LEADING_CRYPTO_WALLET: \"The leading crypto wallet & gateway to blockchain apps built on Ethereum Mainnet, Polygon, Optimism, and many other networks\",\n        CONTROL_DIGITAL_INTERACTIONS: \"Puts you in control of your digital interactions by making power of cryptography more accessible\",\n        INSTALL_META_MASK_EXTENSION: \"Install MetaMask Extension\"\n    },\n    PENDING_MODAL: {\n        OPEN_META_MASK_SELECT_CODE: \"Please open the MetaMask wallet app and select the code on the screen OR disconnect\",\n        OPEN_META_MASK_CONTINUE: \"Open the MetaMask app to continue with your session.\",\n        NUMBER_AFTER_OPEN_NOTICE: \"If a number doesn't appear after opening MetaMask, please click disconnect and re-scan the QRCode.\",\n        DISCONNECT: \"Disconnect\"\n    },\n    SELECT_MODAL: {\n        CRYPTO_TAKE_CONTROL_TEXT: \"Take control of your crypto and explore the blockchain with the wallet trusted by over 30 million people worldwide\"\n    },\n    META_MASK_MODAL: {\n        ADDRESS_COPIED: \"Address copied to clipboard!\",\n        DISCONNECT: \"Disconnect\",\n        ACTIVE_NETWORK: \"Active Network\"\n    }\n};\nclass dg {\n    getBrowserLanguage() {\n        if ((navigator.languages || [\n            navigator.language\n        ]).some((e)=>e.toLowerCase().startsWith(\"en\"))) return \"en\";\n        const e = navigator.language.toLowerCase().split(\"-\")[0];\n        return this.supportedLocales.includes(e) ? e : \"en\";\n    }\n    async init(e) {\n        const t = this.getBrowserLanguage() || e.fallbackLng;\n        await this.loadTranslations(t);\n    }\n    async loadTranslations(e) {\n        const t = e.split(\"-\")[0];\n        if (\"en\" !== t && this.supportedLocales.includes(t)) try {\n            const e = \"\".concat(this.baseUrl, \"/\").concat(t, \".json\"), n = await fetch(e);\n            if (!n.ok) throw new Error(\"HTTP error! status: \".concat(n.status));\n            this.translations = await n.json();\n        } catch (e) {\n            console.warn(\" Failed to load \".concat(t, \" translations, falling back to English:\"), e), this.translations = lg;\n        }\n        else this.translations = lg;\n    }\n    t(e) {\n        return this.getNestedTranslation(e, this.translations) || e;\n    }\n    getNestedTranslation(e, t) {\n        const n = e.split(\".\");\n        let r = t;\n        for (const e of n){\n            if (\"object\" != typeof r) return \"\";\n            r = r[e];\n        }\n        return \"string\" == typeof r ? r : \"\";\n    }\n    constructor(e){\n        var t;\n        this.translations = lg, this.supportedLocales = [\n            \"es\",\n            \"fr\",\n            \"he\",\n            \"it\",\n            \"pt\",\n            \"tr\"\n        ], this.baseUrl = null !== (t = null == e ? void 0 : e.baseUrl) && void 0 !== t ? t : \"https://raw.githubusercontent.com/MetaMask/metamask-sdk/refs/heads/gh-pages/locales\";\n    }\n}\nvar ug;\n!function(e) {\n    e.SDK_MODAL_VIEWED = \"sdk_modal_viewed\", e.SDK_MODAL_BUTTON_CLICKED = \"sdk_modal_button_clicked\", e.SDK_MODAL_TOGGLE_CHANGED = \"sdk_modal_toggle_changed\";\n}(ug || (ug = {}));\nconst hg = class {\n    componentDidLoad() {\n        this.trackAnalytics.emit({\n            event: ug.SDK_MODAL_VIEWED,\n            params: {\n                extensionInstalled: !1,\n                tab: 1 === this.tab ? \"desktop\" : \"mobile\"\n            }\n        });\n    }\n    async connectedCallback() {\n        await this.i18nInstance.init({\n            fallbackLng: \"en\"\n        }), this.translationsLoaded = !0;\n    }\n    updatePreferDesktop(e) {\n        e ? this.setTab(1) : this.setTab(2);\n    }\n    onClose() {\n        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;\n        this.close.emit({\n            shouldTerminate: e\n        });\n    }\n    onStartDesktopOnboardingHandler() {\n        this.trackAnalytics.emit({\n            event: ug.SDK_MODAL_BUTTON_CLICKED,\n            params: {\n                button_type: \"install_extension\",\n                tab: \"desktop\"\n            }\n        }), this.startDesktopOnboarding.emit();\n    }\n    setTab(e) {\n        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;\n        t && this.trackAnalytics.emit({\n            event: ug.SDK_MODAL_TOGGLE_CHANGED,\n            params: {\n                toggle: 1 === this.tab ? \"desktop_to_mobile\" : \"mobile_to_desktop\"\n            }\n        }), this.tab = e, this.isDefaultTab = !1;\n    }\n    render() {\n        if (!this.translationsLoaded) return null;\n        const e = (e)=>this.i18nInstance.t(e), t = this.isDefaultTab ? this.preferDesktop ? 1 : 2 : this.tab, n = cg(this.link, \"svg\", {\n            ecc: \"medium\",\n            scale: 2\n        });\n        return Uf(Np, {\n            className: \"install-model\"\n        }, Uf(\"div\", {\n            class: \"backdrop\",\n            onClick: ()=>this.onClose(!0)\n        }), Uf(\"div\", {\n            class: \"modal\"\n        }, Uf(\"div\", {\n            class: \"closeButtonContainer\"\n        }, Uf(\"div\", {\n            class: \"right\"\n        }, Uf(\"span\", {\n            class: \"closeButton\",\n            onClick: ()=>this.onClose(!0)\n        }, Uf(Up, null)))), Uf(\"div\", {\n            class: \"logoContainer\"\n        }, Uf(Hp, null)), Uf(\"div\", null, Uf(\"div\", {\n            class: \"tabcontainer\"\n        }, Uf(\"div\", {\n            class: \"flexContainer\"\n        }, Uf(\"div\", {\n            onClick: ()=>this.setTab(1, !0),\n            class: \"tab flexItem \" + (1 === t ? \"tabactive\" : \"\")\n        }, e(\"DESKTOP\")), Uf(\"div\", {\n            onClick: ()=>this.setTab(2, !0),\n            class: \"tab flexItem \" + (2 === t ? \"tabactive\" : \"\")\n        }, e(\"MOBILE\")))), Uf(\"div\", {\n            style: {\n                display: 1 === t ? \"none\" : \"block\"\n            }\n        }, Uf(\"div\", {\n            class: \"flexContainer\"\n        }, Uf(\"div\", {\n            class: \"flexItem\",\n            style: {\n                textAlign: \"center\",\n                marginTop: \"4\"\n            }\n        }, n && Uf(\"div\", {\n            id: \"sdk-mm-qrcode\",\n            class: \"center\",\n            innerHTML: n\n        }), Uf(\"div\", {\n            class: \"connectMobileText\"\n        }, e(\"SCAN_TO_CONNECT\"), \" \", Uf(\"br\", null), Uf(\"span\", {\n            class: \"blue\"\n        }, Uf(\"b\", null, e(\"META_MASK_MOBILE_APP\"))))))), Uf(\"div\", {\n            style: {\n                display: 2 === t ? \"none\" : \"block\"\n            }\n        }, Uf(\"div\", {\n            class: \"item\"\n        }, Uf(Lp, {\n            Icon: $p,\n            text: e(\"INSTALL_MODAL.TRUSTED_BY_USERS\")\n        })), Uf(\"div\", {\n            class: \"item\"\n        }, Uf(Lp, {\n            Icon: Dp,\n            text: e(\"INSTALL_MODAL.LEADING_CRYPTO_WALLET\")\n        })), Uf(\"div\", {\n            class: \"item\"\n        }, Uf(Lp, {\n            Icon: Bp,\n            text: e(\"INSTALL_MODAL.CONTROL_DIGITAL_INTERACTIONS\")\n        })), Uf(\"button\", {\n            class: \"button\",\n            onClick: ()=>this.onStartDesktopOnboardingHandler()\n        }, Uf(Kp, null), Uf(\"span\", {\n            class: \"installExtensionText\"\n        }, e(\"INSTALL_MODAL.INSTALL_META_MASK_EXTENSION\"))))), Uf(jp, {\n            version: this.sdkVersion\n        })));\n    }\n    get el() {\n        return Vf(this);\n    }\n    static get watchers() {\n        return {\n            preferDesktop: [\n                \"updatePreferDesktop\"\n            ]\n        };\n    }\n    constructor(e){\n        ff(this, e), this.close = Gf(this, \"close\", 7), this.startDesktopOnboarding = Gf(this, \"startDesktopOnboarding\", 7), this.trackAnalytics = Gf(this, \"trackAnalytics\", 7), this.link = void 0, this.sdkVersion = void 0, this.preferDesktop = void 0, this.tab = 1, this.isDefaultTab = !0, this.translationsLoaded = !1, this.onClose = this.onClose.bind(this), this.onStartDesktopOnboardingHandler = this.onStartDesktopOnboardingHandler.bind(this), this.setTab = this.setTab.bind(this), this.render = this.render.bind(this), this.setTab(this.preferDesktop ? 1 : 2), this.i18nInstance = new dg;\n    }\n};\nhg.style = \".flexContainer {\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    flex-direction: row;\\n}\\n\\n.flexItem {\\n    flex: 1;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\\n.flexItem11 {\\n    flex: 11;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\\n.flexItem1 {\\n    flex: 1;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\\n.tab {\\n    padding: 8px;\\n    cursor: pointer;\\n    background-color: #F2F4F6;\\n    font-size: 12px;\\n    text-align: center;\\n    color: #24292E;\\n}\\n\\n.tabcontainer {\\n    padding: 4px;\\n    background-color: #F2F4F6;\\n    border-radius: 8px;\\n    margin-bottom: 30px;\\n    margin-top: 30px;\\n}\\n\\n.tabactive {\\n    background-color: white;\\n    -webkit-transition: background-color 300ms linear;\\n    -ms-transition: background-color 300ms linear;\\n    transition: background-color 300ms linear;\\n    border-radius: 8px;\\n}\\n\\n.item {\\n    font-size: 12px;\\n    margin-bottom: 16px;\\n    border-radius: 8px;\\n    padding: 10px;\\n    border: 2px #F2F4F6 solid;\\n    color: #24292E;\\n}\\n\\n.extensionLabel {\\n    font-style: normal;\\n    font-weight: bold;\\n    font-size: 14px;\\n    text-align: cetner;\\n    color: #24272A;\\n}\\n\\n.notice {\\n    font-size: 12px;\\n    margin-left: 10px;\\n    margin-right: 10px;\\n    color: grey;\\n}\\n\\n.button {\\n    margin-top: 41.5px;\\n    margin-bottom: 20px;\\n    width: 100%;\\n    display: flex;\\n    flex-direction: row;\\n    justify-content: center;\\n    align-items: center;\\n    padding: 12px 20px;\\n    background: #037DD6;\\n    border-radius: 32px;\\n    color: white;\\n    border: 0;\\n    font-size: 14px;\\n    cursor: pointer;\\n}\\n\\n.backdrop {\\n    visibility: visible;\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n    bottom: 0;\\n    width: 100%;\\n    z-index: 99998;\\n    background: rgba(0, 0, 0, 0.87);\\n    opacity: 0.3;\\n}\\n\\n.modal {\\n    visibility: visible;\\n    position: fixed;\\n    left: 50%;\\n    transform: translate(-50%, -50%);\\n    z-index: 99999;\\n    background: white;\\n    padding: 20px;\\n    border-radius: 8px;\\n    top: 50%;\\n    max-width: 100%;\\n    width: 460px;\\n    min-width: 300px;\\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;\\n    -webkit-font-smoothing: antialiased;\\n}\\n\\n.closeButton {\\n    color: #BBC0C5;\\n    cursor: pointer;\\n}\\n\\n.logoContainer {\\n    margin-left: 24px;\\n    margin-right: 24px;\\n    margin-top: 24px;\\n    display: flex;\\n    align-items: center;\\n    justify-content: center;\\n}\\n\\n.connectMobileText {\\n    font-size: 14px;\\n    color: black;\\n    margin-top: 28px;\\n    margin-bottom: 28px;\\n    line-height: 2;\\n}\\n\\n.blue {\\n    color: #037DD6;\\n    font-weight: 700;\\n}\\n\\n.installExtensionText {\\n    margin-left: 10px;\\n}\\n\\n.center {\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\\n.right {\\n    display: flex;\\n    align-items: center;\\n    justify-content: right;\\n}\\n\\n#sdk-mm-qrcode {\\n    svg {\\n        width: 50%;\\n    }\\n}\";\nconst fg = class {\n    async connectedCallback() {\n        await this.i18nInstance.init({\n            fallbackLng: \"en\"\n        }), this.translationsLoaded = !0;\n    }\n    onClose() {\n        this.close.emit();\n    }\n    onDisconnect() {\n        this.disconnect.emit();\n    }\n    onUpdateOTPValueHandler(e) {\n        this.updateOTPValue.emit({\n            otpValue: e\n        });\n    }\n    disconnectedCallback() {\n        this.onClose();\n    }\n    render() {\n        var e;\n        if (!this.translationsLoaded) return null;\n        const t = null === (e = this.displayOTP) || void 0 === e || e, n = this.sdkVersion, r = (e)=>this.i18nInstance.t(e);\n        return Uf(Np, {\n            className: \"pending-modal\"\n        }, Uf(\"div\", {\n            class: \"backdrop\",\n            onClick: ()=>this.onClose()\n        }), Uf(\"div\", {\n            class: \"modal\"\n        }, Uf(\"div\", {\n            class: \"closeButtonContainer\"\n        }, Uf(\"div\", {\n            class: \"right\"\n        }, Uf(\"span\", {\n            class: \"closeButton\",\n            onClick: ()=>this.onClose()\n        }, Uf(Up, null)))), Uf(\"div\", {\n            class: \"logoContainer\"\n        }, Uf(Hp, null)), Uf(\"div\", null, Uf(\"div\", {\n            class: \"flexContainer\",\n            style: {\n                flexDirection: \"column\",\n                color: \"black\"\n            }\n        }, Uf(\"div\", {\n            class: \"flexItem\",\n            style: {\n                textAlign: \"center\",\n                marginTop: \"30px\",\n                marginBottom: \"30px\",\n                fontSize: \"16px\"\n            }\n        }, r(t ? \"PENDING_MODAL.OPEN_META_MASK_SELECT_CODE\" : \"PENDING_MODAL.OPEN_META_MASK_CONTINUE\")), Uf(\"div\", {\n            id: \"sdk-mm-otp-value\",\n            style: {\n                padding: \"10px\",\n                fontSize: \"32px\",\n                display: this.otpCode ? \"block\" : \"none\"\n            }\n        }, this.otpCode), t && Uf(\"div\", {\n            class: \"notice\"\n        }, \"* \", r(\"PENDING_MODAL.NUMBER_AFTER_OPEN_NOTICE\"))), Uf(\"div\", {\n            style: {\n                marginTop: \"20px\"\n            }\n        }, Uf(\"button\", {\n            class: \"button blue\",\n            style: {\n                marginTop: \"5px\",\n                color: \"#0376C9\",\n                borderColor: \"#0376C9\",\n                borderWidth: \"1px\",\n                borderStyle: \"solid\",\n                backgroundColor: \"white\"\n            },\n            onClick: ()=>this.onDisconnect()\n        }, r(\"PENDING_MODAL.DISCONNECT\")))), Uf(jp, {\n            version: n\n        })));\n    }\n    get el() {\n        return Vf(this);\n    }\n    constructor(e){\n        ff(this, e), this.close = Gf(this, \"close\", 7), this.disconnect = Gf(this, \"disconnect\", 7), this.updateOTPValue = Gf(this, \"updateOTPValue\", 7), this.displayOTP = void 0, this.sdkVersion = void 0, this.otpCode = void 0, this.translationsLoaded = !1, this.i18nInstance = new dg;\n    }\n};\nfg.style = \".flexContainer {\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    flex-direction: row;\\n}\\n\\n.flexItem {\\n    flex: 1;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\\n.flexItem11 {\\n    flex: 11;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\\n.flexItem1 {\\n    flex: 1;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\\n.tab {\\n    padding: 8px;\\n    cursor: pointer;\\n    background-color: #F2F4F6;\\n    font-size: 12px;\\n    text-align: center;\\n    color: #24292E;\\n}\\n\\n.tabcontainer {\\n    padding: 4px;\\n    background-color: #F2F4F6;\\n    border-radius: 8px;\\n    margin-bottom: 30px;\\n    margin-top: 30px;\\n}\\n\\n.tabactive {\\n    background-color: white;\\n    -webkit-transition: background-color 300ms linear;\\n    -ms-transition: background-color 300ms linear;\\n    transition: background-color 300ms linear;\\n    border-radius: 8px;\\n}\\n\\n.item {\\n    font-size: 12px;\\n    margin-bottom: 16px;\\n    border-radius: 8px;\\n    padding: 10px;\\n    border: 2px #F2F4F6 solid;\\n    color: #24292E;\\n}\\n\\n.extensionLabel {\\n    font-style: normal;\\n    font-weight: bold;\\n    font-size: 14px;\\n    text-align: cetner;\\n    color: #24272A;\\n}\\n\\n.notice {\\n    font-size: 12px;\\n    margin-left: 10px;\\n    margin-right: 10px;\\n    color: grey;\\n}\\n\\n.button {\\n    margin-top: 41.5px;\\n    margin-bottom: 20px;\\n    width: 100%;\\n    display: flex;\\n    flex-direction: row;\\n    justify-content: center;\\n    align-items: center;\\n    padding: 12px 20px;\\n    background: #037DD6;\\n    border-radius: 32px;\\n    color: white;\\n    border: 0;\\n    font-size: 14px;\\n    cursor: pointer;\\n}\\n\\n.backdrop {\\n    visibility: visible;\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n    bottom: 0;\\n    width: 100%;\\n    z-index: 99998;\\n    background: rgba(0, 0, 0, 0.87);\\n    opacity: 0.3;\\n}\\n\\n.modal {\\n    visibility: visible;\\n    position: fixed;\\n    left: 50%;\\n    transform: translate(-50%, -50%);\\n    z-index: 99999;\\n    background: white;\\n    padding: 20px;\\n    border-radius: 8px;\\n    top: 50%;\\n    max-width: 100%;\\n    width: 460px;\\n    min-width: 300px;\\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;\\n    -webkit-font-smoothing: antialiased;\\n}\\n\\n.closeButton {\\n    color: #BBC0C5;\\n    cursor: pointer;\\n}\\n\\n.logoContainer {\\n    margin-left: 24px;\\n    margin-right: 24px;\\n    margin-top: 24px;\\n    display: flex;\\n    align-items: center;\\n    justify-content: center;\\n}\\n\\n.connectMobileText {\\n    font-size: 14px;\\n    color: black;\\n    margin-top: 28px;\\n    margin-bottom: 28px;\\n    line-height: 2;\\n}\\n\\n.blue {\\n    color: #037DD6;\\n    font-weight: 700;\\n}\\n\\n.installExtensionText {\\n    margin-left: 10px;\\n}\\n\\n.center {\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\\n.right {\\n    display: flex;\\n    align-items: center;\\n    justify-content: right;\\n}\\n\\n#sdk-mm-qrcode {\\n    svg {\\n        width: 50%;\\n    }\\n}\";\nconst pg = ()=>Uf(\"svg\", {\n        width: \"21\",\n        height: \"15\",\n        viewBox: \"0 0 21 15\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, Uf(\"path\", {\n        d: \"M14.1364 14.9851C13.5909 14.9851 13.2273 14.5851 13.2273 13.9851C13.2273 13.3851 13.5909 12.9851 14.1364 12.9851C16.6818 12.9851 18.6818 10.7851 18.6818 7.98508C18.6818 5.18508 16.6818 2.98508 14.1364 2.98508C11.5909 2.98508 9.59091 5.18508 9.59091 7.98508C9.59091 8.58508 9.22727 8.98508 8.68182 8.98508C8.13636 8.98508 7.77273 8.58508 7.77273 7.98508C7.77273 4.08508 10.5909 0.985077 14.1364 0.985077C17.6818 0.985077 20.5 4.08508 20.5 7.98508C20.5 11.8851 17.6818 14.9851 14.1364 14.9851ZM6.68182 14.7851C3.22727 14.7851 0.5 11.6851 0.5 7.98508C0.5 4.28508 3.22727 1.18508 6.68182 1.18508C7.22727 1.18508 7.59091 1.58508 7.59091 2.18508C7.59091 2.78508 7.22727 3.18508 6.68182 3.18508C4.22727 3.18508 2.31818 5.38508 2.31818 7.98508C2.31818 10.5851 4.22727 12.7851 6.68182 12.7851C9.13636 12.7851 11.0455 10.6851 11.0455 7.98508C11.0455 7.38508 11.4091 6.98508 11.9545 6.98508C12.5 6.98508 12.8636 7.38508 12.8636 7.98508C12.7727 11.6851 10.0455 14.7851 6.68182 14.7851Z\",\n        fill: \"white\"\n    })), gg = ()=>Uf(\"svg\", {\n        width: \"400\",\n        height: \"300\",\n        viewBox: \"0 0 400 300\",\n        fill: \"none\",\n        xmlns: \"http://www.w3.org/2000/svg\"\n    }, Uf(\"rect\", {\n        width: \"400\",\n        height: \"300\",\n        fill: \"white\"\n    }), Uf(\"path\", {\n        d: \"M300.116 242.46L250.485 227.681L213.057 250.055L186.944 250.045L149.493 227.681L99.8843 242.46L84.7939 191.518L99.8843 134.979L84.7939 87.1777L99.8843 27.9336L177.402 74.2466H222.598L300.116 27.9336L315.206 87.1777L300.116 134.979L315.206 191.518L300.116 242.46Z\",\n        fill: \"#FF5C16\"\n    }), Uf(\"path\", {\n        d: \"M99.8955 27.9336L177.414 74.2792L174.331 106.085L99.8955 27.9336Z\",\n        fill: \"#FF5C16\"\n    }), Uf(\"path\", {\n        d: \"M149.505 191.539L183.612 217.521L149.505 227.681V191.539Z\",\n        fill: \"#FF5C16\"\n    }), Uf(\"path\", {\n        d: \"M180.886 148.585L174.33 106.107L132.369 134.991L132.348 134.98V135.001L132.477 164.732L149.493 148.585H149.504H180.886Z\",\n        fill: \"#FF5C16\"\n    }), Uf(\"path\", {\n        d: \"M300.116 27.9336L222.598 74.2792L225.67 106.085L300.116 27.9336Z\",\n        fill: \"#FF5C16\"\n    }), Uf(\"path\", {\n        d: \"M250.508 191.539L216.4 217.521L250.508 227.681V191.539Z\",\n        fill: \"#FF5C16\"\n    }), Uf(\"path\", {\n        d: \"M267.652 135.001H267.663H267.652V134.98L267.641 134.991L225.68 106.107L219.125 148.585H250.507L267.533 164.732L267.652 135.001Z\",\n        fill: \"#FF5C16\"\n    }), Uf(\"path\", {\n        d: \"M149.493 227.681L99.8843 242.46L84.7939 191.54H149.493V227.681Z\",\n        fill: \"#E34807\"\n    }), Uf(\"path\", {\n        d: \"M180.875 148.574L190.351 209.98L177.219 175.838L132.456 164.732L149.483 148.574H180.864H180.875Z\",\n        fill: \"#E34807\"\n    }), Uf(\"path\", {\n        d: \"M250.507 227.681L300.116 242.46L315.206 191.54H250.507V227.681Z\",\n        fill: \"#E34807\"\n    }), Uf(\"path\", {\n        d: \"M219.126 148.574L209.649 209.98L222.782 175.838L267.545 164.732L250.507 148.574H219.126Z\",\n        fill: \"#E34807\"\n    }), Uf(\"path\", {\n        d: \"M84.7939 191.517L99.8843 134.979H132.337L132.456 164.721L177.219 175.826L190.351 209.969L183.601 217.488L149.493 191.506H84.7939V191.517Z\",\n        fill: \"#FF8D5D\"\n    }), Uf(\"path\", {\n        d: \"M315.206 191.517L300.116 134.979H267.664L267.545 164.721L222.782 175.826L209.649 209.969L216.4 217.488L250.507 191.506H315.206V191.517Z\",\n        fill: \"#FF8D5D\"\n    }), Uf(\"path\", {\n        d: \"M222.598 74.2466H200H177.402L174.33 106.053L190.351 209.936H209.649L225.681 106.053L222.598 74.2466Z\",\n        fill: \"#FF8D5D\"\n    }), Uf(\"path\", {\n        d: \"M99.8843 27.9336L84.7939 87.1777L99.8843 134.979H132.337L174.319 106.085L99.8843 27.9336Z\",\n        fill: \"#661800\"\n    }), Uf(\"path\", {\n        d: \"M171.496 160.906H156.795L148.79 168.752L177.229 175.804L171.496 160.896V160.906Z\",\n        fill: \"#661800\"\n    }), Uf(\"path\", {\n        d: \"M300.116 27.9336L315.206 87.1777L300.116 134.979H267.663L225.681 106.085L300.116 27.9336Z\",\n        fill: \"#661800\"\n    }), Uf(\"path\", {\n        d: \"M228.525 160.906H243.248L251.253 168.763L222.781 175.826L228.525 160.896V160.906Z\",\n        fill: \"#661800\"\n    }), Uf(\"path\", {\n        d: \"M213.046 229.789L216.399 217.51L209.649 209.991H190.34L183.59 217.51L186.943 229.789\",\n        fill: \"#661800\"\n    }), Uf(\"path\", {\n        d: \"M213.047 229.789V250.066H186.944V229.789H213.047Z\",\n        fill: \"#C0C4CD\"\n    }), Uf(\"path\", {\n        d: \"M149.504 227.66L186.965 250.056V229.779L183.611 217.5L149.504 227.66Z\",\n        fill: \"#E7EBF6\"\n    }), Uf(\"path\", {\n        d: \"M250.506 227.66L213.045 250.056V229.779L216.398 217.5L250.506 227.66Z\",\n        fill: \"#E7EBF6\"\n    })), mg = class {\n    async connectedCallback() {\n        await this.i18nInstance.init({\n            fallbackLng: \"en\"\n        }), this.translationsLoaded = !0;\n    }\n    onClose() {\n        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;\n        this.close.emit({\n            shouldTerminate: e\n        });\n    }\n    connectWithExtensionHandler() {\n        this.connectWithExtension.emit();\n    }\n    setTab(e) {\n        this.tab = e, this.isDefaultTab = !1;\n    }\n    disconnectedCallback() {\n        this.onClose();\n    }\n    updatePreferDesktop(e) {\n        e ? this.setTab(1) : this.setTab(2);\n    }\n    render() {\n        if (!this.translationsLoaded) return null;\n        const e = (e)=>this.i18nInstance.t(e), t = this.sdkVersion, n = this.isDefaultTab ? this.preferDesktop ? 1 : 2 : this.tab, r = cg(this.link, \"svg\", {\n            ecc: \"medium\",\n            scale: 2\n        });\n        return Uf(Np, {\n            className: \"select-modal\"\n        }, Uf(\"div\", {\n            class: \"backdrop\",\n            onClick: ()=>this.onClose(!0)\n        }), Uf(\"div\", {\n            class: \"modal\"\n        }, Uf(\"div\", {\n            class: \"closeButtonContainer\"\n        }, Uf(\"div\", {\n            class: \"right\"\n        }, Uf(\"span\", {\n            class: \"closeButton\",\n            onClick: ()=>this.onClose(!0)\n        }, Uf(Up, null)))), Uf(\"div\", {\n            class: \"logoContainer\"\n        }, Uf(Hp, null)), Uf(\"div\", null, Uf(\"div\", {\n            class: \"tabcontainer\"\n        }, Uf(\"div\", {\n            class: \"flexContainer\"\n        }, Uf(\"div\", {\n            onClick: ()=>this.setTab(1),\n            class: \"tab flexItem \" + (1 === n ? \"tabactive\" : \"\")\n        }, e(\"DESKTOP\")), Uf(\"div\", {\n            onClick: ()=>this.setTab(2),\n            class: \"tab flexItem \" + (2 === n ? \"tabactive\" : \"\")\n        }, e(\"MOBILE\")))), Uf(\"div\", {\n            style: {\n                display: 1 === n ? \"none\" : \"block\"\n            }\n        }, Uf(\"div\", {\n            class: \"flexContainer\"\n        }, Uf(\"div\", {\n            class: \"flexItem\",\n            style: {\n                textAlign: \"center\",\n                marginTop: \"4\"\n            }\n        }, Uf(\"div\", {\n            class: \"center\",\n            id: \"sdk-mm-qrcode\",\n            innerHTML: r\n        }), Uf(\"div\", {\n            class: \"connectMobileText\"\n        }, e(\"SCAN_TO_CONNECT\"), Uf(\"br\", null), Uf(\"span\", {\n            class: \"blue\"\n        }, Uf(\"b\", null, e(\"META_MASK_MOBILE_APP\"))))))), Uf(\"div\", {\n            style: {\n                display: 2 === n ? \"none\" : \"block\"\n            }\n        }, Uf(\"div\", {\n            style: {\n                display: \"flex\",\n                justifyContent: \"center\",\n                height: \"300\",\n                marginTop: \"-20\"\n            }\n        }, Uf(gg, null)), Uf(\"div\", {\n            class: \"extensionLabel\"\n        }, e(\"SELECT_MODAL.CRYPTO_TAKE_CONTROL_TEXT\")), Uf(\"button\", {\n            class: \"button\",\n            onClick: ()=>this.connectWithExtensionHandler()\n        }, Uf(pg, null), Uf(\"span\", {\n            class: \"installExtensionText\"\n        }, e(\"CONNECT_WITH_EXTENSION\"))))), Uf(jp, {\n            version: t\n        })));\n    }\n    get el() {\n        return Vf(this);\n    }\n    static get watchers() {\n        return {\n            preferDesktop: [\n                \"updatePreferDesktop\"\n            ]\n        };\n    }\n    constructor(e){\n        ff(this, e), this.close = Gf(this, \"close\", 7), this.connectWithExtension = Gf(this, \"connectWithExtension\", 7), this.link = void 0, this.sdkVersion = void 0, this.preferDesktop = void 0, this.tab = 1, this.isDefaultTab = !0, this.translationsLoaded = !1, this.i18nInstance = new dg, this.setTab(this.preferDesktop ? 1 : 2);\n    }\n};\nmg.style = \".flexContainer {\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n    flex-direction: row;\\n}\\n\\n.flexItem {\\n    flex: 1;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\\n.flexItem11 {\\n    flex: 11;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\\n.flexItem1 {\\n    flex: 1;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\\n.tab {\\n    padding: 8px;\\n    cursor: pointer;\\n    background-color: #F2F4F6;\\n    font-size: 12px;\\n    text-align: center;\\n    color: #24292E;\\n}\\n\\n.tabcontainer {\\n    padding: 4px;\\n    background-color: #F2F4F6;\\n    border-radius: 8px;\\n    margin-bottom: 30px;\\n    margin-top: 30px;\\n}\\n\\n.tabactive {\\n    background-color: white;\\n    -webkit-transition: background-color 300ms linear;\\n    -ms-transition: background-color 300ms linear;\\n    transition: background-color 300ms linear;\\n    border-radius: 8px;\\n}\\n\\n.item {\\n    font-size: 12px;\\n    margin-bottom: 16px;\\n    border-radius: 8px;\\n    padding: 10px;\\n    border: 2px #F2F4F6 solid;\\n    color: #24292E;\\n}\\n\\n.extensionLabel {\\n    font-style: normal;\\n    font-weight: bold;\\n    font-size: 14px;\\n    text-align: cetner;\\n    color: #24272A;\\n}\\n\\n.notice {\\n    font-size: 12px;\\n    margin-left: 10px;\\n    margin-right: 10px;\\n    color: grey;\\n}\\n\\n.button {\\n    margin-top: 41.5px;\\n    margin-bottom: 20px;\\n    width: 100%;\\n    display: flex;\\n    flex-direction: row;\\n    justify-content: center;\\n    align-items: center;\\n    padding: 12px 20px;\\n    background: #037DD6;\\n    border-radius: 32px;\\n    color: white;\\n    border: 0;\\n    font-size: 14px;\\n    cursor: pointer;\\n}\\n\\n.backdrop {\\n    visibility: visible;\\n    position: fixed;\\n    top: 0;\\n    left: 0;\\n    right: 0;\\n    bottom: 0;\\n    width: 100%;\\n    z-index: 99998;\\n    background: rgba(0, 0, 0, 0.87);\\n    opacity: 0.3;\\n}\\n\\n.modal {\\n    visibility: visible;\\n    position: fixed;\\n    left: 50%;\\n    transform: translate(-50%, -50%);\\n    z-index: 99999;\\n    background: white;\\n    padding: 20px;\\n    border-radius: 8px;\\n    top: 50%;\\n    max-width: 100%;\\n    width: 460px;\\n    min-width: 300px;\\n    box-shadow: rgba(0, 0, 0, 0.2) 0px 11px 15px -7px, rgba(0, 0, 0, 0.14) 0px 24px 38px 3px, rgba(0, 0, 0, 0.12) 0px 9px 46px 8px;\\n    -webkit-font-smoothing: antialiased;\\n}\\n\\n.closeButton {\\n    color: #BBC0C5;\\n    cursor: pointer;\\n}\\n\\n.logoContainer {\\n    margin-left: 24px;\\n    margin-right: 24px;\\n    margin-top: 24px;\\n    display: flex;\\n    align-items: center;\\n    justify-content: center;\\n}\\n\\n.connectMobileText {\\n    font-size: 14px;\\n    color: black;\\n    margin-top: 28px;\\n    margin-bottom: 28px;\\n    line-height: 2;\\n}\\n\\n.blue {\\n    color: #037DD6;\\n    font-weight: 700;\\n}\\n\\n.installExtensionText {\\n    margin-left: 10px;\\n}\\n\\n.center {\\n    display: flex;\\n    justify-content: center;\\n    align-items: center;\\n}\\n\\n.right {\\n    display: flex;\\n    align-items: center;\\n    justify-content: right;\\n}\\n\\n#sdk-mm-qrcode {\\n    svg {\\n        width: 50%;\\n    }\\n}\";\nvar yg = Object.freeze({\n    __proto__: null,\n    mm_install_modal: hg,\n    mm_pending_modal: fg,\n    mm_select_modal: mg\n});\n //# sourceMappingURL=metamask-sdk.js.map\nvar _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10, _c11, _c12, _c13, _c14, _c15, _c16, _c17, _c18, _c19, _c20, _c21, _c22, _c23, _c24, _c25, _c26, _c27, _c28, _c29, _c30, _c31, _c32, _c33, _c34, _c35, _c36, _c37, _c38, _c39, _c40, _c41, _c42, _c43, _c44, _c45, _c46, _c47, _c48, _c49, _c50, _c51, _c52, _c53, _c54, _c55, _c56, _c57, _c58, _c59, _c60, _c61, _c62, _c63, _c64, _c65, _c66, _c67, _c68, _c69, _c70, _c71, _c72, _c73, _c74, _c75, _c76, _c77, _c78, _c79, _c80, _c81, _c82, _c83, _c84, _c85, _c86, _c87, _c88, _c89, _c90, _c91, _c92, _c93, _c94, _c95, _c96, _c97, _c98, _c99, _c100, _c101, _c102, _c103, _c104, _c105, _c106, _c107, _c108, _c109, _c110, _c111, _c112, _c113, _c114, _c115, _c116, _c117, _c118, _c119, _c120, _c121, _c122, _c123, _c124, _c125, _c126, _c127, _c128, _c129, _c130, _c131, _c132, _c133, _c134, _c135, _c136, _c137, _c138, _c139, _c140, _c141, _c142, _c143, _c144, _c145, _c146, _c147, _c148, _c149, _c150, _c151, _c152, _c153, _c154, _c155;\n$RefreshReg$(_c1, \"S\");\n$RefreshReg$(_c2, \"C\");\n$RefreshReg$(_c3, \"A\");\n$RefreshReg$(_c4, \"M\");\n$RefreshReg$(_c5, \"I\");\n$RefreshReg$(_c6, \"T\");\n$RefreshReg$(_c7, \"R\");\n$RefreshReg$(_c8, \"P\");\n$RefreshReg$(_c9, \"O\");\n$RefreshReg$(_c10, \"N\");\n$RefreshReg$(_c11, \"L\");\n$RefreshReg$(_c12, \"D\");\n$RefreshReg$(_c13, \"B\");\n$RefreshReg$(_c14, \"K\");\n$RefreshReg$(_c15, \"U\");\n$RefreshReg$(_c16, \"H\");\n$RefreshReg$(_c17, \"F\");\n$RefreshReg$(_c18, \"W\");\n$RefreshReg$(_c19, \"V\");\n$RefreshReg$(_c20, \"G\");\n$RefreshReg$(_c21, \"Y\");\n$RefreshReg$(_c22, \"Z\");\n$RefreshReg$(_c23, \"J\");\n$RefreshReg$(_c24, \"Q\");\n$RefreshReg$(_c25, \"X\");\n$RefreshReg$(_c26, \"Ee\");\n$RefreshReg$(_c27, \"Se\");\n$RefreshReg$(_c28, \"De\");\n$RefreshReg$(_c29, \"Be\");\n$RefreshReg$(_c30, \"Ke\");\n$RefreshReg$(_c31, \"Ue\");\n$RefreshReg$(_c32, \"He\");\n$RefreshReg$(_c33, \"Je\");\n$RefreshReg$(_c34, \"Qe\");\n$RefreshReg$(_c35, \"Xe\");\n$RefreshReg$(_c36, \"Bt\");\n$RefreshReg$(_c37, \"Kt\");\n$RefreshReg$(_c38, \"Ut\");\n$RefreshReg$(_c39, \"Ht\");\n$RefreshReg$(_c40, \"Ft\");\n$RefreshReg$(_c41, \"Wt\");\n$RefreshReg$(_c42, \"Vt\");\n$RefreshReg$(_c43, \"Gt\");\n$RefreshReg$(_c44, \"Yt\");\n$RefreshReg$(_c45, \"Zt\");\n$RefreshReg$(_c46, \"Un\");\n$RefreshReg$(_c47, \"Hn\");\n$RefreshReg$(_c48, \"Fn\");\n$RefreshReg$(_c49, \"Sr\");\n$RefreshReg$(_c50, \"Or\");\n$RefreshReg$(_c51, \"Dr\");\n$RefreshReg$(_c52, \"Fr\");\n$RefreshReg$(_c53, \"Zr\");\n$RefreshReg$(_c54, \"Pi\");\n$RefreshReg$(_c55, \"Hi\");\n$RefreshReg$(_c56, \"Oo\");\n$RefreshReg$(_c57, \"Bo\");\n$RefreshReg$(_c58, \"Fo\");\n$RefreshReg$(_c59, \"Wo\");\n$RefreshReg$(_c60, \"Vo\");\n$RefreshReg$(_c61, \"Go\");\n$RefreshReg$(_c62, \"Yo\");\n$RefreshReg$(_c63, \"Zo\");\n$RefreshReg$(_c64, \"Jo\");\n$RefreshReg$(_c65, \"Qo\");\n$RefreshReg$(_c66, \"Xo\");\n$RefreshReg$(_c67, \"Es\");\n$RefreshReg$(_c68, \"Ss\");\n$RefreshReg$(_c69, \"As\");\n$RefreshReg$(_c70, \"Ms\");\n$RefreshReg$(_c71, \"Is\");\n$RefreshReg$(_c72, \"Ts\");\n$RefreshReg$(_c73, \"Rs\");\n$RefreshReg$(_c74, \"Ps\");\n$RefreshReg$(_c75, \"Os\");\n$RefreshReg$(_c76, \"Ns\");\n$RefreshReg$(_c77, \"Ls\");\n$RefreshReg$(_c78, \"Ds\");\n$RefreshReg$(_c79, \"Bs\");\n$RefreshReg$(_c80, \"Ks\");\n$RefreshReg$(_c81, \"Hs\");\n$RefreshReg$(_c82, \"Fs\");\n$RefreshReg$(_c83, \"Ws\");\n$RefreshReg$(_c84, \"Js\");\n$RefreshReg$(_c85, \"Qs\");\n$RefreshReg$(_c86, \"Xs\");\n$RefreshReg$(_c87, \"Ma\");\n$RefreshReg$(_c88, \"Oa\");\n$RefreshReg$(_c89, \"Na\");\n$RefreshReg$(_c90, \"La\");\n$RefreshReg$(_c91, \"Da\");\n$RefreshReg$(_c92, \"Ha\");\n$RefreshReg$(_c93, \"Fa\");\n$RefreshReg$(_c94, \"Wa\");\n$RefreshReg$(_c95, \"Va\");\n$RefreshReg$(_c96, \"Ga\");\n$RefreshReg$(_c97, \"Ya\");\n$RefreshReg$(_c98, \"Qa\");\n$RefreshReg$(_c99, \"Xa\");\n$RefreshReg$(_c100, \"Lc\");\n$RefreshReg$(_c101, \"Bc\");\n$RefreshReg$(_c102, \"Hc\");\n$RefreshReg$(_c103, \"Fc\");\n$RefreshReg$(_c104, \"Zc\");\n$RefreshReg$(_c105, \"El\");\n$RefreshReg$(_c106, \"Sl\");\n$RefreshReg$(_c107, \"Cl\");\n$RefreshReg$(_c108, \"Al\");\n$RefreshReg$(_c109, \"Ml\");\n$RefreshReg$(_c110, \"Il\");\n$RefreshReg$(_c111, \"Tl\");\n$RefreshReg$(_c112, \"Rl\");\n$RefreshReg$(_c113, \"Pl\");\n$RefreshReg$(_c114, \"Ol\");\n$RefreshReg$(_c115, \"Nl\");\n$RefreshReg$(_c116, \"Ll\");\n$RefreshReg$(_c117, \"Dl\");\n$RefreshReg$(_c118, \"Kl\");\n$RefreshReg$(_c119, \"Ul\");\n$RefreshReg$(_c120, \"Fl\");\n$RefreshReg$(_c121, \"Zl\");\n$RefreshReg$(_c122, \"Jl\");\n$RefreshReg$(_c123, \"Ql\");\n$RefreshReg$(_c124, \"Xl\");\n$RefreshReg$(_c125, \"Ed\");\n$RefreshReg$(_c126, \"Cd\");\n$RefreshReg$(_c127, \"Pd\");\n$RefreshReg$(_c128, \"Od\");\n$RefreshReg$(_c129, \"Ud\");\n$RefreshReg$(_c130, \"Hd\");\n$RefreshReg$(_c131, \"Fd\");\n$RefreshReg$(_c132, \"Gd\");\n$RefreshReg$(_c133, \"Qd\");\n$RefreshReg$(_c134, \"Xd\");\n$RefreshReg$(_c135, \"Eu\");\n$RefreshReg$(_c136, \"Pu\");\n$RefreshReg$(_c137, \"Ku\");\n$RefreshReg$(_c138, \"Uu\");\n$RefreshReg$(_c139, \"Vu\");\n$RefreshReg$(_c140, \"Sh\");\n$RefreshReg$(_c141, \"Rh\");\n$RefreshReg$(_c142, \"Ph\");\n$RefreshReg$(_c143, \"Oh\");\n$RefreshReg$(_c144, \"Nh\");\n$RefreshReg$(_c145, \"Lh\");\n$RefreshReg$(_c146, \"Zh\");\n$RefreshReg$(_c147, \"Jh\");\n$RefreshReg$(_c148, \"Qh\");\n$RefreshReg$(_c149, \"Xh\");\n$RefreshReg$(_c150, \"Of\");\n$RefreshReg$(_c151, \"Df\");\n$RefreshReg$(_c152, \"Fp\");\n$RefreshReg$(_c153, \"Wp\");\n$RefreshReg$(_c154, \"Vp\");\n$RefreshReg$(_c155, \"Gp\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc2RrL2Rpc3QvYnJvd3Nlci9lcy9tZXRhbWFzay1zZGsuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVNBLFNB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SUFBQUEsT0FBQUEsSUFBQUEsQ0FBQUEsSUFBQUEsSUFBQUEsQ0FBQUEsR0FBQUEsSUFBQUEsR0FBQUEsSUFBQUEsRUFBQUEsTUFBQUEsRUFBQUEsSUFBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsR0FBQUEsT0FBQUEsd0JBQUFBLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLEVBQUFBO0lBQUFBLE9BQUFBO0FBQUFBLEdBQUFBLEtBQUFBO0FBQUFBLFNBQUFBLEdBQUFBLENBQUFBO0lBQUFBLElBQUFBLENBQUFBLEdBQUFBLElBQUFBO1FBQUFBLElBQUFBLElBQUFBLElBQUFBLEVBQUFBLEVBQUFBLElBQUFBLEdBQUFBLElBQUFBLFVBQUFBLE1BQUFBLEVBQUFBLElBQUFBLEVBQUFBLElBQUFBLENBQUFBLEdBQUFBLFNBQUFBLENBQUFBLEVBQUFBO1FBQUFBLE9BQUFBLEVBQUFBLElBQUFBLENBQUFBO0lBQUFBO0lBQUFBLElBQUFBO0lBQUFBLElBQUFBLElBQUFBLElBQUFBLFdBQUFBLElBQUFBLEVBQUFBLE1BQUFBLEVBQUFBLElBQUFBLE9BQUFBLEdBQUFBLE9BQUFBLENBQUFBLElBQUFBLFNBQUFBLENBQUFBO1FBQUFBLElBQUFBLFNBQUFBLEdBQUFBLE9BQUFBO1FBQUFBLElBQUFBLEtBQUFBLEdBQUFBLE9BQUFBO1FBQUFBLE9BQUFBO1lBQUFBLEtBQUFBO2dCQUFBQSxPQUFBQSxPQUFBQSxDQUFBQSxDQUFBQSxJQUFBQTtZQUFBQSxLQUFBQTtnQkFBQUEsT0FBQUEsT0FBQUEsQ0FBQUEsQ0FBQUEsSUFBQUE7WUFBQUEsS0FBQUE7Z0JBQUFBLElBQUFBO29CQUFBQSxPQUFBQSxLQUFBQSxTQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxJQUFBQTtnQkFBQUEsRUFBQUEsT0FBQUEsR0FBQUE7b0JBQUFBLE9BQUFBO2dCQUFBQTtZQUFBQTtnQkFBQUEsT0FBQUE7UUFBQUE7SUFBQUEsSUFBQUEsSUFBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsRUFBQUEsSUFBQUEsR0FBQUEsSUFBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsR0FBQUEsTUFBQUEsQ0FBQUEsR0FBQUEsS0FBQUEsS0FBQUEsTUFBQUEsSUFBQUEsS0FBQUEsTUFBQUEsR0FBQUE7SUFBQUEsT0FBQUE7QUFBQUE7QUFBQUEsU0FBQUEsR0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUE7SUFBQUEsSUFBQUEsR0FBQUEsRUFBQUEsT0FBQUEsR0FBQUEsT0FBQUE7UUFBQUEsT0FBQUEsR0FBQUEsR0FBQUEsR0FBQUEsS0FBQUEsQ0FBQUEsSUFBQUEsRUFBQUE7SUFBQUE7SUFBQUEsSUFBQUEsQ0FBQUEsTUFBQUEsR0FBQUEsYUFBQUEsRUFBQUEsT0FBQUE7SUFBQUEsSUFBQUEsSUFBQUEsQ0FBQUE7SUFBQUEsT0FBQUE7UUFBQUEsSUFBQUEsQ0FBQUEsR0FBQUE7WUFBQUEsSUFBQUEsR0FBQUEsZ0JBQUFBLEVBQUFBLE1BQUFBLElBQUFBLE1BQUFBO1lBQUFBLEdBQUFBLGdCQUFBQSxHQUFBQSxRQUFBQSxLQUFBQSxDQUFBQSxLQUFBQSxRQUFBQSxLQUFBQSxDQUFBQSxJQUFBQSxJQUFBQSxDQUFBQTtRQUFBQTtRQUFBQSxPQUFBQSxFQUFBQSxLQUFBQSxDQUFBQSxJQUFBQSxFQUFBQTtJQUFBQTtBQUFBQTtBQUFBQSxJQUFBQSxJQUFBQSxLQUFBQSxDQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxJQUFBQSxHQUFBQSxPQUFBQSxDQUFBQSxLQUFBQSxHQUFBQSxHQUFBQSxDQUFBQSxVQUFBQSxJQUFBQSxFQUFBQSxHQUFBQSxJQUFBQSxFQUFBQSxXQUFBQSxJQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxFQUFBQSxJQUFBQSxJQUFBQSxPQUFBQSxRQUFBQSxJQUFBQSxPQUFBQSxLQUFBQSxJQUFBQSxDQUFBQSxLQUFBQTtRQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxHQUFBQTtZQUFBQSxJQUFBQSxJQUFBQSxHQUFBQSxLQUFBQSxDQUFBQSxNQUFBQTtZQUFBQSxRQUFBQSxLQUFBQSxDQUFBQSxhQUFBQSxHQUFBQSxHQUFBQTtRQUFBQTtJQUFBQSxPQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxHQUFBQSxZQUFBQTtJQUFBQSxPQUFBQSxFQUFBQSxDQUFBQSxFQUFBQTtBQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQSxFQUFBQSxDQUFBQTtJQUFBQSxJQUFBQSxJQUFBQTtRQUFBQSxNQUFBQSxFQUFBQTtRQUFBQSxTQUFBQTtJQUFBQTtJQUFBQSxPQUFBQSxVQUFBQSxNQUFBQSxJQUFBQSxLQUFBQSxDQUFBQSxFQUFBQSxLQUFBQSxHQUFBQSxTQUFBQSxDQUFBQSxFQUFBQSxHQUFBQSxVQUFBQSxNQUFBQSxJQUFBQSxLQUFBQSxDQUFBQSxFQUFBQSxNQUFBQSxHQUFBQSxTQUFBQSxDQUFBQSxFQUFBQSxHQUFBQSxHQUFBQSxLQUFBQSxFQUFBQSxVQUFBQSxHQUFBQSxJQUFBQSxLQUFBQSxHQUFBQSxHQUFBQSxJQUFBQSxHQUFBQSxFQUFBQSxVQUFBQSxLQUFBQSxDQUFBQSxFQUFBQSxVQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxHQUFBQSxFQUFBQSxLQUFBQSxLQUFBQSxDQUFBQSxFQUFBQSxLQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxHQUFBQSxFQUFBQSxNQUFBQSxLQUFBQSxDQUFBQSxFQUFBQSxNQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxHQUFBQSxFQUFBQSxhQUFBQSxLQUFBQSxDQUFBQSxFQUFBQSxhQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxFQUFBQSxNQUFBQSxJQUFBQSxDQUFBQSxFQUFBQSxPQUFBQSxHQUFBQSxFQUFBQSxHQUFBQSxHQUFBQSxHQUFBQSxHQUFBQSxFQUFBQSxLQUFBQTtBQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQSxFQUFBQSxDQUFBQTtJQUFBQSxJQUFBQSxJQUFBQSxHQUFBQSxNQUFBQSxDQUFBQSxFQUFBQTtJQUFBQSxPQUFBQSxJQUFBQSxPQUFBQSxHQUFBQSxNQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxHQUFBQSxNQUFBQSxJQUFBQSxPQUFBQSxHQUFBQSxNQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxHQUFBQSxNQUFBQTtBQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQSxFQUFBQSxDQUFBQTtJQUFBQSxPQUFBQTtBQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxDQUFBQTtJQUFBQSxJQUFBQSxFQUFBQSxhQUFBQSxJQUFBQSxLQUFBQSxHQUFBQSxFQUFBQSxPQUFBQSxLQUFBQSxFQUFBQSxPQUFBQSxLQUFBQSxNQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxXQUFBQSxJQUFBQSxFQUFBQSxXQUFBQSxDQUFBQSxTQUFBQSxLQUFBQSxDQUFBQSxHQUFBQTtRQUFBQSxJQUFBQSxJQUFBQSxFQUFBQSxPQUFBQSxDQUFBQSxHQUFBQTtRQUFBQSxPQUFBQSxHQUFBQSxNQUFBQSxDQUFBQSxJQUFBQSxHQUFBQSxHQUFBQSxHQUFBQSxFQUFBQSxHQUFBQTtJQUFBQTtJQUFBQSxJQUFBQSxJQUFBQSxTQUFBQSxDQUFBQSxFQUFBQSxDQUFBQTtRQUFBQSxJQUFBQSxHQUFBQSxJQUFBQSxPQUFBQSxFQUFBQSxPQUFBQSxDQUFBQSxhQUFBQTtRQUFBQSxJQUFBQSxHQUFBQSxJQUFBQTtZQUFBQSxJQUFBQSxJQUFBQSxNQUFBQSxLQUFBQSxTQUFBQSxDQUFBQSxHQUFBQSxPQUFBQSxDQUFBQSxVQUFBQSxJQUFBQSxPQUFBQSxDQUFBQSxNQUFBQSxPQUFBQSxPQUFBQSxDQUFBQSxRQUFBQSxPQUFBQTtZQUFBQSxPQUFBQSxFQUFBQSxPQUFBQSxDQUFBQSxHQUFBQTtRQUFBQTtRQUFBQSxJQUFBQSxHQUFBQSxJQUFBQSxPQUFBQSxFQUFBQSxPQUFBQSxDQUFBQSxLQUFBQSxHQUFBQTtRQUFBQSxJQUFBQSxHQUFBQSxJQUFBQSxPQUFBQSxFQUFBQSxPQUFBQSxDQUFBQSxLQUFBQSxHQUFBQTtRQUFBQSxJQUFBQSxHQUFBQSxJQUFBQSxPQUFBQSxFQUFBQSxPQUFBQSxDQUFBQSxRQUFBQTtJQUFBQSxFQUFBQSxHQUFBQTtJQUFBQSxJQUFBQSxHQUFBQSxPQUFBQTtJQUFBQSxJQUFBQSxJQUFBQSxPQUFBQSxJQUFBQSxDQUFBQSxJQUFBQSxJQUFBQSxTQUFBQSxDQUFBQTtRQUFBQSxJQUFBQSxJQUFBQSxDQUFBQTtRQUFBQSxPQUFBQSxFQUFBQSxPQUFBQSxDQUFBQSxTQUFBQSxDQUFBQSxFQUFBQSxDQUFBQTtZQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxHQUFBQSxDQUFBQTtRQUFBQSxJQUFBQTtJQUFBQSxFQUFBQTtJQUFBQSxJQUFBQSxFQUFBQSxVQUFBQSxJQUFBQSxDQUFBQSxJQUFBQSxPQUFBQSxtQkFBQUEsQ0FBQUEsRUFBQUEsR0FBQUEsR0FBQUEsTUFBQUEsQ0FBQUEsRUFBQUEsT0FBQUEsQ0FBQUEsY0FBQUEsS0FBQUEsRUFBQUEsT0FBQUEsQ0FBQUEsa0JBQUFBLENBQUFBLEdBQUFBLE9BQUFBLEdBQUFBO0lBQUFBLElBQUFBLE1BQUFBLEVBQUFBLE1BQUFBLEVBQUFBO1FBQUFBLElBQUFBLEdBQUFBLElBQUFBO1lBQUFBLElBQUFBLElBQUFBLEVBQUFBLElBQUFBLEdBQUFBLE9BQUFBLEVBQUFBLElBQUFBLEdBQUFBO1lBQUFBLE9BQUFBLEVBQUFBLE9BQUFBLENBQUFBLGNBQUFBLElBQUFBLEtBQUFBO1FBQUFBO1FBQUFBLElBQUFBLEdBQUFBLElBQUFBLE9BQUFBLEVBQUFBLE9BQUFBLENBQUFBLE9BQUFBLFNBQUFBLENBQUFBLFFBQUFBLENBQUFBLElBQUFBLENBQUFBLElBQUFBO1FBQUFBLElBQUFBLEdBQUFBLElBQUFBLE9BQUFBLEVBQUFBLE9BQUFBLENBQUFBLEtBQUFBLFNBQUFBLENBQUFBLFFBQUFBLENBQUFBLElBQUFBLENBQUFBLElBQUFBO1FBQUFBLElBQUFBLEdBQUFBLElBQUFBLE9BQUFBLEdBQUFBO0lBQUFBO0lBQUFBLElBQUFBLEdBQUFBLElBQUFBLElBQUFBLElBQUFBLENBQUFBLEdBQUFBLElBQUFBO1FBQUFBO1FBQUFBO0tBQUFBO0lBQUFBLENBQUFBLEdBQUFBLE1BQUFBLENBQUFBLElBQUFBLENBQUFBLEdBQUFBLElBQUFBO1FBQUFBO1FBQUFBO0tBQUFBLEdBQUFBLEdBQUFBLEVBQUFBLEtBQUFBLENBQUFBLElBQUFBLGVBQUFBLENBQUFBLEVBQUFBLElBQUFBLEdBQUFBLE9BQUFBLEVBQUFBLElBQUFBLEdBQUFBLEVBQUFBLElBQUFBLEdBQUFBO0lBQUFBLE9BQUFBLEdBQUFBLE1BQUFBLENBQUFBLElBQUFBLE1BQUFBLE9BQUFBLFNBQUFBLENBQUFBLFFBQUFBLENBQUFBLElBQUFBLENBQUFBLEVBQUFBLEdBQUFBLEdBQUFBLE1BQUFBLENBQUFBLElBQUFBLE1BQUFBLEtBQUFBLFNBQUFBLENBQUFBLFdBQUFBLENBQUFBLElBQUFBLENBQUFBLEVBQUFBLEdBQUFBLEdBQUFBLE1BQUFBLENBQUFBLElBQUFBLE1BQUFBLEdBQUFBLEVBQUFBLEdBQUFBLE1BQUFBLEVBQUFBLE1BQUFBLElBQUFBLEtBQUFBLEtBQUFBLEVBQUFBLE1BQUFBLEdBQUFBLElBQUFBLElBQUFBLEdBQUFBLEtBQUFBLEVBQUFBLE9BQUFBLENBQUFBLE9BQUFBLFNBQUFBLENBQUFBLFFBQUFBLENBQUFBLElBQUFBLENBQUFBLElBQUFBLFlBQUFBLEVBQUFBLE9BQUFBLENBQUFBLFlBQUFBLGFBQUFBLENBQUFBLEVBQUFBLElBQUFBLENBQUFBLElBQUFBLENBQUFBLElBQUFBLElBQUFBLElBQUFBLFNBQUFBLENBQUFBLEVBQUFBLENBQUFBLEVBQUFBLENBQUFBLEVBQUFBLENBQUFBLEVBQUFBLENBQUFBO1FBQUFBLElBQUFBLElBQUFBLElBQUFBLEVBQUFBLEVBQUFBLElBQUFBLEdBQUFBLElBQUFBLEVBQUFBLE1BQUFBLEVBQUFBLElBQUFBLEdBQUFBLEVBQUFBLEVBQUFBLEdBQUFBLEdBQUFBLE9BQUFBLE1BQUFBLEVBQUFBLElBQUFBLENBQUFBLEdBQUFBLEdBQUFBLEdBQUFBLEdBQUFBLEdBQUFBLE9BQUFBLElBQUFBLENBQUFBLE1BQUFBLEVBQUFBLElBQUFBLENBQUFBO1FBQUFBLE9BQUFBLEVBQUFBLE9BQUFBLENBQUFBLFNBQUFBLENBQUFBO1lBQUFBLEVBQUFBLEtBQUFBLENBQUFBLFlBQUFBLEVBQUFBLElBQUFBLENBQUFBLEdBQUFBLEdBQUFBLEdBQUFBLEdBQUFBLEdBQUFBLEdBQUFBLENBQUFBO1FBQUFBLElBQUFBO0lBQUFBLEVBQUFBLEdBQUFBLEdBQUFBLEdBQUFBLEdBQUFBLEtBQUFBLEVBQUFBLEdBQUFBLENBQUFBLFNBQUFBLENBQUFBO1FBQUFBLE9BQUFBLEdBQUFBLEdBQUFBLEdBQUFBLEdBQUFBLEdBQUFBLEdBQUFBO0lBQUFBLElBQUFBLEVBQUFBLElBQUFBLENBQUFBLEdBQUFBLElBQUFBLFNBQUFBLENBQUFBLEVBQUFBLENBQUFBLEVBQUFBLENBQUFBO1FBQUFBLElBQUFBLElBQUFBLEVBQUFBLE1BQUFBLENBQUFBLFNBQUFBLENBQUFBLEVBQUFBLENBQUFBO1lBQUFBLE9BQUFBLEVBQUFBLE9BQUFBLENBQUFBLE9BQUFBLElBQUFBLEVBQUFBLE9BQUFBLENBQUFBLG1CQUFBQSxJQUFBQSxNQUFBQSxHQUFBQTtRQUFBQSxHQUFBQTtRQUFBQSxJQUFBQSxJQUFBQSxJQUFBQSxPQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxHQUFBQSxDQUFBQSxPQUFBQSxJQUFBQSxLQUFBQSxJQUFBQSxLQUFBQSxJQUFBQSxNQUFBQSxFQUFBQSxJQUFBQSxDQUFBQSxXQUFBQSxNQUFBQSxDQUFBQSxDQUFBQSxFQUFBQTtRQUFBQSxPQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxHQUFBQSxJQUFBQSxNQUFBQSxFQUFBQSxJQUFBQSxDQUFBQSxRQUFBQSxNQUFBQSxDQUFBQSxDQUFBQSxFQUFBQTtJQUFBQSxFQUFBQSxHQUFBQSxHQUFBQSxFQUFBQSxJQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxHQUFBQSxJQUFBQSxDQUFBQSxDQUFBQSxFQUFBQTtBQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxPQUFBQSxNQUFBQSxNQUFBQSxTQUFBQSxDQUFBQSxRQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxLQUFBQTtBQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxDQUFBQTtJQUFBQSxJQUFBQSxHQUFBQSxHQUFBQTtJQUFBQSxJQUFBQSxDQUFBQSxJQUFBQSxPQUFBQSx3QkFBQUEsQ0FBQUEsR0FBQUEsTUFBQUE7UUFBQUEsT0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUE7SUFBQUEsQ0FBQUEsRUFBQUEsR0FBQUEsR0FBQUEsSUFBQUEsRUFBQUEsR0FBQUEsR0FBQUEsRUFBQUEsT0FBQUEsQ0FBQUEsbUJBQUFBLGFBQUFBLEVBQUFBLE9BQUFBLENBQUFBLFlBQUFBLGFBQUFBLEVBQUFBLEdBQUFBLElBQUFBLENBQUFBLElBQUFBLEVBQUFBLE9BQUFBLENBQUFBLFlBQUFBLFVBQUFBLEdBQUFBLEdBQUFBLEdBQUFBLE1BQUFBLENBQUFBLElBQUFBLE1BQUFBLElBQUFBLEdBQUFBLEdBQUFBLEtBQUFBLENBQUFBLEVBQUFBLElBQUFBLENBQUFBLE9BQUFBLENBQUFBLEVBQUFBLEtBQUFBLElBQUFBLElBQUFBLENBQUFBLElBQUFBLEdBQUFBLEtBQUFBLEdBQUFBLEdBQUFBLEVBQUFBLEtBQUFBLEVBQUFBLFFBQUFBLEdBQUFBLEdBQUFBLEVBQUFBLEtBQUFBLEVBQUFBLElBQUFBLEVBQUFBLEVBQUFBLE9BQUFBLENBQUFBLFFBQUFBLENBQUFBLEtBQUFBLENBQUFBLElBQUFBLElBQUFBLEVBQUFBLEtBQUFBLENBQUFBLE1BQUFBLEdBQUFBLENBQUFBLFNBQUFBLENBQUFBO1FBQUFBLE9BQUFBLE9BQUFBO0lBQUFBLEdBQUFBLElBQUFBLENBQUFBLE1BQUFBLE1BQUFBLENBQUFBLEtBQUFBLE9BQUFBLEVBQUFBLEtBQUFBLENBQUFBLE1BQUFBLEdBQUFBLENBQUFBLFNBQUFBLENBQUFBO1FBQUFBLE9BQUFBLFFBQUFBO0lBQUFBLEdBQUFBLElBQUFBLENBQUFBLEtBQUFBLElBQUFBLElBQUFBLEVBQUFBLE9BQUFBLENBQUFBLGNBQUFBLFVBQUFBLEdBQUFBLEdBQUFBLElBQUFBO1FBQUFBLElBQUFBLEtBQUFBLEVBQUFBLEtBQUFBLENBQUFBLFVBQUFBLE9BQUFBO1FBQUFBLENBQUFBLElBQUFBLEtBQUFBLFNBQUFBLENBQUFBLEtBQUFBLEVBQUFBLEVBQUFBLEtBQUFBLENBQUFBLGtDQUFBQSxDQUFBQSxJQUFBQSxFQUFBQSxNQUFBQSxDQUFBQSxHQUFBQSxFQUFBQSxNQUFBQSxHQUFBQSxJQUFBQSxJQUFBQSxFQUFBQSxPQUFBQSxDQUFBQSxHQUFBQSxPQUFBQSxJQUFBQSxDQUFBQSxJQUFBQSxFQUFBQSxPQUFBQSxDQUFBQSxNQUFBQSxPQUFBQSxPQUFBQSxDQUFBQSxRQUFBQSxLQUFBQSxPQUFBQSxDQUFBQSxZQUFBQSxNQUFBQSxJQUFBQSxFQUFBQSxPQUFBQSxDQUFBQSxHQUFBQSxTQUFBQTtJQUFBQTtJQUFBQSxPQUFBQSxJQUFBQSxPQUFBQTtBQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxPQUFBQSxNQUFBQSxPQUFBQSxDQUFBQTtBQUFBQTtRQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxPQUFBQSxhQUFBQSxPQUFBQTtBQUFBQTtRQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxPQUFBQSxTQUFBQTtBQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxPQUFBQSxRQUFBQTtBQUFBQTtRQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxPQUFBQSxZQUFBQSxPQUFBQTtBQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxPQUFBQSxZQUFBQSxPQUFBQTtBQUFBQTtRQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxPQUFBQSxZQUFBQSxPQUFBQTtBQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxPQUFBQSxLQUFBQSxNQUFBQTtBQUFBQTtRQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxPQUFBQSxHQUFBQSxNQUFBQSxzQkFBQUEsR0FBQUE7QUFBQUE7UUFBQUE7QUFBQUEsU0FBQUEsR0FBQUEsQ0FBQUE7SUFBQUEsT0FBQUEsWUFBQUEsT0FBQUEsS0FBQUEsU0FBQUE7QUFBQUE7UUFBQUE7QUFBQUEsU0FBQUEsR0FBQUEsQ0FBQUE7SUFBQUEsT0FBQUEsR0FBQUEsTUFBQUEsb0JBQUFBLEdBQUFBO0FBQUFBO1FBQUFBO0FBQUFBLFNBQUFBLEdBQUFBLENBQUFBO0lBQUFBLE9BQUFBLEdBQUFBLE1BQUFBLENBQUFBLHFCQUFBQSxHQUFBQSxNQUFBQSxhQUFBQSxLQUFBQTtBQUFBQTtRQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxPQUFBQSxjQUFBQSxPQUFBQTtBQUFBQTtRQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxPQUFBQSxTQUFBQSxLQUFBQSxhQUFBQSxPQUFBQSxLQUFBQSxZQUFBQSxPQUFBQSxLQUFBQSxZQUFBQSxPQUFBQSxLQUFBQSxZQUFBQSxPQUFBQSxLQUFBQSxLQUFBQSxNQUFBQTtBQUFBQTtRQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxPQUFBQSxFQUFBQSxRQUFBQSxDQUFBQTtBQUFBQTtRQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxPQUFBQSxPQUFBQSxTQUFBQSxDQUFBQSxRQUFBQSxDQUFBQSxJQUFBQSxDQUFBQTtBQUFBQTtRQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxPQUFBQSxJQUFBQSxLQUFBQSxNQUFBQSxFQUFBQSxRQUFBQSxDQUFBQSxNQUFBQSxFQUFBQSxRQUFBQSxDQUFBQTtBQUFBQTtBQUFBQSxHQUFBQSxNQUFBQSxHQUFBQTtJQUFBQSxNQUFBQTtRQUFBQTtRQUFBQTtLQUFBQTtJQUFBQSxRQUFBQTtRQUFBQTtRQUFBQTtLQUFBQTtJQUFBQSxXQUFBQTtRQUFBQTtRQUFBQTtLQUFBQTtJQUFBQSxTQUFBQTtRQUFBQTtRQUFBQTtLQUFBQTtJQUFBQSxPQUFBQTtRQUFBQTtRQUFBQTtLQUFBQTtJQUFBQSxNQUFBQTtRQUFBQTtRQUFBQTtLQUFBQTtJQUFBQSxPQUFBQTtRQUFBQTtRQUFBQTtLQUFBQTtJQUFBQSxNQUFBQTtRQUFBQTtRQUFBQTtLQUFBQTtJQUFBQSxNQUFBQTtRQUFBQTtRQUFBQTtLQUFBQTtJQUFBQSxPQUFBQTtRQUFBQTtRQUFBQTtLQUFBQTtJQUFBQSxTQUFBQTtRQUFBQTtRQUFBQTtLQUFBQTtJQUFBQSxLQUFBQTtRQUFBQTtRQUFBQTtLQUFBQTtJQUFBQSxRQUFBQTtRQUFBQTtRQUFBQTtLQUFBQTtBQUFBQSxHQUFBQSxHQUFBQSxNQUFBQSxHQUFBQTtJQUFBQSxTQUFBQTtJQUFBQSxRQUFBQTtJQUFBQSxTQUFBQTtJQUFBQSxXQUFBQTtJQUFBQSxNQUFBQTtJQUFBQSxRQUFBQTtJQUFBQSxNQUFBQTtJQUFBQSxRQUFBQTtBQUFBQTtBQUFBQSxJQUFBQSxLQUFBQTtJQUFBQTtJQUFBQTtJQUFBQTtJQUFBQTtJQUFBQTtJQUFBQTtJQUFBQTtJQUFBQTtJQUFBQTtJQUFBQTtJQUFBQTtJQUFBQTtDQUFBQTtBQUFBQSxTQUFBQTtJQUFBQSxJQUFBQSxHQUFBQTtJQUFBQSxRQUFBQSxHQUFBQSxDQUFBQSxXQUFBQSxDQUFBQSxJQUFBQSxJQUFBQSxNQUFBQSxJQUFBQTtRQUFBQSxHQUFBQSxFQUFBQSxRQUFBQTtRQUFBQSxHQUFBQSxFQUFBQSxVQUFBQTtRQUFBQSxHQUFBQSxFQUFBQSxVQUFBQTtLQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxNQUFBQTtRQUFBQSxFQUFBQSxPQUFBQTtRQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxRQUFBQSxHQUFBQTtRQUFBQTtLQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxJQUFBQSxHQUFBQSxHQUFBQSxLQUFBQSxDQUFBQSxNQUFBQTtBQUFBQTtRQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQSxFQUFBQSxDQUFBQTtJQUFBQSxJQUFBQSxDQUFBQSxLQUFBQSxDQUFBQSxHQUFBQSxJQUFBQSxPQUFBQTtJQUFBQSxJQUFBQSxJQUFBQSxJQUFBQSxPQUFBQSxJQUFBQSxDQUFBQSxJQUFBQSxJQUFBQSxFQUFBQSxNQUFBQSxFQUFBQSxLQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxDQUFBQTtJQUFBQSxPQUFBQTtBQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQSxFQUFBQSxDQUFBQTtJQUFBQSxPQUFBQSxPQUFBQSxTQUFBQSxDQUFBQSxjQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxHQUFBQTtBQUFBQTtRQUFBQTtBQUFBQSxJQUFBQSxLQUFBQSxlQUFBQSxPQUFBQSxTQUFBQSxPQUFBQSwyQkFBQUEsS0FBQUE7QUFBQUEsU0FBQUEsR0FBQUEsQ0FBQUE7SUFBQUEsSUFBQUEsY0FBQUEsT0FBQUEsR0FBQUEsTUFBQUEsSUFBQUEsVUFBQUE7SUFBQUEsSUFBQUEsTUFBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsRUFBQUE7UUFBQUEsSUFBQUE7UUFBQUEsSUFBQUEsY0FBQUEsT0FBQUEsQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsR0FBQUEsTUFBQUEsSUFBQUEsVUFBQUE7UUFBQUEsT0FBQUEsT0FBQUEsY0FBQUEsQ0FBQUEsR0FBQUEsSUFBQUE7WUFBQUEsT0FBQUE7WUFBQUEsWUFBQUEsQ0FBQUE7WUFBQUEsVUFBQUEsQ0FBQUE7WUFBQUEsY0FBQUEsQ0FBQUE7UUFBQUEsSUFBQUE7SUFBQUE7SUFBQUEsU0FBQUE7UUFBQUEsSUFBQUEsSUFBQUEsR0FBQUEsR0FBQUEsSUFBQUEsSUFBQUEsUUFBQUEsU0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUE7WUFBQUEsSUFBQUEsR0FBQUEsSUFBQUE7UUFBQUEsSUFBQUEsSUFBQUEsRUFBQUEsRUFBQUEsSUFBQUEsR0FBQUEsSUFBQUEsVUFBQUEsTUFBQUEsRUFBQUEsSUFBQUEsRUFBQUEsSUFBQUEsQ0FBQUEsU0FBQUEsQ0FBQUEsRUFBQUE7UUFBQUEsRUFBQUEsSUFBQUEsQ0FBQUEsU0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUE7WUFBQUEsSUFBQUEsRUFBQUEsS0FBQUEsRUFBQUE7UUFBQUE7UUFBQUEsSUFBQUE7WUFBQUEsRUFBQUEsS0FBQUEsQ0FBQUEsSUFBQUEsRUFBQUE7UUFBQUEsRUFBQUEsT0FBQUEsR0FBQUE7WUFBQUEsRUFBQUE7UUFBQUE7UUFBQUEsT0FBQUE7SUFBQUE7SUFBQUEsT0FBQUEsT0FBQUEsY0FBQUEsQ0FBQUEsR0FBQUEsT0FBQUEsY0FBQUEsQ0FBQUEsS0FBQUEsTUFBQUEsT0FBQUEsY0FBQUEsQ0FBQUEsR0FBQUEsSUFBQUE7UUFBQUEsT0FBQUE7UUFBQUEsWUFBQUEsQ0FBQUE7UUFBQUEsVUFBQUEsQ0FBQUE7UUFBQUEsY0FBQUEsQ0FBQUE7SUFBQUEsSUFBQUEsT0FBQUEsZ0JBQUFBLENBQUFBLEdBQUFBLEdBQUFBO0FBQUFBO1FBQUFBO0FBQUFBLFNBQUFBLEdBQUFBLENBQUFBLEVBQUFBLENBQUFBO0lBQUFBLElBQUFBLENBQUFBLEdBQUFBO1FBQUFBLElBQUFBLElBQUFBLElBQUFBLE1BQUFBO1FBQUFBLEVBQUFBLE1BQUFBLEdBQUFBLEdBQUFBLElBQUFBO0lBQUFBO0lBQUFBLE9BQUFBLEVBQUFBO0FBQUFBO0FBQUFBLFNBQUFBLEdBQUFBLENBQUFBO0lBQUFBLElBQUFBLGNBQUFBLE9BQUFBLEdBQUFBLE1BQUFBLElBQUFBLFVBQUFBO0lBQUFBLFNBQUFBO1FBQUFBLElBQUFBLElBQUFBLElBQUFBLEVBQUFBLEVBQUFBLElBQUFBLEdBQUFBLElBQUFBLFVBQUFBLE1BQUFBLEVBQUFBLElBQUFBLEVBQUFBLElBQUFBLENBQUFBLFNBQUFBLENBQUFBLEVBQUFBO1FBQUFBLElBQUFBLElBQUFBLEVBQUFBLEdBQUFBO1FBQUFBLElBQUFBLGNBQUFBLE9BQUFBLEdBQUFBLE1BQUFBLElBQUFBLFVBQUFBO1FBQUFBLElBQUFBLElBQUFBLElBQUFBLEVBQUFBLElBQUFBO1lBQUFBLE9BQUFBLEVBQUFBLEtBQUFBLENBQUFBLEdBQUFBO1FBQUFBO1FBQUFBLEVBQUFBLEtBQUFBLENBQUFBLElBQUFBLEVBQUFBLEdBQUFBLElBQUFBLENBQUFBLFNBQUFBLENBQUFBO1lBQUFBLEdBQUFBLFFBQUFBLENBQUFBLEVBQUFBLElBQUFBLENBQUFBLE1BQUFBLE1BQUFBO1FBQUFBLEdBQUFBLFNBQUFBLENBQUFBO1lBQUFBLEdBQUFBLFFBQUFBLENBQUFBLEdBQUFBLElBQUFBLENBQUFBLE1BQUFBLEdBQUFBO1FBQUFBO0lBQUFBO0lBQUFBLE9BQUFBLE9BQUFBLGNBQUFBLENBQUFBLEdBQUFBLE9BQUFBLGNBQUFBLENBQUFBLEtBQUFBLE9BQUFBLGdCQUFBQSxDQUFBQSxHQUFBQSxHQUFBQSxLQUFBQTtBQUFBQTtBQUFBQSxHQUFBQSxNQUFBQSxHQUFBQTtBQUFBQSxJQUFBQSxJQUFBQSxJQUFBQSxLQUFBQTtJQUFBQSxVQUFBQTtJQUFBQSxTQUFBQTtJQUFBQSxLQUFBQTtJQUFBQSxVQUFBQTtJQUFBQSxhQUFBQTtJQUFBQSxZQUFBQTtJQUFBQSxTQUFBQTtJQUFBQSxRQUFBQTtJQUFBQSxVQUFBQTtJQUFBQSxVQUFBQTtJQUFBQSxhQUFBQTtJQUFBQSxVQUFBQTtJQUFBQSxVQUFBQTtJQUFBQSxVQUFBQTtJQUFBQSxtQkFBQUE7SUFBQUEsUUFBQUE7SUFBQUEsV0FBQUE7SUFBQUEsU0FBQUE7SUFBQUEsU0FBQUE7SUFBQUEsV0FBQUE7SUFBQUEsUUFBQUE7SUFBQUEsVUFBQUE7SUFBQUEsV0FBQUE7SUFBQUEsYUFBQUE7QUFBQUEsR0FBQUEsS0FBQUEsR0FBQUEsT0FBQUEsTUFBQUEsQ0FBQUE7SUFBQUEsV0FBQUE7SUFBQUEsU0FBQUE7SUFBQUEsYUFBQUE7SUFBQUEsVUFBQUE7SUFBQUEsU0FBQUE7SUFBQUEsV0FBQUE7SUFBQUEsUUFBQUE7SUFBQUEsVUFBQUE7SUFBQUEsU0FBQUE7SUFBQUEsU0FBQUE7SUFBQUEsV0FBQUE7SUFBQUEsVUFBQUE7SUFBQUEsUUFBQUE7SUFBQUEsU0FBQUE7SUFBQUEs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LElBQUFBLENBQUt1OEQsY0FBQUEsQ0FBZXRrRSxTQUFBQSxHQUFZUSxHQUNoQ3VILElBQUFBLENBQUtxOEQsY0FBQUEsQ0FBZXBrRSxTQUFBQSxHQUFZUTtRQUFBQTtJQUFBQSxJQUFBQTtBQUFBQTtBQUFBQSxJQUFBQSxLQUFBQSxFQUFBQSxVQUFBQSxJQUFBQSxTQUFBQSxDQUFBQTtJQUFBQSxPQUFBQSxLQUFBQSxFQUFBQSxXQUFBQTtRQUFBQSxLQUFBQTtRQUFBQSxLQUFBQTtRQUFBQSxLQUFBQTtRQUFBQSxLQUFBQTtRQUFBQSxLQUFBQTtRQUFBQSxLQUFBQTtRQUFBQSxLQUFBQTtRQUFBQSxLQUFBQTtRQUFBQSxLQUFBQTtRQUFBQSxLQUFBQTtRQUFBQSxLQUFBQTtZQUFBQSxPQUFBQSxDQUFBQTtRQUFBQTtZQUFBQSxPQUFBQSxDQUFBQTtJQUFBQTtBQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxPQUFBQSxJQUFBQSxDQUFBQSxRQUFBQSxHQUFBQSxDQUFBQSxLQUFBQSxNQUFBQSxFQUFBQSxXQUFBQSxHQUFBQSxPQUFBQSxDQUFBQSxRQUFBQSxLQUFBQSxTQUFBQSxDQUFBQTtRQUFBQSxJQUFBQSxLQUFBQSxDQUFBQSxHQUFBQSxJQUFBQSxNQUFBQSxJQUFBQSxNQUFBQSx1QkFBQUE7SUFBQUEsRUFBQUEsSUFBQUEsSUFBQUEsQ0FBQUEsUUFBQUE7UUFBQUEsS0FBQUE7WUFBQUEsSUFBQUEsQ0FBQUEsYUFBQUEsR0FBQUE7WUFBQUE7UUFBQUEsS0FBQUE7UUFBQUEsS0FBQUE7WUFBQUEsSUFBQUEsQ0FBQUEsYUFBQUEsR0FBQUEsR0FBQUEsSUFBQUEsQ0FBQUEsb0JBQUFBLEdBQUFBO1lBQUFBO1FBQUFBLEtBQUFBO1lBQUFBLElBQUFBLENBQUFBLGFBQUFBLEdBQUFBLEdBQUFBLElBQUFBLENBQUFBLG9CQUFBQSxHQUFBQTtZQUFBQTtRQUFBQTtZQUFBQSxPQUFBQSxLQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxLQUFBQSxHQUFBQSxFQUFBQTtJQUFBQTtJQUFBQSxJQUFBQSxDQUFBQSxVQUFBQSxHQUFBQSxJQUFBQSxFQUFBQSxJQUFBQSxJQUFBQSxDQUFBQSxZQUFBQSxHQUFBQSxHQUFBQSxJQUFBQSxDQUFBQSxVQUFBQSxHQUFBQTtBQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxPQUFBQSxFQUFBQSxRQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxRQUFBQTtBQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxJQUFBQSxDQUFBQSxZQUFBQSxHQUFBQSxFQUFBQSxNQUFBQSxHQUFBQSxHQUFBQSxJQUFBQSxDQUFBQSxVQUFBQSxHQUFBQSxJQUFBQSxDQUFBQSxZQUFBQSxHQUFBQSxJQUFBQTtBQUFBQTtBQUFBQSxTQUFBQSxHQUFBQSxDQUFBQTtJQUFBQSxJQUFBQSxDQUFBQSxZQUFBQSxHQUFBQSxFQUFBQSxNQUFBQSxHQUFBQSxHQUFBQSxJQUFBQSxDQUFBQSxVQUFBQSxHQUFBQSxJQUFBQSxDQUFBQSxZQUFBQSxHQUFBQSxJQUFBQTtBQUFBQTtRQUFBQTtBQUFBQSxHQUFBQSxTQUFBQSxDQUFBQSxLQUFBQSxHQUFBQSxTQUFBQSxDQUFBQTtJQUFBQSxJQUFBQSxJQUFBQSxJQUFBQSxJQUFBQSxJQUFBQSxDQUFBQSxVQUFBQSxFQUFBQTtRQUFBQSxJQUFBQSxJQUFBQSxFQUFBQSxNQUFBQSxJQUFBQSxJQUFBQSxDQUFBQSxVQUFBQSxHQUFBQSxJQUFBQSxDQUFBQSxZQUFBQSxHQUFBQSxJQUFBQSxDQUFBQSxVQUFBQSxHQUFBQSxJQUFBQSxDQUFBQSxZQUFBQSxHQUFBQSxFQUFBQSxNQUFBQTtRQUFBQSxJQUFBQSxFQUFBQSxJQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxVQUFBQSxFQUFBQSxJQUFBQSxDQUFBQSxZQUFBQSxFQUFBQSxHQUFBQSxJQUFBQSxJQUFBQSxDQUFBQSxZQUFBQSxJQUFBQSxHQUFBQSxJQUFBQSxDQUFBQSxZQUFBQSxHQUFBQSxJQUFBQSxDQUFBQSxVQUFBQSxFQUFBQSxPQUFBQTtRQUFBQSxJQUFBQSxJQUFBQSxFQUFBQSxLQUFBQSxDQUFBQSxHQUFBQSxFQUFBQSxNQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxJQUFBQSxJQUFBQSxDQUFBQSxVQUFBQSxDQUFBQSxLQUFBQSxDQUFBQSxHQUFBQSxJQUFBQSxDQUFBQSxVQUFBQSxFQUFBQSxRQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxRQUFBQSxDQUFBQSxFQUFBQSxVQUFBQSxDQUFBQSxFQUFBQSxNQUFBQSxHQUFBQSxFQUFBQSxLQUFBQSxTQUFBQSxLQUFBQSxLQUFBQSxHQUFBQTtZQUFBQSxJQUFBQSxJQUFBQSxDQUFBQSxZQUFBQSxHQUFBQSxJQUFBQSxDQUFBQSxVQUFBQSxHQUFBQSxHQUFBQSxNQUFBQSxFQUFBQSxNQUFBQSxFQUFBQSxPQUFBQTtZQUFBQTtRQUFBQTtRQUFBQSxJQUFBQSxDQUFBQSxVQUFBQSxJQUFBQSxJQUFBQSxDQUFBQSxhQUFBQSxFQUFBQSxJQUFBQTtJQUFBQTtJQUFBQSxJQUFBQSxDQUFBQSxvQkFBQUEsQ0FBQUE7SUFBQUEsSUFBQUEsSUFBQUEsRUFBQUEsTUFBQUE7SUFBQUEsSUFBQUEsQ0FBQUEsVUFBQUEsSUFBQUEsQ0FBQUEsRUFBQUEsSUFBQUEsQ0FBQUEsSUFBQUEsQ0FBQUEsVUFBQUEsRUFBQUEsR0FBQUEsRUFBQUEsTUFBQUEsR0FBQUEsSUFBQUEsQ0FBQUEsWUFBQUEsRUFBQUEsSUFBQUEsS0FBQUEsSUFBQUEsQ0FBQUEsWUFBQUE7SUFBQUEsSUFBQUE7SUFBQUEsSUFBQUEsQ0FBQUEsS0FBQUEsRUFBQUEsUUFBQUEsQ0FBQUEsSUFBQUEsQ0FBQUEsUUFBQUEsRUFBQUEsR0FBQUEsRUFBQUEsRUFBQUEsTUFBQUEsR0FBQUE7SUFBQUEsSUFBQUEsQ0FBQUEsSUFBQUEsRUFBQUEsVUFBQUEsQ0FBQUEsRUFBQUEsS0FBQUEsU0FBQUEsS0FBQUEsT0FBQUE7UUFBQUEsSUFBQUEsSUFBQUEsSUFBQUEsQ0FBQUEsYUFBQUE7UUFBQUEsT0FBQUEsSUFBQUEsQ0FBQUEsVUFBQUEsSUFBQUEsR0FBQUEsSUFBQUEsQ0FBQUEsWUFBQUEsSUFBQUEsR0FBQUEsSUFBQUEsQ0FBQUEsVUFBQUEsQ0FBQUEsSUFBQUEsQ0FBQUEsSUFBQUEsQ0FBQUEsVUFBQUEsRUFBQUEsR0FBQUEsR0FBQUEsSUFBQUEsRUFBQUEsSUFBQUEsQ0FBQUEsSUFBQUEsQ0FBQUEsVUFBQUEsRUFBQUEsR0FBQUEsR0FBQUEsSUFBQUEsRUFBQUEsU0FBQUEsQ0FBQUEsR0FBQUE7SUFBQUE7SUFBQUEsT0FBQUE7QUFBQUEsR0FBQUEsR0FBQUEsU0FBQUEsQ0FBQUEsb0JBQUFBLEdBQUFBLFNBQUFBLENBQUFBO0lBQUFBLElBQUFBLElBQUFBLElBQUFBLEVBQUFBLE1BQUFBLElBQUFBLElBQUFBLElBQUFBLEVBQUFBLE1BQUFBLEVBQUFBLElBQUFBLEdBQUFBLElBQUFBO1FBQUFBLElBQUFBLElBQUFBLENBQUFBLENBQUFBLEVBQUFBLE1BQUFBLEdBQUFBLEVBQUFBO1FBQUFBLElBQUFBLEtBQUFBLEtBQUFBLEtBQUFBLEtBQUFBLEdBQUFBO1lBQUFBLElBQUFBLENBQUFBLFVBQUFBLEdBQUFBO1lBQUFBO1FBQUFBO1FBQUFBLElBQUFBLEtBQUFBLEtBQUFBLEtBQUFBLEtBQUFBLElBQUFBO1lBQUFBLElBQUFBLENBQUFBLFVBQUFBLEdBQUFBO1lBQUFBO1FBQUFBO1FBQUFBLElBQUFBLEtBQUFBLEtBQUFBLEtBQUFBLEtBQUFBLElBQUFBO1lBQUFBLElBQUFBLENBQUFBLFVBQUFBLEdBQUFBO1lBQUFBO1FBQUFBO0lBQUFBO0lBQUFBLElBQUFBLENBQUFBLFlBQUFBLEdBQUFBO0FBQUFBLEdBQUFBLEdBQUFBLFNBQUFBLENBQUFBLEdBQUFBLEdBQUFBLFNBQUFBLENBQUFBO0lBQUFBLElBQUFBLElBQUFBO0lBQUFBLElBQUFBLEtBQUFBLEVBQUFBLE1BQUFBLElBQUFBLENBQUFBLElBQUFBLElBQUFBLENBQUFBLEtBQUFBLENBQUFBLEVBQUFBLEdBQUFBLElBQUFBLENBQUFBLFlBQUFBLEVBQUFBO1FBQUFBLElBQUFBLElBQUFBLElBQUFBLENB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QTtJQUNqS21xRyxRQUFRO1FBQUM7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7S0FBQTtJQUNyS0MsVUFBVTtRQUFDO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO0tBQUE7SUFDdktDLE1BQU07UUFBQztRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtLQUFBO0FBQUEsR0FHaktDLEtBQWE7SUFFZnRxRyxLQUFLO1FBQUM7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7UUFBSTtRQUFJO1FBQUk7S0FBQTtJQUMzSW1xRyxR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QUUsUUFBUTtRQUFFMFYsR0FBRztRQUFxRW5ZLE1BQU07SUFBQSxJQUMxRnlDLEdBQUUsUUFBUTtRQUFFMFYsR0FBRztRQUE2RG5ZLE1BQU07SUFBQSxJQUNsRnlDLEdBQUUsUUFBUTtRQUFFMFYsR0FBRztRQUEySG5ZLE1BQU07SUFBQSxJQUNoSnlDLEdBQUUsUUFBUTtRQUFFMFYsR0FBRztRQUFvRW5ZLE1BQU07SUFBQSxJQUN6RnlDLEdBQUUsUUFBUTtRQUFFMFYsR0FBRztRQUEyRG5ZLE1BQU07SUFBQSxJQUNoRnlDLEdBQUUsUUFBUTtRQUFFMFYsR0FBRztRQUFtSW5ZLE1BQU07SUFBQSxJQUN4SnlDLEdBQUUsUUFBUTtRQUFFMFYsR0FBRztRQUFtRW5ZLE1BQU07SUFBQSxJQUN4RnlDLEdBQUUsUUFBUTtRQUFFMFYsR0FBRztRQUFvR25ZLE1BQU07SUFBQSxJQUN6SHlDLEdBQUUsUUFBUTtRQUFFMFYsR0FBRztRQUFtRW5ZLE1BQU07SUFBQSxJQUN4RnlDLEdBQUUsUUFBUTtRQUFFMFYsR0FBRztRQUE0Rm5ZLE1BQU07SUFBQSxJQUNqSHlDLEdBQUUsUUFBUTtRQUFFMFYsR0FBRztRQUE2SW5ZLE1BQU07SUFBQSxJQUNsS3lDLEdBQUUsUUFBUTtRQUFFMFYsR0FBRztRQUEySW5ZLE1BQU07SUFBQSxJQUNoS3lDLEdBQUUsUUFBUTtRQUFFMFYsR0FBRztRQUF3R25ZLE1BQU07SUFBQSxJQUM3SHlDLEdBQUUsUUFBUTtRQUFFMFYsR0FBRztRQUE2Rm5ZLE1BQU07SUFBQSxJQUNsSHlDLEdBQUUsUUFBUTtRQUFFMFYsR0FBRztRQUFvRm5ZLE1BQU07SUFBQSxJQUN6R3lDLEdBQUUsUUFBUTtRQUFFMFYsR0FBRztRQUE2Rm5ZLE1BQU07SUFBQSxJQUNsSHlDLEdBQUUsUUFBUTtRQUFFMFYsR0FBRztRQUFxRm5ZLE1BQU07SUFBQSxJQUMxR3lDLEdBQUUsUUFBUTtRQUFFMFYsR0FBRztRQUF3Rm5ZLE1BQU07SUFBQSxJQUM3R3lDLEdBQUUsUUFBUTtRQUFFMFYsR0FBRztRQUFxRG5ZLE1BQU07SUFB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cEcsR0FBQUE7UUFBYSxPQUFPO1lBQzNCeFgsZUFBaUI7Z0JBQUM7YUFBQTtRQUFBO0lBQ3BCO0lBaEVGLFdBQUF0NkYsQ0FBWStqRyxDQUFBQSxDQUFBQTtRQUNSRixHQUFpQmo3RixJQUFBQSxFQUFNbTdGLElBQ3ZCbjdGLElBQUFBLENBQUtrbUQsS0FBQUEsR0FBUTQ1QyxHQUFZOS9GLElBQUFBLEVBQU0sU0FBUyxJQUN4Q0EsSUFBQUEsQ0FBS296RixvQkFBQUEsR0FBdUIwTSxHQUFZOS9GLElBQUFBLEVBQU0sd0JBQXdCLElBQ3RFQSxJQUFBQSxDQUFLNitFLElBQUFBLEdBQUFBLEtBQU96Z0YsR0FDWjRCLElBQUFBLENBQUt1N0MsVUFBQUEsR0FBQUEsS0FBYW45QyxHQUNsQjRCLElBQUFBLENBQUsweEYsYUFBQUEsR0FBQUEsS0FBZ0J0ekYsR0FDckI0QixJQUFBQSxDQUFLbXRHLEdBQUFBLEdBQU0sR0FDWG50RyxJQUFBQSxDQUFLb3RHLFlBQUFBLEdBQUFBLENBQWUsR0FDcEJwdEcsSUFBQUEsQ0FBS3F0RyxrQkFBQUEsR0FBQUEsQ0FBcUIsR0FDMUJydEcsSUFBQUEsQ0FBS2s3RyxZQUFBQSxHQUFlLElBQUluQixJQUN4Qi81RyxJQUFBQSxDQUFLaTdHLE1BQUFBLENBQU9qN0csSUFBQUEsQ0FBSzB4RixhQUFBQSxHQUFnQixJQUFJO0lBQzdDO0FBb0RNO0FBRU4rcUIsR0FBWXBvQixLQUFBQSxHQXRFSztBQUFBO0lBQUE7SUFBQTtJQUFBO0lBQUE7QUFBQTtBQUFBIiwic291cmNlcyI6WyJDOlxcc2RrLWNvbW11bmljYXRpb24tbGF5ZXJcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxjaXBoZXJzXFxfYXNzZXJ0LmpzIiwiQzpcXHNkay1jb21tdW5pY2F0aW9uLWxheWVyXFxub2RlX21vZHVsZXNcXEBub2JsZVxcY2lwaGVyc1xcdXRpbHMuanMiLCJDOlxcc2RrLWNvbW11bmljYXRpb24tbGF5ZXJcXG5vZGVfbW9kdWxlc1xcZWNpZXNqc1xcZGlzdFxcY29uc3RzLmpzIiwiQzpcXHNkay1jb21tdW5pY2F0aW9uLWxheWVyXFxub2RlX21vZHVsZXNcXGVjaWVzanNcXGRpc3RcXGNvbmZpZy5qcyIsIkM6XFxzZGstY29tbXVuaWNhdGlvbi1sYXllclxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGNpcGhlcnNcXGNyeXB0by5qcyIsIkM6XFxzZGstY29tbXVuaWNhdGlvbi1sYXllclxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGNpcGhlcnNcXHdlYmNyeXB0by5qcyIsIkM6XFxzZGstY29tbXVuaWNhdGlvbi1sYXllclxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xcX2Fzc2VydC5qcyIsIkM6XFxzZGstY29tbXVuaWNhdGlvbi1sYXllclxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xcY3J5cHRvLmpzIiwiQzpcXHNkay1jb21tdW5pY2F0aW9uLWxheWVyXFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFx1dGlscy5qcyIsIkM6XFxzZGstY29tbXVuaWNhdGlvbi1sYXllclxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xcX21kLmpzIiwiQzpcXHNkay1jb21tdW5pY2F0aW9uLWxheWVyXFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxfdTY0LmpzIiwiQzpcXHNkay1jb21tdW5pY2F0aW9uLWxheWVyXFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxzaGE1MTIuanMiLCJDOlxcc2RrLWNvbW11bmljYXRpb24tbGF5ZXJcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxjdXJ2ZXNcXGFic3RyYWN0XFx1dGlscy5qcyIsIkM6XFxzZGstY29tbXVuaWNhdGlvbi1sYXllclxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGN1cnZlc1xcYWJzdHJhY3RcXG1vZHVsYXIuanMiLCJDOlxcc2RrLWNvbW11bmljYXRpb24tbGF5ZXJcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxjdXJ2ZXNcXGFic3RyYWN0XFxjdXJ2ZS5qcyIsIkM6XFxzZGstY29tbXVuaWNhdGlvbi1sYXllclxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGN1cnZlc1xcYWJzdHJhY3RcXGVkd2FyZHMuanMiLCJDOlxcc2RrLWNvbW11bmljYXRpb24tbGF5ZXJcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxjdXJ2ZXNcXGFic3RyYWN0XFxoYXNoLXRvLWN1cnZlLmpzIiwiQzpcXHNkay1jb21tdW5pY2F0aW9uLWxheWVyXFxub2RlX21vZHVsZXNcXEBub2JsZVxcY3VydmVzXFxhYnN0cmFjdFxcbW9udGdvbWVyeS5qcyIsIkM6XFxzZGstY29tbXVuaWNhdGlvbi1sYXllclxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGN1cnZlc1xcZWQyNTUxOS5qcyIsIkM6XFxzZGstY29tbXVuaWNhdGlvbi1sYXllclxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xcc2hhMjU2LmpzIiwiQzpcXHNkay1jb21tdW5pY2F0aW9uLWxheWVyXFxub2RlX21vZHVsZXNcXEBub2JsZVxcaGFzaGVzXFxobWFjLmpzIiwiQzpcXHNkay1jb21tdW5pY2F0aW9uLWxheWVyXFxub2RlX21vZHVsZXNcXEBub2JsZVxcY3VydmVzXFxhYnN0cmFjdFxcd2VpZXJzdHJhc3MuanMiLCJDOlxcc2RrLWNvbW11bmljYXRpb24tbGF5ZXJcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxjdXJ2ZXNcXF9zaG9ydHdfdXRpbHMuanMiLCJDOlxcc2RrLWNvbW11bmljYXRpb24tbGF5ZXJcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxjdXJ2ZXNcXHNlY3AyNTZrMS5qcyIsIkM6XFxzZGstY29tbXVuaWNhdGlvbi1sYXllclxcbm9kZV9tb2R1bGVzXFxlY2llc2pzXFxkaXN0XFx1dGlsc1xcaGV4LmpzIiwiQzpcXHNkay1jb21tdW5pY2F0aW9uLWxheWVyXFxub2RlX21vZHVsZXNcXGVjaWVzanNcXGRpc3RcXHV0aWxzXFxlbGxpcHRpYy5qcyIsIkM6XFxzZGstY29tbXVuaWNhdGlvbi1sYXllclxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGhhc2hlc1xcaGtkZi5qcyIsIkM6XFxzZGstY29tbXVuaWNhdGlvbi1sYXllclxcbm9kZV9tb2R1bGVzXFxlY2llc2pzXFxkaXN0XFx1dGlsc1xcaGFzaC5qcyIsIkM6XFxzZGstY29tbXVuaWNhdGlvbi1sYXllclxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGNpcGhlcnNcXF9wb2x5dmFsLmpzIiwiQzpcXHNkay1jb21tdW5pY2F0aW9uLWxheWVyXFxub2RlX21vZHVsZXNcXEBub2JsZVxcY2lwaGVyc1xcYWVzLmpzIiwiQzpcXHNkay1jb21tdW5pY2F0aW9uLWxheWVyXFxub2RlX21vZHVsZXNcXEBlY2llc1xcY2lwaGVyc1xcZGlzdFxcYWVzXFxub2JsZS5qcyIsIkM6XFxzZGstY29tbXVuaWNhdGlvbi1sYXllclxcbm9kZV9tb2R1bGVzXFxAbm9ibGVcXGNpcGhlcnNcXF9hcnguanMiLCJDOlxcc2RrLWNvbW11bmljYXRpb24tbGF5ZXJcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxjaXBoZXJzXFxfcG9seTEzMDUuanMiLCJDOlxcc2RrLWNvbW11bmljYXRpb24tbGF5ZXJcXG5vZGVfbW9kdWxlc1xcQG5vYmxlXFxjaXBoZXJzXFxjaGFjaGEuanMiLCJDOlxcc2RrLWNvbW11bmljYXRpb24tbGF5ZXJcXG5vZGVfbW9kdWxlc1xcQGVjaWVzXFxjaXBoZXJzXFxkaXN0XFxjaGFjaGFcXG5vYmxlLmpzIiwiQzpcXHNkay1jb21tdW5pY2F0aW9uLWxheWVyXFxub2RlX21vZHVsZXNcXGVjaWVzanNcXGRpc3RcXHV0aWxzXFxpbmRleC5qcyIsIkM6XFxzZGstY29tbXVuaWNhdGlvbi1sYXllclxcbm9kZV9tb2R1bGVzXFxlY2llc2pzXFxkaXN0XFx1dGlsc1xcc3ltbWV0cmljLmpzIiwiQzpcXHNkay1jb21tdW5pY2F0aW9uLWxheWVyXFxub2RlX21vZHVsZXNcXGVjaWVzanNcXGRpc3RcXGtleXNcXFB1YmxpY0tleS5qcyIsIkM6XFxzZGstY29tbXVuaWNhdGlvbi1sYXllclxcbm9kZV9tb2R1bGVzXFxlY2llc2pzXFxkaXN0XFxrZXlzXFxQcml2YXRlS2V5LmpzIiwiQzpcXHNkay1jb21tdW5pY2F0aW9uLWxheWVyXFxub2RlX21vZHVsZXNcXGVjaWVzanNcXGRpc3RcXGtleXNcXGluZGV4LmpzIiwiQzpcXHNkay1jb21tdW5pY2F0aW9uLWxheWVyXFxub2RlX21vZHVsZXNcXGVjaWVzanNcXGRpc3RcXGluZGV4LmpzIiwiQzpcXHNkay1jb21tdW5pY2F0aW9uLWxheWVyXFxkaXN0XFxicm93c2VyXFxlc1xcbWV0YW1hc2stc2RrLWNvbW11bmljYXRpb24tbGF5ZXIuanMiLCJDOlxcbm9kZV9tb2R1bGVzXFxAbWV0YW1hc2tcXHByb3ZpZGVyc1xcZGlzdFxcY2h1bmstSTZIWEdaUkQubWpzIiwiQzpcXG5vZGVfbW9kdWxlc1xcQG1ldGFtYXNrXFxwcm92aWRlcnNcXGRpc3RcXGNodW5rLVpHRFEzSVlELm1qcyIsIkM6XFxub2RlX21vZHVsZXNcXEBtZXRhbWFza1xccHJvdmlkZXJzXFxkaXN0XFxjaHVuay01Rkw2VlJKSi5tanMiLCJDOlxcbm9kZV9tb2R1bGVzXFxAbWV0YW1hc2tcXGpzb24tcnBjLWVuZ2luZVxcZGlzdFxcY2h1bmstNlhYUFRaVjYubWpzIiwiQzpcXG5vZGVfbW9kdWxlc1xcQG1ldGFtYXNrXFxqc29uLXJwYy1lbmdpbmVcXGRpc3RcXGNodW5rLVI3TEtJNUg1Lm1qcyIsIkM6XFxub2RlX21vZHVsZXNcXEBtZXRhbWFza1xcanNvbi1ycGMtZW5naW5lXFxkaXN0XFxjaHVuay1YVUk0M0xFWi5tanMiLCJDOlxcbm9kZV9tb2R1bGVzXFxAbWV0YW1hc2tcXHJwYy1lcnJvcnNcXGRpc3RcXGNodW5rLU1JVzROTVk2Lm1qcyIsIkM6XFxub2RlX21vZHVsZXNcXEBtZXRhbWFza1xcdXRpbHNcXGRpc3RcXGNodW5rLUg0WUZETEI3Lm1qcyIsIkM6XFxub2RlX21vZHVsZXNcXHN1cGVyc3RydWN0XFxkaXN0XFxpbmRleC5tanMiLCJDOlxcbm9kZV9tb2R1bGVzXFxAbWV0YW1hc2tcXHV0aWxzXFxkaXN0XFxjaHVuay03NERHVkpWRS5tanMiLCJDOlxcbm9kZV9tb2R1bGVzXFxAbWV0YW1hc2tcXHV0aWxzXFxkaXN0XFxjaHVuay1YWUdVT1k2Ti5tanMiLCJDOlxcbm9kZV9tb2R1bGVzXFxAbWV0YW1hc2tcXHV0aWxzXFxkaXN0XFxjaHVuay02QzM1WFFPRi5tanMiLCJDOlxcbm9kZV9tb2R1bGVzXFxAbWV0YW1hc2tcXHJwYy1lcnJvcnNcXGRpc3RcXGNodW5rLU1QVTNDVlgzLm1qcyIsIkM6XFxub2RlX21vZHVsZXNcXGZhc3Qtc2FmZS1zdHJpbmdpZnlcXGluZGV4LmpzIiwiQzpcXG5vZGVfbW9kdWxlc1xcQG1ldGFtYXNrXFxycGMtZXJyb3JzXFxkaXN0XFxjaHVuay1YU0tPM0dYWi5tanMiLCJDOlxcbm9kZV9tb2R1bGVzXFxAbWV0YW1hc2tcXHJwYy1lcnJvcnNcXGRpc3RcXGNodW5rLUtZUDI3VTNDLm1qcyIsIkM6XFxub2RlX21vZHVsZXNcXEBtZXRhbWFza1xcc2FmZS1ldmVudC1lbWl0dGVyXFxpbmRleC5qcyIsIkM6XFxub2RlX21vZHVsZXNcXEBtZXRhbWFza1xcanNvbi1ycGMtZW5naW5lXFxkaXN0XFxjaHVuay01SENZVjRGVi5tanMiLCJDOlxcbm9kZV9tb2R1bGVzXFxAbWV0YW1hc2tcXHByb3ZpZGVyc1xcZGlzdFxcY2h1bmstWk43V1Y1NUoubWpzIiwiQzpcXG5vZGVfbW9kdWxlc1xcQG1ldGFtYXNrXFxwcm92aWRlcnNcXGRpc3RcXGNodW5rLTU1WlE1NVBPLm1qcyIsIkM6XFxub2RlX21vZHVsZXNcXEBtZXRhbWFza1xccHJvdmlkZXJzXFxkaXN0XFxjaHVuay1YNjZTVUlFRi5tanMiLCJDOlxcbm9kZV9tb2R1bGVzXFxAbWV0YW1hc2tcXHByb3ZpZGVyc1xcbm9kZV9tb2R1bGVzXFxAbWV0YW1hc2tcXHNhZmUtZXZlbnQtZW1pdHRlclxcZGlzdFxcZXNtXFxpbmRleC5tanMiLCJDOlxcbm9kZV9tb2R1bGVzXFxmYXN0LWRlZXAtZXF1YWxcXGluZGV4LmpzIiwiQzpcXG5vZGVfbW9kdWxlc1xcQG1ldGFtYXNrXFxwcm92aWRlcnNcXGRpc3RcXGNodW5rLU9HUEE1UTc2Lm1qcyIsIkM6XFxub2RlX21vZHVsZXNcXHJlYWRhYmxlLXN0cmVhbVxcbGliXFxpbnRlcm5hbFxcc3RyZWFtc1xcc3RyZWFtLWJyb3dzZXIuanMiLCJDOlxcbm9kZV9tb2R1bGVzXFxyZWFkYWJsZS1zdHJlYW1cXGxpYlxcaW50ZXJuYWxcXHN0cmVhbXNcXGJ1ZmZlcl9saXN0LmpzIiwiQzpcXG5vZGVfbW9kdWxlc1xccmVhZGFibGUtc3RyZWFtXFxsaWJcXGludGVybmFsXFxzdHJlYW1zXFxkZXN0cm95LmpzIiwiQzpcXG5vZGVfbW9kdWxlc1xccmVhZGFibGUtc3RyZWFtXFxlcnJvcnMtYnJvd3Nlci5qcyIsIkM6XFxub2RlX21vZHVsZXNcXHJlYWRhYmxlLXN0cmVhbVxcbGliXFxpbnRlcm5hbFxcc3RyZWFtc1xcc3RhdGUuanMiLCJDOlxcbm9kZV9tb2R1bGVzXFx1dGlsLWRlcHJlY2F0ZVxcYnJvd3Nlci5qcyIsIkM6XFxub2RlX21vZHVsZXNcXHJlYWRhYmxlLXN0cmVhbVxcbGliXFxfc3RyZWFtX3dyaXRhYmxlLmpzIiwiQzpcXG5vZGVfbW9kdWxlc1xccmVhZGFibGUtc3RyZWFtXFxsaWJcXF9zdHJlYW1fZHVwbGV4LmpzIiwiQzpcXG5vZGVfbW9kdWxlc1xccmVhZGFibGUtc3RyZWFtXFxsaWJcXGludGVybmFsXFxzdHJlYW1zXFxlbmQtb2Ytc3RyZWFtLmpzIiwiQzpcXG5vZGVfbW9kdWxlc1xccmVhZGFibGUtc3RyZWFtXFxsaWJcXGludGVybmFsXFxzdHJlYW1zXFxhc3luY19pdGVyYXRvci5qcyIsIkM6XFxub2RlX21vZHVsZXNcXHJlYWRhYmxlLXN0cmVhbVxcbGliXFxfc3RyZWFtX3JlYWRhYmxlLmpzIiwiQzpcXG5vZGVfbW9kdWxlc1xccmVhZGFibGUtc3RyZWFtXFxsaWJcXGludGVybmFsXFxzdHJlYW1zXFxmcm9tLWJyb3dzZXIuanMiLCJDOlxcbm9kZV9tb2R1bGVzXFxyZWFkYWJsZS1zdHJlYW1cXGxpYlxcX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJDOlxcbm9kZV9tb2R1bGVzXFxyZWFkYWJsZS1zdHJlYW1cXGxpYlxcaW50ZXJuYWxcXHN0cmVhbXNcXHBpcGVsaW5lLmpzIiwiQzpcXG5vZGVfbW9kdWxlc1xccmVhZGFibGUtc3RyZWFtXFxsaWJcXF9zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJDOlxcbm9kZV9tb2R1bGVzXFxyZWFkYWJsZS1zdHJlYW1cXHJlYWRhYmxlLWJyb3dzZXIuanMiLCJDOlxcbm9kZV9tb2R1bGVzXFxAbWV0YW1hc2tcXGpzb24tcnBjLW1pZGRsZXdhcmUtc3RyZWFtXFxkaXN0XFxjaHVuay00NDZRWU9CUC5tanMiLCJDOlxcbm9kZV9tb2R1bGVzXFx3cmFwcHlcXHdyYXBweS5qcyIsIkM6XFxub2RlX21vZHVsZXNcXG9uY2VcXG9uY2UuanMiLCJDOlxcbm9kZV9tb2R1bGVzXFxAbWV0YW1hc2tcXG9iamVjdC1tdWx0aXBsZXhcXGRpc3RcXFN1YnN0cmVhbS5qcyIsIkM6XFxub2RlX21vZHVsZXNcXEBtZXRhbWFza1xcb2JqZWN0LW11bHRpcGxleFxcZGlzdFxcT2JqZWN0TXVsdGlwbGV4LmpzIiwiQzpcXG5vZGVfbW9kdWxlc1xcQG1ldGFtYXNrXFxvYmplY3QtbXVsdGlwbGV4XFxkaXN0XFxpbmRleC5qcyIsIkM6XFxub2RlX21vZHVsZXNcXGlzLXN0cmVhbVxcaW5kZXguanMiLCJDOlxcbm9kZV9tb2R1bGVzXFxAbWV0YW1hc2tcXHByb3ZpZGVyc1xcZGlzdFxcY2h1bmstVVJNU1pPN1oubWpzIiwiQzpcXG5vZGVfbW9kdWxlc1xcQG1ldGFtYXNrXFxwcm92aWRlcnNcXGRpc3RcXGNodW5rLVVUUk9IWFBULm1qcyIsIkM6XFxzcmNcXHV0aWxzXFxsb2dnZXIudHMiLCJDOlxcc3JjXFxzZXJ2aWNlc1xcU0RLUHJvdmlkZXJcXENoYWluTWFuYWdlclxcaGFuZGxlQ2hhaW5DaGFuZ2VkLnRzIiwiQzpcXG5vZGVfbW9kdWxlc1xcZXRoLXJwYy1lcnJvcnNcXGRpc3RcXGNsYXNzZXMuanMiLCJDOlxcbm9kZV9tb2R1bGVzXFxldGgtcnBjLWVycm9yc1xcZGlzdFxcZXJyb3ItY29uc3RhbnRzLmpzIiwiQzpcXG5vZGVfbW9kdWxlc1xcZXRoLXJwYy1lcnJvcnNcXGRpc3RcXHV0aWxzLmpzIiwiQzpcXG5vZGVfbW9kdWxlc1xcZXRoLXJwYy1lcnJvcnNcXGRpc3RcXGVycm9ycy5qcyIsIkM6XFxub2RlX21vZHVsZXNcXGV0aC1ycGMtZXJyb3JzXFxkaXN0XFxpbmRleC5qcyIsIkM6XFxub2RlX21vZHVsZXNcXGJvd3NlclxcZXM1LmpzIiwiQzpcXHNyY1xcdHlwZXNcXE1ldGFNYXNrU0RLRXZlbnRzLnRzIiwiQzpcXHNyY1xcc2VydmljZXNcXEV0aGVyZXVtLnRzIiwiQzpcXG5vZGVfbW9kdWxlc1xcQG1ldGFtYXNrXFxwcm92aWRlcnNcXGRpc3RcXGNodW5rLUxGMktONlpULm1qcyIsIkM6XFxub2RlX21vZHVsZXNcXEBtZXRhbWFza1xccHJvdmlkZXJzXFxkaXN0XFxjaHVuay1GMlo1Wk1IMy5tanMiLCJDOlxcc3JjXFxQbGF0Zm9ybVxcUGxhdGZmb3JtTWFuYWdlci50cyIsIkM6XFxzcmNcXHNlcnZpY2VzXFxQbGF0ZmZvcm1NYW5hZ2VyXFxvcGVuRGVlcGxpbmsudHMiLCJDOlxcc3JjXFxzZXJ2aWNlc1xcUGxhdGZmb3JtTWFuYWdlclxcaXNNZXRhTWFza0luc3RhbGxlZC50cyIsIkM6XFxzcmNcXHNlcnZpY2VzXFxQbGF0ZmZvcm1NYW5hZ2VyXFxnZXRQbGF0Zm9ybVR5cGUudHMiLCJDOlxcc3JjXFxzdG9yYWdlLW1hbmFnZXJcXGdldFN0b3JhZ2VNYW5hZ2VyLnRzIiwiQzpcXHNyY1xccHJvdmlkZXJcXFNES1Byb3ZpZGVyLnRzIiwiQzpcXHNyY1xcc2VydmljZXNcXFNES1Byb3ZpZGVyXFxDb25uZWN0aW9uTWFuYWdlclxcaGFuZGxlRGlzY29ubmVjdC50cyIsIkM6XFxzcmNcXHNlcnZpY2VzXFxTREtQcm92aWRlclxcSW5pdGlhbGl6YXRpb25NYW5hZ2VyXFxpbml0aWFsaXplU3RhdGVBc3luYy50cyIsIkM6XFxzcmNcXHNlcnZpY2VzXFxTREtQcm92aWRlclxcSW5pdGlhbGl6YXRpb25NYW5hZ2VyXFxpbml0aWFsaXplU3RhdGUudHMiLCJDOlxcc3JjXFxjb25zdGFudHMudHMiLCJDOlxcc3JjXFxjb25maWcudHMiLCJDOlxcc3JjXFx0eXBlc1xcUHJvdmlkZXJVcGRhdGVUeXBlLnRzIiwiQzpcXHNyY1xcc2VydmljZXNcXE1ldGFNYXNrU0RLXFxDb25uZWN0aW9uTWFuYWdlclxcdGVybWluYXRlLnRzIiwiQzpcXHNyY1xcc2VydmljZXNcXE1ldGFNYXNrU0RLXFxDb25uZWN0aW9uTWFuYWdlclxcY29ubmVjdEFuZFNpZ24udHMiLCJDOlxcc3JjXFx1dGlsc1xcaGV4LnV0aWxzLnRzIiwiQzpcXHNyY1xcc2VydmljZXNcXE1ldGFNYXNrU0RLXFxQcm92aWRlck1hbmFnZXJcXGNvbm5lY3RXaXRoRXh0ZW5zaW9uUHJvdmlkZXIudHMiLCJDOlxcc3JjXFx1dGlsc1xcYmFzZTY0LnRzIiwiQzpcXHNyY1xcc2VydmljZXNcXFJlbW90ZUNvbW11bmljYXRpb25Qb3N0TWVzc2FnZVN0cmVhbVxcd3JpdGUudHMiLCJDOlxcc3JjXFxzZXJ2aWNlc1xcUmVtb3RlQ29tbXVuaWNhdGlvblBvc3RNZXNzYWdlU3RyZWFtXFxleHRyYWN0TWV0aG9kLnRzIiwiQzpcXHNyY1xcUG9zdE1lc3NhZ2VTdHJlYW1cXFJlbW90ZUNvbW11bmljYXRpb25Qb3N0TWVzc2FnZVN0cmVhbS50cyIsIkM6XFxzcmNcXHNlcnZpY2VzXFxSZW1vdGVDb21tdW5pY2F0aW9uUG9zdE1lc3NhZ2VTdHJlYW1cXG9uTWVzc2FnZS50cyIsIkM6XFxzcmNcXHNlcnZpY2VzXFxycGMtcmVxdWVzdHNcXFJQQ1JlcXVlc3RIYW5kbGVyLnRzIiwiQzpcXHNyY1xcdXRpbHNcXHdhaXQudHMiLCJDOlxcc3JjXFxwcm92aWRlclxcaW5pdGlhbGl6ZU1vYmlsZVByb3ZpZGVyLnRzIiwiQzpcXHNyY1xcUG9zdE1lc3NhZ2VTdHJlYW1cXGdldFBvc3RNZXNzYWdlU3RyZWFtLnRzIiwiQzpcXHNyY1xccHJvdmlkZXJcXGV4dGVuc2lvbkNvbm5lY3RXaXRoT3ZlcndyaXRlLnRzIiwiQzpcXHNyY1xcc2VydmljZXNcXE1ldGFNYXNrU0RLXFxJbml0aWFsaXplck1hbmFnZXJcXGluaXRpYWxpemVQcm92aWRlckFuZEV2ZW50TGlzdGVuZXJzLnRzIiwiQzpcXHNyY1xcc2VydmljZXNcXE1ldGFNYXNrU0RLXFxJbml0aWFsaXplck1hbmFnZXJcXGluaXRFdmVudExpc3RlbmVycy50cyIsIkM6XFxzcmNcXHNlcnZpY2VzXFxBbmFseXRpY3MudHMiLCJDOlxcc3JjXFx1dGlsc1xcZXh0cmFjdEZhdmljb24udHMiLCJDOlxcc3JjXFxzZXJ2aWNlc1xcTWV0YU1hc2tTREtcXEluaXRpYWxpemVyTWFuYWdlclxcc2V0dXBEYXBwTWV0YWRhdGEudHMiLCJDOlxcc3JjXFxwcm92aWRlclxcZXh0ZW5zaW9uUHJvdmlkZXJIZWxwZXJzXFxoYW5kbGVVdWlkLnRzIiwiQzpcXHNyY1xccHJvdmlkZXJcXGV4dGVuc2lvblByb3ZpZGVySGVscGVyc1xcYW5hbHl0aWNzSGVscGVyLnRzIiwiQzpcXHNyY1xccHJvdmlkZXJcXHdyYXBFeHRlbnNpb25Qcm92aWRlci50cyIsIkM6XFxzcmNcXHByb3ZpZGVyXFxleHRlbnNpb25Qcm92aWRlckhlbHBlcnNcXGhhbmRsZUJhdGNoTWV0aG9kLnRzIiwiQzpcXHNyY1xccHJvdmlkZXJcXGV4dGVuc2lvblByb3ZpZGVySGVscGVyc1xcaGFuZGxlQ29ubmVjdFNpZ25NZXRob2QudHMiLCJDOlxcc3JjXFxwcm92aWRlclxcZXh0ZW5zaW9uUHJvdmlkZXJIZWxwZXJzXFxoYW5kbGVDb25uZWN0V2l0aE1ldGhvZC50cyIsIkM6XFxzcmNcXHV0aWxzXFxlaXA2OTYzUmVxdWVzdFByb3ZpZGVyLnRzIiwiQzpcXHNyY1xcdXRpbHNcXGdldC1icm93c2VyLWV4dGVuc2lvbi50cyIsIkM6XFxzcmNcXHNlcnZpY2VzXFxNZXRhTWFza1NES1xcSW5pdGlhbGl6ZXJNYW5hZ2VyXFxzZXR1cEluZnVyYVByb3ZpZGVyLnRzIiwiQzpcXHNyY1xcc2VydmljZXNcXE1ldGFNYXNrU0RLXFxJbml0aWFsaXplck1hbmFnZXJcXHNldHVwUmVhZE9ubHlSUENQcm92aWRlcnMudHMiLCJDOlxcbm9kZV9tb2R1bGVzXFxAbWV0YW1hc2tcXG9uYm9hcmRpbmdcXGRpc3RcXG1ldGFtYXNrLW9uYm9hcmRpbmcuZXMuanMiLCJDOlxcc3JjXFxzZXJ2aWNlc1xcTWV0YU1hc2tJbnN0YWxsZXJcXHN0YXJ0SW5zdGFsbGVyLnRzIiwiQzpcXHNyY1xcUGxhdGZvcm1cXE1ldGFNYXNrSW5zdGFsbGVyLnRzIiwiQzpcXHNyY1xcc2VydmljZXNcXE1ldGFNYXNrSW5zdGFsbGVyXFxzdGFydERlc2t0b3BPbmJvYXJkaW5nLnRzIiwiQzpcXHNyY1xcc2VydmljZXNcXE1ldGFNYXNrSW5zdGFsbGVyXFxyZWRpcmVjdFRvUHJvcGVySW5zdGFsbC50cyIsIkM6XFxzcmNcXHNlcnZpY2VzXFxNZXRhTWFza0luc3RhbGxlclxcY2hlY2tJbnN0YWxsYXRpb24udHMiLCJDOlxcc3JjXFx1aVxcSW5zdGFsbE1vZGFsXFxNb2RhbC13ZWIudHMiLCJDOlxcc3JjXFx1aVxcSW5zdGFsbE1vZGFsXFxJbnN0YWxsTW9kYWwtd2ViLnRzIiwiQzpcXHNyY1xcdWlcXEluc3RhbGxNb2RhbFxccGVuZGluZ01vZGFsLXdlYi50cyIsIkM6XFxzcmNcXHNlcnZpY2VzXFxSZW1vdGVDb25uZWN0aW9uXFxDb25uZWN0aW9uSW5pdGlhbGl6ZXJcXGluaXRpYWxpemVDb25uZWN0b3IudHMiLCJDOlxcc3JjXFxzZXJ2aWNlc1xcUmVtb3RlQ29ubmVjdGlvblxcRXZlbnRMaXN0ZW5lcnNcXGNsZWFudXBMaXN0ZW5lcnMudHMiLCJDOlxcc3JjXFxzZXJ2aWNlc1xcUmVtb3RlQ29ubmVjdGlvblxcQ29ubmVjdGlvbk1hbmFnZXJcXGNvbm5lY3RXaXRoTW9kYWxJbnN0YWxsZXIudHMiLCJDOlxcc3JjXFxzZXJ2aWNlc1xcUmVtb3RlQ29ubmVjdGlvblxcTW9kYWxNYW5hZ2VyXFxzaG93SW5zdGFsbE1vZGFsLnRzIiwiQzpcXHNyY1xcc2VydmljZXNcXFJlbW90ZUNvbm5lY3Rpb25cXEV2ZW50TGlzdGVuZXJzXFxzZXR1cExpc3RlbmVycy50cyIsIkM6XFxzcmNcXHNlcnZpY2VzXFxSZW1vdGVDb25uZWN0aW9uXFxDb25uZWN0aW9uTWFuYWdlclxcc3RhcnRDb25uZWN0aW9uLnRzIiwiQzpcXHNyY1xcc2VydmljZXNcXFJlbW90ZUNvbm5lY3Rpb25cXENvbm5lY3Rpb25NYW5hZ2VyXFxjb25uZWN0V2l0aERlZXBsaW5rLnRzIiwiQzpcXHNyY1xcc2VydmljZXNcXFJlbW90ZUNvbm5lY3Rpb25cXFJlbW90ZUNvbm5lY3Rpb24udHMiLCJDOlxcc3JjXFxzZXJ2aWNlc1xcUmVtb3RlQ29ubmVjdGlvblxcTW9kYWxNYW5hZ2VyXFxzaG93QWN0aXZlTW9kYWwudHMiLCJDOlxcc3JjXFxzZXJ2aWNlc1xcUmVtb3RlQ29ubmVjdGlvblxcQ29ubmVjdGlvbkluaXRpYWxpemVyXFxjbGVhbnVwQ29ubmVjdG9yLnRzIiwiQzpcXHNyY1xcc2VydmljZXNcXE1ldGFNYXNrU0RLXFxJbml0aWFsaXplck1hbmFnZXJcXHBlcmZvcm1TREtJbml0aWFsaXphdGlvbi50cyIsIkM6XFxzcmNcXHNlcnZpY2VzXFxNZXRhTWFza1NES1xcSW5pdGlhbGl6ZXJNYW5hZ2VyXFxzZXR1cFBsYXRmb3JtTWFuYWdlci50cyIsIkM6XFxzcmNcXHNlcnZpY2VzXFxNZXRhTWFza1NES1xcSW5pdGlhbGl6ZXJNYW5hZ2VyXFxzZXR1cEFuYWx5dGljcy50cyIsIkM6XFxzcmNcXHNlcnZpY2VzXFxNZXRhTWFza1NES1xcSW5pdGlhbGl6ZXJNYW5hZ2VyXFxzZXR1cEFuYWx5dGljc1YyLnRzIiwiQzpcXHNyY1xcc2VydmljZXNcXE1ldGFNYXNrU0RLXFxJbml0aWFsaXplck1hbmFnZXJcXHNldHVwU3RvcmFnZS50cyIsIkM6XFxzcmNcXHNlcnZpY2VzXFxNZXRhTWFza1NES1xcSW5pdGlhbGl6ZXJNYW5hZ2VyXFxzZXR1cEV4dGVuc2lvblByZWZlcmVuY2VzLnRzIiwiQzpcXHNyY1xcc2VydmljZXNcXE1ldGFNYXNrU0RLXFxJbml0aWFsaXplck1hbmFnZXJcXHNldHVwUmVtb3RlQ29ubmVjdGlvbkFuZEluc3RhbGxlci50cyIsIkM6XFxzcmNcXHNlcnZpY2VzXFxNZXRhTWFza1NES1xcSW5pdGlhbGl6ZXJNYW5hZ2VyXFxoYW5kbGVBdXRvQW5kRXh0ZW5zaW9uQ29ubmVjdGlvbnMudHMiLCJDOlxcc3JjXFxzZGsudHMiLCJDOlxcc3JjXFxzZXJ2aWNlc1xcTWV0YU1hc2tTREtcXEluaXRpYWxpemVyTWFuYWdlclxcaW5pdGlhbGl6ZU1ldGFNYXNrU0RLLnRzIiwiQzpcXHNyY1xcc2VydmljZXNcXE1ldGFNYXNrU0RLXFxDb25uZWN0aW9uTWFuYWdlclxcY29ubmVjdC50cyIsIkM6XFxzcmNcXHNlcnZpY2VzXFxNZXRhTWFza1NES1xcQ29ubmVjdGlvbk1hbmFnZXJcXGNvbm5lY3RXaXRoLnRzIiwiQzpcXHNyY1xcc2VydmljZXNcXE1ldGFNYXNrU0RLXFxDb25uZWN0aW9uTWFuYWdlclxccmVzdW1lLnRzIiwiQzpcXHNyY1xcc3RvcmFnZS1tYW5hZ2VyXFxTdG9yYWdlTWFuYWdlcldlYi50cyIsIkM6XFxzZGstaW5zdGFsbC1tb2RhbC13ZWJcXGRpc3RcXGVzbVxcaW5kZXgtNGI4YTk0YzkuanMiLCJDOlxcc2RrLWluc3RhbGwtbW9kYWwtd2ViXFxkaXN0XFxsb2FkZXJcXGluZGV4LmpzIiwiQzpcXHNkay1pbnN0YWxsLW1vZGFsLXdlYlxcZGlzdFxcZXNtXFxsb2FkZXIuanMiLCJDOlxcc2RrLWluc3RhbGwtbW9kYWwtd2ViXFxkaXN0XFxlc21cXG1tLWluc3RhbGwtbW9kYWxfMy5lbnRyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNCeXRlcyA9IGlzQnl0ZXM7XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbmV4cG9ydHMuYm9vbCA9IGJvb2w7XG5leHBvcnRzLmJ5dGVzID0gYnl0ZXM7XG5leHBvcnRzLmhhc2ggPSBoYXNoO1xuZXhwb3J0cy5leGlzdHMgPSBleGlzdHM7XG5leHBvcnRzLm91dHB1dCA9IG91dHB1dDtcbmZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwb3NpdGl2ZSBpbnRlZ2VyIGV4cGVjdGVkLCBub3QgJHtufWApO1xufVxuZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYm9vbGVhbiBleHBlY3RlZCwgbm90ICR7Yn1gKTtcbn1cbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmZ1bmN0aW9uIGhhc2goaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaCBtdXN0IGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGhhc2gub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaGFzaC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5jb25zdCBhc3NlcnQgPSB7IG51bWJlciwgYm9vbCwgYnl0ZXMsIGhhc2gsIGV4aXN0cywgb3V0cHV0IH07XG5leHBvcnRzLmRlZmF1bHQgPSBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy53cmFwQ2lwaGVyID0gZXhwb3J0cy5IYXNoID0gZXhwb3J0cy5uZXh0VGljayA9IGV4cG9ydHMuaXNMRSA9IGV4cG9ydHMuY3JlYXRlVmlldyA9IGV4cG9ydHMudTMyID0gZXhwb3J0cy51MTYgPSBleHBvcnRzLnU4ID0gdm9pZCAwO1xuZXhwb3J0cy5ieXRlc1RvSGV4ID0gYnl0ZXNUb0hleDtcbmV4cG9ydHMuaGV4VG9CeXRlcyA9IGhleFRvQnl0ZXM7XG5leHBvcnRzLmhleFRvTnVtYmVyID0gaGV4VG9OdW1iZXI7XG5leHBvcnRzLmJ5dGVzVG9OdW1iZXJCRSA9IGJ5dGVzVG9OdW1iZXJCRTtcbmV4cG9ydHMubnVtYmVyVG9CeXRlc0JFID0gbnVtYmVyVG9CeXRlc0JFO1xuZXhwb3J0cy5hc3luY0xvb3AgPSBhc3luY0xvb3A7XG5leHBvcnRzLnV0ZjhUb0J5dGVzID0gdXRmOFRvQnl0ZXM7XG5leHBvcnRzLmJ5dGVzVG9VdGY4ID0gYnl0ZXNUb1V0Zjg7XG5leHBvcnRzLnRvQnl0ZXMgPSB0b0J5dGVzO1xuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuZXhwb3J0cy5jaGVja09wdHMgPSBjaGVja09wdHM7XG5leHBvcnRzLmVxdWFsQnl0ZXMgPSBlcXVhbEJ5dGVzO1xuZXhwb3J0cy5zZXRCaWdVaW50NjQgPSBzZXRCaWdVaW50NjQ7XG5leHBvcnRzLnU2NExlbmd0aHMgPSB1NjRMZW5ndGhzO1xuZXhwb3J0cy5pc0FsaWduZWQzMiA9IGlzQWxpZ25lZDMyO1xuZXhwb3J0cy5jb3B5Qnl0ZXMgPSBjb3B5Qnl0ZXM7XG5leHBvcnRzLmNsZWFuID0gY2xlYW47XG4vKiEgbm9ibGUtY2lwaGVycyAtIE1JVCBMaWNlbnNlIChjKSAyMDIzIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmNvbnN0IHU4ID0gKGFycikgPT4gbmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydHMudTggPSB1ODtcbmNvbnN0IHUxNiA9IChhcnIpID0+IG5ldyBVaW50MTZBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDIpKTtcbmV4cG9ydHMudTE2ID0gdTE2O1xuY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuZXhwb3J0cy51MzIgPSB1MzI7XG4vLyBDYXN0IGFycmF5IHRvIHZpZXdcbmNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbmV4cG9ydHMuY3JlYXRlVmlldyA9IGNyZWF0ZVZpZXc7XG4vLyBiaWctZW5kaWFuIGhhcmR3YXJlIGlzIHJhcmUuIEp1c3QgaW4gY2FzZSBzb21lb25lIHN0aWxsIGRlY2lkZXMgdG8gcnVuIGNpcGhlcnM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuZXhwb3J0cy5pc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbmlmICghZXhwb3J0cy5pc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGJ5dGVzKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIF9BOiA2NSwgX0Y6IDcwLCBfYTogOTcsIF9mOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fMCAmJiBjaGFyIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBhc2NpaXMuXzA7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9BICYmIGNoYXIgPD0gYXNjaWlzLl9GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX0EgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9hICYmIGNoYXIgPD0gYXNjaWlzLl9mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX2EgLSAxMCk7XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbmZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEJpZyBFbmRpYW5cbiAgICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiBgMHgke2hleH1gKTtcbn1cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZnVuY3Rpb24gYnl0ZXNUb051bWJlckJFKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGhleFRvTnVtYmVyKGJ5dGVzVG9IZXgoYnl0ZXMpKTtcbn1cbmZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuZXhwb3J0cy5uZXh0VGljayA9IG5leHRUaWNrO1xuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0ICgwLCBleHBvcnRzLm5leHRUaWNrKSgpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0cmluZyBleHBlY3RlZCwgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9VdGY4KG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSkpIC8vICdhYmMnXG4gKi9cbmZ1bmN0aW9uIGJ5dGVzVG9VdGY4KGJ5dGVzKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShieXRlcyk7XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgIGVsc2UgaWYgKCgwLCBfYXNzZXJ0X2pzXzEuaXNCeXRlcykoZGF0YSkpXG4gICAgICAgIGRhdGEgPSBjb3B5Qnl0ZXMoZGF0YSk7XG4gICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVpbnQ4QXJyYXkgZXhwZWN0ZWQsIGdvdCAke3R5cGVvZiBkYXRhfWApO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykoYSk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGNoZWNrT3B0cyhkZWZhdWx0cywgb3B0cykge1xuICAgIGlmIChvcHRzID09IG51bGwgfHwgdHlwZW9mIG9wdHMgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbi8vIENvbXBhcmVzIDIgdThhLXMgaW4ga2luZGEgY29uc3RhbnQgdGltZVxuZnVuY3Rpb24gZXF1YWxCeXRlcyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBkaWZmID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGRpZmYgfD0gYVtpXSBeIGJbaV07XG4gICAgcmV0dXJuIGRpZmYgPT09IDA7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuY2xhc3MgSGFzaCB7XG59XG5leHBvcnRzLkhhc2ggPSBIYXNoO1xuLyoqXG4gKiBAX19OT19TSURFX0VGRkVDVFNfX1xuICovXG5jb25zdCB3cmFwQ2lwaGVyID0gKHBhcmFtcywgYykgPT4ge1xuICAgIE9iamVjdC5hc3NpZ24oYywgcGFyYW1zKTtcbiAgICByZXR1cm4gYztcbn07XG5leHBvcnRzLndyYXBDaXBoZXIgPSB3cmFwQ2lwaGVyO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbmZ1bmN0aW9uIHU2NExlbmd0aHMoY2lwaGVydGV4dCwgQUFEKSB7XG4gICAgY29uc3QgbnVtID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIGNvbnN0IHZpZXcgPSAoMCwgZXhwb3J0cy5jcmVhdGVWaWV3KShudW0pO1xuICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCAwLCBCaWdJbnQoQUFEID8gQUFELmxlbmd0aCA6IDApLCB0cnVlKTtcbiAgICBzZXRCaWdVaW50NjQodmlldywgOCwgQmlnSW50KGNpcGhlcnRleHQubGVuZ3RoKSwgdHJ1ZSk7XG4gICAgcmV0dXJuIG51bTtcbn1cbi8vIElzIGJ5dGUgYXJyYXkgYWxpZ25lZCB0byA0IGJ5dGUgb2Zmc2V0ICh1MzIpP1xuZnVuY3Rpb24gaXNBbGlnbmVkMzIoYnl0ZXMpIHtcbiAgICByZXR1cm4gYnl0ZXMuYnl0ZU9mZnNldCAlIDQgPT09IDA7XG59XG4vLyBjb3B5IGJ5dGVzIHRvIG5ldyB1OGEgKGFsaWduZWQpLiBCZWNhdXNlIEJ1ZmZlci5zbGljZSBpcyBicm9rZW4uXG5mdW5jdGlvbiBjb3B5Qnl0ZXMoYnl0ZXMpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGJ5dGVzKTtcbn1cbmZ1bmN0aW9uIGNsZWFuKC4uLmFycmF5cykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5c1tpXS5maWxsKDApO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BRUFEX1RBR19MRU5HVEggPSBleHBvcnRzLlhDSEFDSEEyMF9OT05DRV9MRU5HVEggPSBleHBvcnRzLkNVUlZFMjU1MTlfUFVCTElDX0tFWV9TSVpFID0gZXhwb3J0cy5FVEhfUFVCTElDX0tFWV9TSVpFID0gZXhwb3J0cy5VTkNPTVBSRVNTRURfUFVCTElDX0tFWV9TSVpFID0gZXhwb3J0cy5DT01QUkVTU0VEX1BVQkxJQ19LRVlfU0laRSA9IGV4cG9ydHMuU0VDUkVUX0tFWV9MRU5HVEggPSB2b2lkIDA7XG4vLyBlbGxpcHRpY1xuZXhwb3J0cy5TRUNSRVRfS0VZX0xFTkdUSCA9IDMyO1xuZXhwb3J0cy5DT01QUkVTU0VEX1BVQkxJQ19LRVlfU0laRSA9IDMzO1xuZXhwb3J0cy5VTkNPTVBSRVNTRURfUFVCTElDX0tFWV9TSVpFID0gNjU7XG5leHBvcnRzLkVUSF9QVUJMSUNfS0VZX1NJWkUgPSA2NDtcbmV4cG9ydHMuQ1VSVkUyNTUxOV9QVUJMSUNfS0VZX1NJWkUgPSAzMjtcbi8vIHN5bW1ldHJpY1xuZXhwb3J0cy5YQ0hBQ0hBMjBfTk9OQ0VfTEVOR1RIID0gMjQ7XG5leHBvcnRzLkFFQURfVEFHX0xFTkdUSCA9IDE2O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVwaGVtZXJhbEtleVNpemUgPSBleHBvcnRzLnN5bW1ldHJpY05vbmNlTGVuZ3RoID0gZXhwb3J0cy5zeW1tZXRyaWNBbGdvcml0aG0gPSBleHBvcnRzLmlzSGtkZktleUNvbXByZXNzZWQgPSBleHBvcnRzLmlzRXBoZW1lcmFsS2V5Q29tcHJlc3NlZCA9IGV4cG9ydHMuZWxsaXB0aWNDdXJ2ZSA9IGV4cG9ydHMuRUNJRVNfQ09ORklHID0gdm9pZCAwO1xudmFyIGNvbnN0c18xID0gcmVxdWlyZShcIi4vY29uc3RzXCIpO1xudmFyIENvbmZpZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25maWcoKSB7XG4gICAgICAgIHRoaXMuZWxsaXB0aWNDdXJ2ZSA9IFwic2VjcDI1NmsxXCI7XG4gICAgICAgIHRoaXMuaXNFcGhlbWVyYWxLZXlDb21wcmVzc2VkID0gZmFsc2U7IC8vIHNlY3AyNTZrMSBvbmx5XG4gICAgICAgIHRoaXMuaXNIa2RmS2V5Q29tcHJlc3NlZCA9IGZhbHNlOyAvLyBzZWNwMjU2azEgb25seVxuICAgICAgICB0aGlzLnN5bW1ldHJpY0FsZ29yaXRobSA9IFwiYWVzLTI1Ni1nY21cIjtcbiAgICAgICAgdGhpcy5zeW1tZXRyaWNOb25jZUxlbmd0aCA9IDE2OyAvLyBhZXMtMjU2LWdjbSBvbmx5XG4gICAgfVxuICAgIHJldHVybiBDb25maWc7XG59KCkpO1xuZXhwb3J0cy5FQ0lFU19DT05GSUcgPSBuZXcgQ29uZmlnKCk7XG52YXIgZWxsaXB0aWNDdXJ2ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4cG9ydHMuRUNJRVNfQ09ORklHLmVsbGlwdGljQ3VydmU7IH07XG5leHBvcnRzLmVsbGlwdGljQ3VydmUgPSBlbGxpcHRpY0N1cnZlO1xudmFyIGlzRXBoZW1lcmFsS2V5Q29tcHJlc3NlZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4cG9ydHMuRUNJRVNfQ09ORklHLmlzRXBoZW1lcmFsS2V5Q29tcHJlc3NlZDsgfTtcbmV4cG9ydHMuaXNFcGhlbWVyYWxLZXlDb21wcmVzc2VkID0gaXNFcGhlbWVyYWxLZXlDb21wcmVzc2VkO1xudmFyIGlzSGtkZktleUNvbXByZXNzZWQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBleHBvcnRzLkVDSUVTX0NPTkZJRy5pc0hrZGZLZXlDb21wcmVzc2VkOyB9O1xuZXhwb3J0cy5pc0hrZGZLZXlDb21wcmVzc2VkID0gaXNIa2RmS2V5Q29tcHJlc3NlZDtcbnZhciBzeW1tZXRyaWNBbGdvcml0aG0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiBleHBvcnRzLkVDSUVTX0NPTkZJRy5zeW1tZXRyaWNBbGdvcml0aG07IH07XG5leHBvcnRzLnN5bW1ldHJpY0FsZ29yaXRobSA9IHN5bW1ldHJpY0FsZ29yaXRobTtcbnZhciBzeW1tZXRyaWNOb25jZUxlbmd0aCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV4cG9ydHMuRUNJRVNfQ09ORklHLnN5bW1ldHJpY05vbmNlTGVuZ3RoOyB9O1xuZXhwb3J0cy5zeW1tZXRyaWNOb25jZUxlbmd0aCA9IHN5bW1ldHJpY05vbmNlTGVuZ3RoO1xudmFyIGVwaGVtZXJhbEtleVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1hcHBpbmcgPSB7XG4gICAgICAgIHNlY3AyNTZrMTogZXhwb3J0cy5FQ0lFU19DT05GSUcuaXNFcGhlbWVyYWxLZXlDb21wcmVzc2VkXG4gICAgICAgICAgICA/IGNvbnN0c18xLkNPTVBSRVNTRURfUFVCTElDX0tFWV9TSVpFXG4gICAgICAgICAgICA6IGNvbnN0c18xLlVOQ09NUFJFU1NFRF9QVUJMSUNfS0VZX1NJWkUsXG4gICAgICAgIHgyNTUxOTogY29uc3RzXzEuQ1VSVkUyNTUxOV9QVUJMSUNfS0VZX1NJWkUsXG4gICAgICAgIGVkMjU1MTk6IGNvbnN0c18xLkNVUlZFMjU1MTlfUFVCTElDX0tFWV9TSVpFLFxuICAgIH07XG4gICAgaWYgKGV4cG9ydHMuRUNJRVNfQ09ORklHLmVsbGlwdGljQ3VydmUgaW4gbWFwcGluZykge1xuICAgICAgICByZXR1cm4gbWFwcGluZ1tleHBvcnRzLkVDSUVTX0NPTkZJRy5lbGxpcHRpY0N1cnZlXTtcbiAgICB9IC8qIHY4IGlnbm9yZSBuZXh0IDIgKi9cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbn07XG5leHBvcnRzLmVwaGVtZXJhbEtleVNpemUgPSBlcGhlbWVyYWxLZXlTaXplO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyeXB0byA9IHZvaWQgMDtcbmV4cG9ydHMuY3J5cHRvID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2NtID0gZXhwb3J0cy5jdHIgPSBleHBvcnRzLmNiYyA9IGV4cG9ydHMudXRpbHMgPSB2b2lkIDA7XG5leHBvcnRzLnJhbmRvbUJ5dGVzID0gcmFuZG9tQnl0ZXM7XG5leHBvcnRzLmdldFdlYmNyeXB0b1N1YnRsZSA9IGdldFdlYmNyeXB0b1N1YnRsZTtcbmV4cG9ydHMubWFuYWdlZE5vbmNlID0gbWFuYWdlZE5vbmNlO1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qcyBvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCwgd2UgY2FuIGp1c3QgZHJvcCB0aGUgaW1wb3J0LlxuLy9cbi8vIFVzZSBmdWxsIHBhdGggc28gdGhhdCBOb2RlLmpzIGNhbiByZXdyaXRlIGl0IHRvIGBjcnlwdG9Ob2RlLmpzYC5cbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIkBub2JsZS9jaXBoZXJzL2NyeXB0b1wiKTtcbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5mdW5jdGlvbiByYW5kb21CeXRlcyhieXRlc0xlbmd0aCA9IDMyKSB7XG4gICAgaWYgKGNyeXB0b18xLmNyeXB0byAmJiB0eXBlb2YgY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvXzEuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheShieXRlc0xlbmd0aCkpO1xuICAgIH1cbiAgICAvLyBMZWdhY3kgTm9kZS5qcyBjb21wYXRpYmlsaXR5XG4gICAgaWYgKGNyeXB0b18xLmNyeXB0byAmJiB0eXBlb2YgY3J5cHRvXzEuY3J5cHRvLnJhbmRvbUJ5dGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG9fMS5jcnlwdG8ucmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGgpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBnZXRXZWJjcnlwdG9TdWJ0bGUoKSB7XG4gICAgaWYgKGNyeXB0b18xLmNyeXB0byAmJiB0eXBlb2YgY3J5cHRvXzEuY3J5cHRvLnN1YnRsZSA9PT0gJ29iamVjdCcgJiYgY3J5cHRvXzEuY3J5cHRvLnN1YnRsZSAhPSBudWxsKVxuICAgICAgICByZXR1cm4gY3J5cHRvXzEuY3J5cHRvLnN1YnRsZTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5zdWJ0bGUgbXVzdCBiZSBkZWZpbmVkJyk7XG59XG4vLyBVc2VzIENTUFJHIGZvciBub25jZSwgbm9uY2UgaW5qZWN0ZWQgaW4gY2lwaGVydGV4dFxuZnVuY3Rpb24gbWFuYWdlZE5vbmNlKGZuKSB7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5udW1iZXIpKGZuLm5vbmNlTGVuZ3RoKTtcbiAgICByZXR1cm4gKChrZXksIC4uLmFyZ3MpID0+ICh7XG4gICAgICAgIGVuY3J5cHQocGxhaW50ZXh0LCAuLi5hcmdzRW5jKSB7XG4gICAgICAgICAgICBjb25zdCB7IG5vbmNlTGVuZ3RoIH0gPSBmbjtcbiAgICAgICAgICAgIGNvbnN0IG5vbmNlID0gcmFuZG9tQnl0ZXMobm9uY2VMZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IGZuKGtleSwgbm9uY2UsIC4uLmFyZ3MpLmVuY3J5cHQocGxhaW50ZXh0LCAuLi5hcmdzRW5jKTtcbiAgICAgICAgICAgIGNvbnN0IG91dCA9ICgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKShub25jZSwgY2lwaGVydGV4dCk7XG4gICAgICAgICAgICBjaXBoZXJ0ZXh0LmZpbGwoMCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICB9LFxuICAgICAgICBkZWNyeXB0KGNpcGhlcnRleHQsIC4uLmFyZ3NEZWMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9uY2VMZW5ndGggfSA9IGZuO1xuICAgICAgICAgICAgY29uc3Qgbm9uY2UgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KDAsIG5vbmNlTGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KG5vbmNlTGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBmbihrZXksIG5vbmNlLCAuLi5hcmdzKS5kZWNyeXB0KGRhdGEsIC4uLmFyZ3NEZWMpO1xuICAgICAgICB9LFxuICAgIH0pKTtcbn1cbi8vIE92ZXJyaWRhYmxlXG5leHBvcnRzLnV0aWxzID0ge1xuICAgIGFzeW5jIGVuY3J5cHQoa2V5LCBrZXlQYXJhbXMsIGNyeXB0UGFyYW1zLCBwbGFpbnRleHQpIHtcbiAgICAgICAgY29uc3QgY3IgPSBnZXRXZWJjcnlwdG9TdWJ0bGUoKTtcbiAgICAgICAgY29uc3QgaUtleSA9IGF3YWl0IGNyLmltcG9ydEtleSgncmF3Jywga2V5LCBrZXlQYXJhbXMsIHRydWUsIFsnZW5jcnlwdCddKTtcbiAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IGF3YWl0IGNyLmVuY3J5cHQoY3J5cHRQYXJhbXMsIGlLZXksIHBsYWludGV4dCk7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShjaXBoZXJ0ZXh0KTtcbiAgICB9LFxuICAgIGFzeW5jIGRlY3J5cHQoa2V5LCBrZXlQYXJhbXMsIGNyeXB0UGFyYW1zLCBjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIGNvbnN0IGNyID0gZ2V0V2ViY3J5cHRvU3VidGxlKCk7XG4gICAgICAgIGNvbnN0IGlLZXkgPSBhd2FpdCBjci5pbXBvcnRLZXkoJ3JhdycsIGtleSwga2V5UGFyYW1zLCB0cnVlLCBbJ2RlY3J5cHQnXSk7XG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IGF3YWl0IGNyLmRlY3J5cHQoY3J5cHRQYXJhbXMsIGlLZXksIGNpcGhlcnRleHQpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0KTtcbiAgICB9LFxufTtcbmNvbnN0IG1vZGUgPSB7XG4gICAgQ0JDOiAnQUVTLUNCQycsXG4gICAgQ1RSOiAnQUVTLUNUUicsXG4gICAgR0NNOiAnQUVTLUdDTScsXG59O1xuZnVuY3Rpb24gZ2V0Q3J5cHRQYXJhbXMoYWxnbywgbm9uY2UsIEFBRCkge1xuICAgIGlmIChhbGdvID09PSBtb2RlLkNCQylcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogbW9kZS5DQkMsIGl2OiBub25jZSB9O1xuICAgIGlmIChhbGdvID09PSBtb2RlLkNUUilcbiAgICAgICAgcmV0dXJuIHsgbmFtZTogbW9kZS5DVFIsIGNvdW50ZXI6IG5vbmNlLCBsZW5ndGg6IDY0IH07XG4gICAgaWYgKGFsZ28gPT09IG1vZGUuR0NNKSB7XG4gICAgICAgIGlmIChBQUQpXG4gICAgICAgICAgICByZXR1cm4geyBuYW1lOiBtb2RlLkdDTSwgaXY6IG5vbmNlLCBhZGRpdGlvbmFsRGF0YTogQUFEIH07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWU6IG1vZGUuR0NNLCBpdjogbm9uY2UgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCd1bmtub3duIGFlcyBibG9jayBtb2RlJyk7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZShhbGdvKSB7XG4gICAgcmV0dXJuIChrZXksIG5vbmNlLCBBQUQpID0+IHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykoa2V5KTtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykobm9uY2UpO1xuICAgICAgICBjb25zdCBrZXlQYXJhbXMgPSB7IG5hbWU6IGFsZ28sIGxlbmd0aDoga2V5Lmxlbmd0aCAqIDggfTtcbiAgICAgICAgY29uc3QgY3J5cHRQYXJhbXMgPSBnZXRDcnlwdFBhcmFtcyhhbGdvLCBub25jZSwgQUFEKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIGtleUxlbmd0aCxcbiAgICAgICAgICAgIGVuY3J5cHQocGxhaW50ZXh0KSB7XG4gICAgICAgICAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykocGxhaW50ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy51dGlscy5lbmNyeXB0KGtleSwga2V5UGFyYW1zLCBjcnlwdFBhcmFtcywgcGxhaW50ZXh0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNyeXB0KGNpcGhlcnRleHQpIHtcbiAgICAgICAgICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShjaXBoZXJ0ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy51dGlscy5kZWNyeXB0KGtleSwga2V5UGFyYW1zLCBjcnlwdFBhcmFtcywgY2lwaGVydGV4dCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG59XG5leHBvcnRzLmNiYyA9IGdlbmVyYXRlKG1vZGUuQ0JDKTtcbmV4cG9ydHMuY3RyID0gZ2VuZXJhdGUobW9kZS5DVFIpO1xuZXhwb3J0cy5nY20gPSBnZW5lcmF0ZShtb2RlLkdDTSk7XG4vLyAvLyBUeXBlIHRlc3RzXG4vLyBpbXBvcnQgeyBzaXYsIGdjbSwgY3RyLCBlY2IsIGNiYyB9IGZyb20gJy4uL2Flcy5qcyc7XG4vLyBpbXBvcnQgeyB4c2Fsc2EyMHBvbHkxMzA1IH0gZnJvbSAnLi4vc2Fsc2EuanMnO1xuLy8gaW1wb3J0IHsgY2hhY2hhMjBwb2x5MTMwNSwgeGNoYWNoYTIwcG9seTEzMDUgfSBmcm9tICcuLi9jaGFjaGEuanMnO1xuLy8gY29uc3Qgd3NpdiA9IG1hbmFnZWROb25jZShzaXYpO1xuLy8gY29uc3Qgd2djbSA9IG1hbmFnZWROb25jZShnY20pO1xuLy8gY29uc3Qgd2N0ciA9IG1hbmFnZWROb25jZShjdHIpO1xuLy8gY29uc3Qgd2NiYyA9IG1hbmFnZWROb25jZShjYmMpO1xuLy8gY29uc3Qgd3NhbHNhcG9seSA9IG1hbmFnZWROb25jZSh4c2Fsc2EyMHBvbHkxMzA1KTtcbi8vIGNvbnN0IHdjaGFjaGEgPSBtYW5hZ2VkTm9uY2UoY2hhY2hhMjBwb2x5MTMwNSk7XG4vLyBjb25zdCB3eGNoYWNoYSA9IG1hbmFnZWROb25jZSh4Y2hhY2hhMjBwb2x5MTMwNSk7XG4vLyAvLyBzaG91bGQgZmFpbFxuLy8gY29uc3Qgd2NiYzIgPSBtYW5hZ2VkTm9uY2UobWFuYWdlZE5vbmNlKGNiYykpO1xuLy8gY29uc3Qgd2N0ciA9IG1hbmFnZWROb25jZShjdHIpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViY3J5cHRvLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0J5dGVzID0gaXNCeXRlcztcbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuZXhwb3J0cy5ib29sID0gYm9vbDtcbmV4cG9ydHMuYnl0ZXMgPSBieXRlcztcbmV4cG9ydHMuaGFzaCA9IGhhc2g7XG5leHBvcnRzLmV4aXN0cyA9IGV4aXN0cztcbmV4cG9ydHMub3V0cHV0ID0gb3V0cHV0O1xuZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBvc2l0aXZlIGludGVnZXIgZXhwZWN0ZWQsIG5vdCAke259YCk7XG59XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBib29sZWFuIGV4cGVjdGVkLCBub3QgJHtifWApO1xufVxuLy8gY29waWVkIGZyb20gdXRpbHNcbmZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbmZ1bmN0aW9uIGJ5dGVzKGIsIC4uLmxlbmd0aHMpIHtcbiAgICBpZiAoIWlzQnl0ZXMoYikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xuICAgIGlmIChsZW5ndGhzLmxlbmd0aCA+IDAgJiYgIWxlbmd0aHMuaW5jbHVkZXMoYi5sZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVpbnQ4QXJyYXkgZXhwZWN0ZWQgb2YgbGVuZ3RoICR7bGVuZ3Roc30sIG5vdCBvZiBsZW5ndGg9JHtiLmxlbmd0aH1gKTtcbn1cbmZ1bmN0aW9uIGhhc2goaCkge1xuICAgIGlmICh0eXBlb2YgaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoLmJsb2NrTGVuKTtcbn1cbmZ1bmN0aW9uIGV4aXN0cyhpbnN0YW5jZSwgY2hlY2tGaW5pc2hlZCA9IHRydWUpIHtcbiAgICBpZiAoaW5zdGFuY2UuZGVzdHJveWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkJyk7XG4gICAgaWYgKGNoZWNrRmluaXNoZWQgJiYgaW5zdGFuY2UuZmluaXNoZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCNkaWdlc3QoKSBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZCcpO1xufVxuZnVuY3Rpb24gb3V0cHV0KG91dCwgaW5zdGFuY2UpIHtcbiAgICBieXRlcyhvdXQpO1xuICAgIGNvbnN0IG1pbiA9IGluc3RhbmNlLm91dHB1dExlbjtcbiAgICBpZiAob3V0Lmxlbmd0aCA8IG1pbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0ICR7bWlufWApO1xuICAgIH1cbn1cbmNvbnN0IGFzc2VydCA9IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmV4cG9ydHMuZGVmYXVsdCA9IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyeXB0byA9IHZvaWQgMDtcbmV4cG9ydHMuY3J5cHRvID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGFzaCA9IGV4cG9ydHMubmV4dFRpY2sgPSBleHBvcnRzLmJ5dGVTd2FwSWZCRSA9IGV4cG9ydHMuYnl0ZVN3YXAgPSBleHBvcnRzLmlzTEUgPSBleHBvcnRzLnJvdGwgPSBleHBvcnRzLnJvdHIgPSBleHBvcnRzLmNyZWF0ZVZpZXcgPSBleHBvcnRzLnUzMiA9IGV4cG9ydHMudTggPSB2b2lkIDA7XG5leHBvcnRzLmlzQnl0ZXMgPSBpc0J5dGVzO1xuZXhwb3J0cy5ieXRlU3dhcDMyID0gYnl0ZVN3YXAzMjtcbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG5leHBvcnRzLmhleFRvQnl0ZXMgPSBoZXhUb0J5dGVzO1xuZXhwb3J0cy5hc3luY0xvb3AgPSBhc3luY0xvb3A7XG5leHBvcnRzLnV0ZjhUb0J5dGVzID0gdXRmOFRvQnl0ZXM7XG5leHBvcnRzLnRvQnl0ZXMgPSB0b0J5dGVzO1xuZXhwb3J0cy5jb25jYXRCeXRlcyA9IGNvbmNhdEJ5dGVzO1xuZXhwb3J0cy5jaGVja09wdHMgPSBjaGVja09wdHM7XG5leHBvcnRzLndyYXBDb25zdHJ1Y3RvciA9IHdyYXBDb25zdHJ1Y3RvcjtcbmV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aE9wdHMgPSB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cztcbmV4cG9ydHMud3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMgPSB3cmFwWE9GQ29uc3RydWN0b3JXaXRoT3B0cztcbmV4cG9ydHMucmFuZG9tQnl0ZXMgPSByYW5kb21CeXRlcztcbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCAoMjAyNS0wNC0zMCksIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmNvbnN0IGNyeXB0b18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvY3J5cHRvXCIpO1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbi8vIGV4cG9ydCB7IGlzQnl0ZXMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuLy8gV2UgY2FuJ3QgcmV1c2UgaXNCeXRlcyBmcm9tIF9hc3NlcnQsIGJlY2F1c2Ugc29tZWhvdyB0aGlzIGNhdXNlcyBodWdlIHBlcmYgaXNzdWVzXG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5jb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnRzLnU4ID0gdTg7XG5jb25zdCB1MzIgPSAoYXJyKSA9PiBuZXcgVWludDMyQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIE1hdGguZmxvb3IoYXJyLmJ5dGVMZW5ndGggLyA0KSk7XG5leHBvcnRzLnUzMiA9IHUzMjtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0cy5jcmVhdGVWaWV3ID0gY3JlYXRlVmlldztcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG5leHBvcnRzLnJvdHIgPSByb3RyO1xuLy8gVGhlIHJvdGF0ZSBsZWZ0IChjaXJjdWxhciBsZWZ0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuY29uc3Qgcm90bCA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgc2hpZnQpIHwgKCh3b3JkID4+PiAoMzIgLSBzaGlmdCkpID4+PiAwKTtcbmV4cG9ydHMucm90bCA9IHJvdGw7XG5leHBvcnRzLmlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuLy8gVGhlIGJ5dGUgc3dhcCBvcGVyYXRpb24gZm9yIHVpbnQzMlxuY29uc3QgYnl0ZVN3YXAgPSAod29yZCkgPT4gKCh3b3JkIDw8IDI0KSAmIDB4ZmYwMDAwMDApIHxcbiAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICgod29yZCA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAoKHdvcmQgPj4+IDI0KSAmIDB4ZmYpO1xuZXhwb3J0cy5ieXRlU3dhcCA9IGJ5dGVTd2FwO1xuLy8gQ29uZGl0aW9uYWxseSBieXRlIHN3YXAgaWYgb24gYSBiaWctZW5kaWFuIHBsYXRmb3JtXG5leHBvcnRzLmJ5dGVTd2FwSWZCRSA9IGV4cG9ydHMuaXNMRSA/IChuKSA9PiBuIDogKG4pID0+ICgwLCBleHBvcnRzLmJ5dGVTd2FwKShuKTtcbi8vIEluIHBsYWNlIGJ5dGUgc3dhcCBmb3IgVWludDMyQXJyYXlcbmZ1bmN0aW9uIGJ5dGVTd2FwMzIoYXJyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gKDAsIGV4cG9ydHMuYnl0ZVN3YXApKGFycltpXSk7XG4gICAgfVxufVxuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGJ5dGVzKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIF9BOiA2NSwgX0Y6IDcwLCBfYTogOTcsIF9mOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fMCAmJiBjaGFyIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBhc2NpaXMuXzA7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9BICYmIGNoYXIgPD0gYXNjaWlzLl9GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX0EgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9hICYmIGNoYXIgPD0gYXNjaWlzLl9mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX2EgLSAxMCk7XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIFRoZXJlIGlzIG5vIHNldEltbWVkaWF0ZSBpbiBicm93c2VyIGFuZCBzZXRUaW1lb3V0IGlzIHNsb3cuXG4vLyBjYWxsIG9mIGFzeW5jIGZuIHdpbGwgcmV0dXJuIFByb21pc2UsIHdoaWNoIHdpbGwgYmUgZnVsbGZpbGVkIG9ubHkgb25cbi8vIG5leHQgc2NoZWR1bGVyIHF1ZXVlIHByb2Nlc3Npbmcgc3RlcCBhbmQgdGhpcyBpcyBleGFjdGx5IHdoYXQgd2UgbmVlZC5cbmNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuZXhwb3J0cy5uZXh0VGljayA9IG5leHRUaWNrO1xuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0ICgwLCBleHBvcnRzLm5leHRUaWNrKSgpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZnVuY3Rpb24gdG9CeXRlcyhkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJylcbiAgICAgICAgZGF0YSA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykoYSk7XG4gICAgICAgIHN1bSArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoc3VtKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhID0gYXJyYXlzW2ldO1xuICAgICAgICByZXMuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5jbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmV4cG9ydHMuSGFzaCA9IEhhc2g7XG5jb25zdCB0b1N0ciA9IHt9LnRvU3RyaW5nO1xuZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiB0b1N0ci5jYWxsKG9wdHMpICE9PSAnW29iamVjdCBPYmplY3RdJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoT3B0cyhoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZywgb3B0cykgPT4gaGFzaENvbnMob3B0cykudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoe30pO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKG9wdHMpID0+IGhhc2hDb25zKG9wdHMpO1xuICAgIHJldHVybiBoYXNoQztcbn1cbmZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG9fMS5jcnlwdG8gJiYgdHlwZW9mIGNyeXB0b18xLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0b18xLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgLy8gTGVnYWN5IE5vZGUuanMgY29tcGF0aWJpbGl0eVxuICAgIGlmIChjcnlwdG9fMS5jcnlwdG8gJiYgdHlwZW9mIGNyeXB0b18xLmNyeXB0by5yYW5kb21CeXRlcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gY3J5cHRvXzEuY3J5cHRvLnJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhhc2hNRCA9IGV4cG9ydHMuTWFqID0gZXhwb3J0cy5DaGkgPSB2b2lkIDA7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLyoqXG4gKiBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG4gKi9cbmZ1bmN0aW9uIHNldEJpZ1VpbnQ2NCh2aWV3LCBieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSkge1xuICAgIGlmICh0eXBlb2Ygdmlldy5zZXRCaWdVaW50NjQgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiB2aWV3LnNldEJpZ1VpbnQ2NChieXRlT2Zmc2V0LCB2YWx1ZSwgaXNMRSk7XG4gICAgY29uc3QgXzMybiA9IEJpZ0ludCgzMik7XG4gICAgY29uc3QgX3UzMl9tYXggPSBCaWdJbnQoMHhmZmZmZmZmZik7XG4gICAgY29uc3Qgd2ggPSBOdW1iZXIoKHZhbHVlID4+IF8zMm4pICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IHdsID0gTnVtYmVyKHZhbHVlICYgX3UzMl9tYXgpO1xuICAgIGNvbnN0IGggPSBpc0xFID8gNCA6IDA7XG4gICAgY29uc3QgbCA9IGlzTEUgPyAwIDogNDtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgaCwgd2gsIGlzTEUpO1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBsLCB3bCwgaXNMRSk7XG59XG4vKipcbiAqIENob2ljZTogYSA/IGIgOiBjXG4gKi9cbmNvbnN0IENoaSA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKH5hICYgYyk7XG5leHBvcnRzLkNoaSA9IENoaTtcbi8qKlxuICogTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1dHMgaXMgdHJ1ZVxuICovXG5jb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuZXhwb3J0cy5NYWogPSBNYWo7XG4vKipcbiAqIE1lcmtsZS1EYW1nYXJkIGhhc2ggY29uc3RydWN0aW9uIGJhc2UgY2xhc3MuXG4gKiBDb3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBNRDUsIFJJUEVNRCwgU0hBMSwgU0hBMi5cbiAqL1xuY2xhc3MgSGFzaE1EIGV4dGVuZHMgdXRpbHNfanNfMS5IYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KSh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuZXhpc3RzKSh0aGlzKTtcbiAgICAgICAgY29uc3QgeyB2aWV3LCBidWZmZXIsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmV4aXN0cykodGhpcyk7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEub3V0cHV0KShvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpblxuICAgICAgICAvLyBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5leHBvcnRzLkhhc2hNRCA9IEhhc2hNRDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9tZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWRkNUwgPSBleHBvcnRzLmFkZDVIID0gZXhwb3J0cy5hZGQ0SCA9IGV4cG9ydHMuYWRkNEwgPSBleHBvcnRzLmFkZDNIID0gZXhwb3J0cy5hZGQzTCA9IGV4cG9ydHMucm90bEJMID0gZXhwb3J0cy5yb3RsQkggPSBleHBvcnRzLnJvdGxTTCA9IGV4cG9ydHMucm90bFNIID0gZXhwb3J0cy5yb3RyMzJMID0gZXhwb3J0cy5yb3RyMzJIID0gZXhwb3J0cy5yb3RyQkwgPSBleHBvcnRzLnJvdHJCSCA9IGV4cG9ydHMucm90clNMID0gZXhwb3J0cy5yb3RyU0ggPSBleHBvcnRzLnNoclNMID0gZXhwb3J0cy5zaHJTSCA9IGV4cG9ydHMudG9CaWcgPSB2b2lkIDA7XG5leHBvcnRzLmZyb21CaWcgPSBmcm9tQmlnO1xuZXhwb3J0cy5zcGxpdCA9IHNwbGl0O1xuZXhwb3J0cy5hZGQgPSBhZGQ7XG5jb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuZXhwb3J0cy50b0JpZyA9IHRvQmlnO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuZXhwb3J0cy5zaHJTSCA9IHNoclNIO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuZXhwb3J0cy5zaHJTTCA9IHNoclNMO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuZXhwb3J0cy5yb3RyU0ggPSByb3RyU0g7XG5jb25zdCByb3RyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuZXhwb3J0cy5yb3RyU0wgPSByb3RyU0w7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmV4cG9ydHMucm90ckJIID0gcm90ckJIO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG5leHBvcnRzLnJvdHJCTCA9IHJvdHJCTDtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3Igc2hpZnQ9PT0zMiAoanVzdCBzd2FwcyBsJmgpXG5jb25zdCByb3RyMzJIID0gKF9oLCBsKSA9PiBsO1xuZXhwb3J0cy5yb3RyMzJIID0gcm90cjMySDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG5leHBvcnRzLnJvdHIzMkwgPSByb3RyMzJMO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5leHBvcnRzLnJvdGxTSCA9IHJvdGxTSDtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG5leHBvcnRzLnJvdGxTTCA9IHJvdGxTTDtcbi8vIExlZnQgcm90YXRlIGZvciBTaGlmdCBpbiAoMzIsIDY0KSwgTk9URTogMzIgaXMgc3BlY2lhbCBjYXNlLlxuY29uc3Qgcm90bEJIID0gKGgsIGwsIHMpID0+IChsIDw8IChzIC0gMzIpKSB8IChoID4+PiAoNjQgLSBzKSk7XG5leHBvcnRzLnJvdGxCSCA9IHJvdGxCSDtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuZXhwb3J0cy5yb3RsQkwgPSByb3RsQkw7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5leHBvcnRzLmFkZDNMID0gYWRkM0w7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmV4cG9ydHMuYWRkM0ggPSBhZGQzSDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuZXhwb3J0cy5hZGQ0TCA9IGFkZDRMO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5leHBvcnRzLmFkZDRIID0gYWRkNEg7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuZXhwb3J0cy5hZGQ1TCA9IGFkZDVMO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5leHBvcnRzLmFkZDVIID0gYWRkNUg7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IHU2NCA9IHtcbiAgICBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsXG4gICAgc2hyU0gsIHNoclNMLFxuICAgIHJvdHJTSCwgcm90clNMLCByb3RyQkgsIHJvdHJCTCxcbiAgICByb3RyMzJILCByb3RyMzJMLFxuICAgIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCxcbiAgICBhZGQsIGFkZDNMLCBhZGQzSCwgYWRkNEwsIGFkZDRILCBhZGQ1SCwgYWRkNUwsXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gdTY0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3U2NC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2hhMzg0ID0gZXhwb3J0cy5zaGE1MTJfMjU2ID0gZXhwb3J0cy5zaGE1MTJfMjI0ID0gZXhwb3J0cy5zaGE1MTIgPSBleHBvcnRzLlNIQTM4NCA9IGV4cG9ydHMuU0hBNTEyXzI1NiA9IGV4cG9ydHMuU0hBNTEyXzIyNCA9IGV4cG9ydHMuU0hBNTEyID0gdm9pZCAwO1xuY29uc3QgX21kX2pzXzEgPSByZXF1aXJlKFwiLi9fbWQuanNcIik7XG5jb25zdCBfdTY0X2pzXzEgPSByZXF1aXJlKFwiLi9fdTY0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gUm91bmQgY29udGFudHMgKGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDgwIHByaW1lcyAyLi40MDkpOlxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBbU0hBNTEyX0toLCBTSEE1MTJfS2xdID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBfdTY0X2pzXzEuZGVmYXVsdC5zcGxpdChbXG4gICAgJzB4NDI4YTJmOThkNzI4YWUyMicsICcweDcxMzc0NDkxMjNlZjY1Y2QnLCAnMHhiNWMwZmJjZmVjNGQzYjJmJywgJzB4ZTliNWRiYTU4MTg5ZGJiYycsXG4gICAgJzB4Mzk1NmMyNWJmMzQ4YjUzOCcsICcweDU5ZjExMWYxYjYwNWQwMTknLCAnMHg5MjNmODJhNGFmMTk0ZjliJywgJzB4YWIxYzVlZDVkYTZkODExOCcsXG4gICAgJzB4ZDgwN2FhOThhMzAzMDI0MicsICcweDEyODM1YjAxNDU3MDZmYmUnLCAnMHgyNDMxODViZTRlZTRiMjhjJywgJzB4NTUwYzdkYzNkNWZmYjRlMicsXG4gICAgJzB4NzJiZTVkNzRmMjdiODk2ZicsICcweDgwZGViMWZlM2IxNjk2YjEnLCAnMHg5YmRjMDZhNzI1YzcxMjM1JywgJzB4YzE5YmYxNzRjZjY5MjY5NCcsXG4gICAgJzB4ZTQ5YjY5YzE5ZWYxNGFkMicsICcweGVmYmU0Nzg2Mzg0ZjI1ZTMnLCAnMHgwZmMxOWRjNjhiOGNkNWI1JywgJzB4MjQwY2ExY2M3N2FjOWM2NScsXG4gICAgJzB4MmRlOTJjNmY1OTJiMDI3NScsICcweDRhNzQ4NGFhNmVhNmU0ODMnLCAnMHg1Y2IwYTlkY2JkNDFmYmQ0JywgJzB4NzZmOTg4ZGE4MzExNTNiNScsXG4gICAgJzB4OTgzZTUxNTJlZTY2ZGZhYicsICcweGE4MzFjNjZkMmRiNDMyMTAnLCAnMHhiMDAzMjdjODk4ZmIyMTNmJywgJzB4YmY1OTdmYzdiZWVmMGVlNCcsXG4gICAgJzB4YzZlMDBiZjMzZGE4OGZjMicsICcweGQ1YTc5MTQ3OTMwYWE3MjUnLCAnMHgwNmNhNjM1MWUwMDM4MjZmJywgJzB4MTQyOTI5NjcwYTBlNmU3MCcsXG4gICAgJzB4MjdiNzBhODU0NmQyMmZmYycsICcweDJlMWIyMTM4NWMyNmM5MjYnLCAnMHg0ZDJjNmRmYzVhYzQyYWVkJywgJzB4NTMzODBkMTM5ZDk1YjNkZicsXG4gICAgJzB4NjUwYTczNTQ4YmFmNjNkZScsICcweDc2NmEwYWJiM2M3N2IyYTgnLCAnMHg4MWMyYzkyZTQ3ZWRhZWU2JywgJzB4OTI3MjJjODUxNDgyMzUzYicsXG4gICAgJzB4YTJiZmU4YTE0Y2YxMDM2NCcsICcweGE4MWE2NjRiYmM0MjMwMDEnLCAnMHhjMjRiOGI3MGQwZjg5NzkxJywgJzB4Yzc2YzUxYTMwNjU0YmUzMCcsXG4gICAgJzB4ZDE5MmU4MTlkNmVmNTIxOCcsICcweGQ2OTkwNjI0NTU2NWE5MTAnLCAnMHhmNDBlMzU4NTU3NzEyMDJhJywgJzB4MTA2YWEwNzAzMmJiZDFiOCcsXG4gICAgJzB4MTlhNGMxMTZiOGQyZDBjOCcsICcweDFlMzc2YzA4NTE0MWFiNTMnLCAnMHgyNzQ4Nzc0Y2RmOGVlYjk5JywgJzB4MzRiMGJjYjVlMTliNDhhOCcsXG4gICAgJzB4MzkxYzBjYjNjNWM5NWE2MycsICcweDRlZDhhYTRhZTM0MThhY2InLCAnMHg1YjljY2E0Zjc3NjNlMzczJywgJzB4NjgyZTZmZjNkNmIyYjhhMycsXG4gICAgJzB4NzQ4ZjgyZWU1ZGVmYjJmYycsICcweDc4YTU2MzZmNDMxNzJmNjAnLCAnMHg4NGM4NzgxNGExZjBhYjcyJywgJzB4OGNjNzAyMDgxYTY0MzllYycsXG4gICAgJzB4OTBiZWZmZmEyMzYzMWUyOCcsICcweGE0NTA2Y2ViZGU4MmJkZTknLCAnMHhiZWY5YTNmN2IyYzY3OTE1JywgJzB4YzY3MTc4ZjJlMzcyNTMyYicsXG4gICAgJzB4Y2EyNzNlY2VlYTI2NjE5YycsICcweGQxODZiOGM3MjFjMGMyMDcnLCAnMHhlYWRhN2RkNmNkZTBlYjFlJywgJzB4ZjU3ZDRmN2ZlZTZlZDE3OCcsXG4gICAgJzB4MDZmMDY3YWE3MjE3NmZiYScsICcweDBhNjM3ZGM1YTJjODk4YTYnLCAnMHgxMTNmOTgwNGJlZjkwZGFlJywgJzB4MWI3MTBiMzUxMzFjNDcxYicsXG4gICAgJzB4MjhkYjc3ZjUyMzA0N2Q4NCcsICcweDMyY2FhYjdiNDBjNzI0OTMnLCAnMHgzYzllYmUwYTE1YzliZWJjJywgJzB4NDMxZDY3YzQ5YzEwMGQ0YycsXG4gICAgJzB4NGNjNWQ0YmVjYjNlNDJiNicsICcweDU5N2YyOTljZmM2NTdlMmEnLCAnMHg1ZmNiNmZhYjNhZDZmYWVjJywgJzB4NmM0NDE5OGM0YTQ3NTgxNydcbl0ubWFwKG4gPT4gQmlnSW50KG4pKSkpKCk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbmNvbnN0IFNIQTUxMl9XX0ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNvbnN0IFNIQTUxMl9XX0wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNsYXNzIFNIQTUxMiBleHRlbmRzIF9tZF9qc18xLkhhc2hNRCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDEyOCwgNjQsIDE2LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGUgd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICAvLyBBbHNvIGxvb2tzIGNsZWFuZXIgYW5kIGVhc2llciB0byB2ZXJpZnkgd2l0aCBzcGVjLlxuICAgICAgICAvLyBJbml0aWFsIHN0YXRlIChmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5KTpcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4NmEwOWU2NjcgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhmM2JjYzkwOCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweGJiNjdhZTg1IHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4ODRjYWE3M2IgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgzYzZlZjM3MiB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweGZlOTRmODJiIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4YTU0ZmY1M2EgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1ZjFkMzZmMSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDUxMGU1MjdmIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4YWRlNjgyZDEgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg5YjA1Njg4YyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDJiM2U2YzFmIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4MWY4M2Q5YWIgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHhmYjQxYmQ2YiB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDViZTBjZDE5IHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4MTM3ZTIxNzkgfCAwO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGxdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwpIHtcbiAgICAgICAgdGhpcy5BaCA9IEFoIHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IEFsIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IEJoIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IEJsIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IENoIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IENsIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IERoIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IERsIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IEVoIHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IEVsIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IEZoIHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IEZsIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IEdoIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IEdsIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IEhoIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IEhsIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNjQgd29yZHMgd1sxNi4uNzldIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpIHtcbiAgICAgICAgICAgIFNIQTUxMl9XX0hbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQpO1xuICAgICAgICAgICAgU0hBNTEyX1dfTFtpXSA9IHZpZXcuZ2V0VWludDMyKChvZmZzZXQgKz0gNCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDgwOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHMwIDo9ICh3W2ktMTVdIHJpZ2h0cm90YXRlIDEpIHhvciAod1tpLTE1XSByaWdodHJvdGF0ZSA4KSB4b3IgKHdbaS0xNV0gcmlnaHRzaGlmdCA3KVxuICAgICAgICAgICAgY29uc3QgVzE1aCA9IFNIQTUxMl9XX0hbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBXMTVsID0gU0hBNTEyX1dfTFtpIC0gMTVdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMwaCA9IF91NjRfanNfMS5kZWZhdWx0LnJvdHJTSChXMTVoLCBXMTVsLCAxKSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJTSChXMTVoLCBXMTVsLCA4KSBeIF91NjRfanNfMS5kZWZhdWx0LnNoclNIKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgY29uc3QgczBsID0gX3U2NF9qc18xLmRlZmF1bHQucm90clNMKFcxNWgsIFcxNWwsIDEpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90clNMKFcxNWgsIFcxNWwsIDgpIF4gX3U2NF9qc18xLmRlZmF1bHQuc2hyU0woVzE1aCwgVzE1bCwgNyk7XG4gICAgICAgICAgICAvLyBzMSA6PSAod1tpLTJdIHJpZ2h0cm90YXRlIDE5KSB4b3IgKHdbaS0yXSByaWdodHJvdGF0ZSA2MSkgeG9yICh3W2ktMl0gcmlnaHRzaGlmdCA2KVxuICAgICAgICAgICAgY29uc3QgVzJoID0gU0hBNTEyX1dfSFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzJsID0gU0hBNTEyX1dfTFtpIC0gMl0gfCAwO1xuICAgICAgICAgICAgY29uc3QgczFoID0gX3U2NF9qc18xLmRlZmF1bHQucm90clNIKFcyaCwgVzJsLCAxOSkgXiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyQkgoVzJoLCBXMmwsIDYxKSBeIF91NjRfanNfMS5kZWZhdWx0LnNoclNIKFcyaCwgVzJsLCA2KTtcbiAgICAgICAgICAgIGNvbnN0IHMxbCA9IF91NjRfanNfMS5kZWZhdWx0LnJvdHJTTChXMmgsIFcybCwgMTkpIF4gX3U2NF9qc18xLmRlZmF1bHQucm90ckJMKFcyaCwgVzJsLCA2MSkgXiBfdTY0X2pzXzEuZGVmYXVsdC5zaHJTTChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICAvLyBTSEEyNTZfV1tpXSA9IHMwICsgczEgKyBTSEEyNTZfV1tpIC0gN10gKyBTSEEyNTZfV1tpIC0gMTZdO1xuICAgICAgICAgICAgY29uc3QgU1VNbCA9IF91NjRfanNfMS5kZWZhdWx0LmFkZDRMKHMwbCwgczFsLCBTSEE1MTJfV19MW2kgLSA3XSwgU0hBNTEyX1dfTFtpIC0gMTZdKTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWggPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQ0SChTVU1sLCBzMGgsIHMxaCwgU0hBNTEyX1dfSFtpIC0gN10sIFNIQTUxMl9XX0hbaSAtIDE2XSk7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gU1VNaCB8IDA7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gU1VNbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgODAgcm91bmRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gUzEgOj0gKGUgcmlnaHRyb3RhdGUgMTQpIHhvciAoZSByaWdodHJvdGF0ZSAxOCkgeG9yIChlIHJpZ2h0cm90YXRlIDQxKVxuICAgICAgICAgICAgY29uc3Qgc2lnbWExaCA9IF91NjRfanNfMS5kZWZhdWx0LnJvdHJTSChFaCwgRWwsIDE0KSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJTSChFaCwgRWwsIDE4KSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJCSChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWwgPSBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyU0woRWgsIEVsLCAxNCkgXiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyU0woRWgsIEVsLCAxOCkgXiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyQkwoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICAvL2NvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBDSEloID0gKEVoICYgRmgpIF4gKH5FaCAmIEdoKTtcbiAgICAgICAgICAgIGNvbnN0IENISWwgPSAoRWwgJiBGbCkgXiAofkVsICYgR2wpO1xuICAgICAgICAgICAgLy8gVDEgPSBIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBNTEyX0tbaV0gKyBTSEE1MTJfV1tpXVxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBUMWxsID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkNUwoSGwsIHNpZ21hMWwsIENISWwsIFNIQTUxMl9LbFtpXSwgU0hBNTEyX1dfTFtpXSk7XG4gICAgICAgICAgICBjb25zdCBUMWggPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQ1SChUMWxsLCBIaCwgc2lnbWExaCwgQ0hJaCwgU0hBNTEyX0toW2ldLCBTSEE1MTJfV19IW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IFQxbCA9IFQxbGwgfCAwO1xuICAgICAgICAgICAgLy8gUzAgOj0gKGEgcmlnaHRyb3RhdGUgMjgpIHhvciAoYSByaWdodHJvdGF0ZSAzNCkgeG9yIChhIHJpZ2h0cm90YXRlIDM5KVxuICAgICAgICAgICAgY29uc3Qgc2lnbWEwaCA9IF91NjRfanNfMS5kZWZhdWx0LnJvdHJTSChBaCwgQWwsIDI4KSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJCSChBaCwgQWwsIDM0KSBeIF91NjRfanNfMS5kZWZhdWx0LnJvdHJCSChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMGwgPSBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyU0woQWgsIEFsLCAyOCkgXiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyQkwoQWgsIEFsLCAzNCkgXiBfdTY0X2pzXzEuZGVmYXVsdC5yb3RyQkwoQWgsIEFsLCAzOSk7XG4gICAgICAgICAgICBjb25zdCBNQUpoID0gKEFoICYgQmgpIF4gKEFoICYgQ2gpIF4gKEJoICYgQ2gpO1xuICAgICAgICAgICAgY29uc3QgTUFKbCA9IChBbCAmIEJsKSBeIChBbCAmIENsKSBeIChCbCAmIENsKTtcbiAgICAgICAgICAgIEhoID0gR2ggfCAwO1xuICAgICAgICAgICAgSGwgPSBHbCB8IDA7XG4gICAgICAgICAgICBHaCA9IEZoIHwgMDtcbiAgICAgICAgICAgIEdsID0gRmwgfCAwO1xuICAgICAgICAgICAgRmggPSBFaCB8IDA7XG4gICAgICAgICAgICBGbCA9IEVsIHwgMDtcbiAgICAgICAgICAgICh7IGg6IEVoLCBsOiBFbCB9ID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkKERoIHwgMCwgRGwgfCAwLCBUMWggfCAwLCBUMWwgfCAwKSk7XG4gICAgICAgICAgICBEaCA9IENoIHwgMDtcbiAgICAgICAgICAgIERsID0gQ2wgfCAwO1xuICAgICAgICAgICAgQ2ggPSBCaCB8IDA7XG4gICAgICAgICAgICBDbCA9IEJsIHwgMDtcbiAgICAgICAgICAgIEJoID0gQWggfCAwO1xuICAgICAgICAgICAgQmwgPSBBbCB8IDA7XG4gICAgICAgICAgICBjb25zdCBBbGwgPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQzTChUMWwsIHNpZ21hMGwsIE1BSmwpO1xuICAgICAgICAgICAgQWggPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQzSChBbGwsIFQxaCwgc2lnbWEwaCwgTUFKaCk7XG4gICAgICAgICAgICBBbCA9IEFsbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgKHsgaDogQWgsIGw6IEFsIH0gPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQodGhpcy5BaCB8IDAsIHRoaXMuQWwgfCAwLCBBaCB8IDAsIEFsIHwgMCkpO1xuICAgICAgICAoeyBoOiBCaCwgbDogQmwgfSA9IF91NjRfanNfMS5kZWZhdWx0LmFkZCh0aGlzLkJoIHwgMCwgdGhpcy5CbCB8IDAsIEJoIHwgMCwgQmwgfCAwKSk7XG4gICAgICAgICh7IGg6IENoLCBsOiBDbCB9ID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkKHRoaXMuQ2ggfCAwLCB0aGlzLkNsIHwgMCwgQ2ggfCAwLCBDbCB8IDApKTtcbiAgICAgICAgKHsgaDogRGgsIGw6IERsIH0gPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQodGhpcy5EaCB8IDAsIHRoaXMuRGwgfCAwLCBEaCB8IDAsIERsIHwgMCkpO1xuICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IF91NjRfanNfMS5kZWZhdWx0LmFkZCh0aGlzLkVoIHwgMCwgdGhpcy5FbCB8IDAsIEVoIHwgMCwgRWwgfCAwKSk7XG4gICAgICAgICh7IGg6IEZoLCBsOiBGbCB9ID0gX3U2NF9qc18xLmRlZmF1bHQuYWRkKHRoaXMuRmggfCAwLCB0aGlzLkZsIHwgMCwgRmggfCAwLCBGbCB8IDApKTtcbiAgICAgICAgKHsgaDogR2gsIGw6IEdsIH0gPSBfdTY0X2pzXzEuZGVmYXVsdC5hZGQodGhpcy5HaCB8IDAsIHRoaXMuR2wgfCAwLCBHaCB8IDAsIEdsIHwgMCkpO1xuICAgICAgICAoeyBoOiBIaCwgbDogSGwgfSA9IF91NjRfanNfMS5kZWZhdWx0LmFkZCh0aGlzLkhoIHwgMCwgdGhpcy5IbCB8IDAsIEhoIHwgMCwgSGwgfCAwKSk7XG4gICAgICAgIHRoaXMuc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBNTEyX1dfSC5maWxsKDApO1xuICAgICAgICBTSEE1MTJfV19MLmZpbGwoMCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApO1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBNTEyID0gU0hBNTEyO1xuY2xhc3MgU0hBNTEyXzIyNCBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDhjM2QzN2M4IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4MTk1NDRkYTIgfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg3M2UxOTk2NiB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDg5ZGNkNGQ2IHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4MWRmYWI3YWUgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHgzMmZmOWM4MiB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDY3OWRkNTE0IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NTgyZjlmY2YgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHgwZjZkMmI2OSB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweDdiZDQ0ZGE4IHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4NzdlMzZmNzMgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHgwNGM0ODk0MiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDNmOWQ4NWE4IHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4NmExZDM2YzggfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHgxMTEyZTZhZCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDkxZDY5MmExIHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAyODtcbiAgICB9XG59XG5leHBvcnRzLlNIQTUxMl8yMjQgPSBTSEE1MTJfMjI0O1xuY2xhc3MgU0hBNTEyXzI1NiBleHRlbmRzIFNIQTUxMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDIyMzEyMTk0IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4ZmMyYmY3MmMgfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHg5ZjU1NWZhMyB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweGM4NGM2NGMyIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4MjM5M2I4NmIgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHg2ZjUzYjE1MSB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweDk2Mzg3NzE5IHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NTk0MGVhYmQgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg5NjI4M2VlMiB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGE4OGVmZmUzIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4YmU1ZTFlMjUgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHg1Mzg2Mzk5MiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDJiMDE5OWZjIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4MmM4NWI4YWEgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHgwZWI3MmRkYyB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDgxYzUyY2EyIHwgMDtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAzMjtcbiAgICB9XG59XG5leHBvcnRzLlNIQTUxMl8yNTYgPSBTSEE1MTJfMjU2O1xuY2xhc3MgU0hBMzg0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4Y2JiYjlkNWQgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDYyOWEyOTJhIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHg5MTU5MDE1YSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4MTUyZmVjZDggfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDY3MzMyNjY3IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg4ZWI0NGE4NyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4ZGIwYzJlMGQgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDQ3YjU0ODFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDQ4O1xuICAgIH1cbn1cbmV4cG9ydHMuU0hBMzg0ID0gU0hBMzg0O1xuZXhwb3J0cy5zaGE1MTIgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEE1MTIoKSk7XG5leHBvcnRzLnNoYTUxMl8yMjQgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEE1MTJfMjI0KCkpO1xuZXhwb3J0cy5zaGE1MTJfMjU2ID0gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgU0hBNTEyXzI1NigpKTtcbmV4cG9ydHMuc2hhMzg0ID0gKDAsIHV0aWxzX2pzXzEud3JhcENvbnN0cnVjdG9yKSgoKSA9PiBuZXcgU0hBMzg0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhNTEyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ub3RJbXBsZW1lbnRlZCA9IGV4cG9ydHMuYml0TWFzayA9IHZvaWQgMDtcbmV4cG9ydHMuaXNCeXRlcyA9IGlzQnl0ZXM7XG5leHBvcnRzLmFieXRlcyA9IGFieXRlcztcbmV4cG9ydHMuYWJvb2wgPSBhYm9vbDtcbmV4cG9ydHMuYnl0ZXNUb0hleCA9IGJ5dGVzVG9IZXg7XG5leHBvcnRzLm51bWJlclRvSGV4VW5wYWRkZWQgPSBudW1iZXJUb0hleFVucGFkZGVkO1xuZXhwb3J0cy5oZXhUb051bWJlciA9IGhleFRvTnVtYmVyO1xuZXhwb3J0cy5oZXhUb0J5dGVzID0gaGV4VG9CeXRlcztcbmV4cG9ydHMuYnl0ZXNUb051bWJlckJFID0gYnl0ZXNUb051bWJlckJFO1xuZXhwb3J0cy5ieXRlc1RvTnVtYmVyTEUgPSBieXRlc1RvTnVtYmVyTEU7XG5leHBvcnRzLm51bWJlclRvQnl0ZXNCRSA9IG51bWJlclRvQnl0ZXNCRTtcbmV4cG9ydHMubnVtYmVyVG9CeXRlc0xFID0gbnVtYmVyVG9CeXRlc0xFO1xuZXhwb3J0cy5udW1iZXJUb1ZhckJ5dGVzQkUgPSBudW1iZXJUb1ZhckJ5dGVzQkU7XG5leHBvcnRzLmVuc3VyZUJ5dGVzID0gZW5zdXJlQnl0ZXM7XG5leHBvcnRzLmNvbmNhdEJ5dGVzID0gY29uY2F0Qnl0ZXM7XG5leHBvcnRzLmVxdWFsQnl0ZXMgPSBlcXVhbEJ5dGVzO1xuZXhwb3J0cy51dGY4VG9CeXRlcyA9IHV0ZjhUb0J5dGVzO1xuZXhwb3J0cy5pblJhbmdlID0gaW5SYW5nZTtcbmV4cG9ydHMuYUluUmFuZ2UgPSBhSW5SYW5nZTtcbmV4cG9ydHMuYml0TGVuID0gYml0TGVuO1xuZXhwb3J0cy5iaXRHZXQgPSBiaXRHZXQ7XG5leHBvcnRzLmJpdFNldCA9IGJpdFNldDtcbmV4cG9ydHMuY3JlYXRlSG1hY0RyYmcgPSBjcmVhdGVIbWFjRHJiZztcbmV4cG9ydHMudmFsaWRhdGVPYmplY3QgPSB2YWxpZGF0ZU9iamVjdDtcbmV4cG9ydHMubWVtb2l6ZWQgPSBtZW1vaXplZDtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIDEwMCBsaW5lcyBvZiBjb2RlIGluIHRoZSBmaWxlIGFyZSBkdXBsaWNhdGVkIGZyb20gbm9ibGUtaGFzaGVzICh1dGlscykuXG4vLyBUaGlzIGlzIE9LOiBgYWJzdHJhY3RgIGRpcmVjdG9yeSBkb2VzIG5vdCB1c2Ugbm9ibGUtaGFzaGVzLlxuLy8gVXNlciBtYXkgb3B0LWluIGludG8gdXNpbmcgZGlmZmVyZW50IGhhc2hpbmcgbGlicmFyeS4gVGhpcyB3YXksIG5vYmxlLWhhc2hlc1xuLy8gd29uJ3QgYmUgaW5jbHVkZWQgaW50byB0aGVpciBidW5kbGUuXG5jb25zdCBfMG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDApO1xuY29uc3QgXzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMik7XG5mdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG5mdW5jdGlvbiBhYnl0ZXMoaXRlbSkge1xuICAgIGlmICghaXNCeXRlcyhpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG59XG5mdW5jdGlvbiBhYm9vbCh0aXRsZSwgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSB2YWxpZCBib29sZWFuLCBnb3QgXCIke3ZhbHVlfVwiLmApO1xufVxuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmZ1bmN0aW9uIG51bWJlclRvSGV4VW5wYWRkZWQobnVtKSB7XG4gICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG59XG5mdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgX0E6IDY1LCBfRjogNzAsIF9hOiA5NywgX2Y6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl8wICYmIGNoYXIgPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2hhciAtIGFzY2lpcy5fMDtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX0EgJiYgY2hhciA8PSBhc2NpaXMuX0YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX2EgJiYgY2hhciA8PSBhc2NpaXMuX2YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fYSAtIDEwKTtcbiAgICByZXR1cm47XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gQkU6IEJpZyBFbmRpYW4sIExFOiBMaXR0bGUgRW5kaWFuXG5mdW5jdGlvbiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpIHtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChieXRlcykpO1xufVxuZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0JFKG4sIGxlbikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzKG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KGxlbiAqIDIsICcwJykpO1xufVxuZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmZ1bmN0aW9uIG51bWJlclRvVmFyQnl0ZXNCRShuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtYmVyVG9IZXhVbnBhZGRlZChuKSk7XG59XG4vKipcbiAqIFRha2VzIGhleCBzdHJpbmcgb3IgVWludDhBcnJheSwgY29udmVydHMgdG8gVWludDhBcnJheS5cbiAqIFZhbGlkYXRlcyBvdXRwdXQgbGVuZ3RoLlxuICogV2lsbCB0aHJvdyBlcnJvciBmb3Igb3RoZXIgdHlwZXMuXG4gKiBAcGFyYW0gdGl0bGUgZGVzY3JpcHRpdmUgdGl0bGUgZm9yIGFuIGVycm9yIGUuZy4gJ3ByaXZhdGUga2V5J1xuICogQHBhcmFtIGhleCBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlcbiAqIEBwYXJhbSBleHBlY3RlZExlbmd0aCBvcHRpb25hbCwgd2lsbCBjb21wYXJlIHRvIHJlc3VsdCBhcnJheSdzIGxlbmd0aFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZW5zdXJlQnl0ZXModGl0bGUsIGhleCwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBsZXQgcmVzO1xuICAgIGlmICh0eXBlb2YgaGV4ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzID0gaGV4VG9CeXRlcyhoZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgdmFsaWQgaGV4IHN0cmluZywgZ290IFwiJHtoZXh9XCIuIENhdXNlOiAke2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCeXRlcyhoZXgpKSB7XG4gICAgICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcbiAgICAgICAgLy8gaXMgaW5zdGFuY2Ugb2YgVWludDhBcnJheSwgYW5kIGl0cyBzbGljZSgpIGNyZWF0ZXMgKiptdXRhYmxlKiogY29weVxuICAgICAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlgKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IGV4cGVjdGVkICR7ZXhwZWN0ZWRMZW5ndGh9IGJ5dGVzLCBnb3QgJHtsZW59YCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGFieXRlcyhhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gQ29tcGFyZXMgMiB1OGEtcyBpbiBraW5kYSBjb25zdGFudCB0aW1lXG5mdW5jdGlvbiBlcXVhbEJ5dGVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRpZmYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgZGlmZiB8PSBhW2ldIF4gYltpXTtcbiAgICByZXR1cm4gZGlmZiA9PT0gMDtcbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vLyBJcyBwb3NpdGl2ZSBiaWdpbnRcbmNvbnN0IGlzUG9zQmlnID0gKG4pID0+IHR5cGVvZiBuID09PSAnYmlnaW50JyAmJiBfMG4gPD0gbjtcbmZ1bmN0aW9uIGluUmFuZ2UobiwgbWluLCBtYXgpIHtcbiAgICByZXR1cm4gaXNQb3NCaWcobikgJiYgaXNQb3NCaWcobWluKSAmJiBpc1Bvc0JpZyhtYXgpICYmIG1pbiA8PSBuICYmIG4gPCBtYXg7XG59XG4vKipcbiAqIEFzc2VydHMgbWluIDw9IG4gPCBtYXguIE5PVEU6IEl0J3MgPCBtYXggYW5kIG5vdCA8PSBtYXguXG4gKiBAZXhhbXBsZVxuICogYUluUmFuZ2UoJ3gnLCB4LCAxbiwgMjU2bik7IC8vIHdvdWxkIGFzc3VtZSB4IGlzIGluICgxbi4uMjU1bilcbiAqL1xuZnVuY3Rpb24gYUluUmFuZ2UodGl0bGUsIG4sIG1pbiwgbWF4KSB7XG4gICAgLy8gV2h5IG1pbiA8PSBuIDwgbWF4IGFuZCBub3QgYSAobWluIDwgbiA8IG1heCkgT1IgYiAobWluIDw9IG4gPD0gbWF4KT9cbiAgICAvLyBjb25zaWRlciBQPTI1Nm4sIG1pbj0wbiwgbWF4PVBcbiAgICAvLyAtIGEgZm9yIG1pbj0wIHdvdWxkIHJlcXVpcmUgLTE6ICAgICAgICAgIGBpblJhbmdlKCd4JywgeCwgLTFuLCBQKWBcbiAgICAvLyAtIGIgd291bGQgY29tbW9ubHkgcmVxdWlyZSBzdWJ0cmFjdGlvbjogIGBpblJhbmdlKCd4JywgeCwgMG4sIFAgLSAxbilgXG4gICAgLy8gLSBvdXIgd2F5IGlzIHRoZSBjbGVhbmVzdDogICAgICAgICAgICAgICBgaW5SYW5nZSgneCcsIHgsIDBuLCBQKVxuICAgIGlmICghaW5SYW5nZShuLCBtaW4sIG1heCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgdmFsaWQgJHt0aXRsZX06ICR7bWlufSA8PSBuIDwgJHttYXh9LCBnb3QgJHt0eXBlb2Ygbn0gJHtufWApO1xufVxuLy8gQml0IG9wZXJhdGlvbnNcbi8qKlxuICogQ2FsY3VsYXRlcyBhbW91bnQgb2YgYml0cyBpbiBhIGJpZ2ludC5cbiAqIFNhbWUgYXMgYG4udG9TdHJpbmcoMikubGVuZ3RoYFxuICovXG5mdW5jdGlvbiBiaXRMZW4obikge1xuICAgIGxldCBsZW47XG4gICAgZm9yIChsZW4gPSAwOyBuID4gXzBuOyBuID4+PSBfMW4sIGxlbiArPSAxKVxuICAgICAgICA7XG4gICAgcmV0dXJuIGxlbjtcbn1cbi8qKlxuICogR2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICogTk9URTogZmlyc3QgYml0IHBvc2l0aW9uIGlzIDAgKHNhbWUgYXMgYXJyYXlzKVxuICogU2FtZSBhcyBgISErQXJyYXkuZnJvbShuLnRvU3RyaW5nKDIpKS5yZXZlcnNlKClbcG9zXWBcbiAqL1xuZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gYml0U2V0KG4sIHBvcywgdmFsdWUpIHtcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIG1hc2sgZm9yIE4gYml0cy4gTm90IHVzaW5nICoqIG9wZXJhdG9yIHdpdGggYmlnaW50cyBiZWNhdXNlIG9mIG9sZCBlbmdpbmVzLlxuICogU2FtZSBhcyBCaWdJbnQoYDBiJHtBcnJheShpKS5maWxsKCcxJykuam9pbignJyl9YClcbiAqL1xuY29uc3QgYml0TWFzayA9IChuKSA9PiAoXzJuIDw8IEJpZ0ludChuIC0gMSkpIC0gXzFuO1xuZXhwb3J0cy5iaXRNYXNrID0gYml0TWFzaztcbi8vIERSQkdcbmNvbnN0IHU4biA9IChkYXRhKSA9PiBuZXcgVWludDhBcnJheShkYXRhKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG5jb25zdCB1OGZyID0gKGFycikgPT4gVWludDhBcnJheS5mcm9tKGFycik7IC8vIGFub3RoZXIgc2hvcnRjdXRcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBjcmVhdGVIbWFjRHJiZyhoYXNoTGVuLCBxQnl0ZUxlbiwgaG1hY0ZuKSB7XG4gICAgaWYgKHR5cGVvZiBoYXNoTGVuICE9PSAnbnVtYmVyJyB8fCBoYXNoTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIHFCeXRlTGVuICE9PSAnbnVtYmVyJyB8fCBxQnl0ZUxlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncUJ5dGVMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgaG1hY0ZuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2htYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAvLyBTdGVwIEIsIFN0ZXAgQzogc2V0IGhhc2hMZW4gdG8gOCpjZWlsKGhsZW4vOClcbiAgICBsZXQgdiA9IHU4bihoYXNoTGVuKTsgLy8gTWluaW1hbCBub24tZnVsbC1zcGVjIEhNQUMtRFJCRyBmcm9tIE5JU1QgODAwLTkwIGZvciBSRkM2OTc5IHNpZ3MuXG4gICAgbGV0IGsgPSB1OG4oaGFzaExlbik7IC8vIFN0ZXBzIEIgYW5kIEMgb2YgUkZDNjk3OSAzLjI6IHNldCBoYXNoTGVuLCBpbiBvdXIgY2FzZSBhbHdheXMgc2FtZVxuICAgIGxldCBpID0gMDsgLy8gSXRlcmF0aW9ucyBjb3VudGVyLCB3aWxsIHRocm93IHdoZW4gb3ZlciAxMDAwXG4gICAgY29uc3QgcmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIHYuZmlsbCgxKTtcbiAgICAgICAgay5maWxsKDApO1xuICAgICAgICBpID0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGggPSAoLi4uYikgPT4gaG1hY0ZuKGssIHYsIC4uLmIpOyAvLyBobWFjKGspKHYsIC4uLnZhbHVlcylcbiAgICBjb25zdCByZXNlZWQgPSAoc2VlZCA9IHU4bigpKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyByZXNlZWQoKSBmdW5jdGlvbi4gU3RlcHMgRC1HXG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDBdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OGZyKFsweDAxXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMSB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgfTtcbiAgICBjb25zdCBnZW4gPSAoKSA9PiB7XG4gICAgICAgIC8vIEhNQUMtRFJCRyBnZW5lcmF0ZSgpIGZ1bmN0aW9uXG4gICAgICAgIGlmIChpKysgPj0gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZHJiZzogdHJpZWQgMTAwMCB2YWx1ZXMnKTtcbiAgICAgICAgbGV0IGxlbiA9IDA7XG4gICAgICAgIGNvbnN0IG91dCA9IFtdO1xuICAgICAgICB3aGlsZSAobGVuIDwgcUJ5dGVMZW4pIHtcbiAgICAgICAgICAgIHYgPSBoKCk7XG4gICAgICAgICAgICBjb25zdCBzbCA9IHYuc2xpY2UoKTtcbiAgICAgICAgICAgIG91dC5wdXNoKHNsKTtcbiAgICAgICAgICAgIGxlbiArPSB2Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoLi4ub3V0KTtcbiAgICB9O1xuICAgIGNvbnN0IGdlblVudGlsID0gKHNlZWQsIHByZWQpID0+IHtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmVzZWVkKHNlZWQpOyAvLyBTdGVwcyBELUdcbiAgICAgICAgbGV0IHJlcyA9IHVuZGVmaW5lZDsgLy8gU3RlcCBIOiBncmluZCB1bnRpbCBrIGlzIGluIFsxLi5uLTFdXG4gICAgICAgIHdoaWxlICghKHJlcyA9IHByZWQoZ2VuKCkpKSlcbiAgICAgICAgICAgIHJlc2VlZCgpO1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgcmV0dXJuIGdlblVudGlsO1xufVxuLy8gVmFsaWRhdGluZyBjdXJ2ZXMgYW5kIGZpZWxkc1xuY29uc3QgdmFsaWRhdG9yRm5zID0ge1xuICAgIGJpZ2ludDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcsXG4gICAgZnVuY3Rpb246ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG4gICAgYm9vbGVhbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nLFxuICAgIHN0cmluZzogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycsXG4gICAgc3RyaW5nT3JVaW50OEFycmF5OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCBpc0J5dGVzKHZhbCksXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdmFsaWRhdG9ycywgb3B0VmFsaWRhdG9ycyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IChmaWVsZE5hbWUsIHR5cGUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tWYWwgPSB2YWxpZGF0b3JGbnNbdHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsaWRhdG9yIFwiJHt0eXBlfVwiLCBleHBlY3RlZCBmdW5jdGlvbmApO1xuICAgICAgICBjb25zdCB2YWwgPSBvYmplY3RbZmllbGROYW1lXTtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghY2hlY2tWYWwodmFsLCBvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFyYW0gJHtTdHJpbmcoZmllbGROYW1lKX09JHt2YWx9ICgke3R5cGVvZiB2YWx9KSwgZXhwZWN0ZWQgJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgZmFsc2UpO1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0VmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufVxuLy8gdmFsaWRhdGUgdHlwZSB0ZXN0c1xuLy8gY29uc3QgbzogeyBhOiBudW1iZXI7IGI6IG51bWJlcjsgYzogbnVtYmVyIH0gPSB7IGE6IDEsIGI6IDUsIGM6IDYgfTtcbi8vIGNvbnN0IHowID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnYmlnaW50JyB9KTsgLy8gT2shXG4vLyAvLyBTaG91bGQgZmFpbCB0eXBlLWNoZWNrXG4vLyBjb25zdCB6MSA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ3RtcCcgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejIgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MyA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgdGVzdDogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIGNvbnN0IHo0ID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLyoqXG4gKiB0aHJvd3Mgbm90IGltcGxlbWVudGVkIGVycm9yXG4gKi9cbmNvbnN0IG5vdEltcGxlbWVudGVkID0gKCkgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuZXhwb3J0cy5ub3RJbXBsZW1lbnRlZCA9IG5vdEltcGxlbWVudGVkO1xuLyoqXG4gKiBNZW1vaXplcyAoY2FjaGVzKSBjb21wdXRhdGlvbiByZXN1bHQuXG4gKiBVc2VzIFdlYWtNYXA6IHRoZSB2YWx1ZSBpcyBnb2luZyBhdXRvLWNsZWFuZWQgYnkgR0MgYWZ0ZXIgbGFzdCByZWZlcmVuY2UgaXMgcmVtb3ZlZC5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZWQoZm4pIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgIHJldHVybiAoYXJnLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IG1hcC5nZXQoYXJnKTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgY29uc3QgY29tcHV0ZWQgPSBmbihhcmcsIC4uLmFyZ3MpO1xuICAgICAgICBtYXAuc2V0KGFyZywgY29tcHV0ZWQpO1xuICAgICAgICByZXR1cm4gY29tcHV0ZWQ7XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc05lZ2F0aXZlTEUgPSB2b2lkIDA7XG5leHBvcnRzLm1vZCA9IG1vZDtcbmV4cG9ydHMucG93ID0gcG93O1xuZXhwb3J0cy5wb3cyID0gcG93MjtcbmV4cG9ydHMuaW52ZXJ0ID0gaW52ZXJ0O1xuZXhwb3J0cy50b25lbGxpU2hhbmtzID0gdG9uZWxsaVNoYW5rcztcbmV4cG9ydHMuRnBTcXJ0ID0gRnBTcXJ0O1xuZXhwb3J0cy52YWxpZGF0ZUZpZWxkID0gdmFsaWRhdGVGaWVsZDtcbmV4cG9ydHMuRnBQb3cgPSBGcFBvdztcbmV4cG9ydHMuRnBJbnZlcnRCYXRjaCA9IEZwSW52ZXJ0QmF0Y2g7XG5leHBvcnRzLkZwRGl2ID0gRnBEaXY7XG5leHBvcnRzLkZwTGVnZW5kcmUgPSBGcExlZ2VuZHJlO1xuZXhwb3J0cy5GcElzU3F1YXJlID0gRnBJc1NxdWFyZTtcbmV4cG9ydHMubkxlbmd0aCA9IG5MZW5ndGg7XG5leHBvcnRzLkZpZWxkID0gRmllbGQ7XG5leHBvcnRzLkZwU3FydE9kZCA9IEZwU3FydE9kZDtcbmV4cG9ydHMuRnBTcXJ0RXZlbiA9IEZwU3FydEV2ZW47XG5leHBvcnRzLmhhc2hUb1ByaXZhdGVTY2FsYXIgPSBoYXNoVG9Qcml2YXRlU2NhbGFyO1xuZXhwb3J0cy5nZXRGaWVsZEJ5dGVzTGVuZ3RoID0gZ2V0RmllbGRCeXRlc0xlbmd0aDtcbmV4cG9ydHMuZ2V0TWluSGFzaExlbmd0aCA9IGdldE1pbkhhc2hMZW5ndGg7XG5leHBvcnRzLm1hcEhhc2hUb0ZpZWxkID0gbWFwSGFzaFRvRmllbGQ7XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBVdGlsaXRpZXMgZm9yIG1vZHVsYXIgYXJpdGhtZXRpY3MgYW5kIGZpbml0ZSBmaWVsZHNcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfNG4gPSBCaWdJbnQoNCksIF81biA9IEJpZ0ludCg1KSwgXzhuID0gQmlnSW50KDgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfOW4gPSBCaWdJbnQoOSksIF8xNm4gPSBCaWdJbnQoMTYpO1xuLy8gQ2FsY3VsYXRlcyBhIG1vZHVsbyBiXG5mdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICogQGV4YW1wbGVcbiAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXG4gKi9cbi8vIFRPRE86IHVzZSBmaWVsZCB2ZXJzaW9uICYmIHJlbW92ZVxuZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIGlmIChtb2R1bG8gPD0gXzBuIHx8IHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyL21vZHVsbyA+IDAnKTtcbiAgICBpZiAobW9kdWxvID09PSBfMW4pXG4gICAgICAgIHJldHVybiBfMG47XG4gICAgbGV0IHJlcyA9IF8xbjtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcmVzID0gKHJlcyAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIG51bSA9IChudW0gKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gRG9lcyB4IF4gKDIgXiBwb3dlcikgbW9kIHAuIHBvdzIoMzAsIDQpID09IDMwIF4gKDIgXiA0KVxuZnVuY3Rpb24gcG93Mih4LCBwb3dlciwgbW9kdWxvKSB7XG4gICAgbGV0IHJlcyA9IHg7XG4gICAgd2hpbGUgKHBvd2VyLS0gPiBfMG4pIHtcbiAgICAgICAgcmVzICo9IHJlcztcbiAgICAgICAgcmVzICU9IG1vZHVsbztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsb1xuZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvKSB7XG4gICAgaWYgKG51bWJlciA9PT0gXzBuIHx8IG1vZHVsbyA8PSBfMG4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJzLCBnb3Qgbj0ke251bWJlcn0gbW9kPSR7bW9kdWxvfWApO1xuICAgIH1cbiAgICAvLyBFdWNsaWRlYW4gR0NEIGh0dHBzOi8vYnJpbGxpYW50Lm9yZy93aWtpL2V4dGVuZGVkLWV1Y2xpZGVhbi1hbGdvcml0aG0vXG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG4vKipcbiAqIFRvbmVsbGktU2hhbmtzIHNxdWFyZSByb290IHNlYXJjaCBhbGdvcml0aG0uXG4gKiAxLiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTIpXG4gKiAyLiBTcXVhcmUgUm9vdHMgZnJvbSAxOyAyNCwgNTEsIDEwIHRvIERhbiBTaGFua3NcbiAqIFdpbGwgc3RhcnQgYW4gaW5maW5pdGUgbG9vcCBpZiBmaWVsZCBvcmRlciBQIGlzIG5vdCBwcmltZS5cbiAqIEBwYXJhbSBQIGZpZWxkIG9yZGVyXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHRha2VzIGZpZWxkIEZwIChjcmVhdGVkIGZyb20gUCkgYW5kIG51bWJlciBuXG4gKi9cbmZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUCkge1xuICAgIC8vIExlZ2VuZHJlIGNvbnN0YW50OiB1c2VkIHRvIGNhbGN1bGF0ZSBMZWdlbmRyZSBzeW1ib2wgKGEgfCBwKSxcbiAgICAvLyB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICAgIC8vIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAgICBjb25zdCBsZWdlbmRyZUMgPSAoUCAtIF8xbikgLyBfMm47XG4gICAgbGV0IFEsIFMsIFo7XG4gICAgLy8gU3RlcCAxOiBCeSBmYWN0b3Jpbmcgb3V0IHBvd2VycyBvZiAyIGZyb20gcCAtIDEsXG4gICAgLy8gZmluZCBxIGFuZCBzIHN1Y2ggdGhhdCBwIC0gMSA9IHEqKDJecykgd2l0aCBxIG9kZFxuICAgIGZvciAoUSA9IFAgLSBfMW4sIFMgPSAwOyBRICUgXzJuID09PSBfMG47IFEgLz0gXzJuLCBTKyspXG4gICAgICAgIDtcbiAgICAvLyBTdGVwIDI6IFNlbGVjdCBhIG5vbi1zcXVhcmUgeiBzdWNoIHRoYXQgKHogfCBwKSDiiaEgLTEgYW5kIHNldCBjIOKJoSB6cVxuICAgIGZvciAoWiA9IF8ybjsgWiA8IFAgJiYgcG93KFosIGxlZ2VuZHJlQywgUCkgIT09IFAgLSBfMW47IForKylcbiAgICAgICAgO1xuICAgIC8vIEZhc3QtcGF0aFxuICAgIGlmIChTID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlGYXN0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBTbG93LXBhdGhcbiAgICBjb25zdCBRMWRpdjIgPSAoUSArIF8xbikgLyBfMm47XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlTbG93KEZwLCBuKSB7XG4gICAgICAgIC8vIFN0ZXAgMDogQ2hlY2sgdGhhdCBuIGlzIGluZGVlZCBhIHNxdWFyZTogKG4gfCBwKSBzaG91bGQgbm90IGJlIOKJoSAtMVxuICAgICAgICBpZiAoRnAucG93KG4sIGxlZ2VuZHJlQykgPT09IEZwLm5lZyhGcC5PTkUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICBsZXQgciA9IFM7XG4gICAgICAgIC8vIFRPRE86IHdpbGwgZmFpbCBhdCBGcDIvZXRjXG4gICAgICAgIGxldCBnID0gRnAucG93KEZwLm11bChGcC5PTkUsIFopLCBRKTsgLy8gd2lsbCB1cGRhdGUgYm90aCB4IGFuZCBiXG4gICAgICAgIGxldCB4ID0gRnAucG93KG4sIFExZGl2Mik7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBzcXVhcmUgcm9vdFxuICAgICAgICBsZXQgYiA9IEZwLnBvdyhuLCBRKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIGZ1ZGdlIGZhY3RvclxuICAgICAgICB3aGlsZSAoIUZwLmVxbChiLCBGcC5PTkUpKSB7XG4gICAgICAgICAgICBpZiAoRnAuZXFsKGIsIEZwLlpFUk8pKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcC5aRVJPOyAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub25lbGxpJUUyJTgwJTkzU2hhbmtzX2FsZ29yaXRobSAoNC4gSWYgdCA9IDAsIHJldHVybiByID0gMClcbiAgICAgICAgICAgIC8vIEZpbmQgbSBzdWNoIGJeKDJebSk9PTFcbiAgICAgICAgICAgIGxldCBtID0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IHQyID0gRnAuc3FyKGIpOyBtIDwgcjsgbSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZwLmVxbCh0MiwgRnAuT05FKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdDIgPSBGcC5zcXIodDIpOyAvLyB0MiAqPSB0MlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URTogci1tLTEgY2FuIGJlIGJpZ2dlciB0aGFuIDMyLCBuZWVkIHRvIGNvbnZlcnQgdG8gYmlnaW50IGJlZm9yZSBzaGlmdCwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmUgb3ZlcmZsb3dcbiAgICAgICAgICAgIGNvbnN0IGdlID0gRnAucG93KGcsIF8xbiA8PCBCaWdJbnQociAtIG0gLSAxKSk7IC8vIGdlID0gMl4oci1tLTEpXG4gICAgICAgICAgICBnID0gRnAuc3FyKGdlKTsgLy8gZyA9IGdlICogZ2VcbiAgICAgICAgICAgIHggPSBGcC5tdWwoeCwgZ2UpOyAvLyB4ICo9IGdlXG4gICAgICAgICAgICBiID0gRnAubXVsKGIsIGcpOyAvLyBiICo9IGdcbiAgICAgICAgICAgIHIgPSBtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG59XG5mdW5jdGlvbiBGcFNxcnQoUCkge1xuICAgIC8vIE5PVEU6IGRpZmZlcmVudCBhbGdvcml0aG1zIGNhbiBnaXZlIGRpZmZlcmVudCByb290cywgaXQgaXMgdXAgdG8gdXNlciB0byBkZWNpZGUgd2hpY2ggb25lIHRoZXkgd2FudC5cbiAgICAvLyBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAgICAvLyBQIOKJoSAzIChtb2QgNClcbiAgICAvLyDiiJpuID0gbl4oKFArMSkvNClcbiAgICBpZiAoUCAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIE5vdCBhbGwgcm9vdHMgcG9zc2libGUhXG4gICAgICAgIC8vIGNvbnN0IE9SREVSID1cbiAgICAgICAgLy8gICAweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWFhYm47XG4gICAgICAgIC8vIGNvbnN0IE5VTSA9IDcyMDU3NTk0MDM3OTI3ODE2bjtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICAvLyBUaHJvdyBpZiByb290KioyICE9IG5cbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEF0a2luIGFsZ29yaXRobSBmb3IgcSDiiaEgNSAobW9kIDgpLCBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTApXG4gICAgaWYgKFAgJSBfOG4gPT09IF81bikge1xuICAgICAgICBjb25zdCBjMSA9IChQIC0gXzVuKSAvIF84bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQ1bW9kOChGcCwgbikge1xuICAgICAgICAgICAgY29uc3QgbjIgPSBGcC5tdWwobiwgXzJuKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIGMxKTtcbiAgICAgICAgICAgIGNvbnN0IG52ID0gRnAubXVsKG4sIHYpO1xuICAgICAgICAgICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLm11bChudiwgRnAuc3ViKGksIEZwLk9ORSkpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUCDiiaEgOSAobW9kIDE2KVxuICAgIGlmIChQICUgXzE2biA9PT0gXzluKSB7XG4gICAgICAgIC8vIE5PVEU6IHRvbmVsbGkgaXMgdG9vIHNsb3cgZm9yIGJscy1GcDIgY2FsY3VsYXRpb25zIGV2ZW4gb24gc3RhcnRcbiAgICAgICAgLy8gTWVhbnMgd2UgY2Fubm90IHVzZSBzcXJ0IGZvciBjb25zdGFudHMgYXQgYWxsIVxuICAgICAgICAvL1xuICAgICAgICAvLyBjb25zdCBjMSA9IEZwLnNxcnQoRnAubmVnYXRlKEZwLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMiA9IEZwLnNxcnQoYzEpOyAgICAgICAgICAgICAgICAvLyAgMi4gYzIgPSBzcXJ0KGMxKSBpbiBGLCBpLmUuLCAoYzJeMikgPT0gYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjMyA9IEZwLnNxcnQoRnAubmVnYXRlKGMxKSk7ICAgICAvLyAgMy4gYzMgPSBzcXJ0KC1jMSkgaW4gRiwgaS5lLiwgKGMzXjIpID09IC1jMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGM0ID0gKFAgKyBfN24pIC8gXzE2bjsgICAgICAgICAgIC8vICA0LiBjNCA9IChxICsgNykgLyAxNiAgICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbiAgICAgICAgLy8gc3FydCA9ICh4KSA9PiB7XG4gICAgICAgIC8vICAgbGV0IHR2MSA9IEZwLnBvdyh4LCBjNCk7ICAgICAgICAgICAgIC8vICAxLiB0djEgPSB4XmM0XG4gICAgICAgIC8vICAgbGV0IHR2MiA9IEZwLm11bChjMSwgdHYxKTsgICAgICAgICAgIC8vICAyLiB0djIgPSBjMSAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IHR2MyA9IEZwLm11bChjMiwgdHYxKTsgICAgICAgICAvLyAgMy4gdHYzID0gYzIgKiB0djFcbiAgICAgICAgLy8gICBsZXQgdHY0ID0gRnAubXVsKGMzLCB0djEpOyAgICAgICAgICAgLy8gIDQuIHR2NCA9IGMzICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgZTEgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgNS4gIGUxID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTIgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MyksIHgpOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgdHYxID0gRnAuY21vdih0djEsIHR2MiwgZTEpOyAvLyAgNy4gdHYxID0gQ01PVih0djEsIHR2MiwgZTEpICAjIFNlbGVjdCB0djIgaWYgKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgdHYyID0gRnAuY21vdih0djQsIHR2MywgZTIpOyAvLyAgOC4gdHYyID0gQ01PVih0djQsIHR2MywgZTIpICAjIFNlbGVjdCB0djMgaWYgKHR2M14yKSA9PSB4XG4gICAgICAgIC8vICAgY29uc3QgZTMgPSBGcC5lcXVhbHMoRnAuc3F1YXJlKHR2MiksIHgpOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIC8vICAgcmV0dXJuIEZwLmNtb3YodHYxLCB0djIsIGUzKTsgLy8gIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgIyBTZWxlY3QgdGhlIHNxcnQgZnJvbSB0djEgYW5kIHR2MlxuICAgICAgICAvLyB9XG4gICAgfVxuICAgIC8vIE90aGVyIGNhc2VzOiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAgICByZXR1cm4gdG9uZWxsaVNoYW5rcyhQKTtcbn1cbi8vIExpdHRsZS1lbmRpYW4gY2hlY2sgZm9yIGZpcnN0IExFIGJpdCAobGFzdCBCRSBiaXQpO1xuY29uc3QgaXNOZWdhdGl2ZUxFID0gKG51bSwgbW9kdWxvKSA9PiAobW9kKG51bSwgbW9kdWxvKSAmIF8xbikgPT09IF8xbjtcbmV4cG9ydHMuaXNOZWdhdGl2ZUxFID0gaXNOZWdhdGl2ZUxFO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmZ1bmN0aW9uIHZhbGlkYXRlRmllbGQoZmllbGQpIHtcbiAgICBjb25zdCBpbml0aWFsID0ge1xuICAgICAgICBPUkRFUjogJ2JpZ2ludCcsXG4gICAgICAgIE1BU0s6ICdiaWdpbnQnLFxuICAgICAgICBCWVRFUzogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBCSVRTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gRklFTERfRklFTERTLnJlZHVjZSgobWFwLCB2YWwpID0+IHtcbiAgICAgICAgbWFwW3ZhbF0gPSAnZnVuY3Rpb24nO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0sIGluaXRpYWwpO1xuICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS52YWxpZGF0ZU9iamVjdCkoZmllbGQsIG9wdHMpO1xufVxuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbi8qKlxuICogU2FtZSBhcyBgcG93YCBidXQgZm9yIEZwOiBub24tY29uc3RhbnQtdGltZS5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqL1xuZnVuY3Rpb24gRnBQb3coZiwgbnVtLCBwb3dlcikge1xuICAgIC8vIFNob3VsZCBoYXZlIHNhbWUgc3BlZWQgYXMgcG93IGZvciBiaWdpbnRzXG4gICAgLy8gVE9ETzogYmVuY2htYXJrIVxuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlciA+IDAnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuIGYuT05FO1xuICAgIGlmIChwb3dlciA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIGxldCBwID0gZi5PTkU7XG4gICAgbGV0IGQgPSBudW07XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHAgPSBmLm11bChwLCBkKTtcbiAgICAgICAgZCA9IGYuc3FyKGQpO1xuICAgICAgICBwb3dlciA+Pj0gXzFuO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgaW52ZXJ0IGFuIGFycmF5IG9mIEZpZWxkIGVsZW1lbnRzLlxuICogYGludigwKWAgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAgaGVyZTogbWFrZSBzdXJlIHRvIHRocm93IGFuIGVycm9yLlxuICovXG5mdW5jdGlvbiBGcEludmVydEJhdGNoKGYsIG51bXMpIHtcbiAgICBjb25zdCB0bXAgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGFjYztcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBmLk9ORSk7XG4gICAgLy8gSW52ZXJ0IGxhc3QgZWxlbWVudFxuICAgIGNvbnN0IGludmVydGVkID0gZi5pbnYobGFzdE11bHRpcGxpZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGYubXVsKGFjYywgdG1wW2ldKTtcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBpbnZlcnRlZCk7XG4gICAgcmV0dXJuIHRtcDtcbn1cbmZ1bmN0aW9uIEZwRGl2KGYsIGxocywgcmhzKSB7XG4gICAgcmV0dXJuIGYubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBmLk9SREVSKSA6IGYuaW52KHJocykpO1xufVxuZnVuY3Rpb24gRnBMZWdlbmRyZShvcmRlcikge1xuICAgIC8vIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApLCBxdWFkcmF0aWMgcmVzaWR1ZVxuICAgIC8vIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKSwgcXVhZHJhdGljIG5vbiByZXNpZHVlXG4gICAgLy8gKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAgICBjb25zdCBsZWdlbmRyZUNvbnN0ID0gKG9yZGVyIC0gXzFuKSAvIF8ybjsgLy8gSW50ZWdlciBhcml0aG1ldGljXG4gICAgcmV0dXJuIChmLCB4KSA9PiBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxuZnVuY3Rpb24gRnBJc1NxdWFyZShmKSB7XG4gICAgY29uc3QgbGVnZW5kcmUgPSBGcExlZ2VuZHJlKGYuT1JERVIpO1xuICAgIHJldHVybiAoeCkgPT4ge1xuICAgICAgICBjb25zdCBwID0gbGVnZW5kcmUoZiwgeCk7XG4gICAgICAgIHJldHVybiBmLmVxbChwLCBmLlpFUk8pIHx8IGYuZXFsKHAsIGYuT05FKTtcbiAgICB9O1xufVxuLy8gQ1VSVkUubiBsZW5ndGhzXG5mdW5jdGlvbiBuTGVuZ3RoKG4sIG5CaXRMZW5ndGgpIHtcbiAgICAvLyBCaXQgc2l6ZSwgYnl0ZSBzaXplIG9mIENVUlZFLm5cbiAgICBjb25zdCBfbkJpdExlbmd0aCA9IG5CaXRMZW5ndGggIT09IHVuZGVmaW5lZCA/IG5CaXRMZW5ndGggOiBuLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBuQnl0ZUxlbmd0aCA9IE1hdGguY2VpbChfbkJpdExlbmd0aCAvIDgpO1xuICAgIHJldHVybiB7IG5CaXRMZW5ndGg6IF9uQml0TGVuZ3RoLCBuQnl0ZUxlbmd0aCB9O1xufVxuLyoqXG4gKiBJbml0aWFsaXplcyBhIGZpbml0ZSBmaWVsZCBvdmVyIHByaW1lLiAqKk5vbi1wcmltZXMgYXJlIG5vdCBzdXBwb3J0ZWQuKipcbiAqIERvIG5vdCBpbml0IGluIGxvb3A6IHNsb3cuIFZlcnkgZnJhZ2lsZTogYWx3YXlzIHJ1biBhIGJlbmNobWFyayBvbiBhIGNoYW5nZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbnM6XG4gKiAqIGEpIGRlbm9ybWFsaXplZCBvcGVyYXRpb25zIGxpa2UgbXVsTiBpbnN0ZWFkIG9mIG11bFxuICogKiBiKSBzYW1lIG9iamVjdCBzaGFwZTogbmV2ZXIgYWRkIG9yIHJlbW92ZSBrZXlzXG4gKiAqIGMpIE9iamVjdC5mcmVlemVcbiAqIE5PVEU6IG9wZXJhdGlvbnMgZG9uJ3QgY2hlY2sgJ2lzVmFsaWQnIGZvciBhbGwgZWxlbWVudHMgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsXG4gKiBpdCBpcyBjYWxsZXIgcmVzcG9uc2liaWxpdHkgdG8gY2hlY2sgdGhpcy5cbiAqIFRoaXMgaXMgbG93LWxldmVsIGNvZGUsIHBsZWFzZSBtYWtlIHN1cmUgeW91IGtub3cgd2hhdCB5b3UgZG9pbmcuXG4gKiBAcGFyYW0gT1JERVIgcHJpbWUgcG9zaXRpdmUgYmlnaW50XG4gKiBAcGFyYW0gYml0TGVuIGhvdyBtYW55IGJpdHMgdGhlIGZpZWxkIGNvbnN1bWVzXG4gKiBAcGFyYW0gaXNMRSAoZGVmOiBmYWxzZSkgaWYgZW5jb2RpbmcgLyBkZWNvZGluZyBzaG91bGQgYmUgaW4gbGl0dGxlLWVuZGlhblxuICogQHBhcmFtIHJlZGVmIG9wdGlvbmFsIGZhc3RlciByZWRlZmluaXRpb25zIG9mIHNxcnQgYW5kIG90aGVyIG1ldGhvZHNcbiAqL1xuZnVuY3Rpb24gRmllbGQoT1JERVIsIGJpdExlbiwgaXNMRSA9IGZhbHNlLCByZWRlZiA9IHt9KSB7XG4gICAgaWYgKE9SREVSIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBGaWVsZCBPUkRFUiA+IDAsIGdvdCAke09SREVSfWApO1xuICAgIGNvbnN0IHsgbkJpdExlbmd0aDogQklUUywgbkJ5dGVMZW5ndGg6IEJZVEVTIH0gPSBuTGVuZ3RoKE9SREVSLCBiaXRMZW4pO1xuICAgIGlmIChCWVRFUyA+IDIwNDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQgbGVuZ3RocyBvdmVyIDIwNDggYnl0ZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICBjb25zdCBzcXJ0UCA9IEZwU3FydChPUkRFUik7XG4gICAgY29uc3QgZiA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBPUkRFUixcbiAgICAgICAgQklUUyxcbiAgICAgICAgQllURVMsXG4gICAgICAgIE1BU0s6ICgwLCB1dGlsc19qc18xLmJpdE1hc2spKEJJVFMpLFxuICAgICAgICBaRVJPOiBfMG4sXG4gICAgICAgIE9ORTogXzFuLFxuICAgICAgICBjcmVhdGU6IChudW0pID0+IG1vZChudW0sIE9SREVSKSxcbiAgICAgICAgaXNWYWxpZDogKG51bSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAke3R5cGVvZiBudW19YCk7XG4gICAgICAgICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuICAgICAgICB9LFxuICAgICAgICBpczA6IChudW0pID0+IG51bSA9PT0gXzBuLFxuICAgICAgICBpc09kZDogKG51bSkgPT4gKG51bSAmIF8xbikgPT09IF8xbixcbiAgICAgICAgbmVnOiAobnVtKSA9PiBtb2QoLW51bSwgT1JERVIpLFxuICAgICAgICBlcWw6IChsaHMsIHJocykgPT4gbGhzID09PSByaHMsXG4gICAgICAgIHNxcjogKG51bSkgPT4gbW9kKG51bSAqIG51bSwgT1JERVIpLFxuICAgICAgICBhZGQ6IChsaHMsIHJocykgPT4gbW9kKGxocyArIHJocywgT1JERVIpLFxuICAgICAgICBzdWI6IChsaHMsIHJocykgPT4gbW9kKGxocyAtIHJocywgT1JERVIpLFxuICAgICAgICBtdWw6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIHJocywgT1JERVIpLFxuICAgICAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBGcFBvdyhmLCBudW0sIHBvd2VyKSxcbiAgICAgICAgZGl2OiAobGhzLCByaHMpID0+IG1vZChsaHMgKiBpbnZlcnQocmhzLCBPUkRFUiksIE9SREVSKSxcbiAgICAgICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGRvZXNuJ3Qgbm9ybWFsaXplXG4gICAgICAgIHNxck46IChudW0pID0+IG51bSAqIG51bSxcbiAgICAgICAgYWRkTjogKGxocywgcmhzKSA9PiBsaHMgKyByaHMsXG4gICAgICAgIHN1Yk46IChsaHMsIHJocykgPT4gbGhzIC0gcmhzLFxuICAgICAgICBtdWxOOiAobGhzLCByaHMpID0+IGxocyAqIHJocyxcbiAgICAgICAgaW52OiAobnVtKSA9PiBpbnZlcnQobnVtLCBPUkRFUiksXG4gICAgICAgIHNxcnQ6IHJlZGVmLnNxcnQgfHwgKChuKSA9PiBzcXJ0UChmLCBuKSksXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXG4gICAgICAgIC8vIFRPRE86IGRvIHdlIHJlYWxseSBuZWVkIGNvbnN0YW50IGNtb3Y/XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgY29uc3QtdGltZSBiaWdpbnRzIGFueXdheSwgc28gcHJvYmFibHkgd2lsbCBiZSBub3QgdmVyeSB1c2VmdWxcbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/ICgwLCB1dGlsc19qc18xLm51bWJlclRvQnl0ZXNMRSkobnVtLCBCWVRFUykgOiAoMCwgdXRpbHNfanNfMS5udW1iZXJUb0J5dGVzQkUpKG51bSwgQllURVMpKSxcbiAgICAgICAgZnJvbUJ5dGVzOiAoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRnAuZnJvbUJ5dGVzOiBleHBlY3RlZCAke0JZVEVTfSwgZ290ICR7Ynl0ZXMubGVuZ3RofWApO1xuICAgICAgICAgICAgcmV0dXJuIGlzTEUgPyAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyTEUpKGJ5dGVzKSA6ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkoYnl0ZXMpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xufVxuZnVuY3Rpb24gRnBTcXJ0T2RkKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gcm9vdCA6IEZwLm5lZyhyb290KTtcbn1cbmZ1bmN0aW9uIEZwU3FydEV2ZW4oRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmllbGQgZG9lc24ndCBoYXZlIGlzT2RkYCk7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyBGcC5uZWcocm9vdCkgOiByb290O1xufVxuLyoqXG4gKiBcIkNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBTYW1lIGFzIG1hcEtleVRvRmllbGQsIGJ1dCBhY2NlcHRzIGxlc3MgYnl0ZXMgKDQwIGluc3RlYWQgb2YgNDggZm9yIDMyLWJ5dGUgZmllbGQpLlxuICogV2hpY2ggbWFrZXMgaXQgc2xpZ2h0bHkgbW9yZSBiaWFzZWQsIGxlc3Mgc2VjdXJlLlxuICogQGRlcHJlY2F0ZWQgdXNlIG1hcEtleVRvRmllbGQgaW5zdGVhZFxuICovXG5mdW5jdGlvbiBoYXNoVG9Qcml2YXRlU2NhbGFyKGhhc2gsIGdyb3VwT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGhhc2ggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtoYXNoTGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyTEUpKGhhc2gpIDogKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFKShoYXNoKTtcbiAgICByZXR1cm4gbW9kKG51bSwgZ3JvdXBPcmRlciAtIF8xbikgKyBfMW47XG59XG4vKipcbiAqIFJldHVybnMgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIGNvbnN1bWVkIGJ5IHRoZSBmaWVsZCBlbGVtZW50LlxuICogRm9yIGV4YW1wbGUsIDMyIGJ5dGVzIGZvciB1c3VhbCAyNTYtYml0IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIGZpZWxkXG4gKi9cbmZ1bmN0aW9uIGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGlmICh0eXBlb2YgZmllbGRPcmRlciAhPT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgb3JkZXIgbXVzdCBiZSBiaWdpbnQnKTtcbiAgICBjb25zdCBiaXRMZW5ndGggPSBmaWVsZE9yZGVyLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGJpdExlbmd0aCAvIDgpO1xufVxuLyoqXG4gKiBSZXR1cm5zIG1pbmltYWwgYW1vdW50IG9mIGJ5dGVzIHRoYXQgY2FuIGJlIHNhZmVseSByZWR1Y2VkXG4gKiBieSBmaWVsZCBvcmRlci5cbiAqIFNob3VsZCBiZSAyXi0xMjggZm9yIDEyOC1iaXQgY3VydmUgc3VjaCBhcyBQMjU2LlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIHRhcmdldCBoYXNoXG4gKi9cbmZ1bmN0aW9uIGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmZ1bmN0aW9uIG1hcEhhc2hUb0ZpZWxkKGtleSwgZmllbGRPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBjb25zdCBmaWVsZExlbiA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgY29uc3QgbWluTGVuID0gZ2V0TWluSGFzaExlbmd0aChmaWVsZE9yZGVyKTtcbiAgICAvLyBObyBzbWFsbCBudW1iZXJzOiBuZWVkIHRvIHVuZGVyc3RhbmQgYmlhcyBzdG9yeS4gTm8gaHVnZSBudW1iZXJzOiBlYXNpZXIgdG8gZGV0ZWN0IEpTIHRpbWluZ3MuXG4gICAgaWYgKGxlbiA8IDE2IHx8IGxlbiA8IG1pbkxlbiB8fCBsZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtsZW59YCk7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRSkoa2V5KSA6ICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJMRSkoa2V5KTtcbiAgICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXG4gICAgY29uc3QgcmVkdWNlZCA9IG1vZChudW0sIGZpZWxkT3JkZXIgLSBfMW4pICsgXzFuO1xuICAgIHJldHVybiBpc0xFID8gKDAsIHV0aWxzX2pzXzEubnVtYmVyVG9CeXRlc0xFKShyZWR1Y2VkLCBmaWVsZExlbikgOiAoMCwgdXRpbHNfanNfMS5udW1iZXJUb0J5dGVzQkUpKHJlZHVjZWQsIGZpZWxkTGVuKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vZHVsYXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLndOQUYgPSB3TkFGO1xuZXhwb3J0cy5waXBwZW5nZXIgPSBwaXBwZW5nZXI7XG5leHBvcnRzLnZhbGlkYXRlQmFzaWMgPSB2YWxpZGF0ZUJhc2ljO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gQWJlbGlhbiBncm91cCB1dGlsaXRpZXNcbmNvbnN0IG1vZHVsYXJfanNfMSA9IHJlcXVpcmUoXCIuL21vZHVsYXIuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG4vLyBTaW5jZSBwb2ludHMgaW4gZGlmZmVyZW50IGdyb3VwcyBjYW5ub3QgYmUgZXF1YWwgKGRpZmZlcmVudCBvYmplY3QgY29uc3RydWN0b3IpLFxuLy8gd2UgY2FuIGhhdmUgc2luZ2xlIHBsYWNlIHRvIHN0b3JlIHByZWNvbXB1dGVzXG5jb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHBvaW50V2luZG93U2l6ZXMgPSBuZXcgV2Vha01hcCgpOyAvLyBUaGlzIGFsbG93cyB1c2UgbWFrZSBwb2ludHMgaW1tdXRhYmxlIChub3RoaW5nIGNoYW5nZXMgaW5zaWRlKVxuLy8gRWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gb2YgUG9pbnQgYnkgc2NhbGFyLiBGcmFnaWxlLlxuLy8gU2NhbGFycyBzaG91bGQgYWx3YXlzIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcjogdGhpcyBzaG91bGQgYmUgY2hlY2tlZCBpbnNpZGUgb2YgYSBjdXJ2ZSBpdHNlbGYuXG4vLyBDcmVhdGVzIHByZWNvbXB1dGF0aW9uIHRhYmxlcyBmb3IgZmFzdCBtdWx0aXBsaWNhdGlvbjpcbi8vIC0gcHJpdmF0ZSBzY2FsYXIgaXMgc3BsaXQgYnkgZml4ZWQgc2l6ZSB3aW5kb3dzIG9mIFcgYml0c1xuLy8gLSBldmVyeSB3aW5kb3cgcG9pbnQgaXMgY29sbGVjdGVkIGZyb20gd2luZG93J3MgdGFibGUgJiBhZGRlZCB0byBhY2N1bXVsYXRvclxuLy8gLSBzaW5jZSB3aW5kb3dzIGFyZSBkaWZmZXJlbnQsIHNhbWUgcG9pbnQgaW5zaWRlIHRhYmxlcyB3b24ndCBiZSBhY2Nlc3NlZCBtb3JlIHRoYW4gb25jZSBwZXIgY2FsY1xuLy8gLSBlYWNoIG11bHRpcGxpY2F0aW9uIGlzICdNYXRoLmNlaWwoQ1VSVkVfT1JERVIgLyDwnZGKKSArIDEnIHBvaW50IGFkZGl0aW9ucyAoZml4ZWQgZm9yIGFueSBzY2FsYXIpXG4vLyAtICsxIHdpbmRvdyBpcyBuZWNjZXNzYXJ5IGZvciB3TkFGXG4vLyAtIHdOQUYgcmVkdWNlcyB0YWJsZSBzaXplOiAyeCBsZXNzIG1lbW9yeSArIDJ4IGZhc3RlciBnZW5lcmF0aW9uLCBidXQgMTAlIHNsb3dlciBtdWx0aXBsaWNhdGlvblxuLy8gVE9ETzogUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LiBUaGlzIHdvdWxkIGFsbG93XG4vLyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG5mdW5jdGlvbiB3TkFGKGMsIGJpdHMpIHtcbiAgICBjb25zdCBjb25zdFRpbWVOZWdhdGUgPSAoY29uZGl0aW9uLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyBuZWcgOiBpdGVtO1xuICAgIH07XG4gICAgY29uc3QgdmFsaWRhdGVXID0gKFcpID0+IHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihXKSB8fCBXIDw9IDAgfHwgVyA+IGJpdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIHdpbmRvdyBzaXplPSR7V30sIHNob3VsZCBiZSBbMS4uJHtiaXRzfV1gKTtcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSAoVykgPT4ge1xuICAgICAgICB2YWxpZGF0ZVcoVyk7XG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoYml0cyAvIFcpICsgMTsgLy8gKzEsIGJlY2F1c2VcbiAgICAgICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgcmV0dXJuIHsgd2luZG93cywgd2luZG93U2l6ZSB9O1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3RUaW1lTmVnYXRlLFxuICAgICAgICAvLyBub24tY29uc3QgdGltZSBtdWx0aXBsaWNhdGlvbiBsYWRkZXJcbiAgICAgICAgdW5zYWZlTGFkZGVyKGVsbSwgbikge1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZCA9IGVsbTtcbiAgICAgICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBuID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cbiAgICAgICAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXG4gICAgICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICAgICAgICogMl4o8J2RiuKIkjEpICogKE1hdGguY2VpbCjwnZGbIC8g8J2RiikgKyAxKSwgd2hlcmU6XG4gICAgICAgICAqIC0g8J2RiiBpcyB0aGUgd2luZG93IHNpemVcbiAgICAgICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAgICAgKiBGb3IgYSAyNTYtYml0IGN1cnZlIGFuZCB3aW5kb3cgc2l6ZSA4LCB0aGUgbnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBpcyAxMjggKiAzMyA9IDQyMjQuXG4gICAgICAgICAqIEByZXR1cm5zIHByZWNvbXB1dGVkIHBvaW50IHRhYmxlcyBmbGF0dGVuZWQgdG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGVXaW5kb3coZWxtLCBXKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBwID0gZWxtO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBwO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICAvLyA9MSwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwID0gYmFzZS5kb3VibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRzIGVjIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICAgICAqIEBwYXJhbSBwcmVjb21wdXRlcyBwcmVjb21wdXRlZCB0YWJsZXNcbiAgICAgICAgICogQHBhcmFtIG4gc2NhbGFyICh3ZSBkb24ndCBjaGVjayBoZXJlLCBidXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcilcbiAgICAgICAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgd05BRihXLCBwcmVjb21wdXRlcywgbikge1xuICAgICAgICAgICAgLy8gVE9ETzogbWF5YmUgY2hlY2sgdGhhdCBzY2FsYXIgaXMgbGVzcyB0aGFuIGdyb3VwIG9yZGVyPyB3TkFGIGJlaGF2aW91cyBpcyB1bmRlZmluZWQgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBCdXQgbmVlZCB0byBjYXJlZnVsbHkgcmVtb3ZlIG90aGVyIGNoZWNrcyBiZWZvcmUgd05BRi4gT1JERVIgPT0gYml0cyBoZXJlXG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBmID0gYy5CQVNFO1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTsgLy8gQ3JlYXRlIG1hc2sgd2l0aCBXIG9uZXM6IDBiMTExMSBmb3IgVz00IGV0Yy5cbiAgICAgICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgICAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJpdHMgYXJlIGJpZ2dlciB0aGFuIG1heCBzaXplLCB3ZSdsbCBzcGxpdCB0aG9zZS5cbiAgICAgICAgICAgICAgICAvLyArMjI0ID0+IDI1NiAtIDMyXG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgb250byBaZXJvIHBvaW50LlxuICAgICAgICAgICAgICAgIC8vIEFkZCByYW5kb20gcG9pbnQgaW5zaWRlIGN1cnJlbnQgd2luZG93IHRvIGYuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQyID0gb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMSA9IHdpbmRvdyAlIDIgIT09IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleVxuICAgICAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBKSVQtY29tcGlsZXIgc2hvdWxkIG5vdCBlbGltaW5hdGUgZiBoZXJlLCBzaW5jZSBpdCB3aWxsIGxhdGVyIGJlIHVzZWQgaW4gbm9ybWFsaXplWigpXG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoZSB2YXJpYWJsZSBpcyBzdGlsbCB1bnVzZWQsIHRoZXJlIGFyZSBzb21lIGNoZWNrcyB3aGljaCB3aWxsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGNvbXBpbGVyIG5lZWRzIHRvIHByb3ZlIHRoZXkgd29uJ3QgaGFwcGVuLCB3aGljaCBpcyBoYXJkLlxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXG4gICAgICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICAgICAgfSxcbiAgICAgICAgd05BRkNhY2hlZChQLCBuLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGNvbnN0IFcgPSBwb2ludFdpbmRvd1NpemVzLmdldChQKSB8fCAxO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgICAgICAgICBsZXQgY29tcCA9IHBvaW50UHJlY29tcHV0ZXMuZ2V0KFApO1xuICAgICAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICAgICAgY29tcCA9IHRoaXMucHJlY29tcHV0ZVdpbmRvdyhQLCBXKTtcbiAgICAgICAgICAgICAgICBpZiAoVyAhPT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRQcmVjb21wdXRlcy5zZXQoUCwgdHJhbnNmb3JtKGNvbXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYoVywgY29tcCwgbik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFdlIGNhbGN1bGF0ZSBwcmVjb21wdXRlcyBmb3IgZWxsaXB0aWMgY3VydmUgcG9pbnQgbXVsdGlwbGljYXRpb25cbiAgICAgICAgLy8gdXNpbmcgd2luZG93ZWQgbWV0aG9kLiBUaGlzIHNwZWNpZmllcyB3aW5kb3cgc2l6ZSBhbmRcbiAgICAgICAgLy8gc3RvcmVzIHByZWNvbXB1dGVkIHZhbHVlcy4gVXN1YWxseSBvbmx5IGJhc2UgcG9pbnQgd291bGQgYmUgcHJlY29tcHV0ZWQuXG4gICAgICAgIHNldFdpbmRvd1NpemUoUCwgVykge1xuICAgICAgICAgICAgdmFsaWRhdGVXKFcpO1xuICAgICAgICAgICAgcG9pbnRXaW5kb3dTaXplcy5zZXQoUCwgVyk7XG4gICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZShQKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBQaXBwZW5nZXIgYWxnb3JpdGhtIGZvciBtdWx0aS1zY2FsYXIgbXVsdGlwbGljYXRpb24gKE1TTSkuXG4gKiBNU00gaXMgYmFzaWNhbGx5IChQYSArIFFiICsgUmMgKyAuLi4pLlxuICogMzB4IGZhc3RlciB2cyBuYWl2ZSBhZGRpdGlvbiBvbiBMPTQwOTYsIDEweCBmYXN0ZXIgd2l0aCBwcmVjb21wdXRlcy5cbiAqIEZvciBOPTI1NGJpdCwgTD0xLCBpdCBkb2VzOiAxMDI0IEFERCArIDI1NCBEQkwuIEZvciBMPTU6IDE1MzYgQUREICsgMjU0IERCTC5cbiAqIEFsZ29yaXRobWljYWxseSBjb25zdGFudC10aW1lIChmb3Igc2FtZSBMKSwgZXZlbiB3aGVuIDEgcG9pbnQgKyBzY2FsYXIsIG9yIHdoZW4gc2NhbGFyID0gMC5cbiAqIEBwYXJhbSBjIEN1cnZlIFBvaW50IGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gZmllbGQgZmllbGQgb3ZlciBDVVJWRS5OIC0gaW1wb3J0YW50IHRoYXQgaXQncyBub3Qgb3ZlciBDVVJWRS5QXG4gKiBAcGFyYW0gcG9pbnRzIGFycmF5IG9mIEwgY3VydmUgcG9pbnRzXG4gKiBAcGFyYW0gc2NhbGFycyBhcnJheSBvZiBMIHNjYWxhcnMgKGFrYSBwcml2YXRlIGtleXMgLyBiaWdpbnRzKVxuICovXG5mdW5jdGlvbiBwaXBwZW5nZXIoYywgZmllbGQsIHBvaW50cywgc2NhbGFycykge1xuICAgIC8vIElmIHdlIHNwbGl0IHNjYWxhcnMgYnkgc29tZSB3aW5kb3cgKGxldCdzIHNheSA4IGJpdHMpLCBldmVyeSBjaHVuayB3aWxsIG9ubHlcbiAgICAvLyB0YWtlIDI1NiBidWNrZXRzIGV2ZW4gaWYgdGhlcmUgYXJlIDQwOTYgc2NhbGFycywgYWxzbyByZS11c2VzIGRvdWJsZS5cbiAgICAvLyBUT0RPOlxuICAgIC8vIC0gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAyNC83NTAucGRmXG4gICAgLy8gLSBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvMTAyODdcbiAgICAvLyAwIGlzIGFjY2VwdGVkIGluIHNjYWxhcnNcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnRzKSB8fCAhQXJyYXkuaXNBcnJheShzY2FsYXJzKSB8fCBzY2FsYXJzLmxlbmd0aCAhPT0gcG9pbnRzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheXMgb2YgcG9pbnRzIGFuZCBzY2FsYXJzIG11c3QgaGF2ZSBlcXVhbCBsZW5ndGgnKTtcbiAgICBzY2FsYXJzLmZvckVhY2goKHMsIGkpID0+IHtcbiAgICAgICAgaWYgKCFmaWVsZC5pc1ZhbGlkKHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB3cm9uZyBzY2FsYXIgYXQgaW5kZXggJHtpfWApO1xuICAgIH0pO1xuICAgIHBvaW50cy5mb3JFYWNoKChwLCBpKSA9PiB7XG4gICAgICAgIGlmICghKHAgaW5zdGFuY2VvZiBjKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgd3JvbmcgcG9pbnQgYXQgaW5kZXggJHtpfWApO1xuICAgIH0pO1xuICAgIGNvbnN0IHdiaXRzID0gKDAsIHV0aWxzX2pzXzEuYml0TGVuKShCaWdJbnQocG9pbnRzLmxlbmd0aCkpO1xuICAgIGNvbnN0IHdpbmRvd1NpemUgPSB3Yml0cyA+IDEyID8gd2JpdHMgLSAzIDogd2JpdHMgPiA0ID8gd2JpdHMgLSAyIDogd2JpdHMgPyAyIDogMTsgLy8gaW4gYml0c1xuICAgIGNvbnN0IE1BU0sgPSAoMSA8PCB3aW5kb3dTaXplKSAtIDE7XG4gICAgY29uc3QgYnVja2V0cyA9IG5ldyBBcnJheShNQVNLICsgMSkuZmlsbChjLlpFUk8pOyAvLyArMSBmb3IgemVybyBhcnJheVxuICAgIGNvbnN0IGxhc3RCaXRzID0gTWF0aC5mbG9vcigoZmllbGQuQklUUyAtIDEpIC8gd2luZG93U2l6ZSkgKiB3aW5kb3dTaXplO1xuICAgIGxldCBzdW0gPSBjLlpFUk87XG4gICAgZm9yIChsZXQgaSA9IGxhc3RCaXRzOyBpID49IDA7IGkgLT0gd2luZG93U2l6ZSkge1xuICAgICAgICBidWNrZXRzLmZpbGwoYy5aRVJPKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzY2FsYXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsYXIgPSBzY2FsYXJzW2pdO1xuICAgICAgICAgICAgY29uc3Qgd2JpdHMgPSBOdW1iZXIoKHNjYWxhciA+PiBCaWdJbnQoaSkpICYgQmlnSW50KE1BU0spKTtcbiAgICAgICAgICAgIGJ1Y2tldHNbd2JpdHNdID0gYnVja2V0c1t3Yml0c10uYWRkKHBvaW50c1tqXSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc0kgPSBjLlpFUk87IC8vIG5vdCB1c2luZyB0aGlzIHdpbGwgZG8gc21hbGwgc3BlZWQtdXAsIGJ1dCB3aWxsIGxvc2UgY3RcbiAgICAgICAgLy8gU2tpcCBmaXJzdCBidWNrZXQsIGJlY2F1c2UgaXQgaXMgemVyb1xuICAgICAgICBmb3IgKGxldCBqID0gYnVja2V0cy5sZW5ndGggLSAxLCBzdW1JID0gYy5aRVJPOyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICBzdW1JID0gc3VtSS5hZGQoYnVja2V0c1tqXSk7XG4gICAgICAgICAgICByZXNJID0gcmVzSS5hZGQoc3VtSSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VtID0gc3VtLmFkZChyZXNJKTtcbiAgICAgICAgaWYgKGkgIT09IDApXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpbmRvd1NpemU7IGorKylcbiAgICAgICAgICAgICAgICBzdW0gPSBzdW0uZG91YmxlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGN1cnZlKSB7XG4gICAgKDAsIG1vZHVsYXJfanNfMS52YWxpZGF0ZUZpZWxkKShjdXJ2ZS5GcCk7XG4gICAgKDAsIHV0aWxzX2pzXzEudmFsaWRhdGVPYmplY3QpKGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4uKDAsIG1vZHVsYXJfanNfMS5uTGVuZ3RoKShjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnZlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50d2lzdGVkRWR3YXJkcyA9IHR3aXN0ZWRFZHdhcmRzO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVHdpc3RlZCBFZHdhcmRzIGN1cnZlLiBUaGUgZm9ybXVsYSBpczogYXjCsiArIHnCsiA9IDEgKyBkeMKyecKyXG5jb25zdCBjdXJ2ZV9qc18xID0gcmVxdWlyZShcIi4vY3VydmUuanNcIik7XG5jb25zdCBtb2R1bGFyX2pzXzEgPSByZXF1aXJlKFwiLi9tb2R1bGFyLmpzXCIpO1xuY29uc3QgdXQgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbi8vIEJlIGZyaWVuZGx5IHRvIGJhZCBFQ01BU2NyaXB0IHBhcnNlcnMgYnkgbm90IHVzaW5nIGJpZ2ludCBsaXRlcmFsc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfOG4gPSBCaWdJbnQoOCk7XG4vLyB2ZXJpZmljYXRpb24gcnVsZSBpcyBlaXRoZXIgemlwMjE1IG9yIHJmYzgwMzIgLyBuaXN0MTg2LTUuIENvbnN1bHQgZnJvbUhleDpcbmNvbnN0IFZFUklGWV9ERUZBVUxUID0geyB6aXAyMTU6IHRydWUgfTtcbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSAoMCwgY3VydmVfanNfMS52YWxpZGF0ZUJhc2ljKShjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgaGFzaDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYTogJ2JpZ2ludCcsXG4gICAgICAgIGQ6ICdiaWdpbnQnLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGFkanVzdFNjYWxhckJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICBkb21haW46ICdmdW5jdGlvbicsXG4gICAgICAgIHV2UmF0aW86ICdmdW5jdGlvbicsXG4gICAgICAgIG1hcFRvQ3VydmU6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5vcHRzIH0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIFR3aXN0ZWQgRWR3YXJkcyBjdXJ2ZSB3aXRoIEVkRFNBIHNpZ25hdHVyZXMuXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgRmllbGQgfSBmcm9tICdAbm9ibGUvY3VydmVzL2Fic3RyYWN0L21vZHVsYXInO1xuICogLy8gQmVmb3JlIHRoYXQsIGRlZmluZSBCaWdJbnQtczogYSwgZCwgcCwgbiwgR3gsIEd5LCBoXG4gKiBjb25zdCBjdXJ2ZSA9IHR3aXN0ZWRFZHdhcmRzKHsgYSwgZCwgRnA6IEZpZWxkKHApLCBuLCBHeCwgR3ksIGggfSlcbiAqL1xuZnVuY3Rpb24gdHdpc3RlZEVkd2FyZHMoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIsIHByZWhhc2g6IHByZWhhc2gsIGhhc2g6IGNIYXNoLCByYW5kb21CeXRlcywgbkJ5dGVMZW5ndGgsIGg6IGNvZmFjdG9yLCB9ID0gQ1VSVkU7XG4gICAgY29uc3QgTUFTSyA9IF8ybiA8PCAoQmlnSW50KG5CeXRlTGVuZ3RoICogOCkgLSBfMW4pO1xuICAgIGNvbnN0IG1vZFAgPSBGcC5jcmVhdGU7IC8vIEZ1bmN0aW9uIG92ZXJyaWRlc1xuICAgIGNvbnN0IEZuID0gKDAsIG1vZHVsYXJfanNfMS5GaWVsZCkoQ1VSVkUubiwgQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgLy8gc3FydCh1L3YpXG4gICAgY29uc3QgdXZSYXRpbyA9IENVUlZFLnV2UmF0aW8gfHxcbiAgICAgICAgKCh1LCB2KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IHRydWUsIHZhbHVlOiBGcC5zcXJ0KHUgKiBGcC5pbnYodikpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCB2YWx1ZTogXzBuIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIGNvbnN0IGFkanVzdFNjYWxhckJ5dGVzID0gQ1VSVkUuYWRqdXN0U2NhbGFyQnl0ZXMgfHwgKChieXRlcykgPT4gYnl0ZXMpOyAvLyBOT09QXG4gICAgY29uc3QgZG9tYWluID0gQ1VSVkUuZG9tYWluIHx8XG4gICAgICAgICgoZGF0YSwgY3R4LCBwaGZsYWcpID0+IHtcbiAgICAgICAgICAgICgwLCB1dGlsc19qc18xLmFib29sKSgncGhmbGFnJywgcGhmbGFnKTtcbiAgICAgICAgICAgIGlmIChjdHgubGVuZ3RoIHx8IHBoZmxhZylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRleHRzL3ByZS1oYXNoIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7IC8vIE5PT1BcbiAgICAvLyAwIDw9IG4gPCBNQVNLXG4gICAgLy8gQ29vcmRpbmF0ZXMgbGFyZ2VyIHRoYW4gRnAuT1JERVIgYXJlIGFsbG93ZWQgZm9yIHppcDIxNVxuICAgIGZ1bmN0aW9uIGFDb29yZGluYXRlKHRpdGxlLCBuKSB7XG4gICAgICAgIHV0LmFJblJhbmdlKCdjb29yZGluYXRlICcgKyB0aXRsZSwgbiwgXzBuLCBNQVNLKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0UG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVuZGVkUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgLy8gQ29udmVydHMgRXh0ZW5kZWQgcG9pbnQgdG8gZGVmYXVsdCAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgY29uc3QgdG9BZmZpbmVNZW1vID0gKDAsIHV0aWxzX2pzXzEubWVtb2l6ZWQpKChwLCBpeikgPT4ge1xuICAgICAgICBjb25zdCB7IGV4OiB4LCBleTogeSwgZXo6IHogfSA9IHA7XG4gICAgICAgIGNvbnN0IGlzMCA9IHAuaXMwKCk7XG4gICAgICAgIGlmIChpeiA9PSBudWxsKVxuICAgICAgICAgICAgaXogPSBpczAgPyBfOG4gOiBGcC5pbnYoeik7IC8vIDggd2FzIGNob3NlbiBhcmJpdHJhcmlseVxuICAgICAgICBjb25zdCBheCA9IG1vZFAoeCAqIGl6KTtcbiAgICAgICAgY29uc3QgYXkgPSBtb2RQKHkgKiBpeik7XG4gICAgICAgIGNvbnN0IHp6ID0gbW9kUCh6ICogaXopO1xuICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgcmV0dXJuIHsgeDogXzBuLCB5OiBfMW4gfTtcbiAgICAgICAgaWYgKHp6ICE9PSBfMW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgfSk7XG4gICAgY29uc3QgYXNzZXJ0VmFsaWRNZW1vID0gKDAsIHV0aWxzX2pzXzEubWVtb2l6ZWQpKChwKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChwLmlzMCgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTsgLy8gVE9ETzogb3B0aW1pemUsIHdpdGggdmFycyBiZWxvdz9cbiAgICAgICAgLy8gRXF1YXRpb24gaW4gYWZmaW5lIGNvb3JkaW5hdGVzOiBheMKyICsgecKyID0gMSArIGR4wrJ5wrJcbiAgICAgICAgLy8gRXF1YXRpb24gaW4gcHJvamVjdGl2ZSBjb29yZGluYXRlcyAoWC9aLCBZL1osIFopOiAgKGFYwrIgKyBZwrIpWsKyID0gWuKBtCArIGRYwrJZwrJcbiAgICAgICAgY29uc3QgeyBleDogWCwgZXk6IFksIGV6OiBaLCBldDogVCB9ID0gcDtcbiAgICAgICAgY29uc3QgWDIgPSBtb2RQKFggKiBYKTsgLy8gWMKyXG4gICAgICAgIGNvbnN0IFkyID0gbW9kUChZICogWSk7IC8vIFnCslxuICAgICAgICBjb25zdCBaMiA9IG1vZFAoWiAqIFopOyAvLyBawrJcbiAgICAgICAgY29uc3QgWjQgPSBtb2RQKFoyICogWjIpOyAvLyBa4oG0XG4gICAgICAgIGNvbnN0IGFYMiA9IG1vZFAoWDIgKiBhKTsgLy8gYVjCslxuICAgICAgICBjb25zdCBsZWZ0ID0gbW9kUChaMiAqIG1vZFAoYVgyICsgWTIpKTsgLy8gKGFYwrIgKyBZwrIpWsKyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gbW9kUChaNCArIG1vZFAoZCAqIG1vZFAoWDIgKiBZMikpKTsgLy8gWuKBtCArIGRYwrJZwrJcbiAgICAgICAgaWYgKGxlZnQgIT09IHJpZ2h0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQgKDEpJyk7XG4gICAgICAgIC8vIEluIEV4dGVuZGVkIGNvb3JkaW5hdGVzIHdlIGFsc28gaGF2ZSBULCB3aGljaCBpcyB4Knk9VC9aOiBjaGVjayBYKlkgPT0gWipUXG4gICAgICAgIGNvbnN0IFhZID0gbW9kUChYICogWSk7XG4gICAgICAgIGNvbnN0IFpUID0gbW9kUChaICogVCk7XG4gICAgICAgIGlmIChYWSAhPT0gWlQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCAoMiknKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgLy8gRXh0ZW5kZWQgUG9pbnQgd29ya3MgaW4gZXh0ZW5kZWQgY29vcmRpbmF0ZXM6ICh4LCB5LCB6LCB0KSDiiIsgKHg9eC96LCB5PXkveiwgdD14eSkuXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHdpc3RlZF9FZHdhcmRzX2N1cnZlI0V4dGVuZGVkX2Nvb3JkaW5hdGVzXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihleCwgZXksIGV6LCBldCkge1xuICAgICAgICAgICAgdGhpcy5leCA9IGV4O1xuICAgICAgICAgICAgdGhpcy5leSA9IGV5O1xuICAgICAgICAgICAgdGhpcy5leiA9IGV6O1xuICAgICAgICAgICAgdGhpcy5ldCA9IGV0O1xuICAgICAgICAgICAgYUNvb3JkaW5hdGUoJ3gnLCBleCk7XG4gICAgICAgICAgICBhQ29vcmRpbmF0ZSgneScsIGV5KTtcbiAgICAgICAgICAgIGFDb29yZGluYXRlKCd6JywgZXopO1xuICAgICAgICAgICAgYUNvb3JkaW5hdGUoJ3QnLCBldCk7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgICAgICB9XG4gICAgICAgIGdldCB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHRlbmRlZCBwb2ludCBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgYUNvb3JkaW5hdGUoJ3gnLCB4KTtcbiAgICAgICAgICAgIGFDb29yZGluYXRlKCd5JywgeSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIF8xbiwgbW9kUCh4ICogeSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChwb2ludHMubWFwKChwKSA9PiBwLmV6KSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXNjYWxhciBNdWx0aXBsaWNhdGlvblxuICAgICAgICBzdGF0aWMgbXNtKHBvaW50cywgc2NhbGFycykge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBjdXJ2ZV9qc18xLnBpcHBlbmdlcikoUG9pbnQsIEZuLCBwb2ludHMsIHNjYWxhcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHduYWYuc2V0V2luZG93U2l6ZSh0aGlzLCB3aW5kb3dTaXplKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3QgcmVxdWlyZWQgZm9yIGZyb21IZXgoKSwgd2hpY2ggYWx3YXlzIGNyZWF0ZXMgdmFsaWQgcG9pbnRzLlxuICAgICAgICAvLyBDb3VsZCBiZSB1c2VmdWwgZm9yIGZyb21BZmZpbmUoKS5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICBhc3NlcnRWYWxpZE1lbW8odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcGFyZSBvbmUgcG9pbnQgdG8gYW5vdGhlci5cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IGV4OiBYMSwgZXk6IFkxLCBlejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGV4OiBYMiwgZXk6IFkyLCBlejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgWDFaMiA9IG1vZFAoWDEgKiBaMik7XG4gICAgICAgICAgICBjb25zdCBYMloxID0gbW9kUChYMiAqIFoxKTtcbiAgICAgICAgICAgIGNvbnN0IFkxWjIgPSBtb2RQKFkxICogWjIpO1xuICAgICAgICAgICAgY29uc3QgWTJaMSA9IG1vZFAoWTIgKiBaMSk7XG4gICAgICAgICAgICByZXR1cm4gWDFaMiA9PT0gWDJaMSAmJiBZMVoyID09PSBZMloxO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICAvLyBGbGlwcyBwb2ludCBzaWduIHRvIGEgbmVnYXRpdmUgb25lICgteCwgeSBpbiBhZmZpbmUgY29vcmRzKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChtb2RQKC10aGlzLmV4KSwgdGhpcy5leSwgdGhpcy5leiwgbW9kUCgtdGhpcy5ldCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhc3QgYWxnbyBmb3IgZG91YmxpbmcgRXh0ZW5kZWQgUG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQuaHRtbCNkb3VibGluZy1kYmwtMjAwOC1od2NkXG4gICAgICAgIC8vIENvc3Q6IDRNICsgNFMgKyAxKmEgKyA2YWRkICsgMSoyLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgeyBleDogWDEsIGV5OiBZMSwgZXo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgQSA9IG1vZFAoWDEgKiBYMSk7IC8vIEEgPSBYMTJcbiAgICAgICAgICAgIGNvbnN0IEIgPSBtb2RQKFkxICogWTEpOyAvLyBCID0gWTEyXG4gICAgICAgICAgICBjb25zdCBDID0gbW9kUChfMm4gKiBtb2RQKFoxICogWjEpKTsgLy8gQyA9IDIqWjEyXG4gICAgICAgICAgICBjb25zdCBEID0gbW9kUChhICogQSk7IC8vIEQgPSBhKkFcbiAgICAgICAgICAgIGNvbnN0IHgxeTEgPSBYMSArIFkxO1xuICAgICAgICAgICAgY29uc3QgRSA9IG1vZFAobW9kUCh4MXkxICogeDF5MSkgLSBBIC0gQik7IC8vIEUgPSAoWDErWTEpMi1BLUJcbiAgICAgICAgICAgIGNvbnN0IEcgPSBEICsgQjsgLy8gRyA9IEQrQlxuICAgICAgICAgICAgY29uc3QgRiA9IEcgLSBDOyAvLyBGID0gRy1DXG4gICAgICAgICAgICBjb25zdCBIID0gRCAtIEI7IC8vIEggPSBELUJcbiAgICAgICAgICAgIGNvbnN0IFgzID0gbW9kUChFICogRik7IC8vIFgzID0gRSpGXG4gICAgICAgICAgICBjb25zdCBZMyA9IG1vZFAoRyAqIEgpOyAvLyBZMyA9IEcqSFxuICAgICAgICAgICAgY29uc3QgVDMgPSBtb2RQKEUgKiBIKTsgLy8gVDMgPSBFKkhcbiAgICAgICAgICAgIGNvbnN0IFozID0gbW9kUChGICogRyk7IC8vIFozID0gRipHXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMsIFQzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYXN0IGFsZ28gZm9yIGFkZGluZyAyIEV4dGVuZGVkIFBvaW50cy5cbiAgICAgICAgLy8gaHR0cHM6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC5odG1sI2FkZGl0aW9uLWFkZC0yMDA4LWh3Y2RcbiAgICAgICAgLy8gQ29zdDogOU0gKyAxKmEgKyAxKmQgKyA3YWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCB7IGV4OiBYMSwgZXk6IFkxLCBlejogWjEsIGV0OiBUMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZXg6IFgyLCBleTogWTIsIGV6OiBaMiwgZXQ6IFQyIH0gPSBvdGhlcjtcbiAgICAgICAgICAgIC8vIEZhc3RlciBhbGdvIGZvciBhZGRpbmcgMiBFeHRlbmRlZCBQb2ludHMgd2hlbiBjdXJ2ZSdzIGE9LTEuXG4gICAgICAgICAgICAvLyBodHRwOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQtMS5odG1sI2FkZGl0aW9uLWFkZC0yMDA4LWh3Y2QtNFxuICAgICAgICAgICAgLy8gQ29zdDogOE0gKyA4YWRkICsgMioyLlxuICAgICAgICAgICAgLy8gTm90ZTogSXQgZG9lcyBub3QgY2hlY2sgd2hldGhlciB0aGUgYG90aGVyYCBwb2ludCBpcyB2YWxpZC5cbiAgICAgICAgICAgIGlmIChhID09PSBCaWdJbnQoLTEpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgQSA9IG1vZFAoKFkxIC0gWDEpICogKFkyICsgWDIpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBCID0gbW9kUCgoWTEgKyBYMSkgKiAoWTIgLSBYMikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEYgPSBtb2RQKEIgLSBBKTtcbiAgICAgICAgICAgICAgICBpZiAoRiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb3VibGUoKTsgLy8gU2FtZSBwb2ludC4gVGVzdHMgc2F5IGl0IGRvZXNuJ3QgYWZmZWN0IHRpbWluZ1xuICAgICAgICAgICAgICAgIGNvbnN0IEMgPSBtb2RQKFoxICogXzJuICogVDIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEQgPSBtb2RQKFQxICogXzJuICogWjIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEUgPSBEICsgQztcbiAgICAgICAgICAgICAgICBjb25zdCBHID0gQiArIEE7XG4gICAgICAgICAgICAgICAgY29uc3QgSCA9IEQgLSBDO1xuICAgICAgICAgICAgICAgIGNvbnN0IFgzID0gbW9kUChFICogRik7XG4gICAgICAgICAgICAgICAgY29uc3QgWTMgPSBtb2RQKEcgKiBIKTtcbiAgICAgICAgICAgICAgICBjb25zdCBUMyA9IG1vZFAoRSAqIEgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFozID0gbW9kUChGICogRyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBBID0gbW9kUChYMSAqIFgyKTsgLy8gQSA9IFgxKlgyXG4gICAgICAgICAgICBjb25zdCBCID0gbW9kUChZMSAqIFkyKTsgLy8gQiA9IFkxKlkyXG4gICAgICAgICAgICBjb25zdCBDID0gbW9kUChUMSAqIGQgKiBUMik7IC8vIEMgPSBUMSpkKlQyXG4gICAgICAgICAgICBjb25zdCBEID0gbW9kUChaMSAqIFoyKTsgLy8gRCA9IFoxKloyXG4gICAgICAgICAgICBjb25zdCBFID0gbW9kUCgoWDEgKyBZMSkgKiAoWDIgKyBZMikgLSBBIC0gQik7IC8vIEUgPSAoWDErWTEpKihYMitZMiktQS1CXG4gICAgICAgICAgICBjb25zdCBGID0gRCAtIEM7IC8vIEYgPSBELUNcbiAgICAgICAgICAgIGNvbnN0IEcgPSBEICsgQzsgLy8gRyA9IEQrQ1xuICAgICAgICAgICAgY29uc3QgSCA9IG1vZFAoQiAtIGEgKiBBKTsgLy8gSCA9IEItYSpBXG4gICAgICAgICAgICBjb25zdCBYMyA9IG1vZFAoRSAqIEYpOyAvLyBYMyA9IEUqRlxuICAgICAgICAgICAgY29uc3QgWTMgPSBtb2RQKEcgKiBIKTsgLy8gWTMgPSBHKkhcbiAgICAgICAgICAgIGNvbnN0IFQzID0gbW9kUChFICogSCk7IC8vIFQzID0gRSpIXG4gICAgICAgICAgICBjb25zdCBaMyA9IG1vZFAoRiAqIEcpOyAvLyBaMyA9IEYqR1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgd05BRihuKSB7XG4gICAgICAgICAgICByZXR1cm4gd25hZi53TkFGQ2FjaGVkKHRoaXMsIG4sIFBvaW50Lm5vcm1hbGl6ZVopO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICAgICAgY29uc3QgbiA9IHNjYWxhcjtcbiAgICAgICAgICAgIHV0LmFJblJhbmdlKCdzY2FsYXInLCBuLCBfMW4sIENVUlZFX09SREVSKTsgLy8gMSA8PSBzY2FsYXIgPCBMXG4gICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5ub3JtYWxpemVaKFtwLCBmXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAvLyBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAvLyBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbi5cbiAgICAgICAgLy8gRG9lcyBOT1QgYWxsb3cgc2NhbGFycyBoaWdoZXIgdGhhbiBDVVJWRS5uLlxuICAgICAgICBtdWx0aXBseVVuc2FmZShzY2FsYXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzY2FsYXI7XG4gICAgICAgICAgICB1dC5hSW5SYW5nZSgnc2NhbGFyJywgbiwgXzBuLCBDVVJWRV9PUkRFUik7IC8vIDAgPD0gc2NhbGFyIDwgTFxuICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFscyhJKSB8fCBuID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHMoRykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRihuKS5wO1xuICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIG4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrcyBpZiBwb2ludCBpcyBvZiBzbWFsbCBvcmRlci5cbiAgICAgICAgLy8gSWYgeW91IGFkZCBzb21ldGhpbmcgdG8gc21hbGwgb3JkZXIgcG9pbnQsIHlvdSB3aWxsIGhhdmUgXCJkaXJ0eVwiXG4gICAgICAgIC8vIHBvaW50IHdpdGggdG9yc2lvbiBjb21wb25lbnQuXG4gICAgICAgIC8vIE11bHRpcGxpZXMgcG9pbnQgYnkgY29mYWN0b3IgYW5kIGNoZWNrcyBpZiB0aGUgcmVzdWx0IGlzIDAuXG4gICAgICAgIGlzU21hbGxPcmRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKGNvZmFjdG9yKS5pczAoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIHBvaW50IGJ5IGN1cnZlIG9yZGVyIGFuZCBjaGVja3MgaWYgdGhlIHJlc3VsdCBpcyAwLlxuICAgICAgICAvLyBSZXR1cm5zIGBmYWxzZWAgaXMgdGhlIHBvaW50IGlzIGRpcnR5LlxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIENVUlZFX09SREVSKS5pczAoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBFeHRlbmRlZCBwb2ludCB0byBkZWZhdWx0ICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XG4gICAgICAgICAgICByZXR1cm4gdG9BZmZpbmVNZW1vKHRoaXMsIGl6KTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKGNvZmFjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAvLyBVc2VzIGFsZ28gZnJvbSBSRkM4MDMyIDUuMS4zLlxuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgsIHppcDIxNSA9IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGQsIGEgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gRnAuQllURVM7XG4gICAgICAgICAgICBoZXggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3BvaW50SGV4JywgaGV4LCBsZW4pOyAvLyBjb3B5IGhleCB0byBhIG5ldyBhcnJheVxuICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuYWJvb2wpKCd6aXAyMTUnLCB6aXAyMTUpO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWVkID0gaGV4LnNsaWNlKCk7IC8vIGNvcHkgYWdhaW4sIHdlJ2xsIG1hbmlwdWxhdGUgaXRcbiAgICAgICAgICAgIGNvbnN0IGxhc3RCeXRlID0gaGV4W2xlbiAtIDFdOyAvLyBzZWxlY3QgbGFzdCBieXRlXG4gICAgICAgICAgICBub3JtZWRbbGVuIC0gMV0gPSBsYXN0Qnl0ZSAmIH4weDgwOyAvLyBjbGVhciBsYXN0IGJpdFxuICAgICAgICAgICAgY29uc3QgeSA9IHV0LmJ5dGVzVG9OdW1iZXJMRShub3JtZWQpO1xuICAgICAgICAgICAgLy8gUkZDODAzMiBwcm9oaWJpdHMgPj0gcCwgYnV0IFpJUDIxNSBkb2Vzbid0XG4gICAgICAgICAgICAvLyB6aXAyMTU9dHJ1ZTogIDAgPD0geSA8IE1BU0sgKDJeMjU2IGZvciBlZDI1NTE5KVxuICAgICAgICAgICAgLy8gemlwMjE1PWZhbHNlOiAwIDw9IHkgPCBQICgyXjI1NS0xOSBmb3IgZWQyNTUxOSlcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IHppcDIxNSA/IE1BU0sgOiBGcC5PUkRFUjtcbiAgICAgICAgICAgIHV0LmFJblJhbmdlKCdwb2ludEhleC55JywgeSwgXzBuLCBtYXgpO1xuICAgICAgICAgICAgLy8gRWQyNTUxOTogeMKyID0gKHnCsi0xKS8oZHnCsisxKSBtb2QgcC4gRWQ0NDg6IHjCsiA9ICh5wrItMSkvKGR5wrItMSkgbW9kIHAuIEdlbmVyaWMgY2FzZTpcbiAgICAgICAgICAgIC8vIGF4wrIrecKyPTErZHjCsnnCsiA9PiB5wrItMT1keMKyecKyLWF4wrIgPT4gecKyLTE9eMKyKGR5wrItYSkgPT4geMKyPSh5wrItMSkvKGR5wrItYSlcbiAgICAgICAgICAgIGNvbnN0IHkyID0gbW9kUCh5ICogeSk7IC8vIGRlbm9taW5hdG9yIGlzIGFsd2F5cyBub24tMCBtb2QgcC5cbiAgICAgICAgICAgIGNvbnN0IHUgPSBtb2RQKHkyIC0gXzFuKTsgLy8gdSA9IHnCsiAtIDFcbiAgICAgICAgICAgIGNvbnN0IHYgPSBtb2RQKGQgKiB5MiAtIGEpOyAvLyB2ID0gZCB5wrIgKyAxLlxuICAgICAgICAgICAgbGV0IHsgaXNWYWxpZCwgdmFsdWU6IHggfSA9IHV2UmF0aW8odSwgdik7IC8vIOKImih1L3YpXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludC5mcm9tSGV4OiBpbnZhbGlkIHkgY29vcmRpbmF0ZScpO1xuICAgICAgICAgICAgY29uc3QgaXNYT2RkID0gKHggJiBfMW4pID09PSBfMW47IC8vIFRoZXJlIGFyZSAyIHNxdWFyZSByb290cy4gVXNlIHhfMCBiaXQgdG8gc2VsZWN0IHByb3BlclxuICAgICAgICAgICAgY29uc3QgaXNMYXN0Qnl0ZU9kZCA9IChsYXN0Qnl0ZSAmIDB4ODApICE9PSAwOyAvLyB4XzAsIGxhc3QgYml0XG4gICAgICAgICAgICBpZiAoIXppcDIxNSAmJiB4ID09PSBfMG4gJiYgaXNMYXN0Qnl0ZU9kZClcbiAgICAgICAgICAgICAgICAvLyBpZiB4PTAgYW5kIHhfMCA9IDEsIGZhaWxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50LmZyb21IZXg6IHg9MCBhbmQgeF8wPTEnKTtcbiAgICAgICAgICAgIGlmIChpc0xhc3RCeXRlT2RkICE9PSBpc1hPZGQpXG4gICAgICAgICAgICAgICAgeCA9IG1vZFAoLXgpOyAvLyBpZiB4XzAgIT0geCBtb2QgMiwgc2V0IHggPSBwLXhcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5mcm9tQWZmaW5lKHsgeCwgeSB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdktleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEV4dGVuZGVkUHVibGljS2V5KHByaXZLZXkpLnBvaW50O1xuICAgICAgICB9XG4gICAgICAgIHRvUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gdXQubnVtYmVyVG9CeXRlc0xFKHksIEZwLkJZVEVTKTsgLy8gZWFjaCB5IGhhcyAyIHggdmFsdWVzICh4LCAteSlcbiAgICAgICAgICAgIGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdIHw9IHggJiBfMW4gPyAweDgwIDogMDsgLy8gd2hlbiBjb21wcmVzc2luZywgaXQncyBlbm91Z2ggdG8gc3RvcmUgeVxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzOyAvLyBhbmQgdXNlIHRoZSBsYXN0IGJ5dGUgdG8gZW5jb2RlIHNpZ24gb2YgeFxuICAgICAgICB9XG4gICAgICAgIHRvSGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKCkpOyAvLyBTYW1lIGFzIHRvUmF3Qnl0ZXMsIGJ1dCByZXR1cm5zIHN0cmluZy5cbiAgICAgICAgfVxuICAgIH1cbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgXzFuLCBtb2RQKENVUlZFLkd4ICogQ1VSVkUuR3kpKTtcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KF8wbiwgXzFuLCBfMW4sIF8wbik7IC8vIDAsIDEsIDEsIDBcbiAgICBjb25zdCB7IEJBU0U6IEcsIFpFUk86IEkgfSA9IFBvaW50O1xuICAgIGNvbnN0IHduYWYgPSAoMCwgY3VydmVfanNfMS53TkFGKShQb2ludCwgbkJ5dGVMZW5ndGggKiA4KTtcbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuICgwLCBtb2R1bGFyX2pzXzEubW9kKShhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIC8vIExpdHRsZS1lbmRpYW4gU0hBNTEyIHdpdGggbW9kdWxvIG5cbiAgICBmdW5jdGlvbiBtb2ROX0xFKGhhc2gpIHtcbiAgICAgICAgcmV0dXJuIG1vZE4odXQuYnl0ZXNUb051bWJlckxFKGhhc2gpKTtcbiAgICB9XG4gICAgLyoqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGNyZWF0ZXMgcHVibGljIGtleSBhbmQgb3RoZXIgc3R1ZmYuIFJGQzgwMzIgNS4xLjUgKi9cbiAgICBmdW5jdGlvbiBnZXRFeHRlbmRlZFB1YmxpY0tleShrZXkpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbkJ5dGVMZW5ndGg7XG4gICAgICAgIGtleSA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgncHJpdmF0ZSBrZXknLCBrZXksIGxlbik7XG4gICAgICAgIC8vIEhhc2ggcHJpdmF0ZSBrZXkgd2l0aCBjdXJ2ZSdzIGhhc2ggZnVuY3Rpb24gdG8gcHJvZHVjZSB1bmlmb3JtaW5nbHkgcmFuZG9tIGlucHV0XG4gICAgICAgIC8vIENoZWNrIGJ5dGUgbGVuZ3RoczogZW5zdXJlKDY0LCBoKGVuc3VyZSgzMiwga2V5KSkpXG4gICAgICAgIGNvbnN0IGhhc2hlZCA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnaGFzaGVkIHByaXZhdGUga2V5JywgY0hhc2goa2V5KSwgMiAqIGxlbik7XG4gICAgICAgIGNvbnN0IGhlYWQgPSBhZGp1c3RTY2FsYXJCeXRlcyhoYXNoZWQuc2xpY2UoMCwgbGVuKSk7IC8vIGNsZWFyIGZpcnN0IGhhbGYgYml0cywgcHJvZHVjZSBGRVxuICAgICAgICBjb25zdCBwcmVmaXggPSBoYXNoZWQuc2xpY2UobGVuLCAyICogbGVuKTsgLy8gc2Vjb25kIGhhbGYgaXMgY2FsbGVkIGtleSBwcmVmaXggKDUuMS42KVxuICAgICAgICBjb25zdCBzY2FsYXIgPSBtb2ROX0xFKGhlYWQpOyAvLyBUaGUgYWN0dWFsIHByaXZhdGUgc2NhbGFyXG4gICAgICAgIGNvbnN0IHBvaW50ID0gRy5tdWx0aXBseShzY2FsYXIpOyAvLyBQb2ludCBvbiBFZHdhcmRzIGN1cnZlIGFrYSBwdWJsaWMga2V5XG4gICAgICAgIGNvbnN0IHBvaW50Qnl0ZXMgPSBwb2ludC50b1Jhd0J5dGVzKCk7IC8vIFVpbnQ4QXJyYXkgcmVwcmVzZW50YXRpb25cbiAgICAgICAgcmV0dXJuIHsgaGVhZCwgcHJlZml4LCBzY2FsYXIsIHBvaW50LCBwb2ludEJ5dGVzIH07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZXMgRWREU0EgcHViIGtleS4gUkZDODAzMiA1LjEuNS4gUHJpdmtleSBpcyBoYXNoZWQuIFVzZSBmaXJzdCBoYWxmIHdpdGggMyBiaXRzIGNsZWFyZWRcbiAgICBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdktleSkge1xuICAgICAgICByZXR1cm4gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkocHJpdktleSkucG9pbnRCeXRlcztcbiAgICB9XG4gICAgLy8gaW50KCdMRScsIFNIQTUxMihkb20yKEYsIEMpIHx8IG1zZ3MpKSBtb2QgTlxuICAgIGZ1bmN0aW9uIGhhc2hEb21haW5Ub1NjYWxhcihjb250ZXh0ID0gbmV3IFVpbnQ4QXJyYXkoKSwgLi4ubXNncykge1xuICAgICAgICBjb25zdCBtc2cgPSB1dC5jb25jYXRCeXRlcyguLi5tc2dzKTtcbiAgICAgICAgcmV0dXJuIG1vZE5fTEUoY0hhc2goZG9tYWluKG1zZywgKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdjb250ZXh0JywgY29udGV4dCksICEhcHJlaGFzaCkpKTtcbiAgICB9XG4gICAgLyoqIFNpZ25zIG1lc3NhZ2Ugd2l0aCBwcml2YXRlS2V5LiBSRkM4MDMyIDUuMS42ICovXG4gICAgZnVuY3Rpb24gc2lnbihtc2csIHByaXZLZXksIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBtc2cgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZyA9IHByZWhhc2gobXNnKTsgLy8gZm9yIGVkMjU1MTlwaCBldGMuXG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCBzY2FsYXIsIHBvaW50Qnl0ZXMgfSA9IGdldEV4dGVuZGVkUHVibGljS2V5KHByaXZLZXkpO1xuICAgICAgICBjb25zdCByID0gaGFzaERvbWFpblRvU2NhbGFyKG9wdGlvbnMuY29udGV4dCwgcHJlZml4LCBtc2cpOyAvLyByID0gZG9tMihGLCBDKSB8fCBwcmVmaXggfHwgUEgoTSlcbiAgICAgICAgY29uc3QgUiA9IEcubXVsdGlwbHkocikudG9SYXdCeXRlcygpOyAvLyBSID0gckdcbiAgICAgICAgY29uc3QgayA9IGhhc2hEb21haW5Ub1NjYWxhcihvcHRpb25zLmNvbnRleHQsIFIsIHBvaW50Qnl0ZXMsIG1zZyk7IC8vIFIgfHwgQSB8fCBQSChNKVxuICAgICAgICBjb25zdCBzID0gbW9kTihyICsgayAqIHNjYWxhcik7IC8vIFMgPSAociArIGsgKiBzKSBtb2QgTFxuICAgICAgICB1dC5hSW5SYW5nZSgnc2lnbmF0dXJlLnMnLCBzLCBfMG4sIENVUlZFX09SREVSKTsgLy8gMCA8PSBzIDwgbFxuICAgICAgICBjb25zdCByZXMgPSB1dC5jb25jYXRCeXRlcyhSLCB1dC5udW1iZXJUb0J5dGVzTEUocywgRnAuQllURVMpKTtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgncmVzdWx0JywgcmVzLCBuQnl0ZUxlbmd0aCAqIDIpOyAvLyA2NC1ieXRlIHNpZ25hdHVyZVxuICAgIH1cbiAgICBjb25zdCB2ZXJpZnlPcHRzID0gVkVSSUZZX0RFRkFVTFQ7XG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZywgbXNnLCBwdWJsaWNLZXksIG9wdGlvbnMgPSB2ZXJpZnlPcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgY29udGV4dCwgemlwMjE1IH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBsZW4gPSBGcC5CWVRFUzsgLy8gVmVyaWZpZXMgRWREU0Egc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBhbmQgcHVibGljIGtleS4gUkZDODAzMiA1LjEuNy5cbiAgICAgICAgc2lnID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdzaWduYXR1cmUnLCBzaWcsIDIgKiBsZW4pOyAvLyBBbiBleHRlbmRlZCBncm91cCBlcXVhdGlvbiBpcyBjaGVja2VkLlxuICAgICAgICBtc2cgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgICBpZiAoemlwMjE1ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAoMCwgdXRpbHNfanNfMS5hYm9vbCkoJ3ppcDIxNScsIHppcDIxNSk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnID0gcHJlaGFzaChtc2cpOyAvLyBmb3IgZWQyNTUxOXBoLCBldGNcbiAgICAgICAgY29uc3QgcyA9IHV0LmJ5dGVzVG9OdW1iZXJMRShzaWcuc2xpY2UobGVuLCAyICogbGVuKSk7XG4gICAgICAgIC8vIHppcDIxNTogdHJ1ZSBpcyBnb29kIGZvciBjb25zZW5zdXMtY3JpdGljYWwgYXBwcyBhbmQgYWxsb3dzIHBvaW50cyA8IDJeMjU2XG4gICAgICAgIC8vIHppcDIxNTogZmFsc2UgZm9sbG93cyBSRkM4MDMyIC8gTklTVDE4Ni01IGFuZCByZXN0cmljdHMgcG9pbnRzIHRvIENVUlZFLnBcbiAgICAgICAgbGV0IEEsIFIsIFNCO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgQSA9IFBvaW50LmZyb21IZXgocHVibGljS2V5LCB6aXAyMTUpO1xuICAgICAgICAgICAgUiA9IFBvaW50LmZyb21IZXgoc2lnLnNsaWNlKDAsIGxlbiksIHppcDIxNSk7XG4gICAgICAgICAgICBTQiA9IEcubXVsdGlwbHlVbnNhZmUocyk7IC8vIDAgPD0gcyA8IGwgaXMgZG9uZSBpbnNpZGVcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXppcDIxNSAmJiBBLmlzU21hbGxPcmRlcigpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBrID0gaGFzaERvbWFpblRvU2NhbGFyKGNvbnRleHQsIFIudG9SYXdCeXRlcygpLCBBLnRvUmF3Qnl0ZXMoKSwgbXNnKTtcbiAgICAgICAgY29uc3QgUmtBID0gUi5hZGQoQS5tdWx0aXBseVVuc2FmZShrKSk7XG4gICAgICAgIC8vIFs4XVtTXUIgPSBbOF1SICsgWzhdW2tdQSdcbiAgICAgICAgcmV0dXJuIFJrQS5zdWJ0cmFjdChTQikuY2xlYXJDb2ZhY3RvcigpLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICB9XG4gICAgRy5fc2V0V2luZG93U2l6ZSg4KTsgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICBnZXRFeHRlbmRlZFB1YmxpY0tleSxcbiAgICAgICAgLy8gZWQyNTUxOSBwcml2YXRlIGtleXMgYXJlIHVuaWZvcm0gMzJiLiBObyBuZWVkIHRvIGNoZWNrIGZvciBtb2R1bG8gYmlhcywgbGlrZSBpbiBzZWNwMjU2azEuXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlJ3JlIGRvaW5nIHNjYWxhciBtdWx0aXBsaWNhdGlvbiAodXNlZCBpbiBnZXRQdWJsaWNLZXkgZXRjKSB3aXRoIHByZWNvbXB1dGVkIEJBU0VfUE9JTlRcbiAgICAgICAgICogdmFsdWVzLiBUaGlzIHNsb3dzIGRvd24gZmlyc3QgZ2V0UHVibGljS2V5KCkgYnkgbWlsbGlzZWNvbmRzIChzZWUgU3BlZWQgc2VjdGlvbiksXG4gICAgICAgICAqIGJ1dCBhbGxvd3MgdG8gc3BlZWQtdXAgc3Vic2VxdWVudCBnZXRQdWJsaWNLZXkoKSBjYWxscyB1cCB0byAyMHguXG4gICAgICAgICAqIEBwYXJhbSB3aW5kb3dTaXplIDIsIDQsIDgsIDE2XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgRXh0ZW5kZWRQb2ludDogUG9pbnQsXG4gICAgICAgIHV0aWxzLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lZHdhcmRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHBhbmRfbWVzc2FnZV94bWQgPSBleHBhbmRfbWVzc2FnZV94bWQ7XG5leHBvcnRzLmV4cGFuZF9tZXNzYWdlX3hvZiA9IGV4cGFuZF9tZXNzYWdlX3hvZjtcbmV4cG9ydHMuaGFzaF90b19maWVsZCA9IGhhc2hfdG9fZmllbGQ7XG5leHBvcnRzLmlzb2dlbnlNYXAgPSBpc29nZW55TWFwO1xuZXhwb3J0cy5jcmVhdGVIYXNoZXIgPSBjcmVhdGVIYXNoZXI7XG5jb25zdCBtb2R1bGFyX2pzXzEgPSByZXF1aXJlKFwiLi9tb2R1bGFyLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gT2N0ZXQgU3RyZWFtIHRvIEludGVnZXIuIFwic3BlY1wiIGltcGxlbWVudGF0aW9uIG9mIG9zMmlwIGlzIDIuNXggc2xvd2VyIHZzIGJ5dGVzVG9OdW1iZXJCRS5cbmNvbnN0IG9zMmlwID0gdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyQkU7XG4vLyBJbnRlZ2VyIHRvIE9jdGV0IFN0cmVhbSAobnVtYmVyVG9CeXRlc0JFKVxuZnVuY3Rpb24gaTJvc3AodmFsdWUsIGxlbmd0aCkge1xuICAgIGFudW0odmFsdWUpO1xuICAgIGFudW0obGVuZ3RoKTtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDEgPDwgKDggKiBsZW5ndGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYmFkIEkyT1NQIGNhbGw6IHZhbHVlPSR7dmFsdWV9IGxlbmd0aD0ke2xlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXNbaV0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcyk7XG59XG5mdW5jdGlvbiBzdHJ4b3IoYSwgYikge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXSBeIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBhbnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGEgY3J5cHRvZ3JhcGhpYyBoYXNoIGZ1bmN0aW9uIEggdGhhdCBvdXRwdXRzIGIgYml0c1xuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMVxuZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBIKSB7XG4gICAgKDAsIHV0aWxzX2pzXzEuYWJ5dGVzKShtc2cpO1xuICAgICgwLCB1dGlsc19qc18xLmFieXRlcykoRFNUKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgRFNUID0gSCgoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykoKDAsIHV0aWxzX2pzXzEudXRmOFRvQnl0ZXMpKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IGVsbCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94bWQ6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9ICgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKShEU1QsIGkyb3NwKERTVC5sZW5ndGgsIDEpKTtcbiAgICBjb25zdCBaX3BhZCA9IGkyb3NwKDAsIHJfaW5fYnl0ZXMpO1xuICAgIGNvbnN0IGxfaV9iX3N0ciA9IGkyb3NwKGxlbkluQnl0ZXMsIDIpOyAvLyBsZW5faW5fYnl0ZXNfc3RyXG4gICAgY29uc3QgYiA9IG5ldyBBcnJheShlbGwpO1xuICAgIGNvbnN0IGJfMCA9IEgoKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKFpfcGFkLCBtc2csIGxfaV9iX3N0ciwgaTJvc3AoMCwgMSksIERTVF9wcmltZSkpO1xuICAgIGJbMF0gPSBIKCgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKShiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSCgoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykoLi4uYXJncykpO1xuICAgIH1cbiAgICBjb25zdCBwc2V1ZG9fcmFuZG9tX2J5dGVzID0gKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKC4uLmIpO1xuICAgIHJldHVybiBwc2V1ZG9fcmFuZG9tX2J5dGVzLnNsaWNlKDAsIGxlbkluQnl0ZXMpO1xufVxuLy8gUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGFuIGV4dGVuZGFibGUtb3V0cHV0IGZ1bmN0aW9uIChYT0YpIEguXG4vLyAxLiBUaGUgY29sbGlzaW9uIHJlc2lzdGFuY2Ugb2YgSCBNVVNUIGJlIGF0IGxlYXN0IGsgYml0cy5cbi8vIDIuIEggTVVTVCBiZSBhbiBYT0YgdGhhdCBoYXMgYmVlbiBwcm92ZWQgaW5kaWZmZXJlbnRpYWJsZSBmcm9tXG4vLyAgICBhIHJhbmRvbSBvcmFjbGUgdW5kZXIgYSByZWFzb25hYmxlIGNyeXB0b2dyYXBoaWMgYXNzdW1wdGlvbi5cbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjJcbmZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuSW5CeXRlcywgaywgSCkge1xuICAgICgwLCB1dGlsc19qc18xLmFieXRlcykobXNnKTtcbiAgICAoMCwgdXRpbHNfanNfMS5hYnl0ZXMpKERTVCk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSgoMCwgdXRpbHNfanNfMS51dGY4VG9CeXRlcykoJ0gyQy1PVkVSU0laRS1EU1QtJykpLnVwZGF0ZShEU1QpLmRpZ2VzdCgpO1xuICAgIH1cbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG9mOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcbiAgICByZXR1cm4gKEguY3JlYXRlKHsgZGtMZW46IGxlbkluQnl0ZXMgfSlcbiAgICAgICAgLnVwZGF0ZShtc2cpXG4gICAgICAgIC51cGRhdGUoaTJvc3AobGVuSW5CeXRlcywgMikpXG4gICAgICAgIC8vIDIuIERTVF9wcmltZSA9IERTVCB8fCBJMk9TUChsZW4oRFNUKSwgMSlcbiAgICAgICAgLnVwZGF0ZShEU1QpXG4gICAgICAgIC51cGRhdGUoaTJvc3AoRFNULmxlbmd0aCwgMSkpXG4gICAgICAgIC5kaWdlc3QoKSk7XG59XG4vKipcbiAqIEhhc2hlcyBhcmJpdHJhcnktbGVuZ3RoIGJ5dGUgc3RyaW5ncyB0byBhIGxpc3Qgb2Ygb25lIG9yIG1vcmUgZWxlbWVudHMgb2YgYSBmaW5pdGUgZmllbGQgRlxuICogaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjJcbiAqIEBwYXJhbSBtc2cgYSBieXRlIHN0cmluZyBjb250YWluaW5nIHRoZSBtZXNzYWdlIHRvIGhhc2hcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIEYgdG8gb3V0cHV0XG4gKiBAcGFyYW0gb3B0aW9ucyBge0RTVDogc3RyaW5nLCBwOiBiaWdpbnQsIG06IG51bWJlciwgazogbnVtYmVyLCBleHBhbmQ6ICd4bWQnIHwgJ3hvZicsIGhhc2g6IEh9YCwgc2VlIGFib3ZlXG4gKiBAcmV0dXJucyBbdV8wLCAuLi4sIHVfKGNvdW50IC0gMSldLCBhIGxpc3Qgb2YgZmllbGQgZWxlbWVudHMuXG4gKi9cbmZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgICgwLCB1dGlsc19qc18xLnZhbGlkYXRlT2JqZWN0KShvcHRpb25zLCB7XG4gICAgICAgIERTVDogJ3N0cmluZ09yVWludDhBcnJheScsXG4gICAgICAgIHA6ICdiaWdpbnQnLFxuICAgICAgICBtOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGs6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgcCwgaywgbSwgaGFzaCwgZXhwYW5kLCBEU1Q6IF9EU1QgfSA9IG9wdGlvbnM7XG4gICAgKDAsIHV0aWxzX2pzXzEuYWJ5dGVzKShtc2cpO1xuICAgIGFudW0oY291bnQpO1xuICAgIGNvbnN0IERTVCA9IHR5cGVvZiBfRFNUID09PSAnc3RyaW5nJyA/ICgwLCB1dGlsc19qc18xLnV0ZjhUb0J5dGVzKShfRFNUKSA6IF9EU1Q7XG4gICAgY29uc3QgbG9nMnAgPSBwLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICBjb25zdCBMID0gTWF0aC5jZWlsKChsb2cycCArIGspIC8gOCk7IC8vIHNlY3Rpb24gNS4xIG9mIGlldGYgZHJhZnQgbGluayBhYm92ZVxuICAgIGNvbnN0IGxlbl9pbl9ieXRlcyA9IGNvdW50ICogbSAqIEw7XG4gICAgbGV0IHByYjsgLy8gcHNldWRvX3JhbmRvbV9ieXRlc1xuICAgIGlmIChleHBhbmQgPT09ICd4bWQnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuX2luX2J5dGVzLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAneG9mJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ19pbnRlcm5hbF9wYXNzJykge1xuICAgICAgICAvLyBmb3IgaW50ZXJuYWwgdGVzdHMgb25seVxuICAgICAgICBwcmIgPSBtc2c7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZCBtdXN0IGJlIFwieG1kXCIgb3IgXCJ4b2ZcIicpO1xuICAgIH1cbiAgICBjb25zdCB1ID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyBBcnJheShtKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbV9vZmZzZXQgPSBMICogKGogKyBpICogbSk7XG4gICAgICAgICAgICBjb25zdCB0diA9IHByYi5zdWJhcnJheShlbG1fb2Zmc2V0LCBlbG1fb2Zmc2V0ICsgTCk7XG4gICAgICAgICAgICBlW2pdID0gKDAsIG1vZHVsYXJfanNfMS5tb2QpKG9zMmlwKHR2KSwgcCk7XG4gICAgICAgIH1cbiAgICAgICAgdVtpXSA9IGU7XG4gICAgfVxuICAgIHJldHVybiB1O1xufVxuZnVuY3Rpb24gaXNvZ2VueU1hcChmaWVsZCwgbWFwKSB7XG4gICAgLy8gTWFrZSBzYW1lIG9yZGVyIGFzIGluIHNwZWNcbiAgICBjb25zdCBDT0VGRiA9IG1hcC5tYXAoKGkpID0+IEFycmF5LmZyb20oaSkucmV2ZXJzZSgpKTtcbiAgICByZXR1cm4gKHgsIHkpID0+IHtcbiAgICAgICAgY29uc3QgW3hOdW0sIHhEZW4sIHlOdW0sIHlEZW5dID0gQ09FRkYubWFwKCh2YWwpID0+IHZhbC5yZWR1Y2UoKGFjYywgaSkgPT4gZmllbGQuYWRkKGZpZWxkLm11bChhY2MsIHgpLCBpKSkpO1xuICAgICAgICB4ID0gZmllbGQuZGl2KHhOdW0sIHhEZW4pOyAvLyB4TnVtIC8geERlblxuICAgICAgICB5ID0gZmllbGQubXVsKHksIGZpZWxkLmRpdih5TnVtLCB5RGVuKSk7IC8vIHkgKiAoeU51bSAvIHlEZXYpXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSGFzaGVyKFBvaW50LCBtYXBUb0N1cnZlLCBkZWYpIHtcbiAgICBpZiAodHlwZW9mIG1hcFRvQ3VydmUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZSgpIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGhhc2hfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgaGFzaFRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDIsIHsgLi4uZGVmLCBEU1Q6IGRlZi5EU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCB1MCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSk7XG4gICAgICAgICAgICBjb25zdCB1MSA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzFdKSk7XG4gICAgICAgICAgICBjb25zdCBQID0gdTAuYWRkKHUxKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gZW5jb2RlX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGVuY29kZVRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDEsIHsgLi4uZGVmLCBEU1Q6IGRlZi5lbmNvZGVEU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU2FtZSBhcyBlbmNvZGVUb0N1cnZlLCBidXQgd2l0aG91dCBoYXNoXG4gICAgICAgIG1hcFRvQ3VydmUoc2NhbGFycykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjYWxhcnMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZTogZXhwZWN0ZWQgYXJyYXkgb2YgYmlnaW50cycpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpIG9mIHNjYWxhcnMpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBtYXBUb0N1cnZlOiBleHBlY3RlZCBhcnJheSBvZiBiaWdpbnRzLCBnb3QgJHtpfSBpbiBhcnJheWApO1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZShzY2FsYXJzKSkuY2xlYXJDb2ZhY3RvcigpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhhc2gtdG8tY3VydmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1vbnRnb21lcnkgPSBtb250Z29tZXJ5O1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3QgbW9kdWxhcl9qc18xID0gcmVxdWlyZShcIi4vbW9kdWxhci5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgICgwLCB1dGlsc19qc18xLnZhbGlkYXRlT2JqZWN0KShjdXJ2ZSwge1xuICAgICAgICBhOiAnYmlnaW50JyxcbiAgICB9LCB7XG4gICAgICAgIG1vbnRnb21lcnlCaXRzOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIG5CeXRlTGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGFkanVzdFNjYWxhckJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICBkb21haW46ICdmdW5jdGlvbicsXG4gICAgICAgIHBvd1BtaW51czI6ICdmdW5jdGlvbicsXG4gICAgICAgIEd1OiAnYmlnaW50JyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLmN1cnZlIH0pO1xufVxuLy8gTk9URTogbm90IHJlYWxseSBtb250Z29tZXJ5IGN1cnZlLCBqdXN0IGJ1bmNoIG9mIHZlcnkgc3BlY2lmaWMgbWV0aG9kcyBmb3IgWDI1NTE5L1g0NDggKFJGQyA3NzQ4LCBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNzc0OClcbi8vIFVzZXMgb25seSBvbmUgY29vcmRpbmF0ZSBpbnN0ZWFkIG9mIHR3b1xuZnVuY3Rpb24gbW9udGdvbWVyeShjdXJ2ZURlZikge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVPcHRzKGN1cnZlRGVmKTtcbiAgICBjb25zdCB7IFAgfSA9IENVUlZFO1xuICAgIGNvbnN0IG1vZFAgPSAobikgPT4gKDAsIG1vZHVsYXJfanNfMS5tb2QpKG4sIFApO1xuICAgIGNvbnN0IG1vbnRnb21lcnlCaXRzID0gQ1VSVkUubW9udGdvbWVyeUJpdHM7XG4gICAgY29uc3QgbW9udGdvbWVyeUJ5dGVzID0gTWF0aC5jZWlsKG1vbnRnb21lcnlCaXRzIC8gOCk7XG4gICAgY29uc3QgZmllbGRMZW4gPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICBjb25zdCBhZGp1c3RTY2FsYXJCeXRlcyA9IENVUlZFLmFkanVzdFNjYWxhckJ5dGVzIHx8ICgoYnl0ZXMpID0+IGJ5dGVzKTtcbiAgICBjb25zdCBwb3dQbWludXMyID0gQ1VSVkUucG93UG1pbnVzMiB8fCAoKHgpID0+ICgwLCBtb2R1bGFyX2pzXzEucG93KSh4LCBQIC0gQmlnSW50KDIpLCBQKSk7XG4gICAgLy8gY3N3YXAgZnJvbSBSRkM3NzQ4LiBCdXQgaXQgaXMgbm90IGZyb20gUkZDNzc0OCFcbiAgICAvKlxuICAgICAgY3N3YXAoc3dhcCwgeF8yLCB4XzMpOlxuICAgICAgICAgICBkdW1teSA9IG1hc2soc3dhcCkgQU5EICh4XzIgWE9SIHhfMylcbiAgICAgICAgICAgeF8yID0geF8yIFhPUiBkdW1teVxuICAgICAgICAgICB4XzMgPSB4XzMgWE9SIGR1bW15XG4gICAgICAgICAgIFJldHVybiAoeF8yLCB4XzMpXG4gICAgV2hlcmUgbWFzayhzd2FwKSBpcyB0aGUgYWxsLTEgb3IgYWxsLTAgd29yZCBvZiB0aGUgc2FtZSBsZW5ndGggYXMgeF8yXG4gICAgIGFuZCB4XzMsIGNvbXB1dGVkLCBlLmcuLCBhcyBtYXNrKHN3YXApID0gMCAtIHN3YXAuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBjc3dhcChzd2FwLCB4XzIsIHhfMykge1xuICAgICAgICBjb25zdCBkdW1teSA9IG1vZFAoc3dhcCAqICh4XzIgLSB4XzMpKTtcbiAgICAgICAgeF8yID0gbW9kUCh4XzIgLSBkdW1teSk7XG4gICAgICAgIHhfMyA9IG1vZFAoeF8zICsgZHVtbXkpO1xuICAgICAgICByZXR1cm4gW3hfMiwgeF8zXTtcbiAgICB9XG4gICAgLy8geDI1NTE5IGZyb20gNFxuICAgIC8vIFRoZSBjb25zdGFudCBhMjQgaXMgKDQ4NjY2MiAtIDIpIC8gNCA9IDEyMTY2NSBmb3IgY3VydmUyNTUxOS9YMjU1MTlcbiAgICBjb25zdCBhMjQgPSAoQ1VSVkUuYSAtIEJpZ0ludCgyKSkgLyBCaWdJbnQoNCk7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9pbnRVIHUgY29vcmRpbmF0ZSAoeCkgb24gTW9udGdvbWVyeSBDdXJ2ZSAyNTUxOVxuICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgKiBAcmV0dXJucyBuZXcgUG9pbnQgb24gTW9udGdvbWVyeSBjdXJ2ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vbnRnb21lcnlMYWRkZXIodSwgc2NhbGFyKSB7XG4gICAgICAgICgwLCB1dGlsc19qc18xLmFJblJhbmdlKSgndScsIHUsIF8wbiwgUCk7XG4gICAgICAgICgwLCB1dGlsc19qc18xLmFJblJhbmdlKSgnc2NhbGFyJywgc2NhbGFyLCBfMG4sIFApO1xuICAgICAgICAvLyBTZWN0aW9uIDU6IEltcGxlbWVudGF0aW9ucyBNVVNUIGFjY2VwdCBub24tY2Fub25pY2FsIHZhbHVlcyBhbmQgcHJvY2VzcyB0aGVtIGFzXG4gICAgICAgIC8vIGlmIHRoZXkgaGFkIGJlZW4gcmVkdWNlZCBtb2R1bG8gdGhlIGZpZWxkIHByaW1lLlxuICAgICAgICBjb25zdCBrID0gc2NhbGFyO1xuICAgICAgICBjb25zdCB4XzEgPSB1O1xuICAgICAgICBsZXQgeF8yID0gXzFuO1xuICAgICAgICBsZXQgel8yID0gXzBuO1xuICAgICAgICBsZXQgeF8zID0gdTtcbiAgICAgICAgbGV0IHpfMyA9IF8xbjtcbiAgICAgICAgbGV0IHN3YXAgPSBfMG47XG4gICAgICAgIGxldCBzdztcbiAgICAgICAgZm9yIChsZXQgdCA9IEJpZ0ludChtb250Z29tZXJ5Qml0cyAtIDEpOyB0ID49IF8wbjsgdC0tKSB7XG4gICAgICAgICAgICBjb25zdCBrX3QgPSAoayA+PiB0KSAmIF8xbjtcbiAgICAgICAgICAgIHN3YXAgXj0ga190O1xuICAgICAgICAgICAgc3cgPSBjc3dhcChzd2FwLCB4XzIsIHhfMyk7XG4gICAgICAgICAgICB4XzIgPSBzd1swXTtcbiAgICAgICAgICAgIHhfMyA9IHN3WzFdO1xuICAgICAgICAgICAgc3cgPSBjc3dhcChzd2FwLCB6XzIsIHpfMyk7XG4gICAgICAgICAgICB6XzIgPSBzd1swXTtcbiAgICAgICAgICAgIHpfMyA9IHN3WzFdO1xuICAgICAgICAgICAgc3dhcCA9IGtfdDtcbiAgICAgICAgICAgIGNvbnN0IEEgPSB4XzIgKyB6XzI7XG4gICAgICAgICAgICBjb25zdCBBQSA9IG1vZFAoQSAqIEEpO1xuICAgICAgICAgICAgY29uc3QgQiA9IHhfMiAtIHpfMjtcbiAgICAgICAgICAgIGNvbnN0IEJCID0gbW9kUChCICogQik7XG4gICAgICAgICAgICBjb25zdCBFID0gQUEgLSBCQjtcbiAgICAgICAgICAgIGNvbnN0IEMgPSB4XzMgKyB6XzM7XG4gICAgICAgICAgICBjb25zdCBEID0geF8zIC0gel8zO1xuICAgICAgICAgICAgY29uc3QgREEgPSBtb2RQKEQgKiBBKTtcbiAgICAgICAgICAgIGNvbnN0IENCID0gbW9kUChDICogQik7XG4gICAgICAgICAgICBjb25zdCBkYWNiID0gREEgKyBDQjtcbiAgICAgICAgICAgIGNvbnN0IGRhX2NiID0gREEgLSBDQjtcbiAgICAgICAgICAgIHhfMyA9IG1vZFAoZGFjYiAqIGRhY2IpO1xuICAgICAgICAgICAgel8zID0gbW9kUCh4XzEgKiBtb2RQKGRhX2NiICogZGFfY2IpKTtcbiAgICAgICAgICAgIHhfMiA9IG1vZFAoQUEgKiBCQik7XG4gICAgICAgICAgICB6XzIgPSBtb2RQKEUgKiAoQUEgKyBtb2RQKGEyNCAqIEUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gKHhfMiwgeF8zKSA9IGNzd2FwKHN3YXAsIHhfMiwgeF8zKVxuICAgICAgICBzdyA9IGNzd2FwKHN3YXAsIHhfMiwgeF8zKTtcbiAgICAgICAgeF8yID0gc3dbMF07XG4gICAgICAgIHhfMyA9IHN3WzFdO1xuICAgICAgICAvLyAoel8yLCB6XzMpID0gY3N3YXAoc3dhcCwgel8yLCB6XzMpXG4gICAgICAgIHN3ID0gY3N3YXAoc3dhcCwgel8yLCB6XzMpO1xuICAgICAgICB6XzIgPSBzd1swXTtcbiAgICAgICAgel8zID0gc3dbMV07XG4gICAgICAgIC8vIHpfMl4ocCAtIDIpXG4gICAgICAgIGNvbnN0IHoyID0gcG93UG1pbnVzMih6XzIpO1xuICAgICAgICAvLyBSZXR1cm4geF8yICogKHpfMl4ocCAtIDIpKVxuICAgICAgICByZXR1cm4gbW9kUCh4XzIgKiB6Mik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZVVDb29yZGluYXRlKHUpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc19qc18xLm51bWJlclRvQnl0ZXNMRSkobW9kUCh1KSwgbW9udGdvbWVyeUJ5dGVzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlVUNvb3JkaW5hdGUodUVuYykge1xuICAgICAgICAvLyBTZWN0aW9uIDU6IFdoZW4gcmVjZWl2aW5nIHN1Y2ggYW4gYXJyYXksIGltcGxlbWVudGF0aW9ucyBvZiBYMjU1MTlcbiAgICAgICAgLy8gTVVTVCBtYXNrIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBpbiB0aGUgZmluYWwgYnl0ZS5cbiAgICAgICAgY29uc3QgdSA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgndSBjb29yZGluYXRlJywgdUVuYywgbW9udGdvbWVyeUJ5dGVzKTtcbiAgICAgICAgaWYgKGZpZWxkTGVuID09PSAzMilcbiAgICAgICAgICAgIHVbMzFdICY9IDEyNzsgLy8gMGIwMTExXzExMTFcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJMRSkodSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZVNjYWxhcihuKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdzY2FsYXInLCBuKTtcbiAgICAgICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuICE9PSBtb250Z29tZXJ5Qnl0ZXMgJiYgbGVuICE9PSBmaWVsZExlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJHttb250Z29tZXJ5Qnl0ZXN9IG9yICR7ZmllbGRMZW59IGJ5dGVzLCBnb3QgJHtsZW59YCk7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS5ieXRlc1RvTnVtYmVyTEUpKGFkanVzdFNjYWxhckJ5dGVzKGJ5dGVzKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYWxhck11bHQoc2NhbGFyLCB1KSB7XG4gICAgICAgIGNvbnN0IHBvaW50VSA9IGRlY29kZVVDb29yZGluYXRlKHUpO1xuICAgICAgICBjb25zdCBfc2NhbGFyID0gZGVjb2RlU2NhbGFyKHNjYWxhcik7XG4gICAgICAgIGNvbnN0IHB1ID0gbW9udGdvbWVyeUxhZGRlcihwb2ludFUsIF9zY2FsYXIpO1xuICAgICAgICAvLyBUaGUgcmVzdWx0IHdhcyBub3QgY29udHJpYnV0b3J5XG4gICAgICAgIC8vIGh0dHBzOi8vY3IueXAudG8vZWNkaC5odG1sI3ZhbGlkYXRlXG4gICAgICAgIGlmIChwdSA9PT0gXzBuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByaXZhdGUgb3IgcHVibGljIGtleSByZWNlaXZlZCcpO1xuICAgICAgICByZXR1cm4gZW5jb2RlVUNvb3JkaW5hdGUocHUpO1xuICAgIH1cbiAgICAvLyBDb21wdXRlcyBwdWJsaWMga2V5IGZyb20gcHJpdmF0ZS4gQnkgZG9pbmcgc2NhbGFyIG11bHRpcGxpY2F0aW9uIG9mIGJhc2UgcG9pbnQuXG4gICAgY29uc3QgR3VCeXRlcyA9IGVuY29kZVVDb29yZGluYXRlKENVUlZFLkd1KTtcbiAgICBmdW5jdGlvbiBzY2FsYXJNdWx0QmFzZShzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIHNjYWxhck11bHQoc2NhbGFyLCBHdUJ5dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NhbGFyTXVsdCxcbiAgICAgICAgc2NhbGFyTXVsdEJhc2UsXG4gICAgICAgIGdldFNoYXJlZFNlY3JldDogKHByaXZhdGVLZXksIHB1YmxpY0tleSkgPT4gc2NhbGFyTXVsdChwcml2YXRlS2V5LCBwdWJsaWNLZXkpLFxuICAgICAgICBnZXRQdWJsaWNLZXk6IChwcml2YXRlS2V5KSA9PiBzY2FsYXJNdWx0QmFzZShwcml2YXRlS2V5KSxcbiAgICAgICAgdXRpbHM6IHsgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4gQ1VSVkUucmFuZG9tQnl0ZXMoQ1VSVkUubkJ5dGVMZW5ndGgpIH0sXG4gICAgICAgIEd1Qnl0ZXM6IEd1Qnl0ZXMsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1vbnRnb21lcnkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhhc2hfdG9fcmlzdHJldHRvMjU1ID0gZXhwb3J0cy5oYXNoVG9SaXN0cmV0dG8yNTUgPSBleHBvcnRzLlJpc3RyZXR0b1BvaW50ID0gZXhwb3J0cy5lbmNvZGVUb0N1cnZlID0gZXhwb3J0cy5oYXNoVG9DdXJ2ZSA9IGV4cG9ydHMuZWR3YXJkc1RvTW9udGdvbWVyeSA9IGV4cG9ydHMueDI1NTE5ID0gZXhwb3J0cy5lZDI1NTE5cGggPSBleHBvcnRzLmVkMjU1MTljdHggPSBleHBvcnRzLmVkMjU1MTkgPSBleHBvcnRzLkVEMjU1MTlfVE9SU0lPTl9TVUJHUk9VUCA9IHZvaWQgMDtcbmV4cG9ydHMuZWR3YXJkc1RvTW9udGdvbWVyeVB1YiA9IGVkd2FyZHNUb01vbnRnb21lcnlQdWI7XG5leHBvcnRzLmVkd2FyZHNUb01vbnRnb21lcnlQcml2ID0gZWR3YXJkc1RvTW9udGdvbWVyeVByaXY7XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCBzaGE1MTJfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTUxMlwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy91dGlsc1wiKTtcbmNvbnN0IGVkd2FyZHNfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L2Vkd2FyZHMuanNcIik7XG5jb25zdCBoYXNoX3RvX2N1cnZlX2pzXzEgPSByZXF1aXJlKFwiLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzXCIpO1xuY29uc3QgbW9kdWxhcl9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QvbW9kdWxhci5qc1wiKTtcbmNvbnN0IG1vbnRnb21lcnlfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L21vbnRnb21lcnkuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QvdXRpbHMuanNcIik7XG4vKipcbiAqIGVkMjU1MTkgVHdpc3RlZCBFZHdhcmRzIGN1cnZlIHdpdGggZm9sbG93aW5nIGFkZG9uczpcbiAqIC0gWDI1NTE5IEVDREhcbiAqIC0gUmlzdHJldHRvIGNvZmFjdG9yIGVsaW1pbmF0aW9uXG4gKiAtIEVsbGlnYXRvciBoYXNoLXRvLWdyb3VwIC8gcG9pbnQgaW5kaXN0aW5ndWlzaGFiaWxpdHlcbiAqL1xuY29uc3QgRUQyNTUxOV9QID0gQmlnSW50KCc1Nzg5NjA0NDYxODY1ODA5NzcxMTc4NTQ5MjUwNDM0Mzk1MzkyNjYzNDk5MjMzMjgyMDI4MjAxOTcyODc5MjAwMzk1NjU2NDgxOTk0OScpO1xuLy8g4oiaKC0xKSBha2Eg4oiaKGEpIGFrYSAyXigocC0xKS80KVxuY29uc3QgRUQyNTUxOV9TUVJUX00xID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgnMTk2ODExNjEzNzY3MDc1MDU5NTY4MDcwNzkzMDQ5ODg1NDIwMTU0NDYwNjY1MTU5MjM4OTAxNjI3NDQwMjEwNzMxMjM4Mjk3ODQ3NTInKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfNW4gPSBCaWdJbnQoNSksIF84biA9IEJpZ0ludCg4KTtcbmZ1bmN0aW9uIGVkMjU1MTlfcG93XzJfMjUyXzMoeCkge1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8xMG4gPSBCaWdJbnQoMTApLCBfMjBuID0gQmlnSW50KDIwKSwgXzQwbiA9IEJpZ0ludCg0MCksIF84MG4gPSBCaWdJbnQoODApO1xuICAgIGNvbnN0IFAgPSBFRDI1NTE5X1A7XG4gICAgY29uc3QgeDIgPSAoeCAqIHgpICUgUDtcbiAgICBjb25zdCBiMiA9ICh4MiAqIHgpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGI0ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjIsIF8ybiwgUCkgKiBiMikgJSBQOyAvLyB4XjE1LCAxMTExXG4gICAgY29uc3QgYjUgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiNCwgXzFuLCBQKSAqIHgpICUgUDsgLy8geF4zMVxuICAgIGNvbnN0IGIxMCA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGI1LCBfNW4sIFApICogYjUpICUgUDtcbiAgICBjb25zdCBiMjAgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMTAsIF8xMG4sIFApICogYjEwKSAlIFA7XG4gICAgY29uc3QgYjQwID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjIwLCBfMjBuLCBQKSAqIGIyMCkgJSBQO1xuICAgIGNvbnN0IGI4MCA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGI0MCwgXzQwbiwgUCkgKiBiNDApICUgUDtcbiAgICBjb25zdCBiMTYwID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjgwLCBfODBuLCBQKSAqIGI4MCkgJSBQO1xuICAgIGNvbnN0IGIyNDAgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMTYwLCBfODBuLCBQKSAqIGI4MCkgJSBQO1xuICAgIGNvbnN0IGIyNTAgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMjQwLCBfMTBuLCBQKSAqIGIxMCkgJSBQO1xuICAgIGNvbnN0IHBvd19wXzVfOCA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGIyNTAsIF8ybiwgUCkgKiB4KSAlIFA7XG4gICAgLy8gXiBUbyBwb3cgdG8gKHArMykvOCwgbXVsdGlwbHkgaXQgYnkgeC5cbiAgICByZXR1cm4geyBwb3dfcF81XzgsIGIyIH07XG59XG5mdW5jdGlvbiBhZGp1c3RTY2FsYXJCeXRlcyhieXRlcykge1xuICAgIC8vIFNlY3Rpb24gNTogRm9yIFgyNTUxOSwgaW4gb3JkZXIgdG8gZGVjb2RlIDMyIHJhbmRvbSBieXRlcyBhcyBhbiBpbnRlZ2VyIHNjYWxhcixcbiAgICAvLyBzZXQgdGhlIHRocmVlIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgb2YgdGhlIGZpcnN0IGJ5dGVcbiAgICBieXRlc1swXSAmPSAyNDg7IC8vIDBiMTExMV8xMDAwXG4gICAgLy8gYW5kIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgbGFzdCB0byB6ZXJvLFxuICAgIGJ5dGVzWzMxXSAmPSAxMjc7IC8vIDBiMDExMV8xMTExXG4gICAgLy8gc2V0IHRoZSBzZWNvbmQgbW9zdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIGxhc3QgYnl0ZSB0byAxXG4gICAgYnl0ZXNbMzFdIHw9IDY0OyAvLyAwYjAxMDBfMDAwMFxuICAgIHJldHVybiBieXRlcztcbn1cbi8vIHNxcnQodS92KVxuZnVuY3Rpb24gdXZSYXRpbyh1LCB2KSB7XG4gICAgY29uc3QgUCA9IEVEMjU1MTlfUDtcbiAgICBjb25zdCB2MyA9ICgwLCBtb2R1bGFyX2pzXzEubW9kKSh2ICogdiAqIHYsIFApOyAvLyB2wrNcbiAgICBjb25zdCB2NyA9ICgwLCBtb2R1bGFyX2pzXzEubW9kKSh2MyAqIHYzICogdiwgUCk7IC8vIHbigbdcbiAgICAvLyAocCszKS84IGFuZCAocC01KS84XG4gICAgY29uc3QgcG93ID0gZWQyNTUxOV9wb3dfMl8yNTJfMyh1ICogdjcpLnBvd19wXzVfODtcbiAgICBsZXQgeCA9ICgwLCBtb2R1bGFyX2pzXzEubW9kKSh1ICogdjMgKiBwb3csIFApOyAvLyAodXbCsykodXbigbcpXihwLTUpLzhcbiAgICBjb25zdCB2eDIgPSAoMCwgbW9kdWxhcl9qc18xLm1vZCkodiAqIHggKiB4LCBQKTsgLy8gdnjCslxuICAgIGNvbnN0IHJvb3QxID0geDsgLy8gRmlyc3Qgcm9vdCBjYW5kaWRhdGVcbiAgICBjb25zdCByb290MiA9ICgwLCBtb2R1bGFyX2pzXzEubW9kKSh4ICogRUQyNTUxOV9TUVJUX00xLCBQKTsgLy8gU2Vjb25kIHJvb3QgY2FuZGlkYXRlXG4gICAgY29uc3QgdXNlUm9vdDEgPSB2eDIgPT09IHU7IC8vIElmIHZ4wrIgPSB1IChtb2QgcCksIHggaXMgYSBzcXVhcmUgcm9vdFxuICAgIGNvbnN0IHVzZVJvb3QyID0gdngyID09PSAoMCwgbW9kdWxhcl9qc18xLm1vZCkoLXUsIFApOyAvLyBJZiB2eMKyID0gLXUsIHNldCB4IDwtLSB4ICogMl4oKHAtMSkvNClcbiAgICBjb25zdCBub1Jvb3QgPSB2eDIgPT09ICgwLCBtb2R1bGFyX2pzXzEubW9kKSgtdSAqIEVEMjU1MTlfU1FSVF9NMSwgUCk7IC8vIFRoZXJlIGlzIG5vIHZhbGlkIHJvb3QsIHZ4wrIgPSAtdeKImigtMSlcbiAgICBpZiAodXNlUm9vdDEpXG4gICAgICAgIHggPSByb290MTtcbiAgICBpZiAodXNlUm9vdDIgfHwgbm9Sb290KVxuICAgICAgICB4ID0gcm9vdDI7IC8vIFdlIHJldHVybiByb290MiBhbnl3YXksIGZvciBjb25zdC10aW1lXG4gICAgaWYgKCgwLCBtb2R1bGFyX2pzXzEuaXNOZWdhdGl2ZUxFKSh4LCBQKSlcbiAgICAgICAgeCA9ICgwLCBtb2R1bGFyX2pzXzEubW9kKSgteCwgUCk7XG4gICAgcmV0dXJuIHsgaXNWYWxpZDogdXNlUm9vdDEgfHwgdXNlUm9vdDIsIHZhbHVlOiB4IH07XG59XG4vLyBKdXN0IGluIGNhc2VcbmV4cG9ydHMuRUQyNTUxOV9UT1JTSU9OX1NVQkdST1VQID0gW1xuICAgICcwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnYzcxNzZhNzAzZDRkZDg0ZmJhM2MwYjc2MGQxMDY3MGYyYTIwNTNmYTJjMzljY2M2NGVjN2ZkNzc5MmFjMDM3YScsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODAnLFxuICAgICcyNmU4OTU4ZmMyYjIyN2IwNDVjM2Y0ODlmMmVmOThmMGQ1ZGZhYzA1ZDNjNjMzMzliMTM4MDI4ODZkNTNmYzA1JyxcbiAgICAnZWNmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY3ZicsXG4gICAgJzI2ZTg5NThmYzJiMjI3YjA0NWMzZjQ4OWYyZWY5OGYwZDVkZmFjMDVkM2M2MzMzOWIxMzgwMjg4NmQ1M2ZjODUnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnYzcxNzZhNzAzZDRkZDg0ZmJhM2MwYjc2MGQxMDY3MGYyYTIwNTNmYTJjMzljY2M2NGVjN2ZkNzc5MmFjMDNmYScsXG5dO1xuY29uc3QgRnAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICgwLCBtb2R1bGFyX2pzXzEuRmllbGQpKEVEMjU1MTlfUCwgdW5kZWZpbmVkLCB0cnVlKSkoKTtcbmNvbnN0IGVkMjU1MTlEZWZhdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKHtcbiAgICAvLyBQYXJhbTogYVxuICAgIGE6IEJpZ0ludCgtMSksIC8vIEZwLmNyZWF0ZSgtMSkgaXMgcHJvcGVyOyBvdXIgd2F5IHN0aWxsIHdvcmtzIGFuZCBpcyBmYXN0ZXJcbiAgICAvLyBkIGlzIGVxdWFsIHRvIC0xMjE2NjUvMTIxNjY2IG92ZXIgZmluaXRlIGZpZWxkLlxuICAgIC8vIE5lZ2F0aXZlIG51bWJlciBpcyBQIC0gbnVtYmVyLCBhbmQgZGl2aXNpb24gaXMgaW52ZXJ0KG51bWJlciwgUClcbiAgICBkOiBCaWdJbnQoJzM3MDk1NzA1OTM0NjY5NDM5MzQzMTM4MDgzNTA4NzU0NTY1MTg5NTQyMTEzODc5ODQzMjE5MDE2Mzg4Nzg1NTMzMDg1OTQwMjgzNTU1JyksXG4gICAgLy8gRmluaXRlIGZpZWxkIPCdlL1wIG92ZXIgd2hpY2ggd2UnbGwgZG8gY2FsY3VsYXRpb25zOyAybioqMjU1biAtIDE5blxuICAgIEZwLFxuICAgIC8vIFN1Ymdyb3VwIG9yZGVyOiBob3cgbWFueSBwb2ludHMgY3VydmUgaGFzXG4gICAgLy8gMm4qKjI1Mm4gKyAyNzc0MjMxNzc3NzM3MjM1MzUzNTg1MTkzNzc5MDg4MzY0ODQ5M247XG4gICAgbjogQmlnSW50KCc3MjM3MDA1NTc3MzMyMjYyMjEzOTczMTg2NTYzMDQyOTk0MjQwODU3MTE2MzU5Mzc5OTA3NjA2MDAxOTUwOTM4Mjg1NDU0MjUwOTg5JyksXG4gICAgLy8gQ29mYWN0b3JcbiAgICBoOiBfOG4sXG4gICAgLy8gQmFzZSBwb2ludCAoeCwgeSkgYWthIGdlbmVyYXRvciBwb2ludFxuICAgIEd4OiBCaWdJbnQoJzE1MTEyMjIxMzQ5NTM1NDAwNzcyNTAxMTUxNDA5NTg4NTMxNTExNDU0MDEyNjkzMDQxODU3MjA2MDQ2MTEzMjgzOTQ5ODQ3NzYyMjAyJyksXG4gICAgR3k6IEJpZ0ludCgnNDYzMTY4MzU2OTQ5MjY0NzgxNjk0MjgzOTQwMDM0NzUxNjMxNDEzMDc5OTM4NjYyNTYyMjU2MTU3ODMwMzM2MDMxNjUyNTE4NTU5NjAnKSxcbiAgICBoYXNoOiBzaGE1MTJfMS5zaGE1MTIsXG4gICAgcmFuZG9tQnl0ZXM6IHV0aWxzXzEucmFuZG9tQnl0ZXMsXG4gICAgYWRqdXN0U2NhbGFyQnl0ZXMsXG4gICAgLy8gZG9tMlxuICAgIC8vIFJhdGlvIG9mIHUgdG8gdi4gQWxsb3dzIHVzIHRvIGNvbWJpbmUgaW52ZXJzaW9uIGFuZCBzcXVhcmUgcm9vdC4gVXNlcyBhbGdvIGZyb20gUkZDODAzMiA1LjEuMy5cbiAgICAvLyBDb25zdGFudC10aW1lLCB1L+KImnZcbiAgICB1dlJhdGlvLFxufSkpKCk7XG4vKipcbiAqIGVkMjU1MTkgY3VydmUgd2l0aCBFZERTQSBzaWduYXR1cmVzLlxuICovXG5leHBvcnRzLmVkMjU1MTkgPSAoKCkgPT4gKDAsIGVkd2FyZHNfanNfMS50d2lzdGVkRWR3YXJkcykoZWQyNTUxOURlZmF1bHRzKSkoKTtcbmZ1bmN0aW9uIGVkMjU1MTlfZG9tYWluKGRhdGEsIGN0eCwgcGhmbGFnKSB7XG4gICAgaWYgKGN0eC5sZW5ndGggPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGV4dCBpcyB0b28gYmlnJyk7XG4gICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKSgoMCwgdXRpbHNfMS51dGY4VG9CeXRlcykoJ1NpZ0VkMjU1MTkgbm8gRWQyNTUxOSBjb2xsaXNpb25zJyksIG5ldyBVaW50OEFycmF5KFtwaGZsYWcgPyAxIDogMCwgY3R4Lmxlbmd0aF0pLCBjdHgsIGRhdGEpO1xufVxuZXhwb3J0cy5lZDI1NTE5Y3R4ID0gKCgpID0+ICgwLCBlZHdhcmRzX2pzXzEudHdpc3RlZEVkd2FyZHMpKHtcbiAgICAuLi5lZDI1NTE5RGVmYXVsdHMsXG4gICAgZG9tYWluOiBlZDI1NTE5X2RvbWFpbixcbn0pKSgpO1xuZXhwb3J0cy5lZDI1NTE5cGggPSAoKCkgPT4gKDAsIGVkd2FyZHNfanNfMS50d2lzdGVkRWR3YXJkcykoT2JqZWN0LmFzc2lnbih7fSwgZWQyNTUxOURlZmF1bHRzLCB7XG4gICAgZG9tYWluOiBlZDI1NTE5X2RvbWFpbixcbiAgICBwcmVoYXNoOiBzaGE1MTJfMS5zaGE1MTIsXG59KSkpKCk7XG5leHBvcnRzLngyNTUxOSA9ICgoKSA9PiAoMCwgbW9udGdvbWVyeV9qc18xLm1vbnRnb21lcnkpKHtcbiAgICBQOiBFRDI1NTE5X1AsXG4gICAgYTogQmlnSW50KDQ4NjY2MiksXG4gICAgbW9udGdvbWVyeUJpdHM6IDI1NSwgLy8gbiBpcyAyNTMgYml0c1xuICAgIG5CeXRlTGVuZ3RoOiAzMixcbiAgICBHdTogQmlnSW50KDkpLFxuICAgIHBvd1BtaW51czI6ICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IFAgPSBFRDI1NTE5X1A7XG4gICAgICAgIC8vIHheKHAtMikgYWthIHheKDJeMjU1LTIxKVxuICAgICAgICBjb25zdCB7IHBvd19wXzVfOCwgYjIgfSA9IGVkMjU1MTlfcG93XzJfMjUyXzMoeCk7XG4gICAgICAgIHJldHVybiAoMCwgbW9kdWxhcl9qc18xLm1vZCkoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShwb3dfcF81XzgsIF8zbiwgUCkgKiBiMiwgUCk7XG4gICAgfSxcbiAgICBhZGp1c3RTY2FsYXJCeXRlcyxcbiAgICByYW5kb21CeXRlczogdXRpbHNfMS5yYW5kb21CeXRlcyxcbn0pKSgpO1xuLyoqXG4gKiBDb252ZXJ0cyBlZDI1NTE5IHB1YmxpYyBrZXkgdG8geDI1NTE5IHB1YmxpYyBrZXkuIFVzZXMgZm9ybXVsYTpcbiAqICogYCh1LCB2KSA9ICgoMSt5KS8oMS15KSwgc3FydCgtNDg2NjY0KSp1L3gpYFxuICogKiBgKHgsIHkpID0gKHNxcnQoLTQ4NjY2NCkqdS92LCAodS0xKS8odSsxKSlgXG4gKiBAZXhhbXBsZVxuICogICBjb25zdCBzb21lb25lc1B1YiA9IGVkMjU1MTkuZ2V0UHVibGljS2V5KGVkMjU1MTkudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpKTtcbiAqICAgY29uc3QgYVByaXYgPSB4MjU1MTkudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICogICB4MjU1MTkuZ2V0U2hhcmVkU2VjcmV0KGFQcml2LCBlZHdhcmRzVG9Nb250Z29tZXJ5UHViKHNvbWVvbmVzUHViKSlcbiAqL1xuZnVuY3Rpb24gZWR3YXJkc1RvTW9udGdvbWVyeVB1YihlZHdhcmRzUHViKSB7XG4gICAgY29uc3QgeyB5IH0gPSBleHBvcnRzLmVkMjU1MTkuRXh0ZW5kZWRQb2ludC5mcm9tSGV4KGVkd2FyZHNQdWIpO1xuICAgIGNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbiAgICByZXR1cm4gRnAudG9CeXRlcyhGcC5jcmVhdGUoKF8xbiArIHkpICogRnAuaW52KF8xbiAtIHkpKSk7XG59XG5leHBvcnRzLmVkd2FyZHNUb01vbnRnb21lcnkgPSBlZHdhcmRzVG9Nb250Z29tZXJ5UHViOyAvLyBkZXByZWNhdGVkXG4vKipcbiAqIENvbnZlcnRzIGVkMjU1MTkgc2VjcmV0IGtleSB0byB4MjU1MTkgc2VjcmV0IGtleS5cbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IHNvbWVvbmVzUHViID0geDI1NTE5LmdldFB1YmxpY0tleSh4MjU1MTkudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpKTtcbiAqICAgY29uc3QgYVByaXYgPSBlZDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAqICAgeDI1NTE5LmdldFNoYXJlZFNlY3JldChlZHdhcmRzVG9Nb250Z29tZXJ5UHJpdihhUHJpdiksIHNvbWVvbmVzUHViKVxuICovXG5mdW5jdGlvbiBlZHdhcmRzVG9Nb250Z29tZXJ5UHJpdihlZHdhcmRzUHJpdikge1xuICAgIGNvbnN0IGhhc2hlZCA9IGVkMjU1MTlEZWZhdWx0cy5oYXNoKGVkd2FyZHNQcml2LnN1YmFycmF5KDAsIDMyKSk7XG4gICAgcmV0dXJuIGVkMjU1MTlEZWZhdWx0cy5hZGp1c3RTY2FsYXJCeXRlcyhoYXNoZWQpLnN1YmFycmF5KDAsIDMyKTtcbn1cbi8vIEhhc2ggVG8gQ3VydmUgRWxsaWdhdG9yMiBNYXAgKE5PVEU6IGRpZmZlcmVudCBmcm9tIHJpc3RyZXR0bzI1NSBlbGxpZ2F0b3IpXG4vLyBOT1RFOiB2ZXJ5IGltcG9ydGFudCBwYXJ0IGlzIHVzYWdlIG9mIEZwU3FydEV2ZW4gZm9yIEVMTDJfQzFfRURXQVJEUywgc2luY2Vcbi8vIFNhZ2VNYXRoIHJldHVybnMgZGlmZmVyZW50IHJvb3QgZmlyc3QgYW5kIGV2ZXJ5dGhpbmcgZmFsbHMgYXBhcnRcbmNvbnN0IEVMTDJfQzEgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IChGcC5PUkRFUiArIF8zbikgLyBfOG4pKCk7IC8vIDEuIGMxID0gKHEgKyAzKSAvIDggICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbmNvbnN0IEVMTDJfQzIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEZwLnBvdyhfMm4sIEVMTDJfQzEpKSgpOyAvLyAyLiBjMiA9IDJeYzFcbmNvbnN0IEVMTDJfQzMgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEZwLnNxcnQoRnAubmVnKEZwLk9ORSkpKSgpOyAvLyAzLiBjMyA9IHNxcnQoLTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmZ1bmN0aW9uIG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2N1cnZlMjU1MTkodSkge1xuICAgIGNvbnN0IEVMTDJfQzQgPSAoRnAuT1JERVIgLSBfNW4pIC8gXzhuOyAvLyA0LiBjNCA9IChxIC0gNSkgLyA4ICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgRUxMMl9KID0gQmlnSW50KDQ4NjY2Mik7XG4gICAgbGV0IHR2MSA9IEZwLnNxcih1KTsgLy8gIDEuICB0djEgPSB1XjJcbiAgICB0djEgPSBGcC5tdWwodHYxLCBfMm4pOyAvLyAgMi4gIHR2MSA9IDIgKiB0djFcbiAgICBsZXQgeGQgPSBGcC5hZGQodHYxLCBGcC5PTkUpOyAvLyAgMy4gICB4ZCA9IHR2MSArIDEgICAgICAgICAjIE5vbnplcm86IC0xIGlzIHNxdWFyZSAobW9kIHApLCB0djEgaXMgbm90XG4gICAgbGV0IHgxbiA9IEZwLm5lZyhFTEwyX0opOyAvLyAgNC4gIHgxbiA9IC1KICAgICAgICAgICAgICAjIHgxID0geDFuIC8geGQgPSAtSiAvICgxICsgMiAqIHVeMilcbiAgICBsZXQgdHYyID0gRnAuc3FyKHhkKTsgLy8gIDUuICB0djIgPSB4ZF4yXG4gICAgbGV0IGd4ZCA9IEZwLm11bCh0djIsIHhkKTsgLy8gIDYuICBneGQgPSB0djIgKiB4ZCAgICAgICAgIyBneGQgPSB4ZF4zXG4gICAgbGV0IGd4MSA9IEZwLm11bCh0djEsIEVMTDJfSik7IC8vICA3LiAgZ3gxID0gSiAqIHR2MSAgICAgICAgICMgeDFuICsgSiAqIHhkXG4gICAgZ3gxID0gRnAubXVsKGd4MSwgeDFuKTsgLy8gIDguICBneDEgPSBneDEgKiB4MW4gICAgICAgIyB4MW5eMiArIEogKiB4MW4gKiB4ZFxuICAgIGd4MSA9IEZwLmFkZChneDEsIHR2Mik7IC8vICA5LiAgZ3gxID0gZ3gxICsgdHYyICAgICAgICMgeDFuXjIgKyBKICogeDFuICogeGQgKyB4ZF4yXG4gICAgZ3gxID0gRnAubXVsKGd4MSwgeDFuKTsgLy8gIDEwLiBneDEgPSBneDEgKiB4MW4gICAgICAgIyB4MW5eMyArIEogKiB4MW5eMiAqIHhkICsgeDFuICogeGReMlxuICAgIGxldCB0djMgPSBGcC5zcXIoZ3hkKTsgLy8gIDExLiB0djMgPSBneGReMlxuICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyAgMTIuIHR2MiA9IHR2M14yICAgICAgICAgICAjIGd4ZF40XG4gICAgdHYzID0gRnAubXVsKHR2MywgZ3hkKTsgLy8gIDEzLiB0djMgPSB0djMgKiBneGQgICAgICAgIyBneGReM1xuICAgIHR2MyA9IEZwLm11bCh0djMsIGd4MSk7IC8vICAxNC4gdHYzID0gdHYzICogZ3gxICAgICAgICMgZ3gxICogZ3hkXjNcbiAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAgMTUuIHR2MiA9IHR2MiAqIHR2MyAgICAgICAjIGd4MSAqIGd4ZF43XG4gICAgbGV0IHkxMSA9IEZwLnBvdyh0djIsIEVMTDJfQzQpOyAvLyAgMTYuIHkxMSA9IHR2Ml5jNCAgICAgICAgIyAoZ3gxICogZ3hkXjcpXigocCAtIDUpIC8gOClcbiAgICB5MTEgPSBGcC5tdWwoeTExLCB0djMpOyAvLyAgMTcuIHkxMSA9IHkxMSAqIHR2MyAgICAgICAjIGd4MSpneGReMyooZ3gxKmd4ZF43KV4oKHAtNSkvOClcbiAgICBsZXQgeTEyID0gRnAubXVsKHkxMSwgRUxMMl9DMyk7IC8vICAxOC4geTEyID0geTExICogYzNcbiAgICB0djIgPSBGcC5zcXIoeTExKTsgLy8gIDE5LiB0djIgPSB5MTFeMlxuICAgIHR2MiA9IEZwLm11bCh0djIsIGd4ZCk7IC8vICAyMC4gdHYyID0gdHYyICogZ3hkXG4gICAgbGV0IGUxID0gRnAuZXFsKHR2MiwgZ3gxKTsgLy8gIDIxLiAgZTEgPSB0djIgPT0gZ3gxXG4gICAgbGV0IHkxID0gRnAuY21vdih5MTIsIHkxMSwgZTEpOyAvLyAgMjIuICB5MSA9IENNT1YoeTEyLCB5MTEsIGUxKSAgIyBJZiBnKHgxKSBpcyBzcXVhcmUsIHRoaXMgaXMgaXRzIHNxcnRcbiAgICBsZXQgeDJuID0gRnAubXVsKHgxbiwgdHYxKTsgLy8gIDIzLiB4Mm4gPSB4MW4gKiB0djEgICAgICAgIyB4MiA9IHgybiAvIHhkID0gMiAqIHVeMiAqIHgxbiAvIHhkXG4gICAgbGV0IHkyMSA9IEZwLm11bCh5MTEsIHUpOyAvLyAgMjQuIHkyMSA9IHkxMSAqIHVcbiAgICB5MjEgPSBGcC5tdWwoeTIxLCBFTEwyX0MyKTsgLy8gIDI1LiB5MjEgPSB5MjEgKiBjMlxuICAgIGxldCB5MjIgPSBGcC5tdWwoeTIxLCBFTEwyX0MzKTsgLy8gIDI2LiB5MjIgPSB5MjEgKiBjM1xuICAgIGxldCBneDIgPSBGcC5tdWwoZ3gxLCB0djEpOyAvLyAgMjcuIGd4MiA9IGd4MSAqIHR2MSAgICAgICAjIGcoeDIpID0gZ3gyIC8gZ3hkID0gMiAqIHVeMiAqIGcoeDEpXG4gICAgdHYyID0gRnAuc3FyKHkyMSk7IC8vICAyOC4gdHYyID0geTIxXjJcbiAgICB0djIgPSBGcC5tdWwodHYyLCBneGQpOyAvLyAgMjkuIHR2MiA9IHR2MiAqIGd4ZFxuICAgIGxldCBlMiA9IEZwLmVxbCh0djIsIGd4Mik7IC8vICAzMC4gIGUyID0gdHYyID09IGd4MlxuICAgIGxldCB5MiA9IEZwLmNtb3YoeTIyLCB5MjEsIGUyKTsgLy8gIDMxLiAgeTIgPSBDTU9WKHkyMiwgeTIxLCBlMikgICMgSWYgZyh4MikgaXMgc3F1YXJlLCB0aGlzIGlzIGl0cyBzcXJ0XG4gICAgdHYyID0gRnAuc3FyKHkxKTsgLy8gIDMyLiB0djIgPSB5MV4yXG4gICAgdHYyID0gRnAubXVsKHR2MiwgZ3hkKTsgLy8gIDMzLiB0djIgPSB0djIgKiBneGRcbiAgICBsZXQgZTMgPSBGcC5lcWwodHYyLCBneDEpOyAvLyAgMzQuICBlMyA9IHR2MiA9PSBneDFcbiAgICBsZXQgeG4gPSBGcC5jbW92KHgybiwgeDFuLCBlMyk7IC8vICAzNS4gIHhuID0gQ01PVih4Mm4sIHgxbiwgZTMpICAjIElmIGUzLCB4ID0geDEsIGVsc2UgeCA9IHgyXG4gICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgZTMpOyAvLyAgMzYuICAgeSA9IENNT1YoeTIsIHkxLCBlMykgICAgIyBJZiBlMywgeSA9IHkxLCBlbHNlIHkgPSB5MlxuICAgIGxldCBlNCA9IEZwLmlzT2RkKHkpOyAvLyAgMzcuICBlNCA9IHNnbjAoeSkgPT0gMSAgICAgICAgIyBGaXggc2lnbiBvZiB5XG4gICAgeSA9IEZwLmNtb3YoeSwgRnAubmVnKHkpLCBlMyAhPT0gZTQpOyAvLyAgMzguICAgeSA9IENNT1YoeSwgLXksIGUzIFhPUiBlNClcbiAgICByZXR1cm4geyB4TW46IHhuLCB4TWQ6IHhkLCB5TW46IHksIHlNZDogXzFuIH07IC8vICAzOS4gcmV0dXJuICh4biwgeGQsIHksIDEpXG59XG5jb25zdCBFTEwyX0MxX0VEV0FSRFMgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICgwLCBtb2R1bGFyX2pzXzEuRnBTcXJ0RXZlbikoRnAsIEZwLm5lZyhCaWdJbnQoNDg2NjY0KSkpKSgpOyAvLyBzZ24wKGMxKSBNVVNUIGVxdWFsIDBcbmZ1bmN0aW9uIG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2Vkd2FyZHMyNTUxOSh1KSB7XG4gICAgY29uc3QgeyB4TW4sIHhNZCwgeU1uLCB5TWQgfSA9IG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2N1cnZlMjU1MTkodSk7IC8vICAxLiAgKHhNbiwgeE1kLCB5TW4sIHlNZCkgPVxuICAgIC8vIG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2N1cnZlMjU1MTkodSlcbiAgICBsZXQgeG4gPSBGcC5tdWwoeE1uLCB5TWQpOyAvLyAgMi4gIHhuID0geE1uICogeU1kXG4gICAgeG4gPSBGcC5tdWwoeG4sIEVMTDJfQzFfRURXQVJEUyk7IC8vICAzLiAgeG4gPSB4biAqIGMxXG4gICAgbGV0IHhkID0gRnAubXVsKHhNZCwgeU1uKTsgLy8gIDQuICB4ZCA9IHhNZCAqIHlNbiAgICAjIHhuIC8geGQgPSBjMSAqIHhNIC8geU1cbiAgICBsZXQgeW4gPSBGcC5zdWIoeE1uLCB4TWQpOyAvLyAgNS4gIHluID0geE1uIC0geE1kXG4gICAgbGV0IHlkID0gRnAuYWRkKHhNbiwgeE1kKTsgLy8gIDYuICB5ZCA9IHhNbiArIHhNZCAgICAjIChuIC8gZCAtIDEpIC8gKG4gLyBkICsgMSkgPSAobiAtIGQpIC8gKG4gKyBkKVxuICAgIGxldCB0djEgPSBGcC5tdWwoeGQsIHlkKTsgLy8gIDcuIHR2MSA9IHhkICogeWRcbiAgICBsZXQgZSA9IEZwLmVxbCh0djEsIEZwLlpFUk8pOyAvLyAgOC4gICBlID0gdHYxID09IDBcbiAgICB4biA9IEZwLmNtb3YoeG4sIEZwLlpFUk8sIGUpOyAvLyAgOS4gIHhuID0gQ01PVih4biwgMCwgZSlcbiAgICB4ZCA9IEZwLmNtb3YoeGQsIEZwLk9ORSwgZSk7IC8vICAxMC4geGQgPSBDTU9WKHhkLCAxLCBlKVxuICAgIHluID0gRnAuY21vdih5biwgRnAuT05FLCBlKTsgLy8gIDExLiB5biA9IENNT1YoeW4sIDEsIGUpXG4gICAgeWQgPSBGcC5jbW92KHlkLCBGcC5PTkUsIGUpOyAvLyAgMTIuIHlkID0gQ01PVih5ZCwgMSwgZSlcbiAgICBjb25zdCBpbnYgPSBGcC5pbnZlcnRCYXRjaChbeGQsIHlkXSk7IC8vIGJhdGNoIGRpdmlzaW9uXG4gICAgcmV0dXJuIHsgeDogRnAubXVsKHhuLCBpbnZbMF0pLCB5OiBGcC5tdWwoeW4sIGludlsxXSkgfTsgLy8gIDEzLiByZXR1cm4gKHhuLCB4ZCwgeW4sIHlkKVxufVxuY29uc3QgaHRmID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoMCwgaGFzaF90b19jdXJ2ZV9qc18xLmNyZWF0ZUhhc2hlcikoZXhwb3J0cy5lZDI1NTE5LkV4dGVuZGVkUG9pbnQsIChzY2FsYXJzKSA9PiBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9lZHdhcmRzMjU1MTkoc2NhbGFyc1swXSksIHtcbiAgICBEU1Q6ICdlZHdhcmRzMjU1MTlfWE1EOlNIQS01MTJfRUxMMl9ST18nLFxuICAgIGVuY29kZURTVDogJ2Vkd2FyZHMyNTUxOV9YTUQ6U0hBLTUxMl9FTEwyX05VXycsXG4gICAgcDogRnAuT1JERVIsXG4gICAgbTogMSxcbiAgICBrOiAxMjgsXG4gICAgZXhwYW5kOiAneG1kJyxcbiAgICBoYXNoOiBzaGE1MTJfMS5zaGE1MTIsXG59KSkoKTtcbmV4cG9ydHMuaGFzaFRvQ3VydmUgPSAoKCkgPT4gaHRmLmhhc2hUb0N1cnZlKSgpO1xuZXhwb3J0cy5lbmNvZGVUb0N1cnZlID0gKCgpID0+IGh0Zi5lbmNvZGVUb0N1cnZlKSgpO1xuZnVuY3Rpb24gYXNzZXJ0UnN0UG9pbnQob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFJpc3RQb2ludCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmlzdHJldHRvUG9pbnQgZXhwZWN0ZWQnKTtcbn1cbi8vIOKImigtMSkgYWthIOKImihhKSBha2EgMl4oKHAtMSkvNClcbmNvbnN0IFNRUlRfTTEgPSBFRDI1NTE5X1NRUlRfTTE7XG4vLyDiiJooYWQgLSAxKVxuY29uc3QgU1FSVF9BRF9NSU5VU19PTkUgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCcyNTA2MzA2ODk1MzM4NDYyMzQ3NDExMTQxNDE1ODcwMjE1MjcwMTI0NDUzMTUwMjQ5MjY1NjQ2MDA3OTIxMDQ4MjYxMDQzMDc1MDIzNScpO1xuLy8gMSAvIOKImihhLWQpXG5jb25zdCBJTlZTUVJUX0FfTUlOVVNfRCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoJzU0NDY5MzA3MDA4OTA5MzE2OTIwOTk1ODEzODY4NzQ1MTQxNjA1MzkzNTk3MjkyOTI3NDU2OTIxMjA1MzEyODk2MzExNzIxMDE3NTc4Jyk7XG4vLyAxLWTCslxuY29uc3QgT05FX01JTlVTX0RfU1EgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCcxMTU5ODQzMDIxNjY4Nzc5ODc5MTkzNzc1NTIxODU1NTg2NjQ3OTM3MzU3NzU5NzE1NDE3NjU0NDM5ODc5NzIwODc2MTExODA2ODM4Jyk7XG4vLyAoZC0xKcKyXG5jb25zdCBEX01JTlVTX09ORV9TUSA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoJzQwNDQwODM0MzQ2MzA4NTM2ODU4MTAxMDQyNDY5MzIzMTkwODI2MjQ4Mzk5MTQ2MjM4NzA4MzUyMjQwMTMzMjIwODY1MTM3MjY1OTUyJyk7XG4vLyBDYWxjdWxhdGVzIDEv4oiaKG51bWJlcilcbmNvbnN0IGludmVydFNxcnQgPSAobnVtYmVyKSA9PiB1dlJhdGlvKF8xbiwgbnVtYmVyKTtcbmNvbnN0IE1BWF8yNTVCID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJyk7XG5jb25zdCBieXRlczI1NVRvTnVtYmVyTEUgPSAoYnl0ZXMpID0+IGV4cG9ydHMuZWQyNTUxOS5DVVJWRS5GcC5jcmVhdGUoKDAsIHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckxFKShieXRlcykgJiBNQVhfMjU1Qik7XG4vLyBDb21wdXRlcyBFbGxpZ2F0b3IgbWFwIGZvciBSaXN0cmV0dG9cbi8vIGh0dHBzOi8vcmlzdHJldHRvLmdyb3VwL2Zvcm11bGFzL2VsbGlnYXRvci5odG1sXG5mdW5jdGlvbiBjYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwKHIwKSB7XG4gICAgY29uc3QgeyBkIH0gPSBleHBvcnRzLmVkMjU1MTkuQ1VSVkU7XG4gICAgY29uc3QgUCA9IGV4cG9ydHMuZWQyNTUxOS5DVVJWRS5GcC5PUkRFUjtcbiAgICBjb25zdCBtb2QgPSBleHBvcnRzLmVkMjU1MTkuQ1VSVkUuRnAuY3JlYXRlO1xuICAgIGNvbnN0IHIgPSBtb2QoU1FSVF9NMSAqIHIwICogcjApOyAvLyAxXG4gICAgY29uc3QgTnMgPSBtb2QoKHIgKyBfMW4pICogT05FX01JTlVTX0RfU1EpOyAvLyAyXG4gICAgbGV0IGMgPSBCaWdJbnQoLTEpOyAvLyAzXG4gICAgY29uc3QgRCA9IG1vZCgoYyAtIGQgKiByKSAqIG1vZChyICsgZCkpOyAvLyA0XG4gICAgbGV0IHsgaXNWYWxpZDogTnNfRF9pc19zcSwgdmFsdWU6IHMgfSA9IHV2UmF0aW8oTnMsIEQpOyAvLyA1XG4gICAgbGV0IHNfID0gbW9kKHMgKiByMCk7IC8vIDZcbiAgICBpZiAoISgwLCBtb2R1bGFyX2pzXzEuaXNOZWdhdGl2ZUxFKShzXywgUCkpXG4gICAgICAgIHNfID0gbW9kKC1zXyk7XG4gICAgaWYgKCFOc19EX2lzX3NxKVxuICAgICAgICBzID0gc187IC8vIDdcbiAgICBpZiAoIU5zX0RfaXNfc3EpXG4gICAgICAgIGMgPSByOyAvLyA4XG4gICAgY29uc3QgTnQgPSBtb2QoYyAqIChyIC0gXzFuKSAqIERfTUlOVVNfT05FX1NRIC0gRCk7IC8vIDlcbiAgICBjb25zdCBzMiA9IHMgKiBzO1xuICAgIGNvbnN0IFcwID0gbW9kKChzICsgcykgKiBEKTsgLy8gMTBcbiAgICBjb25zdCBXMSA9IG1vZChOdCAqIFNRUlRfQURfTUlOVVNfT05FKTsgLy8gMTFcbiAgICBjb25zdCBXMiA9IG1vZChfMW4gLSBzMik7IC8vIDEyXG4gICAgY29uc3QgVzMgPSBtb2QoXzFuICsgczIpOyAvLyAxM1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5lZDI1NTE5LkV4dGVuZGVkUG9pbnQobW9kKFcwICogVzMpLCBtb2QoVzIgKiBXMSksIG1vZChXMSAqIFczKSwgbW9kKFcwICogVzIpKTtcbn1cbi8qKlxuICogRWFjaCBlZDI1NTE5L0V4dGVuZGVkUG9pbnQgaGFzIDggZGlmZmVyZW50IGVxdWl2YWxlbnQgcG9pbnRzLiBUaGlzIGNhbiBiZVxuICogYSBzb3VyY2Ugb2YgYnVncyBmb3IgcHJvdG9jb2xzIGxpa2UgcmluZyBzaWduYXR1cmVzLiBSaXN0cmV0dG8gd2FzIGNyZWF0ZWQgdG8gc29sdmUgdGhpcy5cbiAqIFJpc3RyZXR0byBwb2ludCBvcGVyYXRlcyBpbiBYOlk6WjpUIGV4dGVuZGVkIGNvb3JkaW5hdGVzIGxpa2UgRXh0ZW5kZWRQb2ludCxcbiAqIGJ1dCBpdCBzaG91bGQgd29yayBpbiBpdHMgb3duIG5hbWVzcGFjZTogZG8gbm90IGNvbWJpbmUgdGhvc2UgdHdvLlxuICogaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmctcmlzdHJldHRvMjU1LWRlY2FmNDQ4XG4gKi9cbmNsYXNzIFJpc3RQb2ludCB7XG4gICAgLy8gUHJpdmF0ZSBwcm9wZXJ0eSB0byBkaXNjb3VyYWdlIGNvbWJpbmluZyBFeHRlbmRlZFBvaW50ICsgUmlzdHJldHRvUG9pbnRcbiAgICAvLyBBbHdheXMgdXNlIFJpc3RyZXR0byBlbmNvZGluZy9kZWNvZGluZyBpbnN0ZWFkLlxuICAgIGNvbnN0cnVjdG9yKGVwKSB7XG4gICAgICAgIHRoaXMuZXAgPSBlcDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21BZmZpbmUoYXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQoZXhwb3J0cy5lZDI1NTE5LkV4dGVuZGVkUG9pbnQuZnJvbUFmZmluZShhcCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWtlcyB1bmlmb3JtIG91dHB1dCBvZiA2NC1ieXRlIGhhc2ggZnVuY3Rpb24gbGlrZSBzaGE1MTIgYW5kIGNvbnZlcnRzIGl0IHRvIGBSaXN0cmV0dG9Qb2ludGAuXG4gICAgICogVGhlIGhhc2gtdG8tZ3JvdXAgb3BlcmF0aW9uIGFwcGxpZXMgRWxsaWdhdG9yIHR3aWNlIGFuZCBhZGRzIHRoZSByZXN1bHRzLlxuICAgICAqICoqTm90ZToqKiB0aGlzIGlzIG9uZS13YXkgbWFwLCB0aGVyZSBpcyBubyBjb252ZXJzaW9uIGZyb20gcG9pbnQgdG8gaGFzaC5cbiAgICAgKiBodHRwczovL3Jpc3RyZXR0by5ncm91cC9mb3JtdWxhcy9lbGxpZ2F0b3IuaHRtbFxuICAgICAqIEBwYXJhbSBoZXggNjQtYnl0ZSBvdXRwdXQgb2YgYSBoYXNoIGZ1bmN0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGhhc2hUb0N1cnZlKGhleCkge1xuICAgICAgICBoZXggPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3Jpc3RyZXR0b0hhc2gnLCBoZXgsIDY0KTtcbiAgICAgICAgY29uc3QgcjEgPSBieXRlczI1NVRvTnVtYmVyTEUoaGV4LnNsaWNlKDAsIDMyKSk7XG4gICAgICAgIGNvbnN0IFIxID0gY2FsY0VsbGlnYXRvclJpc3RyZXR0b01hcChyMSk7XG4gICAgICAgIGNvbnN0IHIyID0gYnl0ZXMyNTVUb051bWJlckxFKGhleC5zbGljZSgzMiwgNjQpKTtcbiAgICAgICAgY29uc3QgUjIgPSBjYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwKHIyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQoUjEuYWRkKFIyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHJpc3RyZXR0by1lbmNvZGVkIHN0cmluZyB0byByaXN0cmV0dG8gcG9pbnQuXG4gICAgICogaHR0cHM6Ly9yaXN0cmV0dG8uZ3JvdXAvZm9ybXVsYXMvZGVjb2RpbmcuaHRtbFxuICAgICAqIEBwYXJhbSBoZXggUmlzdHJldHRvLWVuY29kZWQgMzIgYnl0ZXMuIE5vdCBldmVyeSAzMi1ieXRlIHN0cmluZyBpcyB2YWxpZCByaXN0cmV0dG8gZW5jb2RpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgaGV4ID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdyaXN0cmV0dG9IZXgnLCBoZXgsIDMyKTtcbiAgICAgICAgY29uc3QgeyBhLCBkIH0gPSBleHBvcnRzLmVkMjU1MTkuQ1VSVkU7XG4gICAgICAgIGNvbnN0IFAgPSBleHBvcnRzLmVkMjU1MTkuQ1VSVkUuRnAuT1JERVI7XG4gICAgICAgIGNvbnN0IG1vZCA9IGV4cG9ydHMuZWQyNTUxOS5DVVJWRS5GcC5jcmVhdGU7XG4gICAgICAgIGNvbnN0IGVtc2cgPSAnUmlzdHJldHRvUG9pbnQuZnJvbUhleDogdGhlIGhleCBpcyBub3QgdmFsaWQgZW5jb2Rpbmcgb2YgUmlzdHJldHRvUG9pbnQnO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXMyNTVUb051bWJlckxFKGhleCk7XG4gICAgICAgIC8vIDEuIENoZWNrIHRoYXQgc19ieXRlcyBpcyB0aGUgY2Fub25pY2FsIGVuY29kaW5nIG9mIGEgZmllbGQgZWxlbWVudCwgb3IgZWxzZSBhYm9ydC5cbiAgICAgICAgLy8gMy4gQ2hlY2sgdGhhdCBzIGlzIG5vbi1uZWdhdGl2ZSwgb3IgZWxzZSBhYm9ydFxuICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmVxdWFsQnl0ZXMpKCgwLCB1dGlsc19qc18xLm51bWJlclRvQnl0ZXNMRSkocywgMzIpLCBoZXgpIHx8ICgwLCBtb2R1bGFyX2pzXzEuaXNOZWdhdGl2ZUxFKShzLCBQKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlbXNnKTtcbiAgICAgICAgY29uc3QgczIgPSBtb2QocyAqIHMpO1xuICAgICAgICBjb25zdCB1MSA9IG1vZChfMW4gKyBhICogczIpOyAvLyA0IChhIGlzIC0xKVxuICAgICAgICBjb25zdCB1MiA9IG1vZChfMW4gLSBhICogczIpOyAvLyA1XG4gICAgICAgIGNvbnN0IHUxXzIgPSBtb2QodTEgKiB1MSk7XG4gICAgICAgIGNvbnN0IHUyXzIgPSBtb2QodTIgKiB1Mik7XG4gICAgICAgIGNvbnN0IHYgPSBtb2QoYSAqIGQgKiB1MV8yIC0gdTJfMik7IC8vIDZcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZTogSSB9ID0gaW52ZXJ0U3FydChtb2QodiAqIHUyXzIpKTsgLy8gN1xuICAgICAgICBjb25zdCBEeCA9IG1vZChJICogdTIpOyAvLyA4XG4gICAgICAgIGNvbnN0IER5ID0gbW9kKEkgKiBEeCAqIHYpOyAvLyA5XG4gICAgICAgIGxldCB4ID0gbW9kKChzICsgcykgKiBEeCk7IC8vIDEwXG4gICAgICAgIGlmICgoMCwgbW9kdWxhcl9qc18xLmlzTmVnYXRpdmVMRSkoeCwgUCkpXG4gICAgICAgICAgICB4ID0gbW9kKC14KTsgLy8gMTBcbiAgICAgICAgY29uc3QgeSA9IG1vZCh1MSAqIER5KTsgLy8gMTFcbiAgICAgICAgY29uc3QgdCA9IG1vZCh4ICogeSk7IC8vIDEyXG4gICAgICAgIGlmICghaXNWYWxpZCB8fCAoMCwgbW9kdWxhcl9qc18xLmlzTmVnYXRpdmVMRSkodCwgUCkgfHwgeSA9PT0gXzBuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVtc2cpO1xuICAgICAgICByZXR1cm4gbmV3IFJpc3RQb2ludChuZXcgZXhwb3J0cy5lZDI1NTE5LkV4dGVuZGVkUG9pbnQoeCwgeSwgXzFuLCB0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgcmlzdHJldHRvIHBvaW50IHRvIFVpbnQ4QXJyYXkuXG4gICAgICogaHR0cHM6Ly9yaXN0cmV0dG8uZ3JvdXAvZm9ybXVsYXMvZW5jb2RpbmcuaHRtbFxuICAgICAqL1xuICAgIHRvUmF3Qnl0ZXMoKSB7XG4gICAgICAgIGxldCB7IGV4OiB4LCBleTogeSwgZXo6IHosIGV0OiB0IH0gPSB0aGlzLmVwO1xuICAgICAgICBjb25zdCBQID0gZXhwb3J0cy5lZDI1NTE5LkNVUlZFLkZwLk9SREVSO1xuICAgICAgICBjb25zdCBtb2QgPSBleHBvcnRzLmVkMjU1MTkuQ1VSVkUuRnAuY3JlYXRlO1xuICAgICAgICBjb25zdCB1MSA9IG1vZChtb2QoeiArIHkpICogbW9kKHogLSB5KSk7IC8vIDFcbiAgICAgICAgY29uc3QgdTIgPSBtb2QoeCAqIHkpOyAvLyAyXG4gICAgICAgIC8vIFNxdWFyZSByb290IGFsd2F5cyBleGlzdHNcbiAgICAgICAgY29uc3QgdTJzcSA9IG1vZCh1MiAqIHUyKTtcbiAgICAgICAgY29uc3QgeyB2YWx1ZTogaW52c3FydCB9ID0gaW52ZXJ0U3FydChtb2QodTEgKiB1MnNxKSk7IC8vIDNcbiAgICAgICAgY29uc3QgRDEgPSBtb2QoaW52c3FydCAqIHUxKTsgLy8gNFxuICAgICAgICBjb25zdCBEMiA9IG1vZChpbnZzcXJ0ICogdTIpOyAvLyA1XG4gICAgICAgIGNvbnN0IHpJbnYgPSBtb2QoRDEgKiBEMiAqIHQpOyAvLyA2XG4gICAgICAgIGxldCBEOyAvLyA3XG4gICAgICAgIGlmICgoMCwgbW9kdWxhcl9qc18xLmlzTmVnYXRpdmVMRSkodCAqIHpJbnYsIFApKSB7XG4gICAgICAgICAgICBsZXQgX3ggPSBtb2QoeSAqIFNRUlRfTTEpO1xuICAgICAgICAgICAgbGV0IF95ID0gbW9kKHggKiBTUVJUX00xKTtcbiAgICAgICAgICAgIHggPSBfeDtcbiAgICAgICAgICAgIHkgPSBfeTtcbiAgICAgICAgICAgIEQgPSBtb2QoRDEgKiBJTlZTUVJUX0FfTUlOVVNfRCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBEID0gRDI7IC8vIDhcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIG1vZHVsYXJfanNfMS5pc05lZ2F0aXZlTEUpKHggKiB6SW52LCBQKSlcbiAgICAgICAgICAgIHkgPSBtb2QoLXkpOyAvLyA5XG4gICAgICAgIGxldCBzID0gbW9kKCh6IC0geSkgKiBEKTsgLy8gMTAgKGNoZWNrIGZvb3RlcidzIG5vdGUsIG5vIHNxcnQoLWEpKVxuICAgICAgICBpZiAoKDAsIG1vZHVsYXJfanNfMS5pc05lZ2F0aXZlTEUpKHMsIFApKVxuICAgICAgICAgICAgcyA9IG1vZCgtcyk7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS5udW1iZXJUb0J5dGVzTEUpKHMsIDMyKTsgLy8gMTFcbiAgICB9XG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfanNfMS5ieXRlc1RvSGV4KSh0aGlzLnRvUmF3Qnl0ZXMoKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0hleCgpO1xuICAgIH1cbiAgICAvLyBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBhc3NlcnRSc3RQb2ludChvdGhlcik7XG4gICAgICAgIGNvbnN0IHsgZXg6IFgxLCBleTogWTEgfSA9IHRoaXMuZXA7XG4gICAgICAgIGNvbnN0IHsgZXg6IFgyLCBleTogWTIgfSA9IG90aGVyLmVwO1xuICAgICAgICBjb25zdCBtb2QgPSBleHBvcnRzLmVkMjU1MTkuQ1VSVkUuRnAuY3JlYXRlO1xuICAgICAgICAvLyAoeDEgKiB5MiA9PSB5MSAqIHgyKSB8ICh5MSAqIHkyID09IHgxICogeDIpXG4gICAgICAgIGNvbnN0IG9uZSA9IG1vZChYMSAqIFkyKSA9PT0gbW9kKFkxICogWDIpO1xuICAgICAgICBjb25zdCB0d28gPSBtb2QoWTEgKiBZMikgPT09IG1vZChYMSAqIFgyKTtcbiAgICAgICAgcmV0dXJuIG9uZSB8fCB0d287XG4gICAgfVxuICAgIGFkZChvdGhlcikge1xuICAgICAgICBhc3NlcnRSc3RQb2ludChvdGhlcik7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAuYWRkKG90aGVyLmVwKSk7XG4gICAgfVxuICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgIGFzc2VydFJzdFBvaW50KG90aGVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5zdWJ0cmFjdChvdGhlci5lcCkpO1xuICAgIH1cbiAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5tdWx0aXBseShzY2FsYXIpKTtcbiAgICB9XG4gICAgbXVsdGlwbHlVbnNhZmUoc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAubXVsdGlwbHlVbnNhZmUoc2NhbGFyKSk7XG4gICAgfVxuICAgIGRvdWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5kb3VibGUoKSk7XG4gICAgfVxuICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5uZWdhdGUoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5SaXN0cmV0dG9Qb2ludCA9ICgoKSA9PiB7XG4gICAgaWYgKCFSaXN0UG9pbnQuQkFTRSlcbiAgICAgICAgUmlzdFBvaW50LkJBU0UgPSBuZXcgUmlzdFBvaW50KGV4cG9ydHMuZWQyNTUxOS5FeHRlbmRlZFBvaW50LkJBU0UpO1xuICAgIGlmICghUmlzdFBvaW50LlpFUk8pXG4gICAgICAgIFJpc3RQb2ludC5aRVJPID0gbmV3IFJpc3RQb2ludChleHBvcnRzLmVkMjU1MTkuRXh0ZW5kZWRQb2ludC5aRVJPKTtcbiAgICByZXR1cm4gUmlzdFBvaW50O1xufSkoKTtcbi8vIEhhc2hpbmcgdG8gcmlzdHJldHRvMjU1LiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNhcHBlbmRpeC1CXG5jb25zdCBoYXNoVG9SaXN0cmV0dG8yNTUgPSAobXNnLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgZCA9IG9wdGlvbnMuRFNUO1xuICAgIGNvbnN0IERTVCA9IHR5cGVvZiBkID09PSAnc3RyaW5nJyA/ICgwLCB1dGlsc18xLnV0ZjhUb0J5dGVzKShkKSA6IGQ7XG4gICAgY29uc3QgdW5pZm9ybV9ieXRlcyA9ICgwLCBoYXNoX3RvX2N1cnZlX2pzXzEuZXhwYW5kX21lc3NhZ2VfeG1kKShtc2csIERTVCwgNjQsIHNoYTUxMl8xLnNoYTUxMik7XG4gICAgY29uc3QgUCA9IFJpc3RQb2ludC5oYXNoVG9DdXJ2ZSh1bmlmb3JtX2J5dGVzKTtcbiAgICByZXR1cm4gUDtcbn07XG5leHBvcnRzLmhhc2hUb1Jpc3RyZXR0bzI1NSA9IGhhc2hUb1Jpc3RyZXR0bzI1NTtcbmV4cG9ydHMuaGFzaF90b19yaXN0cmV0dG8yNTUgPSBleHBvcnRzLmhhc2hUb1Jpc3RyZXR0bzI1NTsgLy8gbGVnYWN5XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lZDI1NTE5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zaGEyMjQgPSBleHBvcnRzLnNoYTI1NiA9IGV4cG9ydHMuU0hBMjU2ID0gdm9pZCAwO1xuY29uc3QgX21kX2pzXzEgPSByZXF1aXJlKFwiLi9fbWQuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vLyBTSEEyLTI1NiBuZWVkIHRvIHRyeSAyXjEyOCBoYXNoZXMgdG8gZXhlY3V0ZSBiaXJ0aGRheSBhdHRhY2suXG4vLyBCVEMgbmV0d29yayBpcyBkb2luZyAyXjY3IGhhc2hlcy9zZWMgYXMgcGVyIGVhcmx5IDIwMjMuXG4vLyBSb3VuZCBjb25zdGFudHM6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBjdWJlIHJvb3RzIG9mIHRoZSBmaXJzdCA2NCBwcmltZXMgMi4uMzExKVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gICAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNywgMHhjMTliZjE3NCxcbiAgICAweGU0OWI2OWMxLCAweGVmYmU0Nzg2LCAweDBmYzE5ZGM2LCAweDI0MGNhMWNjLCAweDJkZTkyYzZmLCAweDRhNzQ4NGFhLCAweDVjYjBhOWRjLCAweDc2Zjk4OGRhLFxuICAgIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gICAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LCAweGQ2OTkwNjI0LCAweGY0MGUzNTg1LCAweDEwNmFhMDcwLFxuICAgIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gICAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCwgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuXSk7XG4vLyBJbml0aWFsIHN0YXRlOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOVxuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBTSEEyNTZfSVYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuLy8gTmFtZWQgdGhpcyB3YXkgYmVjYXVzZSBpdCBtYXRjaGVzIHNwZWNpZmljYXRpb24uXG5jb25zdCBTSEEyNTZfVyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgU0hBMjU2IGV4dGVuZHMgX21kX2pzXzEuSGFzaE1EIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBTSEEyNTZfSVZbMF0gfCAwO1xuICAgICAgICB0aGlzLkIgPSBTSEEyNTZfSVZbMV0gfCAwO1xuICAgICAgICB0aGlzLkMgPSBTSEEyNTZfSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBTSEEyNTZfSVZbM10gfCAwO1xuICAgICAgICB0aGlzLkUgPSBTSEEyNTZfSVZbNF0gfCAwO1xuICAgICAgICB0aGlzLkYgPSBTSEEyNTZfSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBTSEEyNTZfSVZbNl0gfCAwO1xuICAgICAgICB0aGlzLkggPSBTSEEyNTZfSVZbN10gfCAwO1xuICAgIH1cbiAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHsgQSwgQiwgQywgRCwgRSwgRiwgRywgSCB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtBLCBCLCBDLCBELCBFLCBGLCBHLCBIXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpIHtcbiAgICAgICAgdGhpcy5BID0gQSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IEIgfCAwO1xuICAgICAgICB0aGlzLkMgPSBDIHwgMDtcbiAgICAgICAgdGhpcy5EID0gRCB8IDA7XG4gICAgICAgIHRoaXMuRSA9IEUgfCAwO1xuICAgICAgICB0aGlzLkYgPSBGIHwgMDtcbiAgICAgICAgdGhpcy5HID0gRyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IEggfCAwO1xuICAgIH1cbiAgICBwcm9jZXNzKHZpZXcsIG9mZnNldCkge1xuICAgICAgICAvLyBFeHRlbmQgdGhlIGZpcnN0IDE2IHdvcmRzIGludG8gdGhlIHJlbWFpbmluZyA0OCB3b3JkcyB3WzE2Li42M10gb2YgdGhlIG1lc3NhZ2Ugc2NoZWR1bGUgYXJyYXlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrLCBvZmZzZXQgKz0gNClcbiAgICAgICAgICAgIFNIQTI1Nl9XW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxNjsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFcxNSA9IFNIQTI1Nl9XW2kgLSAxNV07XG4gICAgICAgICAgICBjb25zdCBXMiA9IFNIQTI1Nl9XW2kgLSAyXTtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gKDAsIHV0aWxzX2pzXzEucm90cikoVzE1LCA3KSBeICgwLCB1dGlsc19qc18xLnJvdHIpKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9ICgwLCB1dGlsc19qc18xLnJvdHIpKFcyLCAxNykgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gKDAsIHV0aWxzX2pzXzEucm90cikoRSwgNikgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShFLCAxMSkgXiAoMCwgdXRpbHNfanNfMS5yb3RyKShFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgKDAsIF9tZF9qc18xLkNoaSkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzaWdtYTAgPSAoMCwgdXRpbHNfanNfMS5yb3RyKShBLCAyKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDEzKSBeICgwLCB1dGlsc19qc18xLnJvdHIpKEEsIDIyKTtcbiAgICAgICAgICAgIGNvbnN0IFQyID0gKHNpZ21hMCArICgwLCBfbWRfanNfMS5NYWopKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuZXhwb3J0cy5TSEEyNTYgPSBTSEEyNTY7XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0cy5zaGEyNTYgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEEyNTYoKSk7XG4vKipcbiAqIFNIQTItMjI0IGhhc2ggZnVuY3Rpb25cbiAqL1xuZXhwb3J0cy5zaGEyMjQgPSAoMCwgdXRpbHNfanNfMS53cmFwQ29uc3RydWN0b3IpKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhtYWMgPSBleHBvcnRzLkhNQUMgPSB2b2lkIDA7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gSE1BQyAoUkZDIDIxMDQpXG5jbGFzcyBITUFDIGV4dGVuZHMgdXRpbHNfanNfMS5IYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5oYXNoKShoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5leGlzdHMpKHRoaXMpO1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5leGlzdHMpKHRoaXMpO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG5leHBvcnRzLkhNQUMgPSBITUFDO1xuLyoqXG4gKiBITUFDOiBSRkMyMTA0IG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZS5cbiAqIEBwYXJhbSBoYXNoIC0gZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIGUuZy4gc2hhMjU2XG4gKiBAcGFyYW0ga2V5IC0gbWVzc2FnZSBrZXlcbiAqIEBwYXJhbSBtZXNzYWdlIC0gbWVzc2FnZSBkYXRhXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG4gKiBpbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTInO1xuICogY29uc3QgbWFjMSA9IGhtYWMoc2hhMjU2LCAna2V5JywgJ21lc3NhZ2UnKTtcbiAqL1xuY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuZXhwb3J0cy5obWFjID0gaG1hYztcbmV4cG9ydHMuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuREVSID0gdm9pZCAwO1xuZXhwb3J0cy53ZWllcnN0cmFzc1BvaW50cyA9IHdlaWVyc3RyYXNzUG9pbnRzO1xuZXhwb3J0cy53ZWllcnN0cmFzcyA9IHdlaWVyc3RyYXNzO1xuZXhwb3J0cy5TV1VGcFNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvO1xuZXhwb3J0cy5tYXBUb0N1cnZlU2ltcGxlU1dVID0gbWFwVG9DdXJ2ZVNpbXBsZVNXVTtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFNob3J0IFdlaWVyc3RyYXNzIGN1cnZlLiBUaGUgZm9ybXVsYSBpczogecKyID0geMKzICsgYXggKyBiXG5jb25zdCBjdXJ2ZV9qc18xID0gcmVxdWlyZShcIi4vY3VydmUuanNcIik7XG5jb25zdCBtb2QgPSByZXF1aXJlKFwiLi9tb2R1bGFyLmpzXCIpO1xuY29uc3QgdXQgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmNvbnN0IHV0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbmZ1bmN0aW9uIHZhbGlkYXRlU2lnVmVyT3B0cyhvcHRzKSB7XG4gICAgaWYgKG9wdHMubG93UyAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAoMCwgdXRpbHNfanNfMS5hYm9vbCkoJ2xvd1MnLCBvcHRzLmxvd1MpO1xuICAgIGlmIChvcHRzLnByZWhhc2ggIT09IHVuZGVmaW5lZClcbiAgICAgICAgKDAsIHV0aWxzX2pzXzEuYWJvb2wpKCdwcmVoYXNoJywgb3B0cy5wcmVoYXNoKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUG9pbnRPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9ICgwLCBjdXJ2ZV9qc18xLnZhbGlkYXRlQmFzaWMpKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGE6ICdmaWVsZCcsXG4gICAgICAgIGI6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6ICdhcnJheScsXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiAnYm9vbGVhbicsXG4gICAgICAgIGlzVG9yc2lvbkZyZWU6ICdmdW5jdGlvbicsXG4gICAgICAgIGNsZWFyQ29mYWN0b3I6ICdmdW5jdGlvbicsXG4gICAgICAgIGFsbG93SW5maW5pdHlQb2ludDogJ2Jvb2xlYW4nLFxuICAgICAgICBmcm9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHRvQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBlbmRvLCBGcCwgYSB9ID0gb3B0cztcbiAgICBpZiAoZW5kbykge1xuICAgICAgICBpZiAoIUZwLmVxbChhLCBGcC5aRVJPKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmRvbW9ycGhpc20gY2FuIG9ubHkgYmUgZGVmaW5lZCBmb3IgS29ibGl0eiBjdXJ2ZXMgdGhhdCBoYXZlIGE9MCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW5kbyAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLmJldGEgIT09ICdiaWdpbnQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZW5kby5zcGxpdFNjYWxhciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBlbmRvbW9ycGhpc20gd2l0aCBiZXRhOiBiaWdpbnQgYW5kIHNwbGl0U2NhbGFyOiBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcbn1cbmNvbnN0IHsgYnl0ZXNUb051bWJlckJFOiBiMm4sIGhleFRvQnl0ZXM6IGgyYiB9ID0gdXQ7XG4vKipcbiAqIEFTTi4xIERFUiBlbmNvZGluZyB1dGlsaXRpZXMuIEFTTiBpcyB2ZXJ5IGNvbXBsZXggJiBmcmFnaWxlLiBGb3JtYXQ6XG4gKlxuICogICAgIFsweDMwIChTRVFVRU5DRSksIGJ5dGVsZW5ndGgsIDB4MDIgKElOVEVHRVIpLCBpbnRMZW5ndGgsIFIsIDB4MDIgKElOVEVHRVIpLCBpbnRMZW5ndGgsIFNdXG4gKlxuICogRG9jczogaHR0cHM6Ly9sZXRzZW5jcnlwdC5vcmcvZG9jcy9hLXdhcm0td2VsY29tZS10by1hc24xLWFuZC1kZXIvLCBodHRwczovL2x1Y2EubnRvcC5vcmcvVGVhY2hpbmcvQXBwdW50aS9hc24xLmh0bWxcbiAqL1xuZXhwb3J0cy5ERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBjbGFzcyBERVJFcnIgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICAgICAgc3VwZXIobSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIEJhc2ljIGJ1aWxkaW5nIGJsb2NrIGlzIFRMViAoVGFnLUxlbmd0aC1WYWx1ZSlcbiAgICBfdGx2OiB7XG4gICAgICAgIGVuY29kZTogKHRhZywgZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IGV4cG9ydHMuREVSO1xuICAgICAgICAgICAgaWYgKHRhZyA8IDAgfHwgdGFnID4gMjU2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB3cm9uZyB0YWcnKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAmIDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IHVucGFkZGVkIGRhdGEnKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFMZW4gPSBkYXRhLmxlbmd0aCAvIDI7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSB1dC5udW1iZXJUb0hleFVucGFkZGVkKGRhdGFMZW4pO1xuICAgICAgICAgICAgaWYgKChsZW4ubGVuZ3RoIC8gMikgJiAxMjgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IGxvbmcgZm9ybSBsZW5ndGggdG9vIGJpZycpO1xuICAgICAgICAgICAgLy8gbGVuZ3RoIG9mIGxlbmd0aCB3aXRoIGxvbmcgZm9ybSBmbGFnXG4gICAgICAgICAgICBjb25zdCBsZW5MZW4gPSBkYXRhTGVuID4gMTI3ID8gdXQubnVtYmVyVG9IZXhVbnBhZGRlZCgobGVuLmxlbmd0aCAvIDIpIHwgMTI4KSA6ICcnO1xuICAgICAgICAgICAgcmV0dXJuIGAke3V0Lm51bWJlclRvSGV4VW5wYWRkZWQodGFnKX0ke2xlbkxlbn0ke2xlbn0ke2RhdGF9YDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gdiAtIHZhbHVlLCBsIC0gbGVmdCBieXRlcyAodW5wYXJzZWQpXG4gICAgICAgIGRlY29kZSh0YWcsIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBleHBvcnRzLkRFUjtcbiAgICAgICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICAgICAgaWYgKHRhZyA8IDAgfHwgdGFnID4gMjU2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB3cm9uZyB0YWcnKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVtwb3MrK10gIT09IHRhZylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZTogd3JvbmcgdGx2Jyk7XG4gICAgICAgICAgICBjb25zdCBmaXJzdCA9IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgY29uc3QgaXNMb25nID0gISEoZmlyc3QgJiAxMjgpOyAvLyBGaXJzdCBiaXQgb2YgZmlyc3QgbGVuZ3RoIGJ5dGUgaXMgZmxhZyBmb3Igc2hvcnQvbG9uZyBmb3JtXG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlmICghaXNMb25nKVxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGZpcnN0O1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTG9uZyBmb3JtOiBbbG9uZ0ZsYWcoMWJpdCksIGxlbmd0aExlbmd0aCg3Yml0KSwgbGVuZ3RoIChCRSldXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuTGVuID0gZmlyc3QgJiAxMjc7XG4gICAgICAgICAgICAgICAgaWYgKCFsZW5MZW4pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBpbmRlZmluaXRlIGxlbmd0aCBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxlbkxlbiA+IDQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBieXRlIGxlbmd0aCBpcyB0b28gYmlnJyk7IC8vIHRoaXMgd2lsbCBvdmVyZmxvdyB1MzIgaW4ganNcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGhCeXRlcyA9IGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyBsZW5MZW4pO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGhCeXRlcy5sZW5ndGggIT09IGxlbkxlbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IGxlbmd0aCBieXRlcyBub3QgY29tcGxldGUnKTtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoQnl0ZXNbMF0gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiB6ZXJvIGxlZnRtb3N0IGJ5dGUnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGIgb2YgbGVuZ3RoQnl0ZXMpXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggPDwgOCkgfCBiO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW5MZW47XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA8IDEyOClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IG5vdCBtaW5pbWFsIGVuY29kaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2ID0gZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIGxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodi5sZW5ndGggIT09IGxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZTogd3JvbmcgdmFsdWUgbGVuZ3RoJyk7XG4gICAgICAgICAgICByZXR1cm4geyB2LCBsOiBkYXRhLnN1YmFycmF5KHBvcyArIGxlbmd0aCkgfTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTc3MzQgTGVmdG1vc3QgYml0IG9mIGZpcnN0IGJ5dGUgaXMgJ25lZ2F0aXZlJyBmbGFnLFxuICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgLy8gLSBhZGQgemVybyBieXRlIGlmIGV4aXN0c1xuICAgIC8vIC0gaWYgbmV4dCBieXRlIGRvZXNuJ3QgaGF2ZSBhIGZsYWcsIGxlYWRpbmcgemVybyBpcyBub3QgYWxsb3dlZCAobWluaW1hbCBlbmNvZGluZylcbiAgICBfaW50OiB7XG4gICAgICAgIGVuY29kZShudW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBleHBvcnRzLkRFUjtcbiAgICAgICAgICAgIGlmIChudW0gPCBfMG4pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ2ludGVnZXI6IG5lZ2F0aXZlIGludGVnZXJzIGFyZSBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgbGV0IGhleCA9IHV0Lm51bWJlclRvSGV4VW5wYWRkZWQobnVtKTtcbiAgICAgICAgICAgIC8vIFBhZCB3aXRoIHplcm8gYnl0ZSBpZiBuZWdhdGl2ZSBmbGFnIGlzIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChOdW1iZXIucGFyc2VJbnQoaGV4WzBdLCAxNikgJiAwYjEwMDApXG4gICAgICAgICAgICAgICAgaGV4ID0gJzAwJyArIGhleDtcbiAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoICYgMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndW5leHBlY3RlZCBhc3NlcnRpb24nKTtcbiAgICAgICAgICAgIHJldHVybiBoZXg7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gZXhwb3J0cy5ERVI7XG4gICAgICAgICAgICBpZiAoZGF0YVswXSAmIDEyOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogbmVnYXRpdmUnKTtcbiAgICAgICAgICAgIGlmIChkYXRhWzBdID09PSAweDAwICYmICEoZGF0YVsxXSAmIDEyOCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHVubmVjZXNzYXJ5IGxlYWRpbmcgemVybycpO1xuICAgICAgICAgICAgcmV0dXJuIGIybihkYXRhKTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIHRvU2lnKGhleCkge1xuICAgICAgICAvLyBwYXJzZSBERVIgc2lnbmF0dXJlXG4gICAgICAgIGNvbnN0IHsgRXJyOiBFLCBfaW50OiBpbnQsIF90bHY6IHRsdiB9ID0gZXhwb3J0cy5ERVI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YgaGV4ID09PSAnc3RyaW5nJyA/IGgyYihoZXgpIDogaGV4O1xuICAgICAgICB1dC5hYnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IHsgdjogc2VxQnl0ZXMsIGw6IHNlcUxlZnRCeXRlcyB9ID0gdGx2LmRlY29kZSgweDMwLCBkYXRhKTtcbiAgICAgICAgaWYgKHNlcUxlZnRCeXRlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgICAgICBjb25zdCB7IHY6IHJCeXRlcywgbDogckxlZnRCeXRlcyB9ID0gdGx2LmRlY29kZSgweDAyLCBzZXFCeXRlcyk7XG4gICAgICAgIGNvbnN0IHsgdjogc0J5dGVzLCBsOiBzTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MDIsIHJMZWZ0Qnl0ZXMpO1xuICAgICAgICBpZiAoc0xlZnRCeXRlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgICAgICByZXR1cm4geyByOiBpbnQuZGVjb2RlKHJCeXRlcyksIHM6IGludC5kZWNvZGUoc0J5dGVzKSB9O1xuICAgIH0sXG4gICAgaGV4RnJvbVNpZyhzaWcpIHtcbiAgICAgICAgY29uc3QgeyBfdGx2OiB0bHYsIF9pbnQ6IGludCB9ID0gZXhwb3J0cy5ERVI7XG4gICAgICAgIGNvbnN0IHNlcSA9IGAke3Rsdi5lbmNvZGUoMHgwMiwgaW50LmVuY29kZShzaWcucikpfSR7dGx2LmVuY29kZSgweDAyLCBpbnQuZW5jb2RlKHNpZy5zKSl9YDtcbiAgICAgICAgcmV0dXJuIHRsdi5lbmNvZGUoMHgzMCwgc2VxKTtcbiAgICB9LFxufTtcbi8vIEJlIGZyaWVuZGx5IHRvIGJhZCBFQ01BU2NyaXB0IHBhcnNlcnMgYnkgbm90IHVzaW5nIGJpZ2ludCBsaXRlcmFsc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyksIF80biA9IEJpZ0ludCg0KTtcbmZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKG9wdHMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlUG9pbnRPcHRzKG9wdHMpO1xuICAgIGNvbnN0IHsgRnAgfSA9IENVUlZFOyAvLyBBbGwgY3VydmVzIGhhcyBzYW1lIGZpZWxkIC8gZ3JvdXAgbGVuZ3RoIGFzIGZvciBub3csIGJ1dCB0aGV5IGNhbiBkaWZmZXJcbiAgICBjb25zdCBGbiA9IG1vZC5GaWVsZChDVVJWRS5uLCBDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICBjb25zdCB0b0J5dGVzID0gQ1VSVkUudG9CeXRlcyB8fFxuICAgICAgICAoKF9jLCBwb2ludCwgX2lzQ29tcHJlc3NlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgICAgICAgICByZXR1cm4gdXQuY29uY2F0Qnl0ZXMoVWludDhBcnJheS5mcm9tKFsweDA0XSksIEZwLnRvQnl0ZXMoYS54KSwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgfSk7XG4gICAgY29uc3QgZnJvbUJ5dGVzID0gQ1VSVkUuZnJvbUJ5dGVzIHx8XG4gICAgICAgICgoYnl0ZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIGlmIChoZWFkICE9PSAweDA0KSB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgbm9uLWNvbXByZXNzZWQgZW5jb2RpbmcgaXMgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheShGcC5CWVRFUywgMiAqIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIH0pO1xuICAgIC8qKlxuICAgICAqIHnCsiA9IHjCsyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYVxuICAgICAqIEByZXR1cm5zIHnCslxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4MiAqIHhcbiAgICAgICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBhKSksIGIpOyAvLyB4MyArIGEgKiB4ICsgYlxuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cbiAgICAvLyBXZSBjaGVjayBpZiBjdXJ2ZSBlcXVhdGlvbiB3b3JrcyBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIC8vIGBhc3NlcnRWYWxpZGl0eSgpYCB3b24ndCB3b3JrOiBgaXNUb3JzaW9uRnJlZSgpYCBpcyBub3QgYXZhaWxhYmxlIGF0IHRoaXMgcG9pbnQgaW4gYmxzMTItMzgxLlxuICAgIC8vIFByb2plY3RpdmVQb2ludCBjbGFzcyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0LlxuICAgIGlmICghRnAuZXFsKEZwLnNxcihDVVJWRS5HeSksIHdlaWVyc3RyYXNzRXF1YXRpb24oQ1VSVkUuR3gpKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgZ2VuZXJhdG9yIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgLy8gVmFsaWQgZ3JvdXAgZWxlbWVudHMgcmVzaWRlIGluIHJhbmdlIDEuLm4tMVxuICAgIGZ1bmN0aW9uIGlzV2l0aGluQ3VydmVPcmRlcihudW0pIHtcbiAgICAgICAgcmV0dXJuIHV0LmluUmFuZ2UobnVtLCBfMW4sIENVUlZFLm4pO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZXMgaWYgcHJpdiBrZXkgaXMgdmFsaWQgYW5kIGNvbnZlcnRzIGl0IHRvIGJpZ2ludC5cbiAgICAvLyBTdXBwb3J0cyBvcHRpb25zIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RocyBhbmQgd3JhcFByaXZhdGVLZXkuXG4gICAgZnVuY3Rpb24gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgeyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHM6IGxlbmd0aHMsIG5CeXRlTGVuZ3RoLCB3cmFwUHJpdmF0ZUtleSwgbjogTiB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChsZW5ndGhzICYmIHR5cGVvZiBrZXkgIT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICBpZiAodXQuaXNCeXRlcyhrZXkpKVxuICAgICAgICAgICAgICAgIGtleSA9IHV0LmJ5dGVzVG9IZXgoa2V5KTtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byBoZXggc3RyaW5nLCBwYWQuIEUuZy4gUDUyMSB3b3VsZCBub3JtIDEzMC0xMzIgY2hhciBoZXggdG8gMTMyLWNoYXIgYnl0ZXNcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCAhbGVuZ3Rocy5pbmNsdWRlcyhrZXkubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5Jyk7XG4gICAgICAgICAgICBrZXkgPSBrZXkucGFkU3RhcnQobkJ5dGVMZW5ndGggKiAyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBudW0gPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBrZXkgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICAgICAgICAgIDogdXQuYnl0ZXNUb051bWJlckJFKCgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgncHJpdmF0ZSBrZXknLCBrZXksIG5CeXRlTGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByaXZhdGUga2V5IG11c3QgYmUgJHtuQnl0ZUxlbmd0aH0gYnl0ZXMsIGhleCBvciBiaWdpbnQsIG5vdCAke3R5cGVvZiBrZXl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gbW9kLm1vZChudW0sIE4pOyAvLyBkaXNhYmxlZCBieSBkZWZhdWx0LCBlbmFibGVkIGZvciBCTFNcbiAgICAgICAgdXQuYUluUmFuZ2UoJ3ByaXZhdGUga2V5JywgbnVtLCBfMW4sIE4pOyAvLyBudW0gaW4gcmFuZ2UgWzEuLk4tMV1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0UHJqUG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3RpdmVQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvLyBNZW1vaXplZCB0b0FmZmluZSAvIHZhbGlkaXR5IGNoZWNrLiBUaGV5IGFyZSBoZWF2eS4gUG9pbnRzIGFyZSBpbW11dGFibGUuXG4gICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICBjb25zdCB0b0FmZmluZU1lbW8gPSAoMCwgdXRpbHNfanNfMS5tZW1vaXplZCkoKHAsIGl6KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gcDtcbiAgICAgICAgLy8gRmFzdC1wYXRoIGZvciBub3JtYWxpemVkIHBvaW50c1xuICAgICAgICBpZiAoRnAuZXFsKHosIEZwLk9ORSkpXG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIGNvbnN0IGlzMCA9IHAuaXMwKCk7XG4gICAgICAgIC8vIElmIGludlogd2FzIDAsIHdlIHJldHVybiB6ZXJvIHBvaW50LiBIb3dldmVyIHdlIHN0aWxsIHdhbnQgdG8gZXhlY3V0ZVxuICAgICAgICAvLyBhbGwgb3BlcmF0aW9ucywgc28gd2UgcmVwbGFjZSBpbnZaIHdpdGggYSByYW5kb20gbnVtYmVyLCAxLlxuICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgIGl6ID0gaXMwID8gRnAuT05FIDogRnAuaW52KHopO1xuICAgICAgICBjb25zdCBheCA9IEZwLm11bCh4LCBpeik7XG4gICAgICAgIGNvbnN0IGF5ID0gRnAubXVsKHksIGl6KTtcbiAgICAgICAgY29uc3QgenogPSBGcC5tdWwoeiwgaXopO1xuICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICBpZiAoIUZwLmVxbCh6eiwgRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICB9KTtcbiAgICAvLyBOT1RFOiBvbiBleGNlcHRpb24gdGhpcyB3aWxsIGNyYXNoICdjYWNoZWQnIGFuZCBubyB2YWx1ZSB3aWxsIGJlIHNldC5cbiAgICAvLyBPdGhlcndpc2UgdHJ1ZSB3aWxsIGJlIHJldHVyblxuICAgIGNvbnN0IGFzc2VydFZhbGlkTWVtbyA9ICgwLCB1dGlsc19qc18xLm1lbW9pemVkKSgocCkgPT4ge1xuICAgICAgICBpZiAocC5pczAoKSkge1xuICAgICAgICAgICAgLy8gKDAsIDEsIDApIGFrYSBaRVJPIGlzIGludmFsaWQgaW4gbW9zdCBjb250ZXh0cy5cbiAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgd3JvbmcgcmVwcmVzZW50YXRpb24gb2YgWkVSTyBhbmQgaXMgYWx3YXlzIGludmFsaWQuXG4gICAgICAgICAgICBpZiAoQ1VSVkUuYWxsb3dJbmZpbml0eVBvaW50ICYmICFGcC5pczAocC5weSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcC50b0FmZmluZSgpO1xuICAgICAgICAvLyBDaGVjayBpZiB4LCB5IGFyZSB2YWxpZCBmaWVsZCBlbGVtZW50c1xuICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBGRScpO1xuICAgICAgICBjb25zdCBsZWZ0ID0gRnAuc3FyKHkpOyAvLyB5wrJcbiAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4wrMgKyBheCArIGJcbiAgICAgICAgaWYgKCFGcC5lcWwobGVmdCwgcmlnaHQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAgICAgaWYgKCFwLmlzVG9yc2lvbkZyZWUoKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogUHJvamVjdGl2ZSBQb2ludCB3b3JrcyBpbiAzZCAvIHByb2plY3RpdmUgKGhvbW9nZW5lb3VzKSBjb29yZGluYXRlczogKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAqIERlZmF1bHQgUG9pbnQgd29ya3MgaW4gMmQgLyBhZmZpbmUgY29vcmRpbmF0ZXM6ICh4LCB5KVxuICAgICAqIFdlJ3JlIGRvaW5nIGNhbGN1bGF0aW9ucyBpbiBwcm9qZWN0aXZlLCBiZWNhdXNlIGl0cyBvcGVyYXRpb25zIGRvbid0IHJlcXVpcmUgY29zdGx5IGludmVyc2lvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHB4LCBweSwgcHopIHtcbiAgICAgICAgICAgIHRoaXMucHggPSBweDtcbiAgICAgICAgICAgIHRoaXMucHkgPSBweTtcbiAgICAgICAgICAgIHRoaXMucHogPSBwejtcbiAgICAgICAgICAgIGlmIChweCA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweSA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweiA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB6KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ogcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9lcyBub3QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIG9uLWN1cnZlLlxuICAgICAgICAvLyBVc2UgZnJvbUhleCBpbnN0ZWFkLCBvciBjYWxsIGFzc2VydFZhbGlkaXR5KCkgbGF0ZXIuXG4gICAgICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgICAgICAgIGlmICghcCB8fCAhRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWZmaW5lIHBvaW50Jyk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvamVjdGl2ZSBwb2ludCBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gKGkpID0+IEZwLmVxbChpLCBGcC5aRVJPKTtcbiAgICAgICAgICAgIC8vIGZyb21BZmZpbmUoeDowLCB5OjApIHdvdWxkIHByb2R1Y2UgKHg6MCwgeTowLCB6OjEpLCBidXQgd2UgbmVlZCAoeDowLCB5OjEsIHo6MClcbiAgICAgICAgICAgIGlmIChpczAoeCkgJiYgaXMwKHkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBGcC5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgICAgICB9XG4gICAgICAgIGdldCB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBhIGJ1bmNoIG9mIFByb2plY3RpdmUgUG9pbnRzIGJ1dCBleGVjdXRlcyBvbmx5IG9uZVxuICAgICAgICAgKiBpbnZlcnNpb24gb24gYWxsIG9mIHRoZW0uIEludmVyc2lvbiBpcyB2ZXJ5IHNsb3cgb3BlcmF0aW9uLFxuICAgICAgICAgKiBzbyB0aGlzIGltcHJvdmVzIHBlcmZvcm1hbmNlIG1hc3NpdmVseS5cbiAgICAgICAgICogT3B0aW1pemF0aW9uOiBjb252ZXJ0cyBhIGxpc3Qgb2YgcHJvamVjdGl2ZSBwb2ludHMgdG8gYSBsaXN0IG9mIGlkZW50aWNhbCBwb2ludHMgd2l0aCBaPTEuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSBoZXggc2hvcnQvbG9uZyBFQ0RTQSBoZXhcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUoZnJvbUJ5dGVzKCgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlzY2FsYXIgTXVsdGlwbGljYXRpb25cbiAgICAgICAgc3RhdGljIG1zbShwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgY3VydmVfanNfMS5waXBwZW5nZXIpKFBvaW50LCBGbiwgcG9pbnRzLCBzY2FsYXJzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBcIlByaXZhdGUgbWV0aG9kXCIsIGRvbid0IHVzZSBpdCBkaXJlY3RseVxuICAgICAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICB3bmFmLnNldFdpbmRvd1NpemUodGhpcywgd2luZG93U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICBhc3NlcnRWYWxpZE1lbW8odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRXZlblkoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGlmIChGcC5pc09kZClcbiAgICAgICAgICAgICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAubXVsKFgxLCBZMSk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgdDMpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFgzLCBZMyk7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFkzKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDAsIHQzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChZMSwgWjEpOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MiA9IEZwLmFkZCh0MiwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0MiwgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxuICAgICAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICB3TkFGKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWQodGhpcywgbiwgUG9pbnQubm9ybWFsaXplWik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKHNjKSB7XG4gICAgICAgICAgICB1dC5hSW5SYW5nZSgnc2NhbGFyJywgc2MsIF8wbiwgQ1VSVkUubik7XG4gICAgICAgICAgICBjb25zdCBJID0gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIGlmIChzYyA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgaWYgKHNjID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKCFlbmRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBzYyk7XG4gICAgICAgICAgICAvLyBBcHBseSBlbmRvbW9ycGhpc21cbiAgICAgICAgICAgIGxldCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKHNjKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbywgbjogTiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICB1dC5hSW5SYW5nZSgnc2NhbGFyJywgc2NhbGFyLCBfMW4sIE4pO1xuICAgICAgICAgICAgbGV0IHBvaW50LCBmYWtlOyAvLyBGYWtlIHBvaW50IGlzIHVzZWQgdG8gY29uc3QtdGltZSBtdWx0XG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIoc2NhbGFyKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihzY2FsYXIpO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcDtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBgemAgZm9yIGJvdGggcG9pbnRzLCBidXQgcmV0dXJuIG9ubHkgcmVhbCBvbmVcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5ub3JtYWxpemVaKFtwb2ludCwgZmFrZV0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZmZpY2llbnRseSBjYWxjdWxhdGUgYGFQICsgYlFgLiBVbnNhZmUsIGNhbiBleHBvc2UgcHJpdmF0ZSBrZXksIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG4gICAgICAgICAqIE5vdCB1c2luZyBTdHJhdXNzLVNoYW1pciB0cmljazogcHJlY29tcHV0YXRpb24gdGFibGVzIGFyZSBmYXN0ZXIuXG4gICAgICAgICAqIFRoZSB0cmljayBjb3VsZCBiZSB1c2VmdWwgaWYgYm90aCBQIGFuZCBRIGFyZSBub3QgRyAobm90IGluIG91ciBjYXNlKS5cbiAgICAgICAgICogQHJldHVybnMgbm9uLXplcm8gYWZmaW5lIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XG4gICAgICAgICAgICBjb25zdCBHID0gUG9pbnQuQkFTRTsgLy8gTm8gU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHdlIGhhdmUgMTAlIGZhc3RlciBHIHByZWNvbXB1dGVzXG4gICAgICAgICAgICBjb25zdCBtdWwgPSAoUCwgYSAvLyBTZWxlY3QgZmFzdGVyIG11bHRpcGx5KCkgbWV0aG9kXG4gICAgICAgICAgICApID0+IChhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8ICFQLmVxdWFscyhHKSA/IFAubXVsdGlwbHlVbnNhZmUoYSkgOiBQLm11bHRpcGx5KGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IG11bCh0aGlzLCBhKS5hZGQobXVsKFEsIGIpKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0uaXMwKCkgPyB1bmRlZmluZWQgOiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgICAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAgICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAgICB0b0FmZmluZShpeikge1xuICAgICAgICAgICAgcmV0dXJuIHRvQWZmaW5lTWVtbyh0aGlzLCBpeik7XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgICgwLCB1dGlsc19qc18xLmFib29sKSgnaXNDb21wcmVzc2VkJywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0b0J5dGVzKFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgICgwLCB1dGlsc19qc18xLmFib29sKSgnaXNDb21wcmVzc2VkJywgaXNDb21wcmVzc2VkKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5ieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KEZwLlpFUk8sIEZwLk9ORSwgRnAuWkVSTyk7XG4gICAgY29uc3QgX2JpdHMgPSBDVVJWRS5uQml0TGVuZ3RoO1xuICAgIGNvbnN0IHduYWYgPSAoMCwgY3VydmVfanNfMS53TkFGKShQb2ludCwgQ1VSVkUuZW5kbyA/IE1hdGguY2VpbChfYml0cyAvIDIpIDogX2JpdHMpO1xuICAgIC8vIFZhbGlkYXRlIGlmIGdlbmVyYXRvciBwb2ludCBpcyBvbiBjdXJ2ZVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICB3ZWllcnN0cmFzc0VxdWF0aW9uLFxuICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSAoMCwgY3VydmVfanNfMS52YWxpZGF0ZUJhc2ljKShjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgc2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgYW5kIEVDRFNBIHNpZ25hdHVyZSBtZXRob2RzIGZvciBpdC5cbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBGaWVsZCB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvYWJzdHJhY3QvbW9kdWxhcic7XG4gKiAvLyBCZWZvcmUgdGhhdCwgZGVmaW5lIEJpZ0ludC1zOiBhLCBiLCBwLCBuLCBHeCwgR3lcbiAqIGNvbnN0IGN1cnZlID0gd2VpZXJzdHJhc3MoeyBhLCBiLCBGcDogRmllbGQocCksIG4sIEd4LCBHeSwgaDogMW4gfSlcbiAqL1xuZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5tb2QoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZOKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5pbnZlcnQoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBjb25zdCB7IFByb2plY3RpdmVQb2ludDogUG9pbnQsIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsIHdlaWVyc3RyYXNzRXF1YXRpb24sIGlzV2l0aGluQ3VydmVPcmRlciwgfSA9IHdlaWVyc3RyYXNzUG9pbnRzKHtcbiAgICAgICAgLi4uQ1VSVkUsXG4gICAgICAgIHRvQnl0ZXMoX2MsIHBvaW50LCBpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IHV0LmNvbmNhdEJ5dGVzO1xuICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuYWJvb2wpKCdpc0NvbXByZXNzZWQnLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSBpcyBkb25lIGluc2lkZSBvZiBmcm9tSGV4XG4gICAgICAgICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHV0LmJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoIXV0LmluUmFuZ2UoeCwgXzFuLCBGcC5PUkRFUikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChzcXJ0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gc3FydEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyAnOiAnICsgc3FydEVycm9yLm1lc3NhZ2UgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnICsgc3VmZml4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IG9mIGxlbmd0aCAke2xlbn0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnY29tcGFjdFNpZ25hdHVyZScsIGhleCwgbCAqIDIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUoc2xjTnVtKGhleCwgMCwgbCksIHNsY051bShoZXgsIGwsIDIgKiBsKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSIGVuY29kZWQgRUNEU0Egc2lnbmF0dXJlXG4gICAgICAgIC8vIGh0dHBzOi8vYml0Y29pbi5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNTc2NDQvd2hhdC1hcmUtdGhlLXBhcnRzLW9mLWEtYml0Y29pbi10cmFuc2FjdGlvbi1pbnB1dC1zY3JpcHRcbiAgICAgICAgc3RhdGljIGZyb21ERVIoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IGV4cG9ydHMuREVSLnRvU2lnKCgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnREVSJywgaGV4KSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIHV0LmFJblJhbmdlKCdyJywgdGhpcy5yLCBfMW4sIENVUlZFX09SREVSKTsgLy8gciBpbiBbMS4uTl1cbiAgICAgICAgICAgIHV0LmFJblJhbmdlKCdzJywgdGhpcy5zLCBfMW4sIENVUlZFX09SREVSKTsgLy8gcyBpbiBbMS4uTl1cbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKCgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnbXNnSGFzaCcsIG1zZ0hhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgICAgICAgICAgaWYgKHJlYyA9PSBudWxsIHx8ICFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xuICAgICAgICAgICAgaWYgKHJhZGogPj0gRnAuT1JERVIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChwcmVmaXggKyBudW1Ub05CeXRlU3RyKHJhZGopKTtcbiAgICAgICAgICAgIGNvbnN0IGlyID0gaW52TihyYWRqKTsgLy8gcl4tMVxuICAgICAgICAgICAgY29uc3QgdTEgPSBtb2ROKC1oICogaXIpOyAvLyAtaHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUyID0gbW9kTihzICogaXIpOyAvLyBzcl4tMVxuICAgICAgICAgICAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUiwgdTEsIHUyKTsgLy8gKHNyXi0xKVItKGhyXi0xKUcgPSAtKGhyXi0xKUcgKyAoc3JeLTEpXG4gICAgICAgICAgICBpZiAoIVEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2ludCBhdCBpbmZpbmlmeScpOyAvLyB1bnNhZmUgaXMgZmluZTogbm8gcHJpdiBkYXRhIGxlYWtlZFxuICAgICAgICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzaG91bGQgYmUgbG93LXMsIHRvIHByZXZlbnQgbWFsbGVhYmlsaXR5LlxuICAgICAgICBoYXNIaWdoUygpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVTKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGlnaFMoKSA/IG5ldyBTaWduYXR1cmUodGhpcy5yLCBtb2ROKC10aGlzLnMpLCB0aGlzLnJlY292ZXJ5KSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSLWVuY29kZWRcbiAgICAgICAgdG9ERVJSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9ERVJIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9ERVJIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5ERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHV0LmlzQnl0ZXMoaXRlbSk7XG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIHV0LmFJblJhbmdlKGBudW0gPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gLCBudW0sIF8wbiwgT1JERVJfTUFTSyk7XG4gICAgICAgIC8vIHdvcmtzIHdpdGggb3JkZXIsIGNhbiBoYXZlIGRpZmZlcmVudCBzaXplIHRoYW4gbnVtVG9GaWVsZCFcbiAgICAgICAgcmV0dXJuIHV0Lm51bWJlclRvQnl0ZXNCRShudW0sIENVUlZFLm5CeXRlTGVuZ3RoKTtcbiAgICB9XG4gICAgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMlxuICAgIC8vIENyZWF0ZXMgUkZDNjk3OSBzZWVkOyBjb252ZXJ0cyBtc2cvcHJpdktleSB0byBudW1iZXJzLlxuICAgIC8vIFVzZWQgb25seSBpbiBzaWduLCBub3QgaW4gdmVyaWZ5LlxuICAgIC8vIE5PVEU6IHdlIGNhbm5vdCBhc3N1bWUgaGVyZSB0aGF0IG1zZ0hhc2ggaGFzIHNhbWUgYW1vdW50IG9mIGJ5dGVzIGFzIGN1cnZlIG9yZGVyLCB0aGlzIHdpbGwgYmUgd3JvbmcgYXQgbGVhc3QgZm9yIFA1MjEuXG4gICAgLy8gQWxzbyBpdCBjYW4gYmUgYmlnZ2VyIGZvciBQMjI0ICsgU0hBMjU2XG4gICAgZnVuY3Rpb24gcHJlcFNpZyhtc2dIYXNoLCBwcml2YXRlS2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgaWYgKFsncmVjb3ZlcmVkJywgJ2Nhbm9uaWNhbCddLnNvbWUoKGspID0+IGsgaW4gb3B0cykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24oKSBsZWdhY3kgb3B0aW9ucyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIGNvbnN0IHsgaGFzaCwgcmFuZG9tQnl0ZXMgfSA9IENVUlZFO1xuICAgICAgICBsZXQgeyBsb3dTLCBwcmVoYXNoLCBleHRyYUVudHJvcHk6IGVudCB9ID0gb3B0czsgLy8gZ2VuZXJhdGVzIGxvdy1zIHNpZ3MgYnkgZGVmYXVsdFxuICAgICAgICBpZiAobG93UyA9PSBudWxsKVxuICAgICAgICAgICAgbG93UyA9IHRydWU7IC8vIFJGQzY5NzkgMy4yOiB3ZSBza2lwIHN0ZXAgQSwgYmVjYXVzZSB3ZSBhbHJlYWR5IHByb3ZpZGUgaGFzaFxuICAgICAgICBtc2dIYXNoID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIHZhbGlkYXRlU2lnVmVyT3B0cyhvcHRzKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gKDAsIHV0aWxzX2pzXzEuZW5zdXJlQnl0ZXMpKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwgJiYgZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICAgICAgICBjb25zdCBlID0gZW50ID09PSB0cnVlID8gcmFuZG9tQnl0ZXMoRnAuQllURVMpIDogZW50OyAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuICAgICAgICAgICAgc2VlZEFyZ3MucHVzaCgoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ2V4dHJhRW50cm9weScsIGUpKTsgLy8gY2hlY2sgZm9yIGJlaW5nIGJ5dGVzXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlZCA9IHV0LmNvbmNhdEJ5dGVzKC4uLnNlZWRBcmdzKTsgLy8gU3RlcCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgICAgIGNvbnN0IG0gPSBoMWludDsgLy8gTk9URTogbm8gbmVlZCB0byBjYWxsIGJpdHMyaW50IHNlY29uZCB0aW1lIGhlcmUsIGl0IGlzIGluc2lkZSB0cnVuY2F0ZUhhc2ghXG4gICAgICAgIC8vIENvbnZlcnRzIHNpZ25hdHVyZSBwYXJhbXMgaW50byBwb2ludCB3IHIvcywgY2hlY2tzIHJlc3VsdCBmb3IgdmFsaWRpdHkuXG4gICAgICAgIGZ1bmN0aW9uIGsyc2lnKGtCeXRlcykge1xuICAgICAgICAgICAgLy8gUkZDIDY5NzkgU2VjdGlvbiAzLjIsIHN0ZXAgMzogayA9IGJpdHMyaW50KFQpXG4gICAgICAgICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIoaykpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBJbXBvcnRhbnQ6IGFsbCBtb2QoKSBjYWxscyBoZXJlIG11c3QgYmUgZG9uZSBvdmVyIE5cbiAgICAgICAgICAgIGNvbnN0IGlrID0gaW52TihrKTsgLy8ga14tMSBtb2QgblxuICAgICAgICAgICAgY29uc3QgcSA9IFBvaW50LkJBU0UubXVsdGlwbHkoaykudG9BZmZpbmUoKTsgLy8gcSA9IEdrXG4gICAgICAgICAgICBjb25zdCByID0gbW9kTihxLngpOyAvLyByID0gcS54IG1vZCBuXG4gICAgICAgICAgICBpZiAociA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIENhbiB1c2Ugc2NhbGFyIGJsaW5kaW5nIGJeLTEoYm0gKyBiZHIpIHdoZXJlIGIg4oiIIFsxLHHiiJIxXSBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdGNoZXMuaWFjci5vcmcvaW5kZXgucGhwL1RDSEVTL2FydGljbGUvdmlldy83MzM3LzY1MDkuIFdlJ3ZlIGRlY2lkZWQgYWdhaW5zdCBpdDpcbiAgICAgICAgICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxuICAgICAgICAgICAgY29uc3QgcyA9IG1vZE4oaWsgKiBtb2ROKG0gKyByICogZCkpOyAvLyBOb3QgdXNpbmcgYmxpbmRpbmcgaGVyZVxuICAgICAgICAgICAgaWYgKHMgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcmVjb3ZlcnkgPSAocS54ID09PSByID8gMCA6IDIpIHwgTnVtYmVyKHEueSAmIF8xbik7IC8vIHJlY292ZXJ5IGJpdCAoMiBvciAzLCB3aGVuIHEueCA+IG4pXG4gICAgICAgICAgICBsZXQgbm9ybVMgPSBzO1xuICAgICAgICAgICAgaWYgKGxvd1MgJiYgaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpKSB7XG4gICAgICAgICAgICAgICAgbm9ybVMgPSBub3JtYWxpemVTKHMpOyAvLyBpZiBsb3dTIHdhcyBwYXNzZWQsIGVuc3VyZSBzIGlzIGFsd2F5c1xuICAgICAgICAgICAgICAgIHJlY292ZXJ5IF49IDE7IC8vIC8vIGluIHRoZSBib3R0b20gaGFsZiBvZiBOXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBub3JtUywgcmVjb3ZlcnkpOyAvLyB1c2Ugbm9ybVMsIG5vdCBzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2VlZCwgazJzaWcgfTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdFNpZ09wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgY29uc3QgZGVmYXVsdFZlck9wdHMgPSB7IGxvd1M6IENVUlZFLmxvd1MsIHByZWhhc2g6IGZhbHNlIH07XG4gICAgLyoqXG4gICAgICogU2lnbnMgbWVzc2FnZSBoYXNoIHdpdGggYSBwcml2YXRlIGtleS5cbiAgICAgKiBgYGBcbiAgICAgKiBzaWduKG0sIGQsIGspIHdoZXJlXG4gICAgICogICAoeCwgeSkgPSBHIMOXIGtcbiAgICAgKiAgIHIgPSB4IG1vZCBuXG4gICAgICogICBzID0gKG0gKyBkcikvayBtb2QgblxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBtc2dIYXNoIE5PVCBtZXNzYWdlLiBtc2cgbmVlZHMgdG8gYmUgaGFzaGVkIHRvIGBtc2dIYXNoYCwgb3IgdXNlIGBwcmVoYXNoYC5cbiAgICAgKiBAcGFyYW0gcHJpdktleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBvcHRzIGxvd1MgZm9yIG5vbi1tYWxsZWFibGUgc2lncy4gZXh0cmFFbnRyb3B5IGZvciBtaXhpbmcgcmFuZG9tbmVzcyBpbnRvIGsuIHByZWhhc2ggd2lsbCBoYXNoIGZpcnN0IGFyZy5cbiAgICAgKiBAcmV0dXJucyBzaWduYXR1cmUgd2l0aCByZWNvdmVyeSBwYXJhbVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNpZ24obXNnSGFzaCwgcHJpdktleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGNvbnN0IHsgc2VlZCwgazJzaWcgfSA9IHByZXBTaWcobXNnSGFzaCwgcHJpdktleSwgb3B0cyk7IC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG4gICAgICAgIGNvbnN0IEMgPSBDVVJWRTtcbiAgICAgICAgY29uc3QgZHJiZyA9IHV0LmNyZWF0ZUhtYWNEcmJnKEMuaGFzaC5vdXRwdXRMZW4sIEMubkJ5dGVMZW5ndGgsIEMuaG1hYyk7XG4gICAgICAgIHJldHVybiBkcmJnKHNlZWQsIGsyc2lnKTsgLy8gU3RlcHMgQiwgQywgRCwgRSwgRiwgR1xuICAgIH1cbiAgICAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgUG9pbnQuQkFTRS5fc2V0V2luZG93U2l6ZSg4KTtcbiAgICAvLyB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5CQVNFKVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGEgc2lnbmF0dXJlIGFnYWluc3QgbWVzc2FnZSBoYXNoIGFuZCBwdWJsaWMga2V5LlxuICAgICAqIFJlamVjdHMgbG93UyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQ6IHRvIG92ZXJyaWRlLFxuICAgICAqIHNwZWNpZnkgb3B0aW9uIGB7bG93UzogZmFsc2V9YC4gSW1wbGVtZW50cyBzZWN0aW9uIDQuMS40IGZyb20gaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMS12Mi5wZGY6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiB2ZXJpZnkociwgcywgaCwgUCkgd2hlcmVcbiAgICAgKiAgIFUxID0gaHNeLTEgbW9kIG5cbiAgICAgKiAgIFUyID0gcnNeLTEgbW9kIG5cbiAgICAgKiAgIFIgPSBVMeKLhUcgLSBVMuKLhVBcbiAgICAgKiAgIG1vZChSLngsIG4pID09IHJcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnbmF0dXJlLCBtc2dIYXNoLCBwdWJsaWNLZXksIG9wdHMgPSBkZWZhdWx0VmVyT3B0cykge1xuICAgICAgICBjb25zdCBzZyA9IHNpZ25hdHVyZTtcbiAgICAgICAgbXNnSGFzaCA9ICgwLCB1dGlsc19qc18xLmVuc3VyZUJ5dGVzKSgnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3B1YmxpY0tleScsIHB1YmxpY0tleSk7XG4gICAgICAgIGlmICgnc3RyaWN0JyBpbiBvcHRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnN0cmljdCB3YXMgcmVuYW1lZCB0byBsb3dTJyk7XG4gICAgICAgIHZhbGlkYXRlU2lnVmVyT3B0cyhvcHRzKTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoIH0gPSBvcHRzO1xuICAgICAgICBsZXQgX3NpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IFA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCB1dC5pc0J5dGVzKHNnKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gMiB3YXlzOiBjb21wYWN0ICgyKm5CeXRlTGVuZ3RoKSAmIERFUiAodmFyaWFibGUtbGVuZ3RoKS5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBERVIgY2FuIGFsc28gYmUgMipuQnl0ZUxlbmd0aCBieXRlcywgd2UgY2hlY2sgZm9yIGl0IGZpcnN0LlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbURFUihzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChkZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIGV4cG9ydHMuREVSLkVycikpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkZXJFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tQ29tcGFjdChzZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNnID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygc2cuciA9PT0gJ2JpZ2ludCcgJiYgdHlwZW9mIHNnLnMgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBzZztcbiAgICAgICAgICAgICAgICBfc2lnID0gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUEFSU0UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFAgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IubWVzc2FnZSA9PT0gJ1BBUlNFJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNpZ25hdHVyZSBtdXN0IGJlIFNpZ25hdHVyZSBpbnN0YW5jZSwgVWludDhBcnJheSBvciBoZXggc3RyaW5nYCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd1MgJiYgX3NpZy5oYXNIaWdoUygpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBDVVJWRS5oYXNoKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCB7IHIsIHMgfSA9IF9zaWc7XG4gICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgIGNvbnN0IGlzID0gaW52TihzKTsgLy8gc14tMVxuICAgICAgICBjb25zdCB1MSA9IG1vZE4oaCAqIGlzKTsgLy8gdTEgPSBoc14tMSBtb2QgblxuICAgICAgICBjb25zdCB1MiA9IG1vZE4ociAqIGlzKTsgLy8gdTIgPSByc14tMSBtb2QgblxuICAgICAgICBjb25zdCBSID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShQLCB1MSwgdTIpPy50b0FmZmluZSgpOyAvLyBSID0gdTHii4VHICsgdTLii4VQXG4gICAgICAgIGlmICghUilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgdiA9IG1vZE4oUi54KTtcbiAgICAgICAgcmV0dXJuIHYgPT09IHI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIGdldFNoYXJlZFNlY3JldCxcbiAgICAgICAgc2lnbixcbiAgICAgICAgdmVyaWZ5LFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBTaWduYXR1cmUsXG4gICAgICAgIHV0aWxzLFxuICAgIH07XG59XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBTaGFsbHVlIGFuZCB2YW4gZGUgV29lc3Rpam5lIG1ldGhvZCBmb3IgYW55IHdlaWVyc3RyYXNzIGN1cnZlLlxuICogVE9ETzogY2hlY2sgaWYgdGhlcmUgaXMgYSB3YXkgdG8gbWVyZ2UgdGhpcyB3aXRoIHV2UmF0aW8gaW4gRWR3YXJkczsgbW92ZSB0byBtb2R1bGFyLlxuICogYiA9IFRydWUgYW5kIHkgPSBzcXJ0KHUgLyB2KSBpZiAodSAvIHYpIGlzIHNxdWFyZSBpbiBGLCBhbmRcbiAqIGIgPSBGYWxzZSBhbmQgeSA9IHNxcnQoWiAqICh1IC8gdikpIG90aGVyd2lzZS5cbiAqIEBwYXJhbSBGcFxuICogQHBhcmFtIFpcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIG9wdHMpIHtcbiAgICBtb2QudmFsaWRhdGVGaWVsZChGcCk7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKG9wdHMuQSkgfHwgIUZwLmlzVmFsaWQob3B0cy5CKSB8fCAhRnAuaXNWYWxpZChvcHRzLlopKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICAgIGNvbnN0IHNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvKEZwLCBvcHRzLlopO1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIScpO1xuICAgIC8vIElucHV0OiB1LCBhbiBlbGVtZW50IG9mIEYuXG4gICAgLy8gT3V0cHV0OiAoeCwgeSksIGEgcG9pbnQgb24gRS5cbiAgICByZXR1cm4gKHUpID0+IHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcbiAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgb3B0cy5aKTsgLy8gMi4gIHR2MSA9IFogKiB0djFcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7IC8vIDUuICB0djMgPSB0djIgKyAxXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIG9wdHMuQik7IC8vIDYuICB0djMgPSBCICogdHYzXG4gICAgICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXG4gICAgICAgIHR2NCA9IEZwLm11bCh0djQsIG9wdHMuQSk7IC8vIDguICB0djQgPSBBICogdHY0XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkEpOyAvLyAxMS4gdHY1ID0gQSAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxMi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICAgICAgdHY2ID0gRnAubXVsKHR2NiwgdHY0KTsgLy8gMTQuIHR2NiA9IHR2NiAqIHR2NFxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkIpOyAvLyAxNS4gdHY1ID0gQiAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7IC8vIDE4LiAoaXNfZ3gxX3NxdWFyZSwgeTEpID0gc3FydF9yYXRpbyh0djIsIHR2NilcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXG4gICAgICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7IC8vIDIxLiAgIHggPSBDTU9WKHgsIHR2MywgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgY29uc3QgZTEgPSBGcC5pc09kZCh1KSA9PT0gRnAuaXNPZGQoeSk7IC8vIDIzLiAgZTEgPSBzZ24wKHUpID09IHNnbjAoeSlcbiAgICAgICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcbiAgICAgICAgeCA9IEZwLmRpdih4LCB0djQpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlaWVyc3RyYXNzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRIYXNoID0gZ2V0SGFzaDtcbmV4cG9ydHMuY3JlYXRlQ3VydmUgPSBjcmVhdGVDdXJ2ZTtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IGhtYWNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL2htYWNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5jb25zdCB3ZWllcnN0cmFzc19qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanNcIik7XG4vLyBjb25uZWN0cyBub2JsZS1jdXJ2ZXMgdG8gbm9ibGUtaGFzaGVzXG5mdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBoYXNoLFxuICAgICAgICBobWFjOiAoa2V5LCAuLi5tc2dzKSA9PiAoMCwgaG1hY18xLmhtYWMpKGhhc2gsIGtleSwgKDAsIHV0aWxzXzEuY29uY2F0Qnl0ZXMpKC4uLm1zZ3MpKSxcbiAgICAgICAgcmFuZG9tQnl0ZXM6IHV0aWxzXzEucmFuZG9tQnl0ZXMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUN1cnZlKGN1cnZlRGVmLCBkZWZIYXNoKSB7XG4gICAgY29uc3QgY3JlYXRlID0gKGhhc2gpID0+ICgwLCB3ZWllcnN0cmFzc19qc18xLndlaWVyc3RyYXNzKSh7IC4uLmN1cnZlRGVmLCAuLi5nZXRIYXNoKGhhc2gpIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4uY3JlYXRlKGRlZkhhc2gpLCBjcmVhdGUgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hvcnR3X3V0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbmNvZGVUb0N1cnZlID0gZXhwb3J0cy5oYXNoVG9DdXJ2ZSA9IGV4cG9ydHMuc2Nobm9yciA9IGV4cG9ydHMuc2VjcDI1NmsxID0gdm9pZCAwO1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuY29uc3Qgc2hhMjU2XzEgPSByZXF1aXJlKFwiQG5vYmxlL2hhc2hlcy9zaGEyNTZcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvdXRpbHNcIik7XG5jb25zdCBfc2hvcnR3X3V0aWxzX2pzXzEgPSByZXF1aXJlKFwiLi9fc2hvcnR3X3V0aWxzLmpzXCIpO1xuY29uc3QgaGFzaF90b19jdXJ2ZV9qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qc1wiKTtcbmNvbnN0IG1vZHVsYXJfanNfMSA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0L21vZHVsYXIuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3QvdXRpbHMuanNcIik7XG5jb25zdCB3ZWllcnN0cmFzc19qc18xID0gcmVxdWlyZShcIi4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanNcIik7XG5jb25zdCBzZWNwMjU2azFQID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnKTtcbmNvbnN0IHNlY3AyNTZrMU4gPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScpO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgZGl2TmVhcmVzdCA9IChhLCBiKSA9PiAoYSArIGIgLyBfMm4pIC8gYjtcbi8qKlxuICog4oiabiA9IG5eKChwKzEpLzQpIGZvciBmaWVsZHMgcCA9IDMgbW9kIDQuIFdlIHVud3JhcCB0aGUgbG9vcCBhbmQgbXVsdGlwbHkgYml0LWJ5LWJpdC5cbiAqIChQKzFuLzRuKS50b1N0cmluZygyKSB3b3VsZCBwcm9kdWNlIGJpdHMgWzIyM3ggMSwgMCwgMjJ4IDEsIDR4IDAsIDExLCAwMF1cbiAqL1xuZnVuY3Rpb24gc3FydE1vZCh5KSB7XG4gICAgY29uc3QgUCA9IHNlY3AyNTZrMVA7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzNuID0gQmlnSW50KDMpLCBfNm4gPSBCaWdJbnQoNiksIF8xMW4gPSBCaWdJbnQoMTEpLCBfMjJuID0gQmlnSW50KDIyKTtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfMjNuID0gQmlnSW50KDIzKSwgXzQ0biA9IEJpZ0ludCg0NCksIF84OG4gPSBCaWdJbnQoODgpO1xuICAgIGNvbnN0IGIyID0gKHkgKiB5ICogeSkgJSBQOyAvLyB4XjMsIDExXG4gICAgY29uc3QgYjMgPSAoYjIgKiBiMiAqIHkpICUgUDsgLy8geF43XG4gICAgY29uc3QgYjYgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMywgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjkgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiNiwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjExID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjksIF8ybiwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IGIyMiA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGIxMSwgXzExbiwgUCkgKiBiMTEpICUgUDtcbiAgICBjb25zdCBiNDQgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiMjIsIF8yMm4sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgYjg4ID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjQ0LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIxNzYgPSAoKDAsIG1vZHVsYXJfanNfMS5wb3cyKShiODgsIF84OG4sIFApICogYjg4KSAlIFA7XG4gICAgY29uc3QgYjIyMCA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGIxNzYsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjIyMyA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKGIyMjAsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IHQxID0gKCgwLCBtb2R1bGFyX2pzXzEucG93MikoYjIyMywgXzIzbiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCB0MiA9ICgoMCwgbW9kdWxhcl9qc18xLnBvdzIpKHQxLCBfNm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCByb290ID0gKDAsIG1vZHVsYXJfanNfMS5wb3cyKSh0MiwgXzJuLCBQKTtcbiAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG5jb25zdCBGcCA9ICgwLCBtb2R1bGFyX2pzXzEuRmllbGQpKHNlY3AyNTZrMVAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IHNxcnQ6IHNxcnRNb2QgfSk7XG4vKipcbiAqIHNlY3AyNTZrMSBzaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBhbmQgRUNEU0Egc2lnbmF0dXJlcyBvdmVyIGl0LlxuICovXG5leHBvcnRzLnNlY3AyNTZrMSA9ICgwLCBfc2hvcnR3X3V0aWxzX2pzXzEuY3JlYXRlQ3VydmUpKHtcbiAgICBhOiBCaWdJbnQoMCksIC8vIGVxdWF0aW9uIHBhcmFtczogYSwgYlxuICAgIGI6IEJpZ0ludCg3KSwgLy8gU2VlbSB0byBiZSByaWdpZDogYml0Y29pbnRhbGsub3JnL2luZGV4LnBocD90b3BpYz0yODk3OTUubXNnMzE4Mzk3NSNtc2czMTgzOTc1XG4gICAgRnAsIC8vIEZpZWxkJ3MgcHJpbWU6IDJuKioyNTZuIC0gMm4qKjMybiAtIDJuKio5biAtIDJuKio4biAtIDJuKio3biAtIDJuKio2biAtIDJuKio0biAtIDFuXG4gICAgbjogc2VjcDI1NmsxTiwgLy8gQ3VydmUgb3JkZXIsIHRvdGFsIGNvdW50IG9mIHZhbGlkIHBvaW50cyBpbiB0aGUgZmllbGRcbiAgICAvLyBCYXNlIHBvaW50ICh4LCB5KSBha2EgZ2VuZXJhdG9yIHBvaW50XG4gICAgR3g6IEJpZ0ludCgnNTUwNjYyNjMwMjIyNzczNDM2Njk1Nzg3MTg4OTUxNjg1MzQzMjYyNTA2MDM0NTM3Nzc1OTQxNzU1MDAxODczNjAzODkxMTY3MjkyNDAnKSxcbiAgICBHeTogQmlnSW50KCczMjY3MDUxMDAyMDc1ODgxNjk3ODA4MzA4NTEzMDUwNzA0MzE4NDQ3MTI3MzM4MDY1OTI0MzI3NTkzODkwNDMzNTc1NzMzNzQ4MjQyNCcpLFxuICAgIGg6IEJpZ0ludCgxKSwgLy8gQ29mYWN0b3JcbiAgICBsb3dTOiB0cnVlLCAvLyBBbGxvdyBvbmx5IGxvdy1TIHNpZ25hdHVyZXMgYnkgZGVmYXVsdCBpbiBzaWduKCkgYW5kIHZlcmlmeSgpXG4gICAgLyoqXG4gICAgICogc2VjcDI1NmsxIGJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseSBjb21wdXRhYmxlIGVuZG9tb3JwaGlzbS5cbiAgICAgKiBFbmRvbW9ycGhpc20gdXNlcyAyeCBsZXNzIFJBTSwgc3BlZWRzIHVwIHByZWNvbXB1dGF0aW9uIGJ5IDJ4IGFuZCBFQ0RIIC8ga2V5IHJlY292ZXJ5IGJ5IDIwJS5cbiAgICAgKiBGb3IgcHJlY29tcHV0ZWQgd05BRiBpdCB0cmFkZXMgb2ZmIDEvMiBpbml0IHRpbWUgJiAxLzMgcmFtIGZvciAyMCUgcGVyZiBoaXQuXG4gICAgICogRXhwbGFuYXRpb246IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxtaWxsci9lYjY3MDgwNjc5M2U4NGRmNjI4YTdjNDM0YTg3MzA2NlxuICAgICAqL1xuICAgIGVuZG86IHtcbiAgICAgICAgYmV0YTogQmlnSW50KCcweDdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnKSxcbiAgICAgICAgc3BsaXRTY2FsYXI6IChrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuID0gc2VjcDI1NmsxTjtcbiAgICAgICAgICAgIGNvbnN0IGExID0gQmlnSW50KCcweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyk7XG4gICAgICAgICAgICBjb25zdCBiMSA9IC1fMW4gKiBCaWdJbnQoJzB4ZTQ0MzdlZDYwMTBlODgyODZmNTQ3ZmE5MGFiZmU0YzMnKTtcbiAgICAgICAgICAgIGNvbnN0IGEyID0gQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpO1xuICAgICAgICAgICAgY29uc3QgYjIgPSBhMTtcbiAgICAgICAgICAgIGNvbnN0IFBPV18yXzEyOCA9IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnKTsgLy8gKDJuKioxMjhuKS50b1N0cmluZygxNilcbiAgICAgICAgICAgIGNvbnN0IGMxID0gZGl2TmVhcmVzdChiMiAqIGssIG4pO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgICAgICAgICAgbGV0IGsxID0gKDAsIG1vZHVsYXJfanNfMS5tb2QpKGsgLSBjMSAqIGExIC0gYzIgKiBhMiwgbik7XG4gICAgICAgICAgICBsZXQgazIgPSAoMCwgbW9kdWxhcl9qc18xLm1vZCkoLWMxICogYjEgLSBjMiAqIGIyLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGsxbmVnID0gazEgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBjb25zdCBrMm5lZyA9IGsyID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgaWYgKGsxbmVnKVxuICAgICAgICAgICAgICAgIGsxID0gbiAtIGsxO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsyID0gbiAtIGsyO1xuICAgICAgICAgICAgaWYgKGsxID4gUE9XXzJfMTI4IHx8IGsyID4gUE9XXzJfMTI4KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhcjogRW5kb21vcnBoaXNtIGZhaWxlZCwgaz0nICsgayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBrMW5lZywgazEsIGsybmVnLCBrMiB9O1xuICAgICAgICB9LFxuICAgIH0sXG59LCBzaGEyNTZfMS5zaGEyNTYpO1xuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG4vKiogQW4gb2JqZWN0IG1hcHBpbmcgdGFncyB0byB0aGVpciB0YWdnZWQgaGFzaCBwcmVmaXggb2YgW1NIQTI1Nih0YWcpIHwgU0hBMjU2KHRhZyldICovXG5jb25zdCBUQUdHRURfSEFTSF9QUkVGSVhFUyA9IHt9O1xuZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWcsIC4uLm1lc3NhZ2VzKSB7XG4gICAgbGV0IHRhZ1AgPSBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddO1xuICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFnSCA9ICgwLCBzaGEyNTZfMS5zaGEyNTYpKFVpbnQ4QXJyYXkuZnJvbSh0YWcsIChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbiAgICAgICAgdGFnUCA9ICgwLCB1dGlsc19qc18xLmNvbmNhdEJ5dGVzKSh0YWdILCB0YWdIKTtcbiAgICAgICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XG4gICAgfVxuICAgIHJldHVybiAoMCwgc2hhMjU2XzEuc2hhMjU2KSgoMCwgdXRpbHNfanNfMS5jb25jYXRCeXRlcykodGFnUCwgLi4ubWVzc2FnZXMpKTtcbn1cbi8vIEVDRFNBIGNvbXBhY3QgcG9pbnRzIGFyZSAzMy1ieXRlLiBTY2hub3JyIGlzIDMyOiB3ZSBzdHJpcCBmaXJzdCBieXRlIDB4MDIgb3IgMHgwM1xuY29uc3QgcG9pbnRUb0J5dGVzID0gKHBvaW50KSA9PiBwb2ludC50b1Jhd0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuY29uc3QgbnVtVG8zMmIgPSAobikgPT4gKDAsIHV0aWxzX2pzXzEubnVtYmVyVG9CeXRlc0JFKShuLCAzMik7XG5jb25zdCBtb2RQID0gKHgpID0+ICgwLCBtb2R1bGFyX2pzXzEubW9kKSh4LCBzZWNwMjU2azFQKTtcbmNvbnN0IG1vZE4gPSAoeCkgPT4gKDAsIG1vZHVsYXJfanNfMS5tb2QpKHgsIHNlY3AyNTZrMU4pO1xuY29uc3QgUG9pbnQgPSBleHBvcnRzLnNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQ7XG5jb25zdCBHbXVsQWRkID0gKFEsIGEsIGIpID0+IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYik7XG4vLyBDYWxjdWxhdGUgcG9pbnQsIHNjYWxhciBhbmQgYnl0ZXNcbmZ1bmN0aW9uIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdikge1xuICAgIGxldCBkXyA9IGV4cG9ydHMuc2VjcDI1NmsxLnV0aWxzLm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdik7IC8vIHNhbWUgbWV0aG9kIGV4ZWN1dGVkIGluIGZyb21Qcml2YXRlS2V5XG4gICAgbGV0IHAgPSBQb2ludC5mcm9tUHJpdmF0ZUtleShkXyk7IC8vIFAgPSBkJ+KLhUc7IDAgPCBkJyA8IG4gY2hlY2sgaXMgZG9uZSBpbnNpZGVcbiAgICBjb25zdCBzY2FsYXIgPSBwLmhhc0V2ZW5ZKCkgPyBkXyA6IG1vZE4oLWRfKTtcbiAgICByZXR1cm4geyBzY2FsYXI6IHNjYWxhciwgYnl0ZXM6IHBvaW50VG9CeXRlcyhwKSB9O1xufVxuLyoqXG4gKiBsaWZ0X3ggZnJvbSBCSVAzNDAuIENvbnZlcnQgMzItYnl0ZSB4IGNvb3JkaW5hdGUgdG8gZWxsaXB0aWMgY3VydmUgcG9pbnQuXG4gKiBAcmV0dXJucyB2YWxpZCBwb2ludCBjaGVja2VkIGZvciBiZWluZyBvbi1jdXJ2ZVxuICovXG5mdW5jdGlvbiBsaWZ0X3goeCkge1xuICAgICgwLCB1dGlsc19qc18xLmFJblJhbmdlKSgneCcsIHgsIF8xbiwgc2VjcDI1NmsxUCk7IC8vIEZhaWwgaWYgeCDiiaUgcC5cbiAgICBjb25zdCB4eCA9IG1vZFAoeCAqIHgpO1xuICAgIGNvbnN0IGMgPSBtb2RQKHh4ICogeCArIEJpZ0ludCg3KSk7IC8vIExldCBjID0geMKzICsgNyBtb2QgcC5cbiAgICBsZXQgeSA9IHNxcnRNb2QoYyk7IC8vIExldCB5ID0gY14ocCsxKS80IG1vZCBwLlxuICAgIGlmICh5ICUgXzJuICE9PSBfMG4pXG4gICAgICAgIHkgPSBtb2RQKC15KTsgLy8gUmV0dXJuIHRoZSB1bmlxdWUgcG9pbnQgUCBzdWNoIHRoYXQgeChQKSA9IHggYW5kXG4gICAgY29uc3QgcCA9IG5ldyBQb2ludCh4LCB5LCBfMW4pOyAvLyB5KFApID0geSBpZiB5IG1vZCAyID0gMCBvciB5KFApID0gcC15IG90aGVyd2lzZS5cbiAgICBwLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgcmV0dXJuIHA7XG59XG5jb25zdCBudW0gPSB1dGlsc19qc18xLmJ5dGVzVG9OdW1iZXJCRTtcbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBtb2ROKG51bSh0YWdnZWRIYXNoKCdCSVAwMzQwL2NoYWxsZW5nZScsIC4uLmFyZ3MpKSk7XG59XG4vKipcbiAqIFNjaG5vcnIgcHVibGljIGtleSBpcyBqdXN0IGB4YCBjb29yZGluYXRlIG9mIFBvaW50IGFzIHBlciBCSVAzNDAuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJHZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpLmJ5dGVzOyAvLyBkJz1pbnQoc2spLiBGYWlsIGlmIGQnPTAgb3IgZCfiiaVuLiBSZXQgYnl0ZXMoZCfii4VHKVxufVxuLyoqXG4gKiBDcmVhdGVzIFNjaG5vcnIgc2lnbmF0dXJlIGFzIHBlciBCSVAzNDAuIFZlcmlmaWVzIGl0c2VsZiBiZWZvcmUgcmV0dXJuaW5nIGFueXRoaW5nLlxuICogYXV4UmFuZCBpcyBvcHRpb25hbCBhbmQgaXMgbm90IHRoZSBzb2xlIHNvdXJjZSBvZiBrIGdlbmVyYXRpb246IGJhZCBDU1BSTkcgd29uJ3QgYmUgZGFuZ2Vyb3VzLlxuICovXG5mdW5jdGlvbiBzY2hub3JyU2lnbihtZXNzYWdlLCBwcml2YXRlS2V5LCBhdXhSYW5kID0gKDAsIHV0aWxzXzEucmFuZG9tQnl0ZXMpKDMyKSkge1xuICAgIGNvbnN0IG0gPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ2F1eFJhbmQnLCBhdXhSYW5kLCAzMik7IC8vIEF1eGlsaWFyeSByYW5kb20gZGF0YSBhOiBhIDMyLWJ5dGUgYXJyYXlcbiAgICBjb25zdCB0ID0gbnVtVG8zMmIoZCBeIG51bSh0YWdnZWRIYXNoKCdCSVAwMzQwL2F1eCcsIGEpKSk7IC8vIExldCB0IGJlIHRoZSBieXRlLXdpc2UgeG9yIG9mIGJ5dGVzKGQpIGFuZCBoYXNoL2F1eChhKVxuICAgIGNvbnN0IHJhbmQgPSB0YWdnZWRIYXNoKCdCSVAwMzQwL25vbmNlJywgdCwgcHgsIG0pOyAvLyBMZXQgcmFuZCA9IGhhc2gvbm9uY2UodCB8fCBieXRlcyhQKSB8fCBtKVxuICAgIGNvbnN0IGtfID0gbW9kTihudW0ocmFuZCkpOyAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG5cbiAgICBpZiAoa18gPT09IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduIGZhaWxlZDogayBpcyB6ZXJvJyk7IC8vIEZhaWwgaWYgaycgPSAwLlxuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkoa18pOyAvLyBMZXQgUiA9IGsn4ouFRy5cbiAgICBjb25zdCBlID0gY2hhbGxlbmdlKHJ4LCBweCwgbSk7IC8vIExldCBlID0gaW50KGhhc2gvY2hhbGxlbmdlKGJ5dGVzKFIpIHx8IGJ5dGVzKFApIHx8IG0pKSBtb2Qgbi5cbiAgICBjb25zdCBzaWcgPSBuZXcgVWludDhBcnJheSg2NCk7IC8vIExldCBzaWcgPSBieXRlcyhSKSB8fCBieXRlcygoayArIGVkKSBtb2QgbikuXG4gICAgc2lnLnNldChyeCwgMCk7XG4gICAgc2lnLnNldChudW1UbzMyYihtb2ROKGsgKyBlICogZCkpLCAzMik7XG4gICAgLy8gSWYgVmVyaWZ5KGJ5dGVzKFApLCBtLCBzaWcpIChzZWUgYmVsb3cpIHJldHVybnMgZmFpbHVyZSwgYWJvcnRcbiAgICBpZiAoIXNjaG5vcnJWZXJpZnkoc2lnLCBtLCBweCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbjogSW52YWxpZCBzaWduYXR1cmUgcHJvZHVjZWQnKTtcbiAgICByZXR1cm4gc2lnO1xufVxuLyoqXG4gKiBWZXJpZmllcyBTY2hub3JyIHNpZ25hdHVyZS5cbiAqIFdpbGwgc3dhbGxvdyBlcnJvcnMgJiByZXR1cm4gZmFsc2UgZXhjZXB0IGZvciBpbml0aWFsIHR5cGUgdmFsaWRhdGlvbiBvZiBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJWZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXkpIHtcbiAgICBjb25zdCBzaWcgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3NpZ25hdHVyZScsIHNpZ25hdHVyZSwgNjQpO1xuICAgIGNvbnN0IG0gPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCBwdWIgPSAoMCwgdXRpbHNfanNfMS5lbnN1cmVCeXRlcykoJ3B1YmxpY0tleScsIHB1YmxpY0tleSwgMzIpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFAgPSBsaWZ0X3gobnVtKHB1YikpOyAvLyBQID0gbGlmdF94KGludChwaykpOyBmYWlsIGlmIHRoYXQgZmFpbHNcbiAgICAgICAgY29uc3QgciA9IG51bShzaWcuc3ViYXJyYXkoMCwgMzIpKTsgLy8gTGV0IHIgPSBpbnQoc2lnWzA6MzJdKTsgZmFpbCBpZiByIOKJpSBwLlxuICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmluUmFuZ2UpKHIsIF8xbiwgc2VjcDI1NmsxUCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHMgPSBudW0oc2lnLnN1YmFycmF5KDMyLCA2NCkpOyAvLyBMZXQgcyA9IGludChzaWdbMzI6NjRdKTsgZmFpbCBpZiBzIOKJpSBuLlxuICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmluUmFuZ2UpKHMsIF8xbiwgc2VjcDI1NmsxTikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UobnVtVG8zMmIociksIHBvaW50VG9CeXRlcyhQKSwgbSk7IC8vIGludChjaGFsbGVuZ2UoYnl0ZXMocil8fGJ5dGVzKFApfHxtKSklblxuICAgICAgICBjb25zdCBSID0gR211bEFkZChQLCBzLCBtb2ROKC1lKSk7IC8vIFIgPSBz4ouFRyAtIGXii4VQXG4gICAgICAgIGlmICghUiB8fCAhUi5oYXNFdmVuWSgpIHx8IFIudG9BZmZpbmUoKS54ICE9PSByKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyAtZVAgPT0gKG4tZSlQXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBGYWlsIGlmIGlzX2luZmluaXRlKFIpIC8gbm90IGhhc19ldmVuX3koUikgLyB4KFIpIOKJoCByLlxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogU2Nobm9yciBzaWduYXR1cmVzIG92ZXIgc2VjcDI1NmsxLlxuICovXG5leHBvcnRzLnNjaG5vcnIgPSAoKCkgPT4gKHtcbiAgICBnZXRQdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXksXG4gICAgc2lnbjogc2Nobm9yclNpZ24sXG4gICAgdmVyaWZ5OiBzY2hub3JyVmVyaWZ5LFxuICAgIHV0aWxzOiB7XG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IGV4cG9ydHMuc2VjcDI1NmsxLnV0aWxzLnJhbmRvbVByaXZhdGVLZXksXG4gICAgICAgIGxpZnRfeCxcbiAgICAgICAgcG9pbnRUb0J5dGVzLFxuICAgICAgICBudW1iZXJUb0J5dGVzQkU6IHV0aWxzX2pzXzEubnVtYmVyVG9CeXRlc0JFLFxuICAgICAgICBieXRlc1RvTnVtYmVyQkU6IHV0aWxzX2pzXzEuYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2Q6IG1vZHVsYXJfanNfMS5tb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoMCwgaGFzaF90b19jdXJ2ZV9qc18xLmlzb2dlbnlNYXApKEZwLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiAoMCwgd2VpZXJzdHJhc3NfanNfMS5tYXBUb0N1cnZlU2ltcGxlU1dVKShGcCwge1xuICAgIEE6IEJpZ0ludCgnMHgzZjg3MzFhYmRkNjYxYWRjYTA4YTU1NThmMGY1ZDI3MmU5NTNkMzYzY2I2ZjBlNWQ0MDU0NDdjMDFhNDQ0NTMzJyksXG4gICAgQjogQmlnSW50KCcxNzcxJyksXG4gICAgWjogRnAuY3JlYXRlKEJpZ0ludCgnLTExJykpLFxufSkpKCk7XG5jb25zdCBodGYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICgwLCBoYXNoX3RvX2N1cnZlX2pzXzEuY3JlYXRlSGFzaGVyKShleHBvcnRzLnNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnAuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1Nl8xLnNoYTI1Nixcbn0pKSgpO1xuZXhwb3J0cy5oYXNoVG9DdXJ2ZSA9ICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnRzLmVuY29kZVRvQ3VydmUgPSAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZWNwMjU2azEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZUhleCA9IGV4cG9ydHMucmVtb3ZlMHggPSB2b2lkIDA7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvY2lwaGVycy91dGlsc1wiKTtcbnZhciByZW1vdmUweCA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICByZXR1cm4gaGV4LnN0YXJ0c1dpdGgoXCIweFwiKSB8fCBoZXguc3RhcnRzV2l0aChcIjBYXCIpID8gaGV4LnNsaWNlKDIpIDogaGV4O1xufTtcbmV4cG9ydHMucmVtb3ZlMHggPSByZW1vdmUweDtcbnZhciBkZWNvZGVIZXggPSBmdW5jdGlvbiAoaGV4KSB7IHJldHVybiAoMCwgdXRpbHNfMS5oZXhUb0J5dGVzKSgoMCwgZXhwb3J0cy5yZW1vdmUweCkoaGV4KSk7IH07XG5leHBvcnRzLmRlY29kZUhleCA9IGRlY29kZUhleDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oZXhUb1B1YmxpY0tleSA9IGV4cG9ydHMuY29udmVydFB1YmxpY0tleUZvcm1hdCA9IGV4cG9ydHMuZ2V0U2hhcmVkUG9pbnQgPSBleHBvcnRzLmdldFB1YmxpY0tleSA9IGV4cG9ydHMuaXNWYWxpZFByaXZhdGVLZXkgPSBleHBvcnRzLmdldFZhbGlkU2VjcmV0ID0gdm9pZCAwO1xudmFyIHdlYmNyeXB0b18xID0gcmVxdWlyZShcIkBub2JsZS9jaXBoZXJzL3dlYmNyeXB0b1wiKTtcbnZhciBlZDI1NTE5XzEgPSByZXF1aXJlKFwiQG5vYmxlL2N1cnZlcy9lZDI1NTE5XCIpO1xudmFyIHNlY3AyNTZrMV8xID0gcmVxdWlyZShcIkBub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxXCIpO1xudmFyIGNvbmZpZ18xID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcbnZhciBjb25zdHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdHNcIik7XG52YXIgaGV4XzEgPSByZXF1aXJlKFwiLi9oZXhcIik7XG52YXIgZ2V0VmFsaWRTZWNyZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGtleTtcbiAgICBkbyB7XG4gICAgICAgIGtleSA9ICgwLCB3ZWJjcnlwdG9fMS5yYW5kb21CeXRlcykoY29uc3RzXzEuU0VDUkVUX0tFWV9MRU5HVEgpO1xuICAgIH0gd2hpbGUgKCEoMCwgZXhwb3J0cy5pc1ZhbGlkUHJpdmF0ZUtleSkoa2V5KSk7XG4gICAgcmV0dXJuIGtleTtcbn07XG5leHBvcnRzLmdldFZhbGlkU2VjcmV0ID0gZ2V0VmFsaWRTZWNyZXQ7XG52YXIgaXNWYWxpZFByaXZhdGVLZXkgPSBmdW5jdGlvbiAoc2VjcmV0KSB7XG4gICAgLy8gb24gc2VjcDI1NmsxOiBvbmx5IGtleSDiiIggKDAsIGdyb3VwIG9yZGVyKSBpcyB2YWxpZFxuICAgIC8vIG9uIGN1cnZlMjU1MTk6IGFueSAzMi1ieXRlIGtleSBpcyB2YWxpZFxuICAgIHJldHVybiBfZXhlYygoMCwgY29uZmlnXzEuZWxsaXB0aWNDdXJ2ZSkoKSwgZnVuY3Rpb24gKGN1cnZlKSB7IHJldHVybiBjdXJ2ZS51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleShzZWNyZXQpOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9KTtcbn07XG5leHBvcnRzLmlzVmFsaWRQcml2YXRlS2V5ID0gaXNWYWxpZFByaXZhdGVLZXk7XG52YXIgZ2V0UHVibGljS2V5ID0gZnVuY3Rpb24gKHNlY3JldCkge1xuICAgIHJldHVybiBfZXhlYygoMCwgY29uZmlnXzEuZWxsaXB0aWNDdXJ2ZSkoKSwgZnVuY3Rpb24gKGN1cnZlKSB7IHJldHVybiBjdXJ2ZS5nZXRQdWJsaWNLZXkoc2VjcmV0KTsgfSwgZnVuY3Rpb24gKGN1cnZlKSB7IHJldHVybiBjdXJ2ZS5nZXRQdWJsaWNLZXkoc2VjcmV0KTsgfSwgZnVuY3Rpb24gKGN1cnZlKSB7IHJldHVybiBjdXJ2ZS5nZXRQdWJsaWNLZXkoc2VjcmV0KTsgfSk7XG59O1xuZXhwb3J0cy5nZXRQdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXk7XG52YXIgZ2V0U2hhcmVkUG9pbnQgPSBmdW5jdGlvbiAoc2ssIHBrLCBjb21wcmVzc2VkKSB7XG4gICAgcmV0dXJuIF9leGVjKCgwLCBjb25maWdfMS5lbGxpcHRpY0N1cnZlKSgpLCBmdW5jdGlvbiAoY3VydmUpIHsgcmV0dXJuIGN1cnZlLmdldFNoYXJlZFNlY3JldChzaywgcGssIGNvbXByZXNzZWQpOyB9LCBmdW5jdGlvbiAoY3VydmUpIHsgcmV0dXJuIGN1cnZlLmdldFNoYXJlZFNlY3JldChzaywgcGspOyB9LCBmdW5jdGlvbiAoY3VydmUpIHsgcmV0dXJuIGdldFNoYXJlZFBvaW50T25FZDI1NTE5KGN1cnZlLCBzaywgcGspOyB9KTtcbn07XG5leHBvcnRzLmdldFNoYXJlZFBvaW50ID0gZ2V0U2hhcmVkUG9pbnQ7XG52YXIgY29udmVydFB1YmxpY0tleUZvcm1hdCA9IGZ1bmN0aW9uIChwaywgY29tcHJlc3NlZCkge1xuICAgIC8vIG9ubHkgZm9yIHNlY3AyNTZrMVxuICAgIHJldHVybiBfZXhlYygoMCwgY29uZmlnXzEuZWxsaXB0aWNDdXJ2ZSkoKSwgZnVuY3Rpb24gKGN1cnZlKSB7IHJldHVybiBjdXJ2ZS5nZXRTaGFyZWRTZWNyZXQoQmlnSW50KDEpLCBwaywgY29tcHJlc3NlZCk7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBrOyB9LCBmdW5jdGlvbiAoKSB7IHJldHVybiBwazsgfSk7XG59O1xuZXhwb3J0cy5jb252ZXJ0UHVibGljS2V5Rm9ybWF0ID0gY29udmVydFB1YmxpY0tleUZvcm1hdDtcbnZhciBoZXhUb1B1YmxpY0tleSA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICB2YXIgZGVjb2RlZCA9ICgwLCBoZXhfMS5kZWNvZGVIZXgpKGhleCk7XG4gICAgcmV0dXJuIF9leGVjKCgwLCBjb25maWdfMS5lbGxpcHRpY0N1cnZlKSgpLCBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wYXRFdGhQdWJsaWNLZXkoZGVjb2RlZCk7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZWQ7IH0sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRlY29kZWQ7IH0pO1xufTtcbmV4cG9ydHMuaGV4VG9QdWJsaWNLZXkgPSBoZXhUb1B1YmxpY0tleTtcbmZ1bmN0aW9uIF9leGVjKGN1cnZlLCBzZWNwMjU2azFDYWxsYmFjaywgeDI1NTE5Q2FsbGJhY2ssIGVkMjU1MTlDYWxsYmFjaykge1xuICAgIGlmIChjdXJ2ZSA9PT0gXCJzZWNwMjU2azFcIikge1xuICAgICAgICByZXR1cm4gc2VjcDI1NmsxQ2FsbGJhY2soc2VjcDI1NmsxXzEuc2VjcDI1NmsxKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3VydmUgPT09IFwieDI1NTE5XCIpIHtcbiAgICAgICAgcmV0dXJuIHgyNTUxOUNhbGxiYWNrKGVkMjU1MTlfMS54MjU1MTkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjdXJ2ZSA9PT0gXCJlZDI1NTE5XCIpIHtcbiAgICAgICAgcmV0dXJuIGVkMjU1MTlDYWxsYmFjayhlZDI1NTE5XzEuZWQyNTUxOSk7XG4gICAgfSAvKiB2OCBpZ25vcmUgbmV4dCAyICovXG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9XG59XG52YXIgY29tcGF0RXRoUHVibGljS2V5ID0gZnVuY3Rpb24gKHBrKSB7XG4gICAgaWYgKHBrLmxlbmd0aCA9PT0gY29uc3RzXzEuRVRIX1BVQkxJQ19LRVlfU0laRSkge1xuICAgICAgICB2YXIgZml4ZWQgPSBuZXcgVWludDhBcnJheSgxICsgcGsubGVuZ3RoKTtcbiAgICAgICAgZml4ZWQuc2V0KFsweDA0XSk7XG4gICAgICAgIGZpeGVkLnNldChwaywgMSk7XG4gICAgICAgIHJldHVybiBmaXhlZDtcbiAgICB9XG4gICAgcmV0dXJuIHBrO1xufTtcbnZhciBnZXRTaGFyZWRQb2ludE9uRWQyNTUxOSA9IGZ1bmN0aW9uIChjdXJ2ZSwgc2ssIHBrKSB7XG4gICAgLy8gTm90ZTogc2NhbGFyIGlzIGhhc2hlZCBmcm9tIHNrXG4gICAgdmFyIHNjYWxhciA9IGN1cnZlLnV0aWxzLmdldEV4dGVuZGVkUHVibGljS2V5KHNrKS5zY2FsYXI7XG4gICAgdmFyIHBvaW50ID0gY3VydmUuRXh0ZW5kZWRQb2ludC5mcm9tSGV4KHBrKS5tdWx0aXBseShzY2FsYXIpO1xuICAgIHJldHVybiBwb2ludC50b1Jhd0J5dGVzKCk7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhrZGYgPSB2b2lkIDA7XG5leHBvcnRzLmV4dHJhY3QgPSBleHRyYWN0O1xuZXhwb3J0cy5leHBhbmQgPSBleHBhbmQ7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuY29uc3QgaG1hY19qc18xID0gcmVxdWlyZShcIi4vaG1hYy5qc1wiKTtcbi8vIEhLREYgKFJGQyA1ODY5KVxuLy8gaHR0cHM6Ly9zb2F0b2suYmxvZy8yMDIxLzExLzE3L3VuZGVyc3RhbmRpbmctaGtkZi9cbi8qKlxuICogSEtERi1FeHRyYWN0KElLTSwgc2FsdCkgLT4gUFJLXG4gKiBBcmd1bWVudHMgcG9zaXRpb24gZGlmZmVycyBmcm9tIHNwZWMgKElLTSBpcyBmaXJzdCBvbmUsIHNpbmNlIGl0IGlzIG5vdCBvcHRpb25hbClcbiAqIEBwYXJhbSBoYXNoXG4gKiBAcGFyYW0gaWttXG4gKiBAcGFyYW0gc2FsdFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZXh0cmFjdChoYXNoLCBpa20sIHNhbHQpIHtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmhhc2gpKGhhc2gpO1xuICAgIC8vIE5PVEU6IHNvbWUgbGlicmFyaWVzIHRyZWF0IHplcm8tbGVuZ3RoIGFycmF5IGFzICdub3QgcHJvdmlkZWQnO1xuICAgIC8vIHdlIGRvbid0LCBzaW5jZSB3ZSBoYXZlIHVuZGVmaW5lZCBhcyAnbm90IHByb3ZpZGVkJ1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9SdXN0Q3J5cHRvL0tERnMvaXNzdWVzLzE1XG4gICAgaWYgKHNhbHQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgc2FsdCA9IG5ldyBVaW50OEFycmF5KGhhc2gub3V0cHV0TGVuKTsgLy8gaWYgbm90IHByb3ZpZGVkLCBpdCBpcyBzZXQgdG8gYSBzdHJpbmcgb2YgSGFzaExlbiB6ZXJvc1xuICAgIHJldHVybiAoMCwgaG1hY19qc18xLmhtYWMpKGhhc2gsICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKHNhbHQpLCAoMCwgdXRpbHNfanNfMS50b0J5dGVzKShpa20pKTtcbn1cbi8vIEhLREYtRXhwYW5kKFBSSywgaW5mbywgTCkgLT4gT0tNXG5jb25zdCBIS0RGX0NPVU5URVIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQ4QXJyYXkoWzBdKTtcbmNvbnN0IEVNUFRZX0JVRkZFUiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDhBcnJheSgpO1xuLyoqXG4gKiBIS0RGLWV4cGFuZCBmcm9tIHRoZSBzcGVjLlxuICogQHBhcmFtIHByayAtIGEgcHNldWRvcmFuZG9tIGtleSBvZiBhdCBsZWFzdCBIYXNoTGVuIG9jdGV0cyAodXN1YWxseSwgdGhlIG91dHB1dCBmcm9tIHRoZSBleHRyYWN0IHN0ZXApXG4gKiBAcGFyYW0gaW5mbyAtIG9wdGlvbmFsIGNvbnRleHQgYW5kIGFwcGxpY2F0aW9uIHNwZWNpZmljIGluZm9ybWF0aW9uIChjYW4gYmUgYSB6ZXJvLWxlbmd0aCBzdHJpbmcpXG4gKiBAcGFyYW0gbGVuZ3RoIC0gbGVuZ3RoIG9mIG91dHB1dCBrZXlpbmcgbWF0ZXJpYWwgaW4gb2N0ZXRzXG4gKi9cbmZ1bmN0aW9uIGV4cGFuZChoYXNoLCBwcmssIGluZm8sIGxlbmd0aCA9IDMyKSB7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5oYXNoKShoYXNoKTtcbiAgICAoMCwgX2Fzc2VydF9qc18xLm51bWJlcikobGVuZ3RoKTtcbiAgICBpZiAobGVuZ3RoID4gMjU1ICogaGFzaC5vdXRwdXRMZW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGVuZ3RoIHNob3VsZCBiZSA8PSAyNTUqSGFzaExlbicpO1xuICAgIGNvbnN0IGJsb2NrcyA9IE1hdGguY2VpbChsZW5ndGggLyBoYXNoLm91dHB1dExlbik7XG4gICAgaWYgKGluZm8gPT09IHVuZGVmaW5lZClcbiAgICAgICAgaW5mbyA9IEVNUFRZX0JVRkZFUjtcbiAgICAvLyBmaXJzdCBMKGVuZ3RoKSBvY3RldHMgb2YgVFxuICAgIGNvbnN0IG9rbSA9IG5ldyBVaW50OEFycmF5KGJsb2NrcyAqIGhhc2gub3V0cHV0TGVuKTtcbiAgICAvLyBSZS11c2UgSE1BQyBpbnN0YW5jZSBiZXR3ZWVuIGJsb2Nrc1xuICAgIGNvbnN0IEhNQUMgPSBobWFjX2pzXzEuaG1hYy5jcmVhdGUoaGFzaCwgcHJrKTtcbiAgICBjb25zdCBITUFDVG1wID0gSE1BQy5fY2xvbmVJbnRvKCk7XG4gICAgY29uc3QgVCA9IG5ldyBVaW50OEFycmF5KEhNQUMub3V0cHV0TGVuKTtcbiAgICBmb3IgKGxldCBjb3VudGVyID0gMDsgY291bnRlciA8IGJsb2NrczsgY291bnRlcisrKSB7XG4gICAgICAgIEhLREZfQ09VTlRFUlswXSA9IGNvdW50ZXIgKyAxO1xuICAgICAgICAvLyBUKDApID0gZW1wdHkgc3RyaW5nICh6ZXJvIGxlbmd0aClcbiAgICAgICAgLy8gVChOKSA9IEhNQUMtSGFzaChQUkssIFQoTi0xKSB8IGluZm8gfCBOKVxuICAgICAgICBITUFDVG1wLnVwZGF0ZShjb3VudGVyID09PSAwID8gRU1QVFlfQlVGRkVSIDogVClcbiAgICAgICAgICAgIC51cGRhdGUoaW5mbylcbiAgICAgICAgICAgIC51cGRhdGUoSEtERl9DT1VOVEVSKVxuICAgICAgICAgICAgLmRpZ2VzdEludG8oVCk7XG4gICAgICAgIG9rbS5zZXQoVCwgaGFzaC5vdXRwdXRMZW4gKiBjb3VudGVyKTtcbiAgICAgICAgSE1BQy5fY2xvbmVJbnRvKEhNQUNUbXApO1xuICAgIH1cbiAgICBITUFDLmRlc3Ryb3koKTtcbiAgICBITUFDVG1wLmRlc3Ryb3koKTtcbiAgICBULmZpbGwoMCk7XG4gICAgSEtERl9DT1VOVEVSLmZpbGwoMCk7XG4gICAgcmV0dXJuIG9rbS5zbGljZSgwLCBsZW5ndGgpO1xufVxuLyoqXG4gKiBIS0RGIChSRkMgNTg2OSk6IGV4dHJhY3QgKyBleHBhbmQgaW4gb25lIHN0ZXAuXG4gKiBAcGFyYW0gaGFzaCAtIGhhc2ggZnVuY3Rpb24gdGhhdCB3b3VsZCBiZSB1c2VkIChlLmcuIHNoYTI1NilcbiAqIEBwYXJhbSBpa20gLSBpbnB1dCBrZXlpbmcgbWF0ZXJpYWwsIHRoZSBpbml0aWFsIGtleVxuICogQHBhcmFtIHNhbHQgLSBvcHRpb25hbCBzYWx0IHZhbHVlIChhIG5vbi1zZWNyZXQgcmFuZG9tIHZhbHVlKVxuICogQHBhcmFtIGluZm8gLSBvcHRpb25hbCBjb250ZXh0IGFuZCBhcHBsaWNhdGlvbiBzcGVjaWZpYyBpbmZvcm1hdGlvblxuICogQHBhcmFtIGxlbmd0aCAtIGxlbmd0aCBvZiBvdXRwdXQga2V5aW5nIG1hdGVyaWFsIGluIG9jdGV0c1xuICovXG5jb25zdCBoa2RmID0gKGhhc2gsIGlrbSwgc2FsdCwgaW5mbywgbGVuZ3RoKSA9PiBleHBhbmQoaGFzaCwgZXh0cmFjdChoYXNoLCBpa20sIHNhbHQpLCBpbmZvLCBsZW5ndGgpO1xuZXhwb3J0cy5oa2RmID0gaGtkZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhrZGYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFNoYXJlZEtleSA9IGV4cG9ydHMuZGVyaXZlS2V5ID0gdm9pZCAwO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2NpcGhlcnMvdXRpbHNcIik7XG52YXIgaGtkZl8xID0gcmVxdWlyZShcIkBub2JsZS9oYXNoZXMvaGtkZlwiKTtcbnZhciBzaGEyNTZfMSA9IHJlcXVpcmUoXCJAbm9ibGUvaGFzaGVzL3NoYTI1NlwiKTtcbnZhciBkZXJpdmVLZXkgPSBmdW5jdGlvbiAobWFzdGVyLCBzYWx0LCBpbmZvKSB7XG4gICAgLy8gMzIgYnl0ZXMgc2hhcmVkIHNlY3JldCBmb3IgYWVzMjU2IGFuZCB4Y2hhY2hhMjAgZGVyaXZlZCBmcm9tIEhLREYtU0hBMjU2XG4gICAgcmV0dXJuICgwLCBoa2RmXzEuaGtkZikoc2hhMjU2XzEuc2hhMjU2LCBtYXN0ZXIsIHNhbHQsIGluZm8sIDMyKTtcbn07XG5leHBvcnRzLmRlcml2ZUtleSA9IGRlcml2ZUtleTtcbnZhciBnZXRTaGFyZWRLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgcGFydHNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmRlcml2ZUtleSkodXRpbHNfMS5jb25jYXRCeXRlcy5hcHBseSh2b2lkIDAsIHBhcnRzKSk7XG59O1xuZXhwb3J0cy5nZXRTaGFyZWRLZXkgPSBnZXRTaGFyZWRLZXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucG9seXZhbCA9IGV4cG9ydHMuZ2hhc2ggPSB2b2lkIDA7XG5leHBvcnRzLl90b0dIQVNIS2V5ID0gX3RvR0hBU0hLZXk7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gR0hhc2ggZnJvbSBBRVMtR0NNIGFuZCBpdHMgbGl0dGxlLWVuZGlhbiBcIm1pcnJvciBpbWFnZVwiIFBvbHl2YWwgZnJvbSBBRVMtU0lWLlxuLy8gSW1wbGVtZW50ZWQgaW4gdGVybXMgb2YgR0hhc2ggd2l0aCBjb252ZXJzaW9uIGZ1bmN0aW9uIGZvciBrZXlzXG4vLyBHQ00gR0hBU0ggZnJvbSBOSVNUIFNQODAwLTM4ZCwgU0lWIGZyb20gUkZDIDg0NTIuXG4vLyBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvTGVnYWN5L1NQL25pc3RzcGVjaWFscHVibGljYXRpb244MDAtMzhkLnBkZlxuLy8gR0hBU0ggICBtb2R1bG86IHheMTI4ICsgeF43ICAgKyB4XjIgICArIHggICAgICsgMVxuLy8gUE9MWVZBTCBtb2R1bG86IHheMTI4ICsgeF4xMjcgKyB4XjEyNiArIHheMTIxICsgMVxuY29uc3QgQkxPQ0tfU0laRSA9IDE2O1xuLy8gVE9ETzogcmV3cml0ZVxuLy8gdGVtcG9yYXJ5IHBhZGRpbmcgYnVmZmVyXG5jb25zdCBaRVJPUzE2ID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50OEFycmF5KDE2KTtcbmNvbnN0IFpFUk9TMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKFpFUk9TMTYpO1xuY29uc3QgUE9MWSA9IDB4ZTE7IC8vIHYgPSAyKnYgJSBQT0xZXG4vLyB2ID0gMip2ICUgUE9MWVxuLy8gTk9URTogYmVjYXVzZSB4ICsgeCA9IDAgKGFkZC9zdWIgaXMgc2FtZSksIG11bDIoeCkgIT0geCt4XG4vLyBXZSBjYW4gbXVsdGlwbHkgYW55IG51bWJlciB1c2luZyBtb250Z29tZXJ5IGxhZGRlciBhbmQgdGhpcyBmdW5jdGlvbiAod29ya3MgYXMgZG91YmxlLCBhZGQgaXMgc2ltcGxlIHhvcilcbmNvbnN0IG11bDIgPSAoczAsIHMxLCBzMiwgczMpID0+IHtcbiAgICBjb25zdCBoaUJpdCA9IHMzICYgMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzMzogKHMyIDw8IDMxKSB8IChzMyA+Pj4gMSksXG4gICAgICAgIHMyOiAoczEgPDwgMzEpIHwgKHMyID4+PiAxKSxcbiAgICAgICAgczE6IChzMCA8PCAzMSkgfCAoczEgPj4+IDEpLFxuICAgICAgICBzMDogKHMwID4+PiAxKSBeICgoUE9MWSA8PCAyNCkgJiAtKGhpQml0ICYgMSkpLCAvLyByZWR1Y2UgJSBwb2x5XG4gICAgfTtcbn07XG5jb25zdCBzd2FwTEUgPSAobikgPT4gKCgobiA+Pj4gMCkgJiAweGZmKSA8PCAyNCkgfFxuICAgICgoKG4gPj4+IDgpICYgMHhmZikgPDwgMTYpIHxcbiAgICAoKChuID4+PiAxNikgJiAweGZmKSA8PCA4KSB8XG4gICAgKChuID4+PiAyNCkgJiAweGZmKSB8XG4gICAgMDtcbi8qKlxuICogYG11bFhfUE9MWVZBTChCeXRlUmV2ZXJzZShIKSlgIGZyb20gc3BlY1xuICogQHBhcmFtIGsgbXV0YXRlZCBpbiBwbGFjZVxuICovXG5mdW5jdGlvbiBfdG9HSEFTSEtleShrKSB7XG4gICAgay5yZXZlcnNlKCk7XG4gICAgY29uc3QgaGlCaXQgPSBrWzE1XSAmIDE7XG4gICAgLy8gayA+Pj0gMVxuICAgIGxldCBjYXJyeSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHQgPSBrW2ldO1xuICAgICAgICBrW2ldID0gKHQgPj4+IDEpIHwgY2Fycnk7XG4gICAgICAgIGNhcnJ5ID0gKHQgJiAxKSA8PCA3O1xuICAgIH1cbiAgICBrWzBdIF49IC1oaUJpdCAmIDB4ZTE7IC8vIGlmIChoaUJpdCkgbiBePSAweGUxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwO1xuICAgIHJldHVybiBrO1xufVxuY29uc3QgZXN0aW1hdGVXaW5kb3cgPSAoYnl0ZXMpID0+IHtcbiAgICBpZiAoYnl0ZXMgPiA2NCAqIDEwMjQpXG4gICAgICAgIHJldHVybiA4O1xuICAgIGlmIChieXRlcyA+IDEwMjQpXG4gICAgICAgIHJldHVybiA0O1xuICAgIHJldHVybiAyO1xufTtcbmNsYXNzIEdIQVNIIHtcbiAgICAvLyBXZSBzZWxlY3QgYml0cyBwZXIgd2luZG93IGFkYXB0aXZlbHkgYmFzZWQgb24gZXhwZWN0ZWRMZW5ndGhcbiAgICBjb25zdHJ1Y3RvcihrZXksIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBCTE9DS19TSVpFO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IEJMT0NLX1NJWkU7XG4gICAgICAgIHRoaXMuczAgPSAwO1xuICAgICAgICB0aGlzLnMxID0gMDtcbiAgICAgICAgdGhpcy5zMiA9IDA7XG4gICAgICAgIHRoaXMuczMgPSAwO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIGtleSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGtleSk7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGtleSwgMTYpO1xuICAgICAgICBjb25zdCBrVmlldyA9ICgwLCB1dGlsc19qc18xLmNyZWF0ZVZpZXcpKGtleSk7XG4gICAgICAgIGxldCBrMCA9IGtWaWV3LmdldFVpbnQzMigwLCBmYWxzZSk7XG4gICAgICAgIGxldCBrMSA9IGtWaWV3LmdldFVpbnQzMig0LCBmYWxzZSk7XG4gICAgICAgIGxldCBrMiA9IGtWaWV3LmdldFVpbnQzMig4LCBmYWxzZSk7XG4gICAgICAgIGxldCBrMyA9IGtWaWV3LmdldFVpbnQzMigxMiwgZmFsc2UpO1xuICAgICAgICAvLyBnZW5lcmF0ZSB0YWJsZSBvZiBkb3VibGVkIGtleXMgKGhhbGYgb2YgbW9udGdvbWVyeSBsYWRkZXIpXG4gICAgICAgIGNvbnN0IGRvdWJsZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjg7IGkrKykge1xuICAgICAgICAgICAgZG91Ymxlcy5wdXNoKHsgczA6IHN3YXBMRShrMCksIHMxOiBzd2FwTEUoazEpLCBzMjogc3dhcExFKGsyKSwgczM6IHN3YXBMRShrMykgfSk7XG4gICAgICAgICAgICAoeyBzMDogazAsIHMxOiBrMSwgczI6IGsyLCBzMzogazMgfSA9IG11bDIoazAsIGsxLCBrMiwgazMpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBXID0gZXN0aW1hdGVXaW5kb3coZXhwZWN0ZWRMZW5ndGggfHwgMTAyNCk7XG4gICAgICAgIGlmICghWzEsIDIsIDQsIDhdLmluY2x1ZGVzKFcpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBnaGFzaDogd3Jvbmcgd2luZG93IHNpemU9JHtXfSwgc2hvdWxkIGJlIDIsIDQgb3IgOGApO1xuICAgICAgICB0aGlzLlcgPSBXO1xuICAgICAgICBjb25zdCBiaXRzID0gMTI4OyAvLyBhbHdheXMgMTI4IGJpdHM7XG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSBiaXRzIC8gVztcbiAgICAgICAgY29uc3Qgd2luZG93U2l6ZSA9ICh0aGlzLndpbmRvd1NpemUgPSAyICoqIFcpO1xuICAgICAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgICAgICAvLyBDcmVhdGUgcHJlY29tcHV0ZSB0YWJsZSBmb3Igd2luZG93IG9mIFcgYml0c1xuICAgICAgICBmb3IgKGxldCB3ID0gMDsgdyA8IHdpbmRvd3M7IHcrKykge1xuICAgICAgICAgICAgLy8gdHJ1dGggdGFibGU6IDAwLCAwMSwgMTAsIDExXG4gICAgICAgICAgICBmb3IgKGxldCBieXRlID0gMDsgYnl0ZSA8IHdpbmRvd1NpemU7IGJ5dGUrKykge1xuICAgICAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgICAgIGxldCBzMCA9IDAsIHMxID0gMCwgczIgPSAwLCBzMyA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBXOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYml0ID0gKGJ5dGUgPj4+IChXIC0gaiAtIDEpKSAmIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYml0KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgczA6IGQwLCBzMTogZDEsIHMyOiBkMiwgczM6IGQzIH0gPSBkb3VibGVzW1cgKiB3ICsgal07XG4gICAgICAgICAgICAgICAgICAgIChzMCBePSBkMCksIChzMSBePSBkMSksIChzMiBePSBkMiksIChzMyBePSBkMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goeyBzMCwgczEsIHMyLCBzMyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnQgPSBpdGVtcztcbiAgICB9XG4gICAgX3VwZGF0ZUJsb2NrKHMwLCBzMSwgczIsIHMzKSB7XG4gICAgICAgIChzMCBePSB0aGlzLnMwKSwgKHMxIF49IHRoaXMuczEpLCAoczIgXj0gdGhpcy5zMiksIChzMyBePSB0aGlzLnMzKTtcbiAgICAgICAgY29uc3QgeyBXLCB0LCB3aW5kb3dTaXplIH0gPSB0aGlzO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IG8wID0gMCwgbzEgPSAwLCBvMiA9IDAsIG8zID0gMDtcbiAgICAgICAgY29uc3QgbWFzayA9ICgxIDw8IFcpIC0gMTsgLy8gMioqVyB3aWxsIGtpbGwgcGVyZm9ybWFuY2UuXG4gICAgICAgIGxldCB3ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBudW0gb2YgW3MwLCBzMSwgczIsIHMzXSkge1xuICAgICAgICAgICAgZm9yIChsZXQgYnl0ZVBvcyA9IDA7IGJ5dGVQb3MgPCA0OyBieXRlUG9zKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBieXRlID0gKG51bSA+Pj4gKDggKiBieXRlUG9zKSkgJiAweGZmO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGJpdFBvcyA9IDggLyBXIC0gMTsgYml0UG9zID49IDA7IGJpdFBvcy0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJpdCA9IChieXRlID4+PiAoVyAqIGJpdFBvcykpICYgbWFzaztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzMDogZTAsIHMxOiBlMSwgczI6IGUyLCBzMzogZTMgfSA9IHRbdyAqIHdpbmRvd1NpemUgKyBiaXRdO1xuICAgICAgICAgICAgICAgICAgICAobzAgXj0gZTApLCAobzEgXj0gZTEpLCAobzIgXj0gZTIpLCAobzMgXj0gZTMpO1xuICAgICAgICAgICAgICAgICAgICB3ICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuczAgPSBvMDtcbiAgICAgICAgdGhpcy5zMSA9IG8xO1xuICAgICAgICB0aGlzLnMyID0gbzI7XG4gICAgICAgIHRoaXMuczMgPSBvMztcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZGF0YSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGRhdGEpO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmV4aXN0cykodGhpcyk7XG4gICAgICAgIGNvbnN0IGIzMiA9ICgwLCB1dGlsc19qc18xLnUzMikoZGF0YSk7XG4gICAgICAgIGNvbnN0IGJsb2NrcyA9IE1hdGguZmxvb3IoZGF0YS5sZW5ndGggLyBCTE9DS19TSVpFKTtcbiAgICAgICAgY29uc3QgbGVmdCA9IGRhdGEubGVuZ3RoICUgQkxPQ0tfU0laRTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja3M7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlQmxvY2soYjMyW2kgKiA0ICsgMF0sIGIzMltpICogNCArIDFdLCBiMzJbaSAqIDQgKyAyXSwgYjMyW2kgKiA0ICsgM10pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZWZ0KSB7XG4gICAgICAgICAgICBaRVJPUzE2LnNldChkYXRhLnN1YmFycmF5KGJsb2NrcyAqIEJMT0NLX1NJWkUpKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUJsb2NrKFpFUk9TMzJbMF0sIFpFUk9TMzJbMV0sIFpFUk9TMzJbMl0sIFpFUk9TMzJbM10pO1xuICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKFpFUk9TMzIpOyAvLyBjbGVhbiB0bXAgYnVmZmVyXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IHsgdCB9ID0gdGhpcztcbiAgICAgICAgLy8gY2xlYW4gcHJlY29tcHV0ZSB0YWJsZVxuICAgICAgICBmb3IgKGNvbnN0IGVsbSBvZiB0KSB7XG4gICAgICAgICAgICAoZWxtLnMwID0gMCksIChlbG0uczEgPSAwKSwgKGVsbS5zMiA9IDApLCAoZWxtLnMzID0gMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5leGlzdHMpKHRoaXMpO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLm91dHB1dCkob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHsgczAsIHMxLCBzMiwgczMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG8zMiA9ICgwLCB1dGlsc19qc18xLnUzMikob3V0KTtcbiAgICAgICAgbzMyWzBdID0gczA7XG4gICAgICAgIG8zMlsxXSA9IHMxO1xuICAgICAgICBvMzJbMl0gPSBzMjtcbiAgICAgICAgbzMyWzNdID0gczM7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IFVpbnQ4QXJyYXkoQkxPQ0tfU0laRSk7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhyZXMpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5jbGFzcyBQb2x5dmFsIGV4dGVuZHMgR0hBU0gge1xuICAgIGNvbnN0cnVjdG9yKGtleSwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAga2V5ID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoa2V5KTtcbiAgICAgICAgY29uc3QgZ2hLZXkgPSBfdG9HSEFTSEtleSgoMCwgdXRpbHNfanNfMS5jb3B5Qnl0ZXMpKGtleSkpO1xuICAgICAgICBzdXBlcihnaEtleSwgZXhwZWN0ZWRMZW5ndGgpO1xuICAgICAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikoZ2hLZXkpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBkYXRhID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoZGF0YSk7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuZXhpc3RzKSh0aGlzKTtcbiAgICAgICAgY29uc3QgYjMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShkYXRhKTtcbiAgICAgICAgY29uc3QgbGVmdCA9IGRhdGEubGVuZ3RoICUgQkxPQ0tfU0laRTtcbiAgICAgICAgY29uc3QgYmxvY2tzID0gTWF0aC5mbG9vcihkYXRhLmxlbmd0aCAvIEJMT0NLX1NJWkUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrczsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVCbG9jayhzd2FwTEUoYjMyW2kgKiA0ICsgM10pLCBzd2FwTEUoYjMyW2kgKiA0ICsgMl0pLCBzd2FwTEUoYjMyW2kgKiA0ICsgMV0pLCBzd2FwTEUoYjMyW2kgKiA0ICsgMF0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVmdCkge1xuICAgICAgICAgICAgWkVST1MxNi5zZXQoZGF0YS5zdWJhcnJheShibG9ja3MgKiBCTE9DS19TSVpFKSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVCbG9jayhzd2FwTEUoWkVST1MzMlszXSksIHN3YXBMRShaRVJPUzMyWzJdKSwgc3dhcExFKFpFUk9TMzJbMV0pLCBzd2FwTEUoWkVST1MzMlswXSkpO1xuICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKFpFUk9TMzIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmV4aXN0cykodGhpcyk7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEub3V0cHV0KShvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gdG1wIHVnbHkgaGFja1xuICAgICAgICBjb25zdCB7IHMwLCBzMSwgczIsIHMzIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBvMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKG91dCk7XG4gICAgICAgIG8zMlswXSA9IHMwO1xuICAgICAgICBvMzJbMV0gPSBzMTtcbiAgICAgICAgbzMyWzJdID0gczI7XG4gICAgICAgIG8zMlszXSA9IHMzO1xuICAgICAgICByZXR1cm4gb3V0LnJldmVyc2UoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB3cmFwQ29uc3RydWN0b3JXaXRoS2V5KGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBrZXkpID0+IGhhc2hDb25zKGtleSwgbXNnLmxlbmd0aCkudXBkYXRlKCgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKG5ldyBVaW50OEFycmF5KDE2KSwgMCk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAoa2V5LCBleHBlY3RlZExlbmd0aCkgPT4gaGFzaENvbnMoa2V5LCBleHBlY3RlZExlbmd0aCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy5naGFzaCA9IHdyYXBDb25zdHJ1Y3RvcldpdGhLZXkoKGtleSwgZXhwZWN0ZWRMZW5ndGgpID0+IG5ldyBHSEFTSChrZXksIGV4cGVjdGVkTGVuZ3RoKSk7XG5leHBvcnRzLnBvbHl2YWwgPSB3cmFwQ29uc3RydWN0b3JXaXRoS2V5KChrZXksIGV4cGVjdGVkTGVuZ3RoKSA9PiBuZXcgUG9seXZhbChrZXksIGV4cGVjdGVkTGVuZ3RoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fcG9seXZhbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudW5zYWZlID0gZXhwb3J0cy5hZXNrd3AgPSBleHBvcnRzLmFlc2t3ID0gZXhwb3J0cy5zaXYgPSBleHBvcnRzLmdjbSA9IGV4cG9ydHMuY2ZiID0gZXhwb3J0cy5jYmMgPSBleHBvcnRzLmVjYiA9IGV4cG9ydHMuY3RyID0gdm9pZCAwO1xuZXhwb3J0cy5leHBhbmRLZXlMRSA9IGV4cGFuZEtleUxFO1xuZXhwb3J0cy5leHBhbmRLZXlEZWNMRSA9IGV4cGFuZEtleURlY0xFO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgX3BvbHl2YWxfanNfMSA9IHJlcXVpcmUoXCIuL19wb2x5dmFsLmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLypcbkFFUyAoQWR2YW5jZWQgRW5jcnlwdGlvbiBTdGFuZGFyZCkgYWthIFJpam5kYWVsIGJsb2NrIGNpcGhlci5cblxuRGF0YSBpcyBzcGxpdCBpbnRvIDEyOC1iaXQgYmxvY2tzLiBFbmNyeXB0ZWQgaW4gMTAvMTIvMTQgcm91bmRzICgxMjgvMTkyLzI1NiBiaXRzKS4gSW4gZXZlcnkgcm91bmQ6XG4xLiAqKlMtYm94KiosIHRhYmxlIHN1YnN0aXR1dGlvblxuMi4gKipTaGlmdCByb3dzKiosIGN5Y2xpYyBzaGlmdCBsZWZ0IG9mIGFsbCByb3dzIG9mIGRhdGEgYXJyYXlcbjMuICoqTWl4IGNvbHVtbnMqKiwgbXVsdGlwbHlpbmcgZXZlcnkgY29sdW1uIGJ5IGZpeGVkIHBvbHlub21pYWxcbjQuICoqQWRkIHJvdW5kIGtleSoqLCByb3VuZF9rZXkgeG9yIGktdGggY29sdW1uIG9mIGFycmF5XG5cblJlc291cmNlczpcbi0gRklQUy0xOTcgaHR0cHM6Ly9jc3JjLm5pc3QuZ292L2ZpbGVzL3B1YnMvZmlwcy8xOTcvZmluYWwvZG9jcy9maXBzLTE5Ny5wZGZcbi0gT3JpZ2luYWwgcHJvcG9zYWw6IGh0dHBzOi8vY3NyYy5uaXN0Lmdvdi9jc3JjL21lZGlhL3Byb2plY3RzL2NyeXB0b2dyYXBoaWMtc3RhbmRhcmRzLWFuZC1ndWlkZWxpbmVzL2RvY3VtZW50cy9hZXMtZGV2ZWxvcG1lbnQvcmlqbmRhZWwtYW1tZW5kZWQucGRmXG4qL1xuY29uc3QgQkxPQ0tfU0laRSA9IDE2O1xuY29uc3QgQkxPQ0tfU0laRTMyID0gNDtcbmNvbnN0IEVNUFRZX0JMT0NLID0gbmV3IFVpbnQ4QXJyYXkoQkxPQ0tfU0laRSk7XG5jb25zdCBQT0xZID0gMHgxMWI7IC8vIDEgKyB4ICsgeCoqMyArIHgqKjQgKyB4Kio4XG4vLyBUT0RPOiByZW1vdmUgbXVsdGlwbGljYXRpb24sIGJpbmFyeSBvcHMgb25seVxuZnVuY3Rpb24gbXVsMihuKSB7XG4gICAgcmV0dXJuIChuIDw8IDEpIF4gKFBPTFkgJiAtKG4gPj4gNykpO1xufVxuZnVuY3Rpb24gbXVsKGEsIGIpIHtcbiAgICBsZXQgcmVzID0gMDtcbiAgICBmb3IgKDsgYiA+IDA7IGIgPj49IDEpIHtcbiAgICAgICAgLy8gTW9udGdvbWVyeSBsYWRkZXJcbiAgICAgICAgcmVzIF49IGEgJiAtKGIgJiAxKTsgLy8gaWYgKGImMSkgcmVzIF49YSAoYnV0IGNvbnN0LXRpbWUpLlxuICAgICAgICBhID0gbXVsMihhKTsgLy8gYSA9IDIqYVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gQUVTIFMtYm94IGlzIGdlbmVyYXRlZCB1c2luZyBmaW5pdGUgZmllbGQgaW52ZXJzaW9uLFxuLy8gYW4gYWZmaW5lIHRyYW5zZm9ybSwgYW5kIHhvciBvZiBhIGNvbnN0YW50IDB4NjMuXG5jb25zdCBzYm94ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgY29uc3QgdCA9IG5ldyBVaW50OEFycmF5KDI1Nik7XG4gICAgZm9yIChsZXQgaSA9IDAsIHggPSAxOyBpIDwgMjU2OyBpKyssIHggXj0gbXVsMih4KSlcbiAgICAgICAgdFtpXSA9IHg7XG4gICAgY29uc3QgYm94ID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICBib3hbMF0gPSAweDYzOyAvLyBmaXJzdCBlbG1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NTsgaSsrKSB7XG4gICAgICAgIGxldCB4ID0gdFsyNTUgLSBpXTtcbiAgICAgICAgeCB8PSB4IDw8IDg7XG4gICAgICAgIGJveFt0W2ldXSA9ICh4IF4gKHggPj4gNCkgXiAoeCA+PiA1KSBeICh4ID4+IDYpIF4gKHggPj4gNykgXiAweDYzKSAmIDB4ZmY7XG4gICAgfVxuICAgICgwLCB1dGlsc19qc18xLmNsZWFuKSh0KTtcbiAgICByZXR1cm4gYm94O1xufSkoKTtcbi8vIEludmVydGVkIFMtYm94XG5jb25zdCBpbnZTYm94ID0gLyogQF9fUFVSRV9fICovIHNib3gubWFwKChfLCBqKSA9PiBzYm94LmluZGV4T2YoaikpO1xuLy8gUm90YXRlIHUzMiBieSA4XG5jb25zdCByb3RyMzJfOCA9IChuKSA9PiAobiA8PCAyNCkgfCAobiA+Pj4gOCk7XG5jb25zdCByb3RsMzJfOCA9IChuKSA9PiAobiA8PCA4KSB8IChuID4+PiAyNCk7XG4vLyBUaGUgYnl0ZSBzd2FwIG9wZXJhdGlvbiBmb3IgdWludDMyIChMRTwtPkJFKVxuY29uc3QgYnl0ZVN3YXAgPSAod29yZCkgPT4gKCh3b3JkIDw8IDI0KSAmIDB4ZmYwMDAwMDApIHxcbiAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICgod29yZCA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAoKHdvcmQgPj4+IDI0KSAmIDB4ZmYpO1xuLy8gVC10YWJsZSBpcyBvcHRpbWl6YXRpb24gc3VnZ2VzdGVkIGluIDUuMiBvZiBvcmlnaW5hbCBwcm9wb3NhbCAobWlzc2VkIGZyb20gRklQUy0xOTcpLiBDaGFuZ2VzOlxuLy8gLSBMRSBpbnN0ZWFkIG9mIEJFXG4vLyAtIGJpZ2dlciB0YWJsZXM6IFQwIGFuZCBUMSBhcmUgbWVyZ2VkIGludG8gVDAxIHRhYmxlIGFuZCBUMiAmIFQzIGludG8gVDIzO1xuLy8gICBzbyBpbmRleCBpcyB1MTYsIGluc3RlYWQgb2YgdTguIFRoaXMgc3BlZWRzIHVwIHRoaW5ncywgdW5leHBlY3RlZGx5XG5mdW5jdGlvbiBnZW5UdGFibGUoc2JveCwgZm4pIHtcbiAgICBpZiAoc2JveC5sZW5ndGggIT09IDI1NilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyBzYm94IGxlbmd0aCcpO1xuICAgIGNvbnN0IFQwID0gbmV3IFVpbnQzMkFycmF5KDI1NikubWFwKChfLCBqKSA9PiBmbihzYm94W2pdKSk7XG4gICAgY29uc3QgVDEgPSBUMC5tYXAocm90bDMyXzgpO1xuICAgIGNvbnN0IFQyID0gVDEubWFwKHJvdGwzMl84KTtcbiAgICBjb25zdCBUMyA9IFQyLm1hcChyb3RsMzJfOCk7XG4gICAgY29uc3QgVDAxID0gbmV3IFVpbnQzMkFycmF5KDI1NiAqIDI1Nik7XG4gICAgY29uc3QgVDIzID0gbmV3IFVpbnQzMkFycmF5KDI1NiAqIDI1Nik7XG4gICAgY29uc3Qgc2JveDIgPSBuZXcgVWludDE2QXJyYXkoMjU2ICogMjU2KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMjU2OyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IGkgKiAyNTYgKyBqO1xuICAgICAgICAgICAgVDAxW2lkeF0gPSBUMFtpXSBeIFQxW2pdO1xuICAgICAgICAgICAgVDIzW2lkeF0gPSBUMltpXSBeIFQzW2pdO1xuICAgICAgICAgICAgc2JveDJbaWR4XSA9IChzYm94W2ldIDw8IDgpIHwgc2JveFtqXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzYm94LCBzYm94MiwgVDAsIFQxLCBUMiwgVDMsIFQwMSwgVDIzIH07XG59XG5jb25zdCB0YWJsZUVuY29kaW5nID0gLyogQF9fUFVSRV9fICovIGdlblR0YWJsZShzYm94LCAocykgPT4gKG11bChzLCAzKSA8PCAyNCkgfCAocyA8PCAxNikgfCAocyA8PCA4KSB8IG11bChzLCAyKSk7XG5jb25zdCB0YWJsZURlY29kaW5nID0gLyogQF9fUFVSRV9fICovIGdlblR0YWJsZShpbnZTYm94LCAocykgPT4gKG11bChzLCAxMSkgPDwgMjQpIHwgKG11bChzLCAxMykgPDwgMTYpIHwgKG11bChzLCA5KSA8PCA4KSB8IG11bChzLCAxNCkpO1xuY29uc3QgeFBvd2VycyA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgIGNvbnN0IHAgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgZm9yIChsZXQgaSA9IDAsIHggPSAxOyBpIDwgMTY7IGkrKywgeCA9IG11bDIoeCkpXG4gICAgICAgIHBbaV0gPSB4O1xuICAgIHJldHVybiBwO1xufSkoKTtcbmZ1bmN0aW9uIGV4cGFuZEtleUxFKGtleSkge1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGtleSk7XG4gICAgY29uc3QgbGVuID0ga2V5Lmxlbmd0aDtcbiAgICBpZiAoIVsxNiwgMjQsIDMyXS5pbmNsdWRlcyhsZW4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFlczogd3Jvbmcga2V5IHNpemU6IHNob3VsZCBiZSAxNiwgMjQgb3IgMzIsIGdvdDogJHtsZW59YCk7XG4gICAgY29uc3QgeyBzYm94MiB9ID0gdGFibGVFbmNvZGluZztcbiAgICBjb25zdCB0b0NsZWFuID0gW107XG4gICAgaWYgKCEoMCwgdXRpbHNfanNfMS5pc0FsaWduZWQzMikoa2V5KSlcbiAgICAgICAgdG9DbGVhbi5wdXNoKChrZXkgPSAoMCwgdXRpbHNfanNfMS5jb3B5Qnl0ZXMpKGtleSkpKTtcbiAgICBjb25zdCBrMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKGtleSk7XG4gICAgY29uc3QgTmsgPSBrMzIubGVuZ3RoO1xuICAgIGNvbnN0IHN1YkJ5dGUgPSAobikgPT4gYXBwbHlTYm94KHNib3gyLCBuLCBuLCBuLCBuKTtcbiAgICBjb25zdCB4ayA9IG5ldyBVaW50MzJBcnJheShsZW4gKyAyOCk7IC8vIGV4cGFuZGVkIGtleVxuICAgIHhrLnNldChrMzIpO1xuICAgIC8vIDQuMy4xIEtleSBleHBhbnNpb25cbiAgICBmb3IgKGxldCBpID0gTms7IGkgPCB4ay5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgdCA9IHhrW2kgLSAxXTtcbiAgICAgICAgaWYgKGkgJSBOayA9PT0gMClcbiAgICAgICAgICAgIHQgPSBzdWJCeXRlKHJvdHIzMl84KHQpKSBeIHhQb3dlcnNbaSAvIE5rIC0gMV07XG4gICAgICAgIGVsc2UgaWYgKE5rID4gNiAmJiBpICUgTmsgPT09IDQpXG4gICAgICAgICAgICB0ID0gc3ViQnl0ZSh0KTtcbiAgICAgICAgeGtbaV0gPSB4a1tpIC0gTmtdIF4gdDtcbiAgICB9XG4gICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKC4uLnRvQ2xlYW4pO1xuICAgIHJldHVybiB4aztcbn1cbmZ1bmN0aW9uIGV4cGFuZEtleURlY0xFKGtleSkge1xuICAgIGNvbnN0IGVuY0tleSA9IGV4cGFuZEtleUxFKGtleSk7XG4gICAgY29uc3QgeGsgPSBlbmNLZXkuc2xpY2UoKTtcbiAgICBjb25zdCBOayA9IGVuY0tleS5sZW5ndGg7XG4gICAgY29uc3QgeyBzYm94MiB9ID0gdGFibGVFbmNvZGluZztcbiAgICBjb25zdCB7IFQwLCBUMSwgVDIsIFQzIH0gPSB0YWJsZURlY29kaW5nO1xuICAgIC8vIEludmVyc2Uga2V5IGJ5IGNodW5rcyBvZiA0IChyb3VuZHMpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBOazsgaSArPSA0KSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKVxuICAgICAgICAgICAgeGtbaSArIGpdID0gZW5jS2V5W05rIC0gaSAtIDQgKyBqXTtcbiAgICB9XG4gICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKGVuY0tleSk7XG4gICAgLy8gYXBwbHkgSW52TWl4Q29sdW1uIGV4Y2VwdCBmaXJzdCAmIGxhc3Qgcm91bmRcbiAgICBmb3IgKGxldCBpID0gNDsgaSA8IE5rIC0gNDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHggPSB4a1tpXTtcbiAgICAgICAgY29uc3QgdyA9IGFwcGx5U2JveChzYm94MiwgeCwgeCwgeCwgeCk7XG4gICAgICAgIHhrW2ldID0gVDBbdyAmIDB4ZmZdIF4gVDFbKHcgPj4+IDgpICYgMHhmZl0gXiBUMlsodyA+Pj4gMTYpICYgMHhmZl0gXiBUM1t3ID4+PiAyNF07XG4gICAgfVxuICAgIHJldHVybiB4aztcbn1cbi8vIEFwcGx5IHRhYmxlc1xuZnVuY3Rpb24gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMCwgczEsIHMyLCBzMykge1xuICAgIHJldHVybiAoVDAxWygoczAgPDwgOCkgJiAweGZmMDApIHwgKChzMSA+Pj4gOCkgJiAweGZmKV0gXlxuICAgICAgICBUMjNbKChzMiA+Pj4gOCkgJiAweGZmMDApIHwgKChzMyA+Pj4gMjQpICYgMHhmZildKTtcbn1cbmZ1bmN0aW9uIGFwcGx5U2JveChzYm94MiwgczAsIHMxLCBzMiwgczMpIHtcbiAgICByZXR1cm4gKHNib3gyWyhzMCAmIDB4ZmYpIHwgKHMxICYgMHhmZjAwKV0gfFxuICAgICAgICAoc2JveDJbKChzMiA+Pj4gMTYpICYgMHhmZikgfCAoKHMzID4+PiAxNikgJiAweGZmMDApXSA8PCAxNikpO1xufVxuZnVuY3Rpb24gZW5jcnlwdCh4aywgczAsIHMxLCBzMiwgczMpIHtcbiAgICBjb25zdCB7IHNib3gyLCBUMDEsIFQyMyB9ID0gdGFibGVFbmNvZGluZztcbiAgICBsZXQgayA9IDA7XG4gICAgKHMwIF49IHhrW2srK10pLCAoczEgXj0geGtbaysrXSksIChzMiBePSB4a1trKytdKSwgKHMzIF49IHhrW2srK10pO1xuICAgIGNvbnN0IHJvdW5kcyA9IHhrLmxlbmd0aCAvIDQgLSAyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm91bmRzOyBpKyspIHtcbiAgICAgICAgY29uc3QgdDAgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMCwgczEsIHMyLCBzMyk7XG4gICAgICAgIGNvbnN0IHQxID0geGtbaysrXSBeIGFwcGx5MDEyMyhUMDEsIFQyMywgczEsIHMyLCBzMywgczApO1xuICAgICAgICBjb25zdCB0MiA9IHhrW2srK10gXiBhcHBseTAxMjMoVDAxLCBUMjMsIHMyLCBzMywgczAsIHMxKTtcbiAgICAgICAgY29uc3QgdDMgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMywgczAsIHMxLCBzMik7XG4gICAgICAgIChzMCA9IHQwKSwgKHMxID0gdDEpLCAoczIgPSB0MiksIChzMyA9IHQzKTtcbiAgICB9XG4gICAgLy8gbGFzdCByb3VuZCAod2l0aG91dCBtaXhjb2x1bW5zLCBzbyB1c2luZyBTQk9YMiB0YWJsZSlcbiAgICBjb25zdCB0MCA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMwLCBzMSwgczIsIHMzKTtcbiAgICBjb25zdCB0MSA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMxLCBzMiwgczMsIHMwKTtcbiAgICBjb25zdCB0MiA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMyLCBzMywgczAsIHMxKTtcbiAgICBjb25zdCB0MyA9IHhrW2srK10gXiBhcHBseVNib3goc2JveDIsIHMzLCBzMCwgczEsIHMyKTtcbiAgICByZXR1cm4geyBzMDogdDAsIHMxOiB0MSwgczI6IHQyLCBzMzogdDMgfTtcbn1cbi8vIENhbid0IGJlIG1lcmdlZCB3aXRoIGVuY3J5cHQ6IGFyZyBwb3NpdGlvbnMgZm9yIGFwcGx5MDEyMyAvIGFwcGx5U2JveCBhcmUgZGlmZmVyZW50XG5mdW5jdGlvbiBkZWNyeXB0KHhrLCBzMCwgczEsIHMyLCBzMykge1xuICAgIGNvbnN0IHsgc2JveDIsIFQwMSwgVDIzIH0gPSB0YWJsZURlY29kaW5nO1xuICAgIGxldCBrID0gMDtcbiAgICAoczAgXj0geGtbaysrXSksIChzMSBePSB4a1trKytdKSwgKHMyIF49IHhrW2srK10pLCAoczMgXj0geGtbaysrXSk7XG4gICAgY29uc3Qgcm91bmRzID0geGsubGVuZ3RoIC8gNCAtIDI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3VuZHM7IGkrKykge1xuICAgICAgICBjb25zdCB0MCA9IHhrW2srK10gXiBhcHBseTAxMjMoVDAxLCBUMjMsIHMwLCBzMywgczIsIHMxKTtcbiAgICAgICAgY29uc3QgdDEgPSB4a1trKytdIF4gYXBwbHkwMTIzKFQwMSwgVDIzLCBzMSwgczAsIHMzLCBzMik7XG4gICAgICAgIGNvbnN0IHQyID0geGtbaysrXSBeIGFwcGx5MDEyMyhUMDEsIFQyMywgczIsIHMxLCBzMCwgczMpO1xuICAgICAgICBjb25zdCB0MyA9IHhrW2srK10gXiBhcHBseTAxMjMoVDAxLCBUMjMsIHMzLCBzMiwgczEsIHMwKTtcbiAgICAgICAgKHMwID0gdDApLCAoczEgPSB0MSksIChzMiA9IHQyKSwgKHMzID0gdDMpO1xuICAgIH1cbiAgICAvLyBMYXN0IHJvdW5kXG4gICAgY29uc3QgdDAgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMCwgczMsIHMyLCBzMSk7XG4gICAgY29uc3QgdDEgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMSwgczAsIHMzLCBzMik7XG4gICAgY29uc3QgdDIgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMiwgczEsIHMwLCBzMyk7XG4gICAgY29uc3QgdDMgPSB4a1trKytdIF4gYXBwbHlTYm94KHNib3gyLCBzMywgczIsIHMxLCBzMCk7XG4gICAgcmV0dXJuIHsgczA6IHQwLCBzMTogdDEsIHMyOiB0MiwgczM6IHQzIH07XG59XG5mdW5jdGlvbiBnZXREc3QobGVuLCBkc3QpIHtcbiAgICBpZiAoZHN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShsZW4pO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGRzdCk7XG4gICAgaWYgKGRzdC5sZW5ndGggPCBsZW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYWVzOiB3cm9uZyBkZXN0aW5hdGlvbiBsZW5ndGgsIGV4cGVjdGVkIGF0IGxlYXN0ICR7bGVufSwgZ290OiAke2RzdC5sZW5ndGh9YCk7XG4gICAgaWYgKCEoMCwgdXRpbHNfanNfMS5pc0FsaWduZWQzMikoZHN0KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFsaWduZWQgZHN0Jyk7XG4gICAgcmV0dXJuIGRzdDtcbn1cbi8vIFRPRE86IGludmVzdGlnYXRlIG1lcmdpbmcgd2l0aCBjdHIzMlxuZnVuY3Rpb24gY3RyQ291bnRlcih4aywgbm9uY2UsIHNyYywgZHN0KSB7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykobm9uY2UsIEJMT0NLX1NJWkUpO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKHNyYyk7XG4gICAgY29uc3Qgc3JjTGVuID0gc3JjLmxlbmd0aDtcbiAgICBkc3QgPSBnZXREc3Qoc3JjTGVuLCBkc3QpO1xuICAgIGNvbnN0IGN0ciA9IG5vbmNlO1xuICAgIGNvbnN0IGMzMiA9ICgwLCB1dGlsc19qc18xLnUzMikoY3RyKTtcbiAgICAvLyBGaWxsIGJsb2NrIChlbXB0eSwgY3RyPTApXG4gICAgbGV0IHsgczAsIHMxLCBzMiwgczMgfSA9IGVuY3J5cHQoeGssIGMzMlswXSwgYzMyWzFdLCBjMzJbMl0sIGMzMlszXSk7XG4gICAgY29uc3Qgc3JjMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKHNyYyk7XG4gICAgY29uc3QgZHN0MzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKGRzdCk7XG4gICAgLy8gcHJvY2VzcyBibG9ja3NcbiAgICBmb3IgKGxldCBpID0gMDsgaSArIDQgPD0gc3JjMzIubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgZHN0MzJbaSArIDBdID0gc3JjMzJbaSArIDBdIF4gczA7XG4gICAgICAgIGRzdDMyW2kgKyAxXSA9IHNyYzMyW2kgKyAxXSBeIHMxO1xuICAgICAgICBkc3QzMltpICsgMl0gPSBzcmMzMltpICsgMl0gXiBzMjtcbiAgICAgICAgZHN0MzJbaSArIDNdID0gc3JjMzJbaSArIDNdIF4gczM7XG4gICAgICAgIC8vIEZ1bGwgMTI4IGJpdCBjb3VudGVyIHdpdGggd3JhcCBhcm91bmRcbiAgICAgICAgbGV0IGNhcnJ5ID0gMTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGN0ci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY2FycnkgPSAoY2FycnkgKyAoY3RyW2ldICYgMHhmZikpIHwgMDtcbiAgICAgICAgICAgIGN0cltpXSA9IGNhcnJ5ICYgMHhmZjtcbiAgICAgICAgICAgIGNhcnJ5ID4+Pj0gODtcbiAgICAgICAgfVxuICAgICAgICAoeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgYzMyWzBdLCBjMzJbMV0sIGMzMlsyXSwgYzMyWzNdKSk7XG4gICAgfVxuICAgIC8vIGxlZnRvdmVycyAobGVzcyB0aGFuIGJsb2NrKVxuICAgIC8vIEl0J3MgcG9zc2libGUgdG8gaGFuZGxlID4gdTMyIGZhc3QsIGJ1dCBpcyBpdCB3b3J0aCBpdD9cbiAgICBjb25zdCBzdGFydCA9IEJMT0NLX1NJWkUgKiBNYXRoLmZsb29yKHNyYzMyLmxlbmd0aCAvIEJMT0NLX1NJWkUzMik7XG4gICAgaWYgKHN0YXJ0IDwgc3JjTGVuKSB7XG4gICAgICAgIGNvbnN0IGIzMiA9IG5ldyBVaW50MzJBcnJheShbczAsIHMxLCBzMiwgczNdKTtcbiAgICAgICAgY29uc3QgYnVmID0gKDAsIHV0aWxzX2pzXzEudTgpKGIzMik7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydCwgcG9zID0gMDsgaSA8IHNyY0xlbjsgaSsrLCBwb3MrKylcbiAgICAgICAgICAgIGRzdFtpXSA9IHNyY1tpXSBeIGJ1Zltwb3NdO1xuICAgICAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikoYjMyKTtcbiAgICB9XG4gICAgcmV0dXJuIGRzdDtcbn1cbi8vIEFFUyBDVFIgd2l0aCBvdmVyZmxvd2luZyAzMiBiaXQgY291bnRlclxuLy8gSXQncyBwb3NzaWJsZSB0byBkbyAzMmxlIHNpZ25pZmljYW50bHkgc2ltcGxlciAoYW5kIHByb2JhYmx5IGZhc3RlcikgYnkgdXNpbmcgdTMyLlxuLy8gQnV0LCB3ZSBuZWVkIGJvdGgsIGFuZCBwZXJmIGJvdHRsZW5lY2sgaXMgaW4gZ2hhc2ggYW55d2F5LlxuZnVuY3Rpb24gY3RyMzIoeGssIGlzTEUsIG5vbmNlLCBzcmMsIGRzdCkge1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKG5vbmNlLCBCTE9DS19TSVpFKTtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShzcmMpO1xuICAgIGRzdCA9IGdldERzdChzcmMubGVuZ3RoLCBkc3QpO1xuICAgIGNvbnN0IGN0ciA9IG5vbmNlOyAvLyB3cml0ZSBuZXcgdmFsdWUgdG8gbm9uY2UsIHNvIGl0IGNhbiBiZSByZS11c2VkXG4gICAgY29uc3QgYzMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShjdHIpO1xuICAgIGNvbnN0IHZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShjdHIpO1xuICAgIGNvbnN0IHNyYzMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShzcmMpO1xuICAgIGNvbnN0IGRzdDMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShkc3QpO1xuICAgIGNvbnN0IGN0clBvcyA9IGlzTEUgPyAwIDogMTI7XG4gICAgY29uc3Qgc3JjTGVuID0gc3JjLmxlbmd0aDtcbiAgICAvLyBGaWxsIGJsb2NrIChlbXB0eSwgY3RyPTApXG4gICAgbGV0IGN0ck51bSA9IHZpZXcuZ2V0VWludDMyKGN0clBvcywgaXNMRSk7IC8vIHJlYWQgY3VycmVudCBjb3VudGVyIHZhbHVlXG4gICAgbGV0IHsgczAsIHMxLCBzMiwgczMgfSA9IGVuY3J5cHQoeGssIGMzMlswXSwgYzMyWzFdLCBjMzJbMl0sIGMzMlszXSk7XG4gICAgLy8gcHJvY2VzcyBibG9ja3NcbiAgICBmb3IgKGxldCBpID0gMDsgaSArIDQgPD0gc3JjMzIubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgZHN0MzJbaSArIDBdID0gc3JjMzJbaSArIDBdIF4gczA7XG4gICAgICAgIGRzdDMyW2kgKyAxXSA9IHNyYzMyW2kgKyAxXSBeIHMxO1xuICAgICAgICBkc3QzMltpICsgMl0gPSBzcmMzMltpICsgMl0gXiBzMjtcbiAgICAgICAgZHN0MzJbaSArIDNdID0gc3JjMzJbaSArIDNdIF4gczM7XG4gICAgICAgIGN0ck51bSA9IChjdHJOdW0gKyAxKSA+Pj4gMDsgLy8gdTMyIHdyYXBcbiAgICAgICAgdmlldy5zZXRVaW50MzIoY3RyUG9zLCBjdHJOdW0sIGlzTEUpO1xuICAgICAgICAoeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgYzMyWzBdLCBjMzJbMV0sIGMzMlsyXSwgYzMyWzNdKSk7XG4gICAgfVxuICAgIC8vIGxlZnRvdmVycyAobGVzcyB0aGFuIGEgYmxvY2spXG4gICAgY29uc3Qgc3RhcnQgPSBCTE9DS19TSVpFICogTWF0aC5mbG9vcihzcmMzMi5sZW5ndGggLyBCTE9DS19TSVpFMzIpO1xuICAgIGlmIChzdGFydCA8IHNyY0xlbikge1xuICAgICAgICBjb25zdCBiMzIgPSBuZXcgVWludDMyQXJyYXkoW3MwLCBzMSwgczIsIHMzXSk7XG4gICAgICAgIGNvbnN0IGJ1ZiA9ICgwLCB1dGlsc19qc18xLnU4KShiMzIpO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQsIHBvcyA9IDA7IGkgPCBzcmNMZW47IGkrKywgcG9zKyspXG4gICAgICAgICAgICBkc3RbaV0gPSBzcmNbaV0gXiBidWZbcG9zXTtcbiAgICAgICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKGIzMik7XG4gICAgfVxuICAgIHJldHVybiBkc3Q7XG59XG4vKipcbiAqIENUUjogY291bnRlciBtb2RlLiBDcmVhdGVzIHN0cmVhbSBjaXBoZXIuXG4gKiBSZXF1aXJlcyBnb29kIElWLiBQYXJhbGxlbGl6YWJsZS4gT0ssIGJ1dCBubyBNQUMuXG4gKi9cbmV4cG9ydHMuY3RyID0gKDAsIHV0aWxzX2pzXzEud3JhcENpcGhlcikoeyBibG9ja1NpemU6IDE2LCBub25jZUxlbmd0aDogMTYgfSwgZnVuY3Rpb24gY3RyKGtleSwgbm9uY2UpIHtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShrZXkpO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKG5vbmNlLCBCTE9DS19TSVpFKTtcbiAgICBmdW5jdGlvbiBwcm9jZXNzQ3RyKGJ1ZiwgZHN0KSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGJ1Zik7XG4gICAgICAgIGlmIChkc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykoZHN0KTtcbiAgICAgICAgICAgIGlmICghKDAsIHV0aWxzX2pzXzEuaXNBbGlnbmVkMzIpKGRzdCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFsaWduZWQgZGVzdGluYXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG4gICAgICAgIGNvbnN0IG4gPSAoMCwgdXRpbHNfanNfMS5jb3B5Qnl0ZXMpKG5vbmNlKTsgLy8gYWxpZ24gKyBhdm9pZCBjaGFuZ2luZ1xuICAgICAgICBjb25zdCB0b0NsZWFuID0gW3hrLCBuXTtcbiAgICAgICAgaWYgKCEoMCwgdXRpbHNfanNfMS5pc0FsaWduZWQzMikoYnVmKSlcbiAgICAgICAgICAgIHRvQ2xlYW4ucHVzaCgoYnVmID0gKDAsIHV0aWxzX2pzXzEuY29weUJ5dGVzKShidWYpKSk7XG4gICAgICAgIGNvbnN0IG91dCA9IGN0ckNvdW50ZXIoeGssIG4sIGJ1ZiwgZHN0KTtcbiAgICAgICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKC4uLnRvQ2xlYW4pO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNyeXB0OiAocGxhaW50ZXh0LCBkc3QpID0+IHByb2Nlc3NDdHIocGxhaW50ZXh0LCBkc3QpLFxuICAgICAgICBkZWNyeXB0OiAoY2lwaGVydGV4dCwgZHN0KSA9PiBwcm9jZXNzQ3RyKGNpcGhlcnRleHQsIGRzdCksXG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gdmFsaWRhdGVCbG9ja0RlY3J5cHQoZGF0YSkge1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGRhdGEpO1xuICAgIGlmIChkYXRhLmxlbmd0aCAlIEJMT0NLX1NJWkUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhZXMvKGNiYy1lY2IpLmRlY3J5cHQgY2lwaGVydGV4dCBzaG91bGQgY29uc2lzdCBvZiBibG9ja3Mgd2l0aCBzaXplICR7QkxPQ0tfU0laRX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUJsb2NrRW5jcnlwdChwbGFpbnRleHQsIHBja3M1LCBkc3QpIHtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShwbGFpbnRleHQpO1xuICAgIGxldCBvdXRMZW4gPSBwbGFpbnRleHQubGVuZ3RoO1xuICAgIGNvbnN0IHJlbWFpbmluZyA9IG91dExlbiAlIEJMT0NLX1NJWkU7XG4gICAgaWYgKCFwY2tzNSAmJiByZW1haW5pbmcgIT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWVjLyhjYmMtZWNiKTogdW5wYWRkZWQgcGxhaW50ZXh0IHdpdGggZGlzYWJsZWQgcGFkZGluZycpO1xuICAgIGlmICghKDAsIHV0aWxzX2pzXzEuaXNBbGlnbmVkMzIpKHBsYWludGV4dCkpXG4gICAgICAgIHBsYWludGV4dCA9ICgwLCB1dGlsc19qc18xLmNvcHlCeXRlcykocGxhaW50ZXh0KTtcbiAgICBjb25zdCBiID0gKDAsIHV0aWxzX2pzXzEudTMyKShwbGFpbnRleHQpO1xuICAgIGlmIChwY2tzNSkge1xuICAgICAgICBsZXQgbGVmdCA9IEJMT0NLX1NJWkUgLSByZW1haW5pbmc7XG4gICAgICAgIGlmICghbGVmdClcbiAgICAgICAgICAgIGxlZnQgPSBCTE9DS19TSVpFOyAvLyBpZiBubyBieXRlcyBsZWZ0LCBjcmVhdGUgZW1wdHkgcGFkZGluZyBibG9ja1xuICAgICAgICBvdXRMZW4gPSBvdXRMZW4gKyBsZWZ0O1xuICAgIH1cbiAgICBjb25zdCBvdXQgPSBnZXREc3Qob3V0TGVuLCBkc3QpO1xuICAgIGNvbnN0IG8gPSAoMCwgdXRpbHNfanNfMS51MzIpKG91dCk7XG4gICAgcmV0dXJuIHsgYiwgbywgb3V0IH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBDS1MoZGF0YSwgcGNrczUpIHtcbiAgICBpZiAoIXBja3M1KVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICBpZiAoIWxlbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZXMvcGNrczU6IGVtcHR5IGNpcGhlcnRleHQgbm90IGFsbG93ZWQnKTtcbiAgICBjb25zdCBsYXN0Qnl0ZSA9IGRhdGFbbGVuIC0gMV07XG4gICAgaWYgKGxhc3RCeXRlIDw9IDAgfHwgbGFzdEJ5dGUgPiAxNilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZXMvcGNrczU6IHdyb25nIHBhZGRpbmcnKTtcbiAgICBjb25zdCBvdXQgPSBkYXRhLnN1YmFycmF5KDAsIC1sYXN0Qnl0ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0Qnl0ZTsgaSsrKVxuICAgICAgICBpZiAoZGF0YVtsZW4gLSBpIC0gMV0gIT09IGxhc3RCeXRlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZXMvcGNrczU6IHdyb25nIHBhZGRpbmcnKTtcbiAgICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gcGFkUENLUyhsZWZ0KSB7XG4gICAgY29uc3QgdG1wID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIGNvbnN0IHRtcDMyID0gKDAsIHV0aWxzX2pzXzEudTMyKSh0bXApO1xuICAgIHRtcC5zZXQobGVmdCk7XG4gICAgY29uc3QgcGFkZGluZ0J5dGUgPSBCTE9DS19TSVpFIC0gbGVmdC5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IEJMT0NLX1NJWkUgLSBwYWRkaW5nQnl0ZTsgaSA8IEJMT0NLX1NJWkU7IGkrKylcbiAgICAgICAgdG1wW2ldID0gcGFkZGluZ0J5dGU7XG4gICAgcmV0dXJuIHRtcDMyO1xufVxuLyoqXG4gKiBFQ0I6IEVsZWN0cm9uaWMgQ29kZUJvb2suIFNpbXBsZSBkZXRlcm1pbmlzdGljIHJlcGxhY2VtZW50LlxuICogRGFuZ2Vyb3VzOiBhbHdheXMgbWFwIHggdG8geS4gU2VlIFtBRVMgUGVuZ3Vpbl0oaHR0cHM6Ly93b3Jkcy5maWxpcHBvLmlvL3RoZS1lY2ItcGVuZ3Vpbi8pLlxuICovXG5leHBvcnRzLmVjYiA9ICgwLCB1dGlsc19qc18xLndyYXBDaXBoZXIpKHsgYmxvY2tTaXplOiAxNiB9LCBmdW5jdGlvbiBlY2Ioa2V5LCBvcHRzID0ge30pIHtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShrZXkpO1xuICAgIGNvbnN0IHBja3M1ID0gIW9wdHMuZGlzYWJsZVBhZGRpbmc7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jcnlwdChwbGFpbnRleHQsIGRzdCkge1xuICAgICAgICAgICAgY29uc3QgeyBiLCBvLCBvdXQ6IF9vdXQgfSA9IHZhbGlkYXRlQmxvY2tFbmNyeXB0KHBsYWludGV4dCwgcGNrczUsIGRzdCk7XG4gICAgICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSArIDQgPD0gYi5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgYltpICsgMF0sIGJbaSArIDFdLCBiW2kgKyAyXSwgYltpICsgM10pO1xuICAgICAgICAgICAgICAgIChvW2krK10gPSBzMCksIChvW2krK10gPSBzMSksIChvW2krK10gPSBzMiksIChvW2krK10gPSBzMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGNrczUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0bXAzMiA9IHBhZFBDS1MocGxhaW50ZXh0LnN1YmFycmF5KGkgKiA0KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgdG1wMzJbMF0sIHRtcDMyWzFdLCB0bXAzMlsyXSwgdG1wMzJbM10pO1xuICAgICAgICAgICAgICAgIChvW2krK10gPSBzMCksIChvW2krK10gPSBzMSksIChvW2krK10gPSBzMiksIChvW2krK10gPSBzMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikoeGspO1xuICAgICAgICAgICAgcmV0dXJuIF9vdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY3J5cHQoY2lwaGVydGV4dCwgZHN0KSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUJsb2NrRGVjcnlwdChjaXBoZXJ0ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IHhrID0gZXhwYW5kS2V5RGVjTEUoa2V5KTtcbiAgICAgICAgICAgIGNvbnN0IG91dCA9IGdldERzdChjaXBoZXJ0ZXh0Lmxlbmd0aCwgZHN0KTtcbiAgICAgICAgICAgIGNvbnN0IHRvQ2xlYW4gPSBbeGtdO1xuICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfanNfMS5pc0FsaWduZWQzMikoY2lwaGVydGV4dCkpXG4gICAgICAgICAgICAgICAgdG9DbGVhbi5wdXNoKChjaXBoZXJ0ZXh0ID0gKDAsIHV0aWxzX2pzXzEuY29weUJ5dGVzKShjaXBoZXJ0ZXh0KSkpO1xuICAgICAgICAgICAgY29uc3QgYiA9ICgwLCB1dGlsc19qc18xLnUzMikoY2lwaGVydGV4dCk7XG4gICAgICAgICAgICBjb25zdCBvID0gKDAsIHV0aWxzX2pzXzEudTMyKShvdXQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgKyA0IDw9IGIubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgczAsIHMxLCBzMiwgczMgfSA9IGRlY3J5cHQoeGssIGJbaSArIDBdLCBiW2kgKyAxXSwgYltpICsgMl0sIGJbaSArIDNdKTtcbiAgICAgICAgICAgICAgICAob1tpKytdID0gczApLCAob1tpKytdID0gczEpLCAob1tpKytdID0gczIpLCAob1tpKytdID0gczMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKC4uLnRvQ2xlYW4pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlUENLUyhvdXQsIHBja3M1KTtcbiAgICAgICAgfSxcbiAgICB9O1xufSk7XG4vKipcbiAqIENCQzogQ2lwaGVyLUJsb2NrLUNoYWluaW5nLiBLZXkgaXMgcHJldmlvdXMgcm91bmTigJlzIGJsb2NrLlxuICogRnJhZ2lsZTogbmVlZHMgcHJvcGVyIHBhZGRpbmcuIFVuYXV0aGVudGljYXRlZDogbmVlZHMgTUFDLlxuICovXG5leHBvcnRzLmNiYyA9ICgwLCB1dGlsc19qc18xLndyYXBDaXBoZXIpKHsgYmxvY2tTaXplOiAxNiwgbm9uY2VMZW5ndGg6IDE2IH0sIGZ1bmN0aW9uIGNiYyhrZXksIGl2LCBvcHRzID0ge30pIHtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShrZXkpO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGl2LCAxNik7XG4gICAgY29uc3QgcGNrczUgPSAhb3B0cy5kaXNhYmxlUGFkZGluZztcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNyeXB0KHBsYWludGV4dCwgZHN0KSB7XG4gICAgICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG4gICAgICAgICAgICBjb25zdCB7IGIsIG8sIG91dDogX291dCB9ID0gdmFsaWRhdGVCbG9ja0VuY3J5cHQocGxhaW50ZXh0LCBwY2tzNSwgZHN0KTtcbiAgICAgICAgICAgIGxldCBfaXYgPSBpdjtcbiAgICAgICAgICAgIGNvbnN0IHRvQ2xlYW4gPSBbeGtdO1xuICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfanNfMS5pc0FsaWduZWQzMikoX2l2KSlcbiAgICAgICAgICAgICAgICB0b0NsZWFuLnB1c2goKF9pdiA9ICgwLCB1dGlsc19qc18xLmNvcHlCeXRlcykoX2l2KSkpO1xuICAgICAgICAgICAgY29uc3QgbjMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShfaXYpO1xuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgczAgPSBuMzJbMF0sIHMxID0gbjMyWzFdLCBzMiA9IG4zMlsyXSwgczMgPSBuMzJbM107XG4gICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSArIDQgPD0gYi5sZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgKHMwIF49IGJbaSArIDBdKSwgKHMxIF49IGJbaSArIDFdKSwgKHMyIF49IGJbaSArIDJdKSwgKHMzIF49IGJbaSArIDNdKTtcbiAgICAgICAgICAgICAgICAoeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgczAsIHMxLCBzMiwgczMpKTtcbiAgICAgICAgICAgICAgICAob1tpKytdID0gczApLCAob1tpKytdID0gczEpLCAob1tpKytdID0gczIpLCAob1tpKytdID0gczMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBja3M1KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG1wMzIgPSBwYWRQQ0tTKHBsYWludGV4dC5zdWJhcnJheShpICogNCkpO1xuICAgICAgICAgICAgICAgIChzMCBePSB0bXAzMlswXSksIChzMSBePSB0bXAzMlsxXSksIChzMiBePSB0bXAzMlsyXSksIChzMyBePSB0bXAzMlszXSk7XG4gICAgICAgICAgICAgICAgKHsgczAsIHMxLCBzMiwgczMgfSA9IGVuY3J5cHQoeGssIHMwLCBzMSwgczIsIHMzKSk7XG4gICAgICAgICAgICAgICAgKG9baSsrXSA9IHMwKSwgKG9baSsrXSA9IHMxKSwgKG9baSsrXSA9IHMyKSwgKG9baSsrXSA9IHMzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICgwLCB1dGlsc19qc18xLmNsZWFuKSguLi50b0NsZWFuKTtcbiAgICAgICAgICAgIHJldHVybiBfb3V0O1xuICAgICAgICB9LFxuICAgICAgICBkZWNyeXB0KGNpcGhlcnRleHQsIGRzdCkge1xuICAgICAgICAgICAgdmFsaWRhdGVCbG9ja0RlY3J5cHQoY2lwaGVydGV4dCk7XG4gICAgICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleURlY0xFKGtleSk7XG4gICAgICAgICAgICBsZXQgX2l2ID0gaXY7XG4gICAgICAgICAgICBjb25zdCB0b0NsZWFuID0gW3hrXTtcbiAgICAgICAgICAgIGlmICghKDAsIHV0aWxzX2pzXzEuaXNBbGlnbmVkMzIpKF9pdikpXG4gICAgICAgICAgICAgICAgdG9DbGVhbi5wdXNoKChfaXYgPSAoMCwgdXRpbHNfanNfMS5jb3B5Qnl0ZXMpKF9pdikpKTtcbiAgICAgICAgICAgIGNvbnN0IG4zMiA9ICgwLCB1dGlsc19qc18xLnUzMikoX2l2KTtcbiAgICAgICAgICAgIGNvbnN0IG91dCA9IGdldERzdChjaXBoZXJ0ZXh0Lmxlbmd0aCwgZHN0KTtcbiAgICAgICAgICAgIGlmICghKDAsIHV0aWxzX2pzXzEuaXNBbGlnbmVkMzIpKGNpcGhlcnRleHQpKVxuICAgICAgICAgICAgICAgIHRvQ2xlYW4ucHVzaCgoY2lwaGVydGV4dCA9ICgwLCB1dGlsc19qc18xLmNvcHlCeXRlcykoY2lwaGVydGV4dCkpKTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSAoMCwgdXRpbHNfanNfMS51MzIpKGNpcGhlcnRleHQpO1xuICAgICAgICAgICAgY29uc3QgbyA9ICgwLCB1dGlsc19qc18xLnUzMikob3V0KTtcbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgbGV0IHMwID0gbjMyWzBdLCBzMSA9IG4zMlsxXSwgczIgPSBuMzJbMl0sIHMzID0gbjMyWzNdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgKyA0IDw9IGIubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgICAgIGNvbnN0IHBzMCA9IHMwLCBwczEgPSBzMSwgcHMyID0gczIsIHBzMyA9IHMzO1xuICAgICAgICAgICAgICAgIChzMCA9IGJbaSArIDBdKSwgKHMxID0gYltpICsgMV0pLCAoczIgPSBiW2kgKyAyXSksIChzMyA9IGJbaSArIDNdKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHMwOiBvMCwgczE6IG8xLCBzMjogbzIsIHMzOiBvMyB9ID0gZGVjcnlwdCh4aywgczAsIHMxLCBzMiwgczMpO1xuICAgICAgICAgICAgICAgIChvW2krK10gPSBvMCBeIHBzMCksIChvW2krK10gPSBvMSBeIHBzMSksIChvW2krK10gPSBvMiBeIHBzMiksIChvW2krK10gPSBvMyBeIHBzMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikoLi4udG9DbGVhbik7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVQQ0tTKG91dCwgcGNrczUpO1xuICAgICAgICB9LFxuICAgIH07XG59KTtcbi8qKlxuICogQ0ZCOiBDaXBoZXIgRmVlZGJhY2sgTW9kZS4gVGhlIGlucHV0IGZvciB0aGUgYmxvY2sgY2lwaGVyIGlzIHRoZSBwcmV2aW91cyBjaXBoZXIgb3V0cHV0LlxuICogVW5hdXRoZW50aWNhdGVkOiBuZWVkcyBNQUMuXG4gKi9cbmV4cG9ydHMuY2ZiID0gKDAsIHV0aWxzX2pzXzEud3JhcENpcGhlcikoeyBibG9ja1NpemU6IDE2LCBub25jZUxlbmd0aDogMTYgfSwgZnVuY3Rpb24gY2ZiKGtleSwgaXYpIHtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShrZXkpO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGl2LCAxNik7XG4gICAgZnVuY3Rpb24gcHJvY2Vzc0NmYihzcmMsIGlzRW5jcnlwdCwgZHN0KSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKHNyYyk7XG4gICAgICAgIGNvbnN0IHNyY0xlbiA9IHNyYy5sZW5ndGg7XG4gICAgICAgIGRzdCA9IGdldERzdChzcmNMZW4sIGRzdCk7XG4gICAgICAgIGNvbnN0IHhrID0gZXhwYW5kS2V5TEUoa2V5KTtcbiAgICAgICAgbGV0IF9pdiA9IGl2O1xuICAgICAgICBjb25zdCB0b0NsZWFuID0gW3hrXTtcbiAgICAgICAgaWYgKCEoMCwgdXRpbHNfanNfMS5pc0FsaWduZWQzMikoX2l2KSlcbiAgICAgICAgICAgIHRvQ2xlYW4ucHVzaCgoX2l2ID0gKDAsIHV0aWxzX2pzXzEuY29weUJ5dGVzKShfaXYpKSk7XG4gICAgICAgIGlmICghKDAsIHV0aWxzX2pzXzEuaXNBbGlnbmVkMzIpKHNyYykpXG4gICAgICAgICAgICB0b0NsZWFuLnB1c2goKHNyYyA9ICgwLCB1dGlsc19qc18xLmNvcHlCeXRlcykoc3JjKSkpO1xuICAgICAgICBjb25zdCBzcmMzMiA9ICgwLCB1dGlsc19qc18xLnUzMikoc3JjKTtcbiAgICAgICAgY29uc3QgZHN0MzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKGRzdCk7XG4gICAgICAgIGNvbnN0IG5leHQzMiA9IGlzRW5jcnlwdCA/IGRzdDMyIDogc3JjMzI7XG4gICAgICAgIGNvbnN0IG4zMiA9ICgwLCB1dGlsc19qc18xLnUzMikoX2l2KTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCBzMCA9IG4zMlswXSwgczEgPSBuMzJbMV0sIHMyID0gbjMyWzJdLCBzMyA9IG4zMlszXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgKyA0IDw9IHNyYzMyLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGNvbnN0IHsgczA6IGUwLCBzMTogZTEsIHMyOiBlMiwgczM6IGUzIH0gPSBlbmNyeXB0KHhrLCBzMCwgczEsIHMyLCBzMyk7XG4gICAgICAgICAgICBkc3QzMltpICsgMF0gPSBzcmMzMltpICsgMF0gXiBlMDtcbiAgICAgICAgICAgIGRzdDMyW2kgKyAxXSA9IHNyYzMyW2kgKyAxXSBeIGUxO1xuICAgICAgICAgICAgZHN0MzJbaSArIDJdID0gc3JjMzJbaSArIDJdIF4gZTI7XG4gICAgICAgICAgICBkc3QzMltpICsgM10gPSBzcmMzMltpICsgM10gXiBlMztcbiAgICAgICAgICAgIChzMCA9IG5leHQzMltpKytdKSwgKHMxID0gbmV4dDMyW2krK10pLCAoczIgPSBuZXh0MzJbaSsrXSksIChzMyA9IG5leHQzMltpKytdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsZWZ0b3ZlcnMgKGxlc3MgdGhhbiBibG9jaylcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBCTE9DS19TSVpFICogTWF0aC5mbG9vcihzcmMzMi5sZW5ndGggLyBCTE9DS19TSVpFMzIpO1xuICAgICAgICBpZiAoc3RhcnQgPCBzcmNMZW4pIHtcbiAgICAgICAgICAgICh7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBzMCwgczEsIHMyLCBzMykpO1xuICAgICAgICAgICAgY29uc3QgYnVmID0gKDAsIHV0aWxzX2pzXzEudTgpKG5ldyBVaW50MzJBcnJheShbczAsIHMxLCBzMiwgczNdKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQsIHBvcyA9IDA7IGkgPCBzcmNMZW47IGkrKywgcG9zKyspXG4gICAgICAgICAgICAgICAgZHN0W2ldID0gc3JjW2ldIF4gYnVmW3Bvc107XG4gICAgICAgICAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikoYnVmKTtcbiAgICAgICAgfVxuICAgICAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikoLi4udG9DbGVhbik7XG4gICAgICAgIHJldHVybiBkc3Q7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVuY3J5cHQ6IChwbGFpbnRleHQsIGRzdCkgPT4gcHJvY2Vzc0NmYihwbGFpbnRleHQsIHRydWUsIGRzdCksXG4gICAgICAgIGRlY3J5cHQ6IChjaXBoZXJ0ZXh0LCBkc3QpID0+IHByb2Nlc3NDZmIoY2lwaGVydGV4dCwgZmFsc2UsIGRzdCksXG4gICAgfTtcbn0pO1xuLy8gVE9ETzogbWVyZ2Ugd2l0aCBjaGFjaGEsIGhvd2V2ZXIgZ2NtIGhhcyBiaXRMZW4gd2hpbGUgY2hhY2hhIGhhcyBieXRlTGVuXG5mdW5jdGlvbiBjb21wdXRlVGFnKGZuLCBpc0xFLCBrZXksIGRhdGEsIEFBRCkge1xuICAgIGNvbnN0IGFhZExlbmd0aCA9IEFBRCA9PSBudWxsID8gMCA6IEFBRC5sZW5ndGg7XG4gICAgY29uc3QgaCA9IGZuLmNyZWF0ZShrZXksIGRhdGEubGVuZ3RoICsgYWFkTGVuZ3RoKTtcbiAgICBpZiAoQUFEKVxuICAgICAgICBoLnVwZGF0ZShBQUQpO1xuICAgIGgudXBkYXRlKGRhdGEpO1xuICAgIGNvbnN0IG51bSA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICBjb25zdCB2aWV3ID0gKDAsIHV0aWxzX2pzXzEuY3JlYXRlVmlldykobnVtKTtcbiAgICBpZiAoQUFEKVxuICAgICAgICAoMCwgdXRpbHNfanNfMS5zZXRCaWdVaW50NjQpKHZpZXcsIDAsIEJpZ0ludChhYWRMZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgKDAsIHV0aWxzX2pzXzEuc2V0QmlnVWludDY0KSh2aWV3LCA4LCBCaWdJbnQoZGF0YS5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgaC51cGRhdGUobnVtKTtcbiAgICBjb25zdCByZXMgPSBoLmRpZ2VzdCgpO1xuICAgICgwLCB1dGlsc19qc18xLmNsZWFuKShudW0pO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEdDTTogR2Fsb2lzL0NvdW50ZXIgTW9kZS5cbiAqIE1vZGVybiwgcGFyYWxsZWwgdmVyc2lvbiBvZiBDVFIsIHdpdGggTUFDLlxuICogQmUgY2FyZWZ1bDogTUFDcyBjYW4gYmUgZm9yZ2VkLlxuICogVW5zYWZlIHRvIHVzZSByYW5kb20gbm9uY2VzIHVuZGVyIHRoZSBzYW1lIGtleSwgZHVlIHRvIGNvbGxpc2lvbiBjaGFuY2UuXG4gKiBBcyBmb3Igbm9uY2Ugc2l6ZSwgcHJlZmVyIDEyLWJ5dGUsIGluc3RlYWQgb2YgOC1ieXRlLlxuICovXG5leHBvcnRzLmdjbSA9ICgwLCB1dGlsc19qc18xLndyYXBDaXBoZXIpKHsgYmxvY2tTaXplOiAxNiwgbm9uY2VMZW5ndGg6IDEyLCB0YWdMZW5ndGg6IDE2IH0sIGZ1bmN0aW9uIGdjbShrZXksIG5vbmNlLCBBQUQpIHtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShrZXkpO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKG5vbmNlKTtcbiAgICBpZiAoQUFEICE9PSB1bmRlZmluZWQpXG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKEFBRCk7XG4gICAgLy8gTklTVCA4MDAtMzhkIGRvZXNuJ3QgZW5mb3JjZSBtaW5pbXVtIG5vbmNlIGxlbmd0aC5cbiAgICAvLyBXZSBlbmZvcmNlIDggYnl0ZXMgZm9yIGNvbXBhdCB3aXRoIG9wZW5zc2wuXG4gICAgLy8gMTIgYnl0ZXMgYXJlIHJlY29tbWVuZGVkLiBNb3JlIHRoYW4gMTIgYnl0ZXMgd291bGQgYmUgY29udmVydGVkIGludG8gMTIuXG4gICAgaWYgKG5vbmNlLmxlbmd0aCA8IDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYWVzL2djbTogaW52YWxpZCBub25jZSBsZW5ndGgnKTtcbiAgICBjb25zdCB0YWdMZW5ndGggPSAxNjtcbiAgICBmdW5jdGlvbiBfY29tcHV0ZVRhZyhhdXRoS2V5LCB0YWdNYXNrLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHRhZyA9IGNvbXB1dGVUYWcoX3BvbHl2YWxfanNfMS5naGFzaCwgZmFsc2UsIGF1dGhLZXksIGRhdGEsIEFBRCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFnTWFzay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRhZ1tpXSBePSB0YWdNYXNrW2ldO1xuICAgICAgICByZXR1cm4gdGFnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXJpdmVLZXlzKCkge1xuICAgICAgICBjb25zdCB4ayA9IGV4cGFuZEtleUxFKGtleSk7XG4gICAgICAgIGNvbnN0IGF1dGhLZXkgPSBFTVBUWV9CTE9DSy5zbGljZSgpO1xuICAgICAgICBjb25zdCBjb3VudGVyID0gRU1QVFlfQkxPQ0suc2xpY2UoKTtcbiAgICAgICAgY3RyMzIoeGssIGZhbHNlLCBjb3VudGVyLCBjb3VudGVyLCBhdXRoS2V5KTtcbiAgICAgICAgLy8gTklTVCA4MDAtMzhkLCBwYWdlIDE1OiBkaWZmZXJlbnQgYmVoYXZpb3IgZm9yIDk2LWJpdCBhbmQgbm9uLTk2LWJpdCBub25jZXNcbiAgICAgICAgaWYgKG5vbmNlLmxlbmd0aCA9PT0gMTIpIHtcbiAgICAgICAgICAgIGNvdW50ZXIuc2V0KG5vbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5vbmNlTGVuID0gRU1QVFlfQkxPQ0suc2xpY2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShub25jZUxlbik7XG4gICAgICAgICAgICAoMCwgdXRpbHNfanNfMS5zZXRCaWdVaW50NjQpKHZpZXcsIDgsIEJpZ0ludChub25jZS5sZW5ndGggKiA4KSwgZmFsc2UpO1xuICAgICAgICAgICAgLy8gZ2hhc2gobm9uY2UgfHwgdTY0YmUoMCkgfHwgdTY0YmUobm9uY2VMZW4qOCkpXG4gICAgICAgICAgICBjb25zdCBnID0gX3BvbHl2YWxfanNfMS5naGFzaC5jcmVhdGUoYXV0aEtleSkudXBkYXRlKG5vbmNlKS51cGRhdGUobm9uY2VMZW4pO1xuICAgICAgICAgICAgZy5kaWdlc3RJbnRvKGNvdW50ZXIpOyAvLyBkaWdlc3RJbnRvIGRvZXNuJ3QgdHJpZ2dlciAnLmRlc3Ryb3knXG4gICAgICAgICAgICBnLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWdNYXNrID0gY3RyMzIoeGssIGZhbHNlLCBjb3VudGVyLCBFTVBUWV9CTE9DSyk7XG4gICAgICAgIHJldHVybiB7IHhrLCBhdXRoS2V5LCBjb3VudGVyLCB0YWdNYXNrIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVuY3J5cHQocGxhaW50ZXh0KSB7XG4gICAgICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShwbGFpbnRleHQpO1xuICAgICAgICAgICAgY29uc3QgeyB4aywgYXV0aEtleSwgY291bnRlciwgdGFnTWFzayB9ID0gZGVyaXZlS2V5cygpO1xuICAgICAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkocGxhaW50ZXh0Lmxlbmd0aCArIHRhZ0xlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCB0b0NsZWFuID0gW3hrLCBhdXRoS2V5LCBjb3VudGVyLCB0YWdNYXNrXTtcbiAgICAgICAgICAgIGlmICghKDAsIHV0aWxzX2pzXzEuaXNBbGlnbmVkMzIpKHBsYWludGV4dCkpXG4gICAgICAgICAgICAgICAgdG9DbGVhbi5wdXNoKChwbGFpbnRleHQgPSAoMCwgdXRpbHNfanNfMS5jb3B5Qnl0ZXMpKHBsYWludGV4dCkpKTtcbiAgICAgICAgICAgIGN0cjMyKHhrLCBmYWxzZSwgY291bnRlciwgcGxhaW50ZXh0LCBvdXQpO1xuICAgICAgICAgICAgY29uc3QgdGFnID0gX2NvbXB1dGVUYWcoYXV0aEtleSwgdGFnTWFzaywgb3V0LnN1YmFycmF5KDAsIG91dC5sZW5ndGggLSB0YWdMZW5ndGgpKTtcbiAgICAgICAgICAgIHRvQ2xlYW4ucHVzaCh0YWcpO1xuICAgICAgICAgICAgb3V0LnNldCh0YWcsIHBsYWludGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKC4uLnRvQ2xlYW4pO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XG4gICAgICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShjaXBoZXJ0ZXh0KTtcbiAgICAgICAgICAgIGlmIChjaXBoZXJ0ZXh0Lmxlbmd0aCA8IHRhZ0xlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFlcy9nY206IGNpcGhlcnRleHQgbGVzcyB0aGFuIHRhZ0xlbiAoJHt0YWdMZW5ndGh9KWApO1xuICAgICAgICAgICAgY29uc3QgeyB4aywgYXV0aEtleSwgY291bnRlciwgdGFnTWFzayB9ID0gZGVyaXZlS2V5cygpO1xuICAgICAgICAgICAgY29uc3QgdG9DbGVhbiA9IFt4aywgYXV0aEtleSwgdGFnTWFzaywgY291bnRlcl07XG4gICAgICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmlzQWxpZ25lZDMyKShjaXBoZXJ0ZXh0KSlcbiAgICAgICAgICAgICAgICB0b0NsZWFuLnB1c2goKGNpcGhlcnRleHQgPSAoMCwgdXRpbHNfanNfMS5jb3B5Qnl0ZXMpKGNpcGhlcnRleHQpKSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gY2lwaGVydGV4dC5zdWJhcnJheSgwLCAtdGFnTGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhc3NlZFRhZyA9IGNpcGhlcnRleHQuc3ViYXJyYXkoLXRhZ0xlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBfY29tcHV0ZVRhZyhhdXRoS2V5LCB0YWdNYXNrLCBkYXRhKTtcbiAgICAgICAgICAgIHRvQ2xlYW4ucHVzaCh0YWcpO1xuICAgICAgICAgICAgaWYgKCEoMCwgdXRpbHNfanNfMS5lcXVhbEJ5dGVzKSh0YWcsIHBhc3NlZFRhZykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZXMvZ2NtOiBpbnZhbGlkIGdoYXNoIHRhZycpO1xuICAgICAgICAgICAgY29uc3Qgb3V0ID0gY3RyMzIoeGssIGZhbHNlLCBjb3VudGVyLCBkYXRhKTtcbiAgICAgICAgICAgICgwLCB1dGlsc19qc18xLmNsZWFuKSguLi50b0NsZWFuKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgfTtcbn0pO1xuY29uc3QgbGltaXQgPSAobmFtZSwgbWluLCBtYXgpID0+ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpIHx8IG1pbiA+IHZhbHVlIHx8IHZhbHVlID4gbWF4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX06IGludmFsaWQgdmFsdWU9JHt2YWx1ZX0sIG11c3QgYmUgWyR7bWlufS4uJHttYXh9XWApO1xufTtcbi8qKlxuICogQUVTLUdDTS1TSVY6IGNsYXNzaWMgQUVTLUdDTSB3aXRoIG5vbmNlLW1pc3VzZSByZXNpc3RhbmNlLlxuICogR3VhcmFudGVlcyB0aGF0LCB3aGVuIGEgbm9uY2UgaXMgcmVwZWF0ZWQsIHRoZSBvbmx5IHNlY3VyaXR5IGxvc3MgaXMgdGhhdCBpZGVudGljYWxcbiAqIHBsYWludGV4dHMgd2lsbCBwcm9kdWNlIGlkZW50aWNhbCBjaXBoZXJ0ZXh0cy5cbiAqIFJGQyA4NDUyLCBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzg0NTJcbiAqL1xuZXhwb3J0cy5zaXYgPSAoMCwgdXRpbHNfanNfMS53cmFwQ2lwaGVyKSh7IGJsb2NrU2l6ZTogMTYsIG5vbmNlTGVuZ3RoOiAxMiwgdGFnTGVuZ3RoOiAxNiB9LCBmdW5jdGlvbiBzaXYoa2V5LCBub25jZSwgQUFEKSB7XG4gICAgY29uc3QgdGFnTGVuZ3RoID0gMTY7XG4gICAgLy8gRnJvbSBSRkMgODQ1MjogU2VjdGlvbiA2XG4gICAgY29uc3QgQUFEX0xJTUlUID0gbGltaXQoJ0FBRCcsIDAsIDIgKiogMzYpO1xuICAgIGNvbnN0IFBMQUlOX0xJTUlUID0gbGltaXQoJ3BsYWludGV4dCcsIDAsIDIgKiogMzYpO1xuICAgIGNvbnN0IE5PTkNFX0xJTUlUID0gbGltaXQoJ25vbmNlJywgMTIsIDEyKTtcbiAgICBjb25zdCBDSVBIRVJfTElNSVQgPSBsaW1pdCgnY2lwaGVydGV4dCcsIDE2LCAyICoqIDM2ICsgMTYpO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGtleSwgMTYsIDI0LCAzMik7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykobm9uY2UpO1xuICAgIE5PTkNFX0xJTUlUKG5vbmNlLmxlbmd0aCk7XG4gICAgaWYgKEFBRCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKEFBRCk7XG4gICAgICAgIEFBRF9MSU1JVChBQUQubGVuZ3RoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVyaXZlS2V5cygpIHtcbiAgICAgICAgY29uc3QgeGsgPSBleHBhbmRLZXlMRShrZXkpO1xuICAgICAgICBjb25zdCBlbmNLZXkgPSBuZXcgVWludDhBcnJheShrZXkubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgYXV0aEtleSA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgICAgICAgY29uc3QgdG9DbGVhbiA9IFt4aywgZW5jS2V5XTtcbiAgICAgICAgbGV0IF9ub25jZSA9IG5vbmNlO1xuICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmlzQWxpZ25lZDMyKShfbm9uY2UpKVxuICAgICAgICAgICAgdG9DbGVhbi5wdXNoKChfbm9uY2UgPSAoMCwgdXRpbHNfanNfMS5jb3B5Qnl0ZXMpKF9ub25jZSkpKTtcbiAgICAgICAgY29uc3QgbjMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShfbm9uY2UpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IHMwID0gMCwgczEgPSBuMzJbMF0sIHMyID0gbjMyWzFdLCBzMyA9IG4zMlsyXTtcbiAgICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGRlcml2ZWRLZXkgb2YgW2F1dGhLZXksIGVuY0tleV0ubWFwKHV0aWxzX2pzXzEudTMyKSkge1xuICAgICAgICAgICAgY29uc3QgZDMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShkZXJpdmVkS2V5KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZDMyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgLy8gYWVzKHUzMmxlKDApIHx8IG5vbmNlKVs6OF0gfHwgYWVzKHUzMmxlKDEpIHx8IG5vbmNlKVs6OF0gLi4uXG4gICAgICAgICAgICAgICAgY29uc3QgeyBzMDogbzAsIHMxOiBvMSB9ID0gZW5jcnlwdCh4aywgczAsIHMxLCBzMiwgczMpO1xuICAgICAgICAgICAgICAgIGQzMltpICsgMF0gPSBvMDtcbiAgICAgICAgICAgICAgICBkMzJbaSArIDFdID0gbzE7XG4gICAgICAgICAgICAgICAgczAgPSArK2NvdW50ZXI7IC8vIGluY3JlbWVudCBjb3VudGVyIGluc2lkZSBzdGF0ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IHsgYXV0aEtleSwgZW5jS2V5OiBleHBhbmRLZXlMRShlbmNLZXkpIH07XG4gICAgICAgIC8vIENsZWFudXBcbiAgICAgICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKC4uLnRvQ2xlYW4pO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfY29tcHV0ZVRhZyhlbmNLZXksIGF1dGhLZXksIGRhdGEpIHtcbiAgICAgICAgY29uc3QgdGFnID0gY29tcHV0ZVRhZyhfcG9seXZhbF9qc18xLnBvbHl2YWwsIHRydWUsIGF1dGhLZXksIGRhdGEsIEFBRCk7XG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGV4cGVjdGVkIHRhZyBieSBYT1JpbmcgU19zIGFuZCB0aGUgbm9uY2UsIGNsZWFyaW5nIHRoZVxuICAgICAgICAvLyBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgbGFzdCBieXRlIGFuZCBlbmNyeXB0aW5nIHdpdGggdGhlXG4gICAgICAgIC8vIG1lc3NhZ2UtZW5jcnlwdGlvbiBrZXkuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKylcbiAgICAgICAgICAgIHRhZ1tpXSBePSBub25jZVtpXTtcbiAgICAgICAgdGFnWzE1XSAmPSAweDdmOyAvLyBDbGVhciB0aGUgaGlnaGVzdCBiaXRcbiAgICAgICAgLy8gZW5jcnlwdCB0YWcgYXMgYmxvY2tcbiAgICAgICAgY29uc3QgdDMyID0gKDAsIHV0aWxzX2pzXzEudTMyKSh0YWcpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IHMwID0gdDMyWzBdLCBzMSA9IHQzMlsxXSwgczIgPSB0MzJbMl0sIHMzID0gdDMyWzNdO1xuICAgICAgICAoeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdChlbmNLZXksIHMwLCBzMSwgczIsIHMzKSk7XG4gICAgICAgICh0MzJbMF0gPSBzMCksICh0MzJbMV0gPSBzMSksICh0MzJbMl0gPSBzMiksICh0MzJbM10gPSBzMyk7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIC8vIGFjdHVhbCBkZWNyeXB0L2VuY3J5cHQgb2YgbWVzc2FnZS5cbiAgICBmdW5jdGlvbiBwcm9jZXNzU2l2KGVuY0tleSwgdGFnLCBpbnB1dCkge1xuICAgICAgICBsZXQgYmxvY2sgPSAoMCwgdXRpbHNfanNfMS5jb3B5Qnl0ZXMpKHRhZyk7XG4gICAgICAgIGJsb2NrWzE1XSB8PSAweDgwOyAvLyBGb3JjZSBoaWdoZXN0IGJpdFxuICAgICAgICBjb25zdCByZXMgPSBjdHIzMihlbmNLZXksIHRydWUsIGJsb2NrLCBpbnB1dCk7XG4gICAgICAgIC8vIENsZWFudXBcbiAgICAgICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKGJsb2NrKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jcnlwdChwbGFpbnRleHQpIHtcbiAgICAgICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKHBsYWludGV4dCk7XG4gICAgICAgICAgICBQTEFJTl9MSU1JVChwbGFpbnRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZW5jS2V5LCBhdXRoS2V5IH0gPSBkZXJpdmVLZXlzKCk7XG4gICAgICAgICAgICBjb25zdCB0YWcgPSBfY29tcHV0ZVRhZyhlbmNLZXksIGF1dGhLZXksIHBsYWludGV4dCk7XG4gICAgICAgICAgICBjb25zdCB0b0NsZWFuID0gW2VuY0tleSwgYXV0aEtleSwgdGFnXTtcbiAgICAgICAgICAgIGlmICghKDAsIHV0aWxzX2pzXzEuaXNBbGlnbmVkMzIpKHBsYWludGV4dCkpXG4gICAgICAgICAgICAgICAgdG9DbGVhbi5wdXNoKChwbGFpbnRleHQgPSAoMCwgdXRpbHNfanNfMS5jb3B5Qnl0ZXMpKHBsYWludGV4dCkpKTtcbiAgICAgICAgICAgIGNvbnN0IG91dCA9IG5ldyBVaW50OEFycmF5KHBsYWludGV4dC5sZW5ndGggKyB0YWdMZW5ndGgpO1xuICAgICAgICAgICAgb3V0LnNldCh0YWcsIHBsYWludGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgb3V0LnNldChwcm9jZXNzU2l2KGVuY0tleSwgdGFnLCBwbGFpbnRleHQpKTtcbiAgICAgICAgICAgIC8vIENsZWFudXBcbiAgICAgICAgICAgICgwLCB1dGlsc19qc18xLmNsZWFuKSguLi50b0NsZWFuKTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY3J5cHQoY2lwaGVydGV4dCkge1xuICAgICAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykoY2lwaGVydGV4dCk7XG4gICAgICAgICAgICBDSVBIRVJfTElNSVQoY2lwaGVydGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgdGFnID0gY2lwaGVydGV4dC5zdWJhcnJheSgtdGFnTGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZW5jS2V5LCBhdXRoS2V5IH0gPSBkZXJpdmVLZXlzKCk7XG4gICAgICAgICAgICBjb25zdCB0b0NsZWFuID0gW2VuY0tleSwgYXV0aEtleV07XG4gICAgICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmlzQWxpZ25lZDMyKShjaXBoZXJ0ZXh0KSlcbiAgICAgICAgICAgICAgICB0b0NsZWFuLnB1c2goKGNpcGhlcnRleHQgPSAoMCwgdXRpbHNfanNfMS5jb3B5Qnl0ZXMpKGNpcGhlcnRleHQpKSk7XG4gICAgICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBwcm9jZXNzU2l2KGVuY0tleSwgdGFnLCBjaXBoZXJ0ZXh0LnN1YmFycmF5KDAsIC10YWdMZW5ndGgpKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVGFnID0gX2NvbXB1dGVUYWcoZW5jS2V5LCBhdXRoS2V5LCBwbGFpbnRleHQpO1xuICAgICAgICAgICAgdG9DbGVhbi5wdXNoKGV4cGVjdGVkVGFnKTtcbiAgICAgICAgICAgIGlmICghKDAsIHV0aWxzX2pzXzEuZXF1YWxCeXRlcykodGFnLCBleHBlY3RlZFRhZykpIHtcbiAgICAgICAgICAgICAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikoLi4udG9DbGVhbik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvbHl2YWwgdGFnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDbGVhbnVwXG4gICAgICAgICAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikoLi4udG9DbGVhbik7XG4gICAgICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuICAgICAgICB9LFxuICAgIH07XG59KTtcbmZ1bmN0aW9uIGlzQnl0ZXMzMihhKSB7XG4gICAgcmV0dXJuIChhICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmXG4gICAgICAgIChhIGluc3RhbmNlb2YgVWludDMyQXJyYXkgfHwgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDMyQXJyYXknKSk7XG59XG5mdW5jdGlvbiBlbmNyeXB0QmxvY2soeGssIGJsb2NrKSB7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykoYmxvY2ssIDE2KTtcbiAgICBpZiAoIWlzQnl0ZXMzMih4aykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignX2VuY3J5cHRCbG9jayBhY2NlcHRzIHJlc3VsdCBvZiBleHBhbmRLZXlMRScpO1xuICAgIGNvbnN0IGIzMiA9ICgwLCB1dGlsc19qc18xLnUzMikoYmxvY2spO1xuICAgIGxldCB7IHMwLCBzMSwgczIsIHMzIH0gPSBlbmNyeXB0KHhrLCBiMzJbMF0sIGIzMlsxXSwgYjMyWzJdLCBiMzJbM10pO1xuICAgIChiMzJbMF0gPSBzMCksIChiMzJbMV0gPSBzMSksIChiMzJbMl0gPSBzMiksIChiMzJbM10gPSBzMyk7XG4gICAgcmV0dXJuIGJsb2NrO1xufVxuZnVuY3Rpb24gZGVjcnlwdEJsb2NrKHhrLCBibG9jaykge1xuICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGJsb2NrLCAxNik7XG4gICAgaWYgKCFpc0J5dGVzMzIoeGspKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19kZWNyeXB0QmxvY2sgYWNjZXB0cyByZXN1bHQgb2YgZXhwYW5kS2V5TEUnKTtcbiAgICBjb25zdCBiMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKGJsb2NrKTtcbiAgICBsZXQgeyBzMCwgczEsIHMyLCBzMyB9ID0gZGVjcnlwdCh4aywgYjMyWzBdLCBiMzJbMV0sIGIzMlsyXSwgYjMyWzNdKTtcbiAgICAoYjMyWzBdID0gczApLCAoYjMyWzFdID0gczEpLCAoYjMyWzJdID0gczIpLCAoYjMyWzNdID0gczMpO1xuICAgIHJldHVybiBibG9jaztcbn1cbi8qKlxuICogQUVTLVcgKGJhc2UgZm9yIEFFU0tXL0FFU0tXUCkuXG4gKiBTcGVjczogW1NQODAwLTM4Rl0oaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL1NwZWNpYWxQdWJsaWNhdGlvbnMvTklTVC5TUC44MDAtMzhGLnBkZiksXG4gKiBbUkZDIDMzOTRdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL3JmYzMzOTQvKSxcbiAqIFtSRkMgNTY0OV0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvcmZjNTY0OS8pLlxuICovXG5jb25zdCBBRVNXID0ge1xuICAgIC8qXG4gICAgSGlnaC1sZXZlbCBwc2V1ZG9jb2RlOlxuICAgIGBgYFxuICAgIEE6IHU2NCA9IElWXG4gICAgb3V0ID0gW11cbiAgICBmb3IgKGxldCBpPTAsIGN0ciA9IDA7IGk8NjsgaSsrKSB7XG4gICAgICBmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcyhwbGFpbnRleHQsIDgpKSB7XG4gICAgICAgIEEgXj0gc3dhcEVuZGlhbmVzcyhjdHIrKylcbiAgICAgICAgW0EsIHJlc10gPSBjaHVua3MoZW5jcnlwdChBIHx8IGNodW5rKSwgOCk7XG4gICAgICAgIG91dCB8fD0gcmVzXG4gICAgICB9XG4gICAgfVxuICAgIG91dCA9IEEgfHwgb3V0XG4gICAgYGBgXG4gICAgRGVjcnlwdCBpcyB0aGUgc2FtZSwgYnV0IHJldmVyc2VkLlxuICAgICovXG4gICAgZW5jcnlwdChrZWssIG91dCkge1xuICAgICAgICAvLyBTaXplIGlzIGxpbWl0ZWQgdG8gNEdCLCBvdGhlcndpc2UgY3RyIHdpbGwgb3ZlcmZsb3cgYW5kIHdlJ2xsIG5lZWQgdG8gc3dpdGNoIHRvIGJpZ2ludHMuXG4gICAgICAgIC8vIElmIHlvdSBuZWVkIGl0IGxhcmdlciwgb3BlbiBhbiBpc3N1ZS5cbiAgICAgICAgaWYgKG91dC5sZW5ndGggPj0gMiAqKiAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncGxhaW50ZXh0IHNob3VsZCBiZSBsZXNzIHRoYW4gNGdiJyk7XG4gICAgICAgIGNvbnN0IHhrID0gZXhwYW5kS2V5TEUoa2VrKTtcbiAgICAgICAgaWYgKG91dC5sZW5ndGggPT09IDE2KVxuICAgICAgICAgICAgZW5jcnlwdEJsb2NrKHhrLCBvdXQpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG8zMiA9ICgwLCB1dGlsc19qc18xLnUzMikob3V0KTtcbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgbGV0IGEwID0gbzMyWzBdLCBhMSA9IG8zMlsxXTsgLy8gQVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDAsIGN0ciA9IDE7IGogPCA2OyBqKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MgPSAyOyBwb3MgPCBvMzIubGVuZ3RoOyBwb3MgKz0gMiwgY3RyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzMCwgczEsIHMyLCBzMyB9ID0gZW5jcnlwdCh4aywgYTAsIGExLCBvMzJbcG9zXSwgbzMyW3BvcyArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSA9IE1TQig2NCwgQikgXiB0IHdoZXJlIHQgPSAobipqKStpXG4gICAgICAgICAgICAgICAgICAgIChhMCA9IHMwKSwgKGExID0gczEgXiBieXRlU3dhcChjdHIpKSwgKG8zMltwb3NdID0gczIpLCAobzMyW3BvcyArIDFdID0gczMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChvMzJbMF0gPSBhMCksIChvMzJbMV0gPSBhMSk7IC8vIG91dCA9IEEgfHwgb3V0XG4gICAgICAgIH1cbiAgICAgICAgeGsuZmlsbCgwKTtcbiAgICB9LFxuICAgIGRlY3J5cHQoa2VrLCBvdXQpIHtcbiAgICAgICAgaWYgKG91dC5sZW5ndGggLSA4ID49IDIgKiogMzIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NpcGhlcnRleHQgc2hvdWxkIGJlIGxlc3MgdGhhbiA0Z2InKTtcbiAgICAgICAgY29uc3QgeGsgPSBleHBhbmRLZXlEZWNMRShrZWspO1xuICAgICAgICBjb25zdCBjaHVua3MgPSBvdXQubGVuZ3RoIC8gOCAtIDE7IC8vIGZpcnN0IGNodW5rIGlzIElWXG4gICAgICAgIGlmIChjaHVua3MgPT09IDEpXG4gICAgICAgICAgICBkZWNyeXB0QmxvY2soeGssIG91dCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbzMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShvdXQpO1xuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgYTAgPSBvMzJbMF0sIGExID0gbzMyWzFdOyAvLyBBXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgY3RyID0gY2h1bmtzICogNjsgaiA8IDY7IGorKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IGNodW5rcyAqIDI7IHBvcyA+PSAxOyBwb3MgLT0gMiwgY3RyLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgYTEgXj0gYnl0ZVN3YXAoY3RyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzMCwgczEsIHMyLCBzMyB9ID0gZGVjcnlwdCh4aywgYTAsIGExLCBvMzJbcG9zXSwgbzMyW3BvcyArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgKGEwID0gczApLCAoYTEgPSBzMSksIChvMzJbcG9zXSA9IHMyKSwgKG8zMltwb3MgKyAxXSA9IHMzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAobzMyWzBdID0gYTApLCAobzMyWzFdID0gYTEpO1xuICAgICAgICB9XG4gICAgICAgIHhrLmZpbGwoMCk7XG4gICAgfSxcbn07XG5jb25zdCBBRVNLV19JViA9IG5ldyBVaW50OEFycmF5KDgpLmZpbGwoMHhhNik7IC8vIEE2QTZBNkE2QTZBNkE2QTZcbi8qKlxuICogQUVTLUtXIChrZXktd3JhcCkuIEluamVjdHMgc3RhdGljIElWIGludG8gcGxhaW50ZXh0LCBhZGRzIGNvdW50ZXIsIGVuY3J5cHRzIDYgdGltZXMuXG4gKiBSZWR1Y2VzIGJsb2NrIHNpemUgZnJvbSAxNiB0byA4IGJ5dGVzLlxuICogRm9yIHBhZGRlZCB2ZXJzaW9uLCB1c2UgYWVza3dwLlxuICogW1JGQyAzMzk0XShodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9yZmMzMzk0LyksXG4gKiBbTklTVC5TUC44MDAtMzhGXShodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvU3BlY2lhbFB1YmxpY2F0aW9ucy9OSVNULlNQLjgwMC0zOEYucGRmKS5cbiAqL1xuZXhwb3J0cy5hZXNrdyA9ICgwLCB1dGlsc19qc18xLndyYXBDaXBoZXIpKHsgYmxvY2tTaXplOiA4IH0sIChrZWspID0+ICh7XG4gICAgZW5jcnlwdChwbGFpbnRleHQpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykocGxhaW50ZXh0KTtcbiAgICAgICAgaWYgKCFwbGFpbnRleHQubGVuZ3RoIHx8IHBsYWludGV4dC5sZW5ndGggJSA4ICE9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBsYWludGV4dCBsZW5ndGgnKTtcbiAgICAgICAgaWYgKHBsYWludGV4dC5sZW5ndGggPT09IDgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzgtYnl0ZSBrZXlzIG5vdCBhbGxvd2VkIGluIEFFU0tXLCB1c2UgQUVTS1dQIGluc3RlYWQnKTtcbiAgICAgICAgY29uc3Qgb3V0ID0gKDAsIHV0aWxzX2pzXzEuY29uY2F0Qnl0ZXMpKEFFU0tXX0lWLCBwbGFpbnRleHQpO1xuICAgICAgICBBRVNXLmVuY3J5cHQoa2VrLCBvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH0sXG4gICAgZGVjcnlwdChjaXBoZXJ0ZXh0KSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGNpcGhlcnRleHQpO1xuICAgICAgICAvLyBjaXBoZXJ0ZXh0IG11c3QgYmUgYXQgbGVhc3QgMjQgYnl0ZXMgYW5kIGEgbXVsdGlwbGUgb2YgOCBieXRlc1xuICAgICAgICAvLyAyNCBiZWNhdXNlIHNob3VsZCBoYXZlIGF0IGxlYXN0IHR3byBibG9jayAoMSBpdiArIDIpLlxuICAgICAgICAvLyBSZXBsYWNlIHdpdGggMTYgdG8gZW5hYmxlICc4LWJ5dGUga2V5cydcbiAgICAgICAgaWYgKGNpcGhlcnRleHQubGVuZ3RoICUgOCAhPT0gMCB8fCBjaXBoZXJ0ZXh0Lmxlbmd0aCA8IDMgKiA4KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNpcGhlcnRleHQgbGVuZ3RoJyk7XG4gICAgICAgIGNvbnN0IG91dCA9ICgwLCB1dGlsc19qc18xLmNvcHlCeXRlcykoY2lwaGVydGV4dCk7XG4gICAgICAgIEFFU1cuZGVjcnlwdChrZWssIG91dCk7XG4gICAgICAgIGlmICghKDAsIHV0aWxzX2pzXzEuZXF1YWxCeXRlcykob3V0LnN1YmFycmF5KDAsIDgpLCBBRVNLV19JVikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludGVncml0eSBjaGVjayBmYWlsZWQnKTtcbiAgICAgICAgb3V0LnN1YmFycmF5KDAsIDgpLmZpbGwoMCk7IC8vIGNpcGhlcnRleHQuc3ViYXJyYXkoMCwgOCkgPT09IElWLCBidXQgd2UgY2xlYW4gaXQgYW55d2F5XG4gICAgICAgIHJldHVybiBvdXQuc3ViYXJyYXkoOCk7XG4gICAgfSxcbn0pKTtcbi8qXG5XZSBkb24ndCBzdXBwb3J0IDgtYnl0ZSBrZXlzLiBUaGUgcmFiYml0IGhvbGU6XG5cbi0gV3ljaGVwcm9vZiBzYXlzOiBcIk5JU1QgU1AgODAwLTM4RiBkb2VzIG5vdCBkZWZpbmUgdGhlIHdyYXBwaW5nIG9mIDggYnl0ZSBrZXlzLlxuICBSRkMgMzM5NCBTZWN0aW9uIDIgIG9uIHRoZSBvdGhlciBoYW5kIHNwZWNpZmllcyB0aGF0IDggYnl0ZSBrZXlzIGFyZSB3cmFwcGVkXG4gIGJ5IGRpcmVjdGx5IGVuY3J5cHRpbmcgb25lIGJsb2NrIHdpdGggQUVTLlwiXG4gICAgLSBodHRwczovL2dpdGh1Yi5jb20vQzJTUC93eWNoZXByb29mL2Jsb2IvbWFzdGVyL2RvYy9rZXlfd3JhcC5tZFxuICAgIC0gXCJSRkMgMzM5NCBzcGVjaWZpZXMgaW4gU2VjdGlvbiAyLCB0aGF0IHRoZSBpbnB1dCBmb3IgdGhlIGtleSB3cmFwXG4gICAgICBhbGdvcml0aG0gbXVzdCBiZSBhdCBsZWFzdCB0d28gYmxvY2tzIGFuZCBvdGhlcndpc2UgdGhlIGNvbnN0YW50XG4gICAgICBmaWVsZCBhbmQga2V5IGFyZSBzaW1wbHkgZW5jcnlwdGVkIHdpdGggRUNCIGFzIGEgc2luZ2xlIGJsb2NrXCJcbi0gV2hhdCBSRkMgMzM5NCBhY3R1YWxseSBzYXlzIChpbiBTZWN0aW9uIDIpOlxuICAgIC0gXCJCZWZvcmUgYmVpbmcgd3JhcHBlZCwgdGhlIGtleSBkYXRhIGlzIHBhcnNlZCBpbnRvIG4gYmxvY2tzIG9mIDY0IGJpdHMuXG4gICAgICBUaGUgb25seSByZXN0cmljdGlvbiB0aGUga2V5IHdyYXAgYWxnb3JpdGhtIHBsYWNlcyBvbiBuIGlzIHRoYXQgbiBiZVxuICAgICAgYXQgbGVhc3QgdHdvXCJcbiAgICAtIFwiRm9yIGtleSBkYXRhIHdpdGggbGVuZ3RoIGxlc3MgdGhhbiBvciBlcXVhbCB0byA2NCBiaXRzLCB0aGUgY29uc3RhbnRcbiAgICAgIGZpZWxkIHVzZWQgaW4gdGhpcyBzcGVjaWZpY2F0aW9uIGFuZCB0aGUga2V5IGRhdGEgZm9ybSBhIHNpbmdsZVxuICAgICAgMTI4LWJpdCBjb2RlYm9vayBpbnB1dCBtYWtpbmcgdGhpcyBrZXkgd3JhcCB1bm5lY2Vzc2FyeS5cIlxuLSBXaGljaCBtZWFucyBcImFzc2VydChuID49IDIpXCIgYW5kIFwidXNlIHNvbWV0aGluZyBlbHNlIGZvciA4IGJ5dGUga2V5c1wiXG4tIE5JU1QgU1A4MDAtMzhGIGFjdHVhbGx5IHByb2hpYml0cyA4LWJ5dGUgaW4gXCI1LjMuMSBNYW5kYXRvcnkgTGltaXRzXCIuXG4gIEl0IHN0YXRlcyB0aGF0IHBsYWludGV4dCBmb3IgS1cgc2hvdWxkIGJlIFwiMiB0byAyXjU0IC0xIHNlbWlibG9ja3NcIi5cbi0gU28sIHdoZXJlIGRvZXMgXCJkaXJlY3RseSBlbmNyeXB0IHNpbmdsZSBibG9jayB3aXRoIEFFU1wiIGNvbWUgZnJvbT9cbiAgICAtIE5vdCBSRkMgMzM5NC4gUHNldWRvY29kZSBvZiBrZXkgd3JhcCBpbiAyLjIgZXhwbGljaXRseSB1c2VzXG4gICAgICBsb29wIG9mIDYgZm9yIGFueSBjb2RlIHBhdGhcbiAgICAtIFRoZXJlIGlzIGEgd2VpcmQgVzNDIHNwZWM6XG4gICAgICBodHRwczovL3d3dy53My5vcmcvVFIvMjAwMi9SRUMteG1sZW5jLWNvcmUtMjAwMjEyMTAvT3ZlcnZpZXcuaHRtbCNrdy1hZXMxMjhcbiAgICAtIFRoaXMgc3BlYyBpcyBvdXRkYXRlZCwgYXMgYWRtaXR0ZWQgYnkgV3ljaGVwcm9vZiBhdXRob3JzXG4gICAgLSBUaGVyZSBpcyBSRkMgNTY0OSBmb3IgcGFkZGVkIGtleSB3cmFwLCB3aGljaCBpcyBwYWRkaW5nIGNvbnN0cnVjdGlvbiBvblxuICAgICAgdG9wIG9mIEFFU0tXLiBJbiAnNC4xLjInIGl0IHNheXM6IFwiSWYgdGhlIHBhZGRlZCBwbGFpbnRleHQgY29udGFpbnMgZXhhY3RseVxuICAgICAgZWlnaHQgb2N0ZXRzLCB0aGVuIHByZXBlbmQgdGhlIEFJViBhcyBkZWZpbmVkIGluIFNlY3Rpb24gMyBhYm92ZSB0byBQWzFdIGFuZFxuICAgICAgZW5jcnlwdCB0aGUgcmVzdWx0aW5nIDEyOC1iaXQgYmxvY2sgdXNpbmcgQUVTIGluIEVDQiBtb2RlIFtNb2Rlc10gd2l0aCBrZXlcbiAgICAgIEsgKHRoZSBLRUspLiAgSW4gdGhpcyBjYXNlLCB0aGUgb3V0cHV0IGlzIHR3byA2NC1iaXQgYmxvY2tzIENbMF0gYW5kIENbMV06XCJcbiAgICAtIEJyb3dzZXIgc3VidGxlIGNyeXB0byBpcyBhY3R1YWxseSBjcmFzaGVzIG9uIHdyYXBwaW5nIGtleXMgbGVzcyB0aGFuIDE2IGJ5dGVzOlxuICAgICAgYEVycm9yOiBlcnJvcjoxQzgwMDBFNjpQcm92aWRlciByb3V0aW5lczo6aW52YWxpZCBpbnB1dCBsZW5ndGhdIHsgb3BlbnNzbEVycm9yU3RhY2s6IFsgJ2Vycm9yOjAzMDAwMEJEOmRpZ2l0YWwgZW52ZWxvcGUgcm91dGluZXM6OnVwZGF0ZSBlcnJvcicgXWBcblxuSW4gdGhlIGVuZCwgc2VlbXMgbGlrZSBhIGJ1ZyBpbiBXeWNoZXByb29mLlxuVGhlIDgtYnl0ZSBjaGVjayBjYW4gYmUgZWFzaWx5IGRpc2FibGVkIGluc2lkZSBvZiBBRVNfVy5cbiovXG5jb25zdCBBRVNLV1BfSVYgPSAweGE2NTk1OWE2OyAvLyBzaW5nbGUgdTMybGUgdmFsdWVcbi8qKlxuICogQUVTLUtXLCBidXQgd2l0aCBwYWRkaW5nIGFuZCBhbGxvd3MgcmFuZG9tIGtleXMuXG4gKiBTZWNvbmQgdTMyIG9mIElWIGlzIHVzZWQgYXMgY291bnRlciBmb3IgbGVuZ3RoLlxuICogW1JGQyA1NjQ5XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjNTY0OSlcbiAqL1xuZXhwb3J0cy5hZXNrd3AgPSAoMCwgdXRpbHNfanNfMS53cmFwQ2lwaGVyKSh7IGJsb2NrU2l6ZTogOCB9LCAoa2VrKSA9PiAoe1xuICAgIGVuY3J5cHQocGxhaW50ZXh0KSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKHBsYWludGV4dCk7XG4gICAgICAgIGlmICghcGxhaW50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwbGFpbnRleHQgbGVuZ3RoJyk7XG4gICAgICAgIGNvbnN0IHBhZGRlZCA9IE1hdGguY2VpbChwbGFpbnRleHQubGVuZ3RoIC8gOCkgKiA4O1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSg4ICsgcGFkZGVkKTtcbiAgICAgICAgb3V0LnNldChwbGFpbnRleHQsIDgpO1xuICAgICAgICBjb25zdCBvdXQzMiA9ICgwLCB1dGlsc19qc18xLnUzMikob3V0KTtcbiAgICAgICAgb3V0MzJbMF0gPSBBRVNLV1BfSVY7XG4gICAgICAgIG91dDMyWzFdID0gYnl0ZVN3YXAocGxhaW50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIEFFU1cuZW5jcnlwdChrZWssIG91dCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfSxcbiAgICBkZWNyeXB0KGNpcGhlcnRleHQpIHtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykoY2lwaGVydGV4dCk7XG4gICAgICAgIC8vIDE2IGJlY2F1c2Ugc2hvdWxkIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrXG4gICAgICAgIGlmIChjaXBoZXJ0ZXh0Lmxlbmd0aCA8IDE2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNpcGhlcnRleHQgbGVuZ3RoJyk7XG4gICAgICAgIGNvbnN0IG91dCA9ICgwLCB1dGlsc19qc18xLmNvcHlCeXRlcykoY2lwaGVydGV4dCk7XG4gICAgICAgIGNvbnN0IG8zMiA9ICgwLCB1dGlsc19qc18xLnUzMikob3V0KTtcbiAgICAgICAgQUVTVy5kZWNyeXB0KGtlaywgb3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gYnl0ZVN3YXAobzMyWzFdKSA+Pj4gMDtcbiAgICAgICAgY29uc3QgcGFkZGVkID0gTWF0aC5jZWlsKGxlbiAvIDgpICogODtcbiAgICAgICAgaWYgKG8zMlswXSAhPT0gQUVTS1dQX0lWIHx8IG91dC5sZW5ndGggLSA4ICE9PSBwYWRkZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludGVncml0eSBjaGVjayBmYWlsZWQnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGxlbjsgaSA8IHBhZGRlZDsgaSsrKVxuICAgICAgICAgICAgaWYgKG91dFs4ICsgaV0gIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnRlZ3JpdHkgY2hlY2sgZmFpbGVkJyk7XG4gICAgICAgIG91dC5zdWJhcnJheSgwLCA4KS5maWxsKDApOyAvLyBjaXBoZXJ0ZXh0LnN1YmFycmF5KDAsIDgpID09PSBJViwgYnV0IHdlIGNsZWFuIGl0IGFueXdheVxuICAgICAgICByZXR1cm4gb3V0LnN1YmFycmF5KDgsIDggKyBsZW4pO1xuICAgIH0sXG59KSk7XG4vLyBQcml2YXRlLCB1bnNhZmUgbG93LWxldmVsIG1ldGhvZHMuIENhbiBjaGFuZ2UgYXQgYW55IHRpbWUuXG5leHBvcnRzLnVuc2FmZSA9IHtcbiAgICBleHBhbmRLZXlMRSxcbiAgICBleHBhbmRLZXlEZWNMRSxcbiAgICBlbmNyeXB0LFxuICAgIGRlY3J5cHQsXG4gICAgZW5jcnlwdEJsb2NrLFxuICAgIGRlY3J5cHRCbG9jayxcbiAgICBjdHJDb3VudGVyLFxuICAgIGN0cjMyLFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYWVzMjU2Y2JjID0gZXhwb3J0cy5hZXMyNTZnY20gPSB2b2lkIDA7XG52YXIgYWVzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2NpcGhlcnMvYWVzXCIpO1xudmFyIGFlczI1NmdjbSA9IGZ1bmN0aW9uIChrZXksIG5vbmNlLCBBQUQpIHtcbiAgICByZXR1cm4gKDAsIGFlc18xLmdjbSkoa2V5LCBub25jZSwgQUFEKTtcbn07XG5leHBvcnRzLmFlczI1NmdjbSA9IGFlczI1NmdjbTtcbnZhciBhZXMyNTZjYmMgPSBmdW5jdGlvbiAoa2V5LCBub25jZSwgQUFEKSB7XG4gICAgcmV0dXJuICgwLCBhZXNfMS5jYmMpKGtleSwgbm9uY2UpO1xufTtcbmV4cG9ydHMuYWVzMjU2Y2JjID0gYWVzMjU2Y2JjO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNpZ21hID0gdm9pZCAwO1xuZXhwb3J0cy5yb3RsID0gcm90bDtcbmV4cG9ydHMuY3JlYXRlQ2lwaGVyID0gY3JlYXRlQ2lwaGVyO1xuLy8gQmFzaWMgdXRpbHMgZm9yIEFSWCAoYWRkLXJvdGF0ZS14b3IpIHNhbHNhIGFuZCBjaGFjaGEgY2lwaGVycy5cbmNvbnN0IF9hc3NlcnRfanNfMSA9IHJlcXVpcmUoXCIuL19hc3NlcnQuanNcIik7XG5jb25zdCB1dGlsc19qc18xID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG4vKlxuUkZDODQzOSByZXF1aXJlcyBtdWx0aS1zdGVwIGNpcGhlciBzdHJlYW0sIHdoZXJlXG5hdXRoS2V5IHN0YXJ0cyB3aXRoIGNvdW50ZXI6IDAsIGFjdHVhbCBtc2cgd2l0aCBjb3VudGVyOiAxLlxuXG5Gb3IgdGhpcywgd2UgbmVlZCBhIHdheSB0byByZS11c2Ugbm9uY2UgLyBjb3VudGVyOlxuXG4gICAgY29uc3QgY291bnRlciA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNoYWNoYSguLi4sIGNvdW50ZXIsIC4uLik7IC8vIGNvdW50ZXIgaXMgbm93IDFcbiAgICBjaGFjaGEoLi4uLCBjb3VudGVyLCAuLi4pOyAvLyBjb3VudGVyIGlzIG5vdyAyXG5cblRoaXMgaXMgY29tcGxpY2F0ZWQ6XG5cbi0gMzItYml0IGNvdW50ZXJzIGFyZSBlbm91Z2gsIG5vIG5lZWQgZm9yIDY0LWJpdDogbWF4IEFycmF5QnVmZmVyIHNpemUgaW4gSlMgaXMgNEdCXG4tIE9yaWdpbmFsIHBhcGVycyBkb24ndCBhbGxvdyBtdXRhdGluZyBjb3VudGVyc1xuLSBDb3VudGVyIG92ZXJmbG93IGlzIHVuZGVmaW5lZCBbXjFdXG4tIElkZWEgQTogYWxsb3cgcHJvdmlkaW5nIChub25jZSB8IGNvdW50ZXIpIGluc3RlYWQgb2YganVzdCBub25jZSwgcmUtdXNlIGl0XG4tIENhdmVhdDogQ2Fubm90IGJlIHJlLXVzZWQgdGhyb3VnaCBhbGwgY2FzZXM6XG4tICogY2hhY2hhIGhhcyAoY291bnRlciB8IG5vbmNlKVxuLSAqIHhjaGFjaGEgaGFzIChub25jZTE2IHwgY291bnRlciB8IG5vbmNlMTYpXG4tIElkZWEgQjogc2VwYXJhdGUgbm9uY2UgLyBjb3VudGVyIGFuZCBwcm92aWRlIHNlcGFyYXRlIEFQSSBmb3IgY291bnRlciByZS11c2Vcbi0gQ2F2ZWF0OiB0aGVyZSBhcmUgZGlmZmVyZW50IGNvdW50ZXIgc2l6ZXMgZGVwZW5kaW5nIG9uIGFuIGFsZ29yaXRobS5cbi0gc2Fsc2EgJiBjaGFjaGEgYWxzbyBkaWZmZXIgaW4gc3RydWN0dXJlcyBvZiBrZXkgJiBzaWdtYTpcbiAgc2Fsc2EyMDogICAgICBzWzBdIHwgayg0KSB8IHNbMV0gfCBub25jZSgyKSB8IGN0cigyKSB8IHNbMl0gfCBrKDQpIHwgc1szXVxuICBjaGFjaGE6ICAgICAgIHMoNCkgfCBrKDgpIHwgY3RyKDEpIHwgbm9uY2UoMylcbiAgY2hhY2hhMjBvcmlnOiBzKDQpIHwgayg4KSB8IGN0cigyKSB8IG5vbmNlKDIpXG4tIElkZWEgQzogaGVscGVyIG1ldGhvZCBzdWNoIGFzIGBzZXRTYWxzYVN0YXRlKGtleSwgbm9uY2UsIHNpZ21hLCBkYXRhKWBcbi0gQ2F2ZWF0OiB3ZSBjYW4ndCByZS11c2UgY291bnRlciBhcnJheVxuXG54Y2hhY2hhIFteMl0gdXNlcyB0aGUgc3Via2V5IGFuZCByZW1haW5pbmcgOCBieXRlIG5vbmNlIHdpdGggQ2hhQ2hhMjAgYXMgbm9ybWFsXG4ocHJlZml4ZWQgYnkgNCBOVUwgYnl0ZXMsIHNpbmNlIFtSRkM4NDM5XSBzcGVjaWZpZXMgYSAxMi1ieXRlIG5vbmNlKS5cblxuW14xXTogaHR0cHM6Ly9tYWlsYXJjaGl2ZS5pZXRmLm9yZy9hcmNoL21zZy9jZnJnL2dzT25USnpjYmdHNk9xRDhTYzBHTzVhUl90VS9cblteMl06IGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLXhjaGFjaGEjYXBwZW5kaXgtQS4yXG4qL1xuLy8gV2UgY2FuJ3QgbWFrZSB0b3AtbGV2ZWwgdmFyIGRlcGVuZCBvbiB1dGlscy51dGY4VG9CeXRlc1xuLy8gYmVjYXVzZSBpdCdzIG5vdCBwcmVzZW50IGluIGFsbCBlbnZzLiBDcmVhdGluZyBhIHNpbWlsYXIgZm4gaGVyZVxuY29uc3QgX3V0ZjhUb0J5dGVzID0gKHN0cikgPT4gVWludDhBcnJheS5mcm9tKHN0ci5zcGxpdCgnJykubWFwKChjKSA9PiBjLmNoYXJDb2RlQXQoMCkpKTtcbmNvbnN0IHNpZ21hMTYgPSBfdXRmOFRvQnl0ZXMoJ2V4cGFuZCAxNi1ieXRlIGsnKTtcbmNvbnN0IHNpZ21hMzIgPSBfdXRmOFRvQnl0ZXMoJ2V4cGFuZCAzMi1ieXRlIGsnKTtcbmNvbnN0IHNpZ21hMTZfMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKHNpZ21hMTYpO1xuY29uc3Qgc2lnbWEzMl8zMiA9ICgwLCB1dGlsc19qc18xLnUzMikoc2lnbWEzMik7XG5leHBvcnRzLnNpZ21hID0gc2lnbWEzMl8zMi5zbGljZSgpO1xuZnVuY3Rpb24gcm90bChhLCBiKSB7XG4gICAgcmV0dXJuIChhIDw8IGIpIHwgKGEgPj4+ICgzMiAtIGIpKTtcbn1cbi8vIElzIGJ5dGUgYXJyYXkgYWxpZ25lZCB0byA0IGJ5dGUgb2Zmc2V0ICh1MzIpP1xuZnVuY3Rpb24gaXNBbGlnbmVkMzIoYikge1xuICAgIHJldHVybiBiLmJ5dGVPZmZzZXQgJSA0ID09PSAwO1xufVxuLy8gU2Fsc2EgYW5kIENoYWNoYSBibG9jayBsZW5ndGggaXMgYWx3YXlzIDUxMi1iaXRcbmNvbnN0IEJMT0NLX0xFTiA9IDY0O1xuY29uc3QgQkxPQ0tfTEVOMzIgPSAxNjtcbi8vIG5ldyBVaW50MzJBcnJheShbMioqMzJdKSAgIC8vID0+IFVpbnQzMkFycmF5KDEpIFsgMCBdXG4vLyBuZXcgVWludDMyQXJyYXkoWzIqKjMyLTFdKSAvLyA9PiBVaW50MzJBcnJheSgxKSBbIDQyOTQ5NjcyOTUgXVxuY29uc3QgTUFYX0NPVU5URVIgPSAyICoqIDMyIC0gMTtcbmNvbnN0IFUzMl9FTVBUWSA9IG5ldyBVaW50MzJBcnJheSgpO1xuZnVuY3Rpb24gcnVuQ2lwaGVyKGNvcmUsIHNpZ21hLCBrZXksIG5vbmNlLCBkYXRhLCBvdXRwdXQsIGNvdW50ZXIsIHJvdW5kcykge1xuICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgIGNvbnN0IGJsb2NrID0gbmV3IFVpbnQ4QXJyYXkoQkxPQ0tfTEVOKTtcbiAgICBjb25zdCBiMzIgPSAoMCwgdXRpbHNfanNfMS51MzIpKGJsb2NrKTtcbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBidWZmZXJzIGFsaWduZWQgdG8gNCBieXRlc1xuICAgIGNvbnN0IGlzQWxpZ25lZCA9IGlzQWxpZ25lZDMyKGRhdGEpICYmIGlzQWxpZ25lZDMyKG91dHB1dCk7XG4gICAgY29uc3QgZDMyID0gaXNBbGlnbmVkID8gKDAsIHV0aWxzX2pzXzEudTMyKShkYXRhKSA6IFUzMl9FTVBUWTtcbiAgICBjb25zdCBvMzIgPSBpc0FsaWduZWQgPyAoMCwgdXRpbHNfanNfMS51MzIpKG91dHB1dCkgOiBVMzJfRU1QVFk7XG4gICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOyBjb3VudGVyKyspIHtcbiAgICAgICAgY29yZShzaWdtYSwga2V5LCBub25jZSwgYjMyLCBjb3VudGVyLCByb3VuZHMpO1xuICAgICAgICBpZiAoY291bnRlciA+PSBNQVhfQ09VTlRFUilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJ4OiBjb3VudGVyIG92ZXJmbG93Jyk7XG4gICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihCTE9DS19MRU4sIGxlbiAtIHBvcyk7XG4gICAgICAgIC8vIGFsaWduZWQgdG8gNCBieXRlc1xuICAgICAgICBpZiAoaXNBbGlnbmVkICYmIHRha2UgPT09IEJMT0NLX0xFTikge1xuICAgICAgICAgICAgY29uc3QgcG9zMzIgPSBwb3MgLyA0O1xuICAgICAgICAgICAgaWYgKHBvcyAlIDQgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcng6IGludmFsaWQgYmxvY2sgcG9zaXRpb24nKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwLCBwb3NqOyBqIDwgQkxPQ0tfTEVOMzI7IGorKykge1xuICAgICAgICAgICAgICAgIHBvc2ogPSBwb3MzMiArIGo7XG4gICAgICAgICAgICAgICAgbzMyW3Bvc2pdID0gZDMyW3Bvc2pdIF4gYjMyW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9zICs9IEJMT0NLX0xFTjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBwb3NqOyBqIDwgdGFrZTsgaisrKSB7XG4gICAgICAgICAgICBwb3NqID0gcG9zICsgajtcbiAgICAgICAgICAgIG91dHB1dFtwb3NqXSA9IGRhdGFbcG9zal0gXiBibG9ja1tqXTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVDaXBoZXIoY29yZSwgb3B0cykge1xuICAgIGNvbnN0IHsgYWxsb3dTaG9ydEtleXMsIGV4dGVuZE5vbmNlRm4sIGNvdW50ZXJMZW5ndGgsIGNvdW50ZXJSaWdodCwgcm91bmRzIH0gPSAoMCwgdXRpbHNfanNfMS5jaGVja09wdHMpKHsgYWxsb3dTaG9ydEtleXM6IGZhbHNlLCBjb3VudGVyTGVuZ3RoOiA4LCBjb3VudGVyUmlnaHQ6IGZhbHNlLCByb3VuZHM6IDIwIH0sIG9wdHMpO1xuICAgIGlmICh0eXBlb2YgY29yZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3JlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICgwLCBfYXNzZXJ0X2pzXzEubnVtYmVyKShjb3VudGVyTGVuZ3RoKTtcbiAgICAoMCwgX2Fzc2VydF9qc18xLm51bWJlcikocm91bmRzKTtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmJvb2wpKGNvdW50ZXJSaWdodCk7XG4gICAgKDAsIF9hc3NlcnRfanNfMS5ib29sKShhbGxvd1Nob3J0S2V5cyk7XG4gICAgcmV0dXJuIChrZXksIG5vbmNlLCBkYXRhLCBvdXRwdXQsIGNvdW50ZXIgPSAwKSA9PiB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKGtleSk7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuYnl0ZXMpKG5vbmNlKTtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAob3V0cHV0ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBvdXRwdXQgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShvdXRwdXQpO1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLm51bWJlcikoY291bnRlcik7XG4gICAgICAgIGlmIChjb3VudGVyIDwgMCB8fCBjb3VudGVyID49IE1BWF9DT1VOVEVSKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcng6IGNvdW50ZXIgb3ZlcmZsb3cnKTtcbiAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggPCBsZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFyeDogb3V0cHV0ICgke291dHB1dC5sZW5ndGh9KSBpcyBzaG9ydGVyIHRoYW4gZGF0YSAoJHtsZW59KWApO1xuICAgICAgICBjb25zdCB0b0NsZWFuID0gW107XG4gICAgICAgIC8vIEtleSAmIHNpZ21hXG4gICAgICAgIC8vIGtleT0xNiAtPiBzaWdtYTE2LCBrPWtleXxrZXlcbiAgICAgICAgLy8ga2V5PTMyIC0+IHNpZ21hMzIsIGs9a2V5XG4gICAgICAgIGxldCBsID0ga2V5Lmxlbmd0aCwgaywgc2lnbWE7XG4gICAgICAgIGlmIChsID09PSAzMikge1xuICAgICAgICAgICAgdG9DbGVhbi5wdXNoKChrID0gKDAsIHV0aWxzX2pzXzEuY29weUJ5dGVzKShrZXkpKSk7XG4gICAgICAgICAgICBzaWdtYSA9IHNpZ21hMzJfMzI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobCA9PT0gMTYgJiYgYWxsb3dTaG9ydEtleXMpIHtcbiAgICAgICAgICAgIGsgPSBuZXcgVWludDhBcnJheSgzMik7XG4gICAgICAgICAgICBrLnNldChrZXkpO1xuICAgICAgICAgICAgay5zZXQoa2V5LCAxNik7XG4gICAgICAgICAgICBzaWdtYSA9IHNpZ21hMTZfMzI7XG4gICAgICAgICAgICB0b0NsZWFuLnB1c2goayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFyeDogaW52YWxpZCAzMi1ieXRlIGtleSwgZ290IGxlbmd0aD0ke2x9YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9uY2VcbiAgICAgICAgLy8gc2Fsc2EyMDogICAgICA4ICAgKDgtYnl0ZSBjb3VudGVyKVxuICAgICAgICAvLyBjaGFjaGEyMG9yaWc6IDggICAoOC1ieXRlIGNvdW50ZXIpXG4gICAgICAgIC8vIGNoYWNoYTIwOiAgICAgMTIgICg0LWJ5dGUgY291bnRlcilcbiAgICAgICAgLy8geHNhbHNhMjA6ICAgICAyNCAgKDE2IC0+IGhzYWxzYSwgIDggLT4gb2xkIG5vbmNlKVxuICAgICAgICAvLyB4Y2hhY2hhMjA6ICAgIDI0ICAoMTYgLT4gaGNoYWNoYSwgOCAtPiBvbGQgbm9uY2UpXG4gICAgICAgIC8vIEFsaWduIG5vbmNlIHRvIDQgYnl0ZXNcbiAgICAgICAgaWYgKCFpc0FsaWduZWQzMihub25jZSkpXG4gICAgICAgICAgICB0b0NsZWFuLnB1c2goKG5vbmNlID0gKDAsIHV0aWxzX2pzXzEuY29weUJ5dGVzKShub25jZSkpKTtcbiAgICAgICAgY29uc3QgazMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShrKTtcbiAgICAgICAgLy8gaHNhbHNhICYgaGNoYWNoYTogaGFuZGxlIGV4dGVuZGVkIG5vbmNlXG4gICAgICAgIGlmIChleHRlbmROb25jZUZuKSB7XG4gICAgICAgICAgICBpZiAobm9uY2UubGVuZ3RoICE9PSAyNClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGFyeDogZXh0ZW5kZWQgbm9uY2UgbXVzdCBiZSAyNCBieXRlc2ApO1xuICAgICAgICAgICAgZXh0ZW5kTm9uY2VGbihzaWdtYSwgazMyLCAoMCwgdXRpbHNfanNfMS51MzIpKG5vbmNlLnN1YmFycmF5KDAsIDE2KSksIGszMik7XG4gICAgICAgICAgICBub25jZSA9IG5vbmNlLnN1YmFycmF5KDE2KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgbm9uY2UgY291bnRlclxuICAgICAgICBjb25zdCBub25jZU5jTGVuID0gMTYgLSBjb3VudGVyTGVuZ3RoO1xuICAgICAgICBpZiAobm9uY2VOY0xlbiAhPT0gbm9uY2UubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcng6IG5vbmNlIG11c3QgYmUgJHtub25jZU5jTGVufSBvciAxNiBieXRlc2ApO1xuICAgICAgICAvLyBQYWQgY291bnRlciB3aGVuIG5vbmNlIGlzIDY0IGJpdFxuICAgICAgICBpZiAobm9uY2VOY0xlbiAhPT0gMTIpIHtcbiAgICAgICAgICAgIGNvbnN0IG5jID0gbmV3IFVpbnQ4QXJyYXkoMTIpO1xuICAgICAgICAgICAgbmMuc2V0KG5vbmNlLCBjb3VudGVyUmlnaHQgPyAwIDogMTIgLSBub25jZS5sZW5ndGgpO1xuICAgICAgICAgICAgbm9uY2UgPSBuYztcbiAgICAgICAgICAgIHRvQ2xlYW4ucHVzaChub25jZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbjMyID0gKDAsIHV0aWxzX2pzXzEudTMyKShub25jZSk7XG4gICAgICAgIHJ1bkNpcGhlcihjb3JlLCBzaWdtYSwgazMyLCBuMzIsIGRhdGEsIG91dHB1dCwgY291bnRlciwgcm91bmRzKTtcbiAgICAgICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKC4uLnRvQ2xlYW4pO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXJ4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wb2x5MTMwNSA9IHZvaWQgMDtcbmV4cG9ydHMud3JhcENvbnN0cnVjdG9yV2l0aEtleSA9IHdyYXBDb25zdHJ1Y3RvcldpdGhLZXk7XG5jb25zdCBfYXNzZXJ0X2pzXzEgPSByZXF1aXJlKFwiLi9fYXNzZXJ0LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gUG9seTEzMDUgaXMgYSBmYXN0IGFuZCBwYXJhbGxlbCBzZWNyZXQta2V5IG1lc3NhZ2UtYXV0aGVudGljYXRpb24gY29kZS5cbi8vIGh0dHBzOi8vY3IueXAudG8vbWFjLmh0bWwsIGh0dHBzOi8vY3IueXAudG8vbWFjL3BvbHkxMzA1LTIwMDUwMzI5LnBkZlxuLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmM4NDM5XG4vLyBCYXNlZCBvbiBQdWJsaWMgRG9tYWluIHBvbHkxMzA1LWRvbm5hIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9vZHliZXJyeS9wb2x5MTMwNS1kb25uYVxuY29uc3QgdTh0bzE2ID0gKGEsIGkpID0+IChhW2krK10gJiAweGZmKSB8ICgoYVtpKytdICYgMHhmZikgPDwgOCk7XG5jbGFzcyBQb2x5MTMwNSB7XG4gICAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSAxNjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSAxNjtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIHRoaXMuciA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gICAgICAgIHRoaXMuaCA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gICAgICAgIHRoaXMucGFkID0gbmV3IFVpbnQxNkFycmF5KDgpO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAga2V5ID0gKDAsIHV0aWxzX2pzXzEudG9CeXRlcykoa2V5KTtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykoa2V5LCAzMik7XG4gICAgICAgIGNvbnN0IHQwID0gdTh0bzE2KGtleSwgMCk7XG4gICAgICAgIGNvbnN0IHQxID0gdTh0bzE2KGtleSwgMik7XG4gICAgICAgIGNvbnN0IHQyID0gdTh0bzE2KGtleSwgNCk7XG4gICAgICAgIGNvbnN0IHQzID0gdTh0bzE2KGtleSwgNik7XG4gICAgICAgIGNvbnN0IHQ0ID0gdTh0bzE2KGtleSwgOCk7XG4gICAgICAgIGNvbnN0IHQ1ID0gdTh0bzE2KGtleSwgMTApO1xuICAgICAgICBjb25zdCB0NiA9IHU4dG8xNihrZXksIDEyKTtcbiAgICAgICAgY29uc3QgdDcgPSB1OHRvMTYoa2V5LCAxNCk7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mbG9vZHliZXJyeS9wb2x5MTMwNS1kb25uYS9ibG9iL2U2YWQ2ZTA5MWQzMGQ3ZjRlYzJkNGY5NzhiZTFmY2ZjYmNlNzI3ODEvcG9seTEzMDUtZG9ubmEtMTYuaCNMNDdcbiAgICAgICAgdGhpcy5yWzBdID0gdDAgJiAweDFmZmY7XG4gICAgICAgIHRoaXMuclsxXSA9ICgodDAgPj4+IDEzKSB8ICh0MSA8PCAzKSkgJiAweDFmZmY7XG4gICAgICAgIHRoaXMuclsyXSA9ICgodDEgPj4+IDEwKSB8ICh0MiA8PCA2KSkgJiAweDFmMDM7XG4gICAgICAgIHRoaXMuclszXSA9ICgodDIgPj4+IDcpIHwgKHQzIDw8IDkpKSAmIDB4MWZmZjtcbiAgICAgICAgdGhpcy5yWzRdID0gKCh0MyA+Pj4gNCkgfCAodDQgPDwgMTIpKSAmIDB4MDBmZjtcbiAgICAgICAgdGhpcy5yWzVdID0gKHQ0ID4+PiAxKSAmIDB4MWZmZTtcbiAgICAgICAgdGhpcy5yWzZdID0gKCh0NCA+Pj4gMTQpIHwgKHQ1IDw8IDIpKSAmIDB4MWZmZjtcbiAgICAgICAgdGhpcy5yWzddID0gKCh0NSA+Pj4gMTEpIHwgKHQ2IDw8IDUpKSAmIDB4MWY4MTtcbiAgICAgICAgdGhpcy5yWzhdID0gKCh0NiA+Pj4gOCkgfCAodDcgPDwgOCkpICYgMHgxZmZmO1xuICAgICAgICB0aGlzLnJbOV0gPSAodDcgPj4+IDUpICYgMHgwMDdmO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKylcbiAgICAgICAgICAgIHRoaXMucGFkW2ldID0gdTh0bzE2KGtleSwgMTYgKyAyICogaSk7XG4gICAgfVxuICAgIHByb2Nlc3MoZGF0YSwgb2Zmc2V0LCBpc0xhc3QgPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBoaWJpdCA9IGlzTGFzdCA/IDAgOiAxIDw8IDExO1xuICAgICAgICBjb25zdCB7IGgsIHIgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHIwID0gclswXTtcbiAgICAgICAgY29uc3QgcjEgPSByWzFdO1xuICAgICAgICBjb25zdCByMiA9IHJbMl07XG4gICAgICAgIGNvbnN0IHIzID0gclszXTtcbiAgICAgICAgY29uc3QgcjQgPSByWzRdO1xuICAgICAgICBjb25zdCByNSA9IHJbNV07XG4gICAgICAgIGNvbnN0IHI2ID0gcls2XTtcbiAgICAgICAgY29uc3QgcjcgPSByWzddO1xuICAgICAgICBjb25zdCByOCA9IHJbOF07XG4gICAgICAgIGNvbnN0IHI5ID0gcls5XTtcbiAgICAgICAgY29uc3QgdDAgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgMCk7XG4gICAgICAgIGNvbnN0IHQxID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDIpO1xuICAgICAgICBjb25zdCB0MiA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyA0KTtcbiAgICAgICAgY29uc3QgdDMgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgNik7XG4gICAgICAgIGNvbnN0IHQ0ID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDgpO1xuICAgICAgICBjb25zdCB0NSA9IHU4dG8xNihkYXRhLCBvZmZzZXQgKyAxMCk7XG4gICAgICAgIGNvbnN0IHQ2ID0gdTh0bzE2KGRhdGEsIG9mZnNldCArIDEyKTtcbiAgICAgICAgY29uc3QgdDcgPSB1OHRvMTYoZGF0YSwgb2Zmc2V0ICsgMTQpO1xuICAgICAgICBsZXQgaDAgPSBoWzBdICsgKHQwICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGgxID0gaFsxXSArICgoKHQwID4+PiAxMykgfCAodDEgPDwgMykpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGgyID0gaFsyXSArICgoKHQxID4+PiAxMCkgfCAodDIgPDwgNikpICYgMHgxZmZmKTtcbiAgICAgICAgbGV0IGgzID0gaFszXSArICgoKHQyID4+PiA3KSB8ICh0MyA8PCA5KSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDQgPSBoWzRdICsgKCgodDMgPj4+IDQpIHwgKHQ0IDw8IDEyKSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDUgPSBoWzVdICsgKCh0NCA+Pj4gMSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDYgPSBoWzZdICsgKCgodDQgPj4+IDE0KSB8ICh0NSA8PCAyKSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDcgPSBoWzddICsgKCgodDUgPj4+IDExKSB8ICh0NiA8PCA1KSkgJiAweDFmZmYpO1xuICAgICAgICBsZXQgaDggPSBoWzhdICsgKCgodDYgPj4+IDgpIHwgKHQ3IDw8IDgpKSAmIDB4MWZmZik7XG4gICAgICAgIGxldCBoOSA9IGhbOV0gKyAoKHQ3ID4+PiA1KSB8IGhpYml0KTtcbiAgICAgICAgbGV0IGMgPSAwO1xuICAgICAgICBsZXQgZDAgPSBjICsgaDAgKiByMCArIGgxICogKDUgKiByOSkgKyBoMiAqICg1ICogcjgpICsgaDMgKiAoNSAqIHI3KSArIGg0ICogKDUgKiByNik7XG4gICAgICAgIGMgPSBkMCA+Pj4gMTM7XG4gICAgICAgIGQwICY9IDB4MWZmZjtcbiAgICAgICAgZDAgKz0gaDUgKiAoNSAqIHI1KSArIGg2ICogKDUgKiByNCkgKyBoNyAqICg1ICogcjMpICsgaDggKiAoNSAqIHIyKSArIGg5ICogKDUgKiByMSk7XG4gICAgICAgIGMgKz0gZDAgPj4+IDEzO1xuICAgICAgICBkMCAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkMSA9IGMgKyBoMCAqIHIxICsgaDEgKiByMCArIGgyICogKDUgKiByOSkgKyBoMyAqICg1ICogcjgpICsgaDQgKiAoNSAqIHI3KTtcbiAgICAgICAgYyA9IGQxID4+PiAxMztcbiAgICAgICAgZDEgJj0gMHgxZmZmO1xuICAgICAgICBkMSArPSBoNSAqICg1ICogcjYpICsgaDYgKiAoNSAqIHI1KSArIGg3ICogKDUgKiByNCkgKyBoOCAqICg1ICogcjMpICsgaDkgKiAoNSAqIHIyKTtcbiAgICAgICAgYyArPSBkMSA+Pj4gMTM7XG4gICAgICAgIGQxICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQyID0gYyArIGgwICogcjIgKyBoMSAqIHIxICsgaDIgKiByMCArIGgzICogKDUgKiByOSkgKyBoNCAqICg1ICogcjgpO1xuICAgICAgICBjID0gZDIgPj4+IDEzO1xuICAgICAgICBkMiAmPSAweDFmZmY7XG4gICAgICAgIGQyICs9IGg1ICogKDUgKiByNykgKyBoNiAqICg1ICogcjYpICsgaDcgKiAoNSAqIHI1KSArIGg4ICogKDUgKiByNCkgKyBoOSAqICg1ICogcjMpO1xuICAgICAgICBjICs9IGQyID4+PiAxMztcbiAgICAgICAgZDIgJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDMgPSBjICsgaDAgKiByMyArIGgxICogcjIgKyBoMiAqIHIxICsgaDMgKiByMCArIGg0ICogKDUgKiByOSk7XG4gICAgICAgIGMgPSBkMyA+Pj4gMTM7XG4gICAgICAgIGQzICY9IDB4MWZmZjtcbiAgICAgICAgZDMgKz0gaDUgKiAoNSAqIHI4KSArIGg2ICogKDUgKiByNykgKyBoNyAqICg1ICogcjYpICsgaDggKiAoNSAqIHI1KSArIGg5ICogKDUgKiByNCk7XG4gICAgICAgIGMgKz0gZDMgPj4+IDEzO1xuICAgICAgICBkMyAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkNCA9IGMgKyBoMCAqIHI0ICsgaDEgKiByMyArIGgyICogcjIgKyBoMyAqIHIxICsgaDQgKiByMDtcbiAgICAgICAgYyA9IGQ0ID4+PiAxMztcbiAgICAgICAgZDQgJj0gMHgxZmZmO1xuICAgICAgICBkNCArPSBoNSAqICg1ICogcjkpICsgaDYgKiAoNSAqIHI4KSArIGg3ICogKDUgKiByNykgKyBoOCAqICg1ICogcjYpICsgaDkgKiAoNSAqIHI1KTtcbiAgICAgICAgYyArPSBkNCA+Pj4gMTM7XG4gICAgICAgIGQ0ICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQ1ID0gYyArIGgwICogcjUgKyBoMSAqIHI0ICsgaDIgKiByMyArIGgzICogcjIgKyBoNCAqIHIxO1xuICAgICAgICBjID0gZDUgPj4+IDEzO1xuICAgICAgICBkNSAmPSAweDFmZmY7XG4gICAgICAgIGQ1ICs9IGg1ICogcjAgKyBoNiAqICg1ICogcjkpICsgaDcgKiAoNSAqIHI4KSArIGg4ICogKDUgKiByNykgKyBoOSAqICg1ICogcjYpO1xuICAgICAgICBjICs9IGQ1ID4+PiAxMztcbiAgICAgICAgZDUgJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDYgPSBjICsgaDAgKiByNiArIGgxICogcjUgKyBoMiAqIHI0ICsgaDMgKiByMyArIGg0ICogcjI7XG4gICAgICAgIGMgPSBkNiA+Pj4gMTM7XG4gICAgICAgIGQ2ICY9IDB4MWZmZjtcbiAgICAgICAgZDYgKz0gaDUgKiByMSArIGg2ICogcjAgKyBoNyAqICg1ICogcjkpICsgaDggKiAoNSAqIHI4KSArIGg5ICogKDUgKiByNyk7XG4gICAgICAgIGMgKz0gZDYgPj4+IDEzO1xuICAgICAgICBkNiAmPSAweDFmZmY7XG4gICAgICAgIGxldCBkNyA9IGMgKyBoMCAqIHI3ICsgaDEgKiByNiArIGgyICogcjUgKyBoMyAqIHI0ICsgaDQgKiByMztcbiAgICAgICAgYyA9IGQ3ID4+PiAxMztcbiAgICAgICAgZDcgJj0gMHgxZmZmO1xuICAgICAgICBkNyArPSBoNSAqIHIyICsgaDYgKiByMSArIGg3ICogcjAgKyBoOCAqICg1ICogcjkpICsgaDkgKiAoNSAqIHI4KTtcbiAgICAgICAgYyArPSBkNyA+Pj4gMTM7XG4gICAgICAgIGQ3ICY9IDB4MWZmZjtcbiAgICAgICAgbGV0IGQ4ID0gYyArIGgwICogcjggKyBoMSAqIHI3ICsgaDIgKiByNiArIGgzICogcjUgKyBoNCAqIHI0O1xuICAgICAgICBjID0gZDggPj4+IDEzO1xuICAgICAgICBkOCAmPSAweDFmZmY7XG4gICAgICAgIGQ4ICs9IGg1ICogcjMgKyBoNiAqIHIyICsgaDcgKiByMSArIGg4ICogcjAgKyBoOSAqICg1ICogcjkpO1xuICAgICAgICBjICs9IGQ4ID4+PiAxMztcbiAgICAgICAgZDggJj0gMHgxZmZmO1xuICAgICAgICBsZXQgZDkgPSBjICsgaDAgKiByOSArIGgxICogcjggKyBoMiAqIHI3ICsgaDMgKiByNiArIGg0ICogcjU7XG4gICAgICAgIGMgPSBkOSA+Pj4gMTM7XG4gICAgICAgIGQ5ICY9IDB4MWZmZjtcbiAgICAgICAgZDkgKz0gaDUgKiByNCArIGg2ICogcjMgKyBoNyAqIHIyICsgaDggKiByMSArIGg5ICogcjA7XG4gICAgICAgIGMgKz0gZDkgPj4+IDEzO1xuICAgICAgICBkOSAmPSAweDFmZmY7XG4gICAgICAgIGMgPSAoKGMgPDwgMikgKyBjKSB8IDA7XG4gICAgICAgIGMgPSAoYyArIGQwKSB8IDA7XG4gICAgICAgIGQwID0gYyAmIDB4MWZmZjtcbiAgICAgICAgYyA9IGMgPj4+IDEzO1xuICAgICAgICBkMSArPSBjO1xuICAgICAgICBoWzBdID0gZDA7XG4gICAgICAgIGhbMV0gPSBkMTtcbiAgICAgICAgaFsyXSA9IGQyO1xuICAgICAgICBoWzNdID0gZDM7XG4gICAgICAgIGhbNF0gPSBkNDtcbiAgICAgICAgaFs1XSA9IGQ1O1xuICAgICAgICBoWzZdID0gZDY7XG4gICAgICAgIGhbN10gPSBkNztcbiAgICAgICAgaFs4XSA9IGQ4O1xuICAgICAgICBoWzldID0gZDk7XG4gICAgfVxuICAgIGZpbmFsaXplKCkge1xuICAgICAgICBjb25zdCB7IGgsIHBhZCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZyA9IG5ldyBVaW50MTZBcnJheSgxMCk7XG4gICAgICAgIGxldCBjID0gaFsxXSA+Pj4gMTM7XG4gICAgICAgIGhbMV0gJj0gMHgxZmZmO1xuICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgICAgIGhbaV0gKz0gYztcbiAgICAgICAgICAgIGMgPSBoW2ldID4+PiAxMztcbiAgICAgICAgICAgIGhbaV0gJj0gMHgxZmZmO1xuICAgICAgICB9XG4gICAgICAgIGhbMF0gKz0gYyAqIDU7XG4gICAgICAgIGMgPSBoWzBdID4+PiAxMztcbiAgICAgICAgaFswXSAmPSAweDFmZmY7XG4gICAgICAgIGhbMV0gKz0gYztcbiAgICAgICAgYyA9IGhbMV0gPj4+IDEzO1xuICAgICAgICBoWzFdICY9IDB4MWZmZjtcbiAgICAgICAgaFsyXSArPSBjO1xuICAgICAgICBnWzBdID0gaFswXSArIDU7XG4gICAgICAgIGMgPSBnWzBdID4+PiAxMztcbiAgICAgICAgZ1swXSAmPSAweDFmZmY7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgZ1tpXSA9IGhbaV0gKyBjO1xuICAgICAgICAgICAgYyA9IGdbaV0gPj4+IDEzO1xuICAgICAgICAgICAgZ1tpXSAmPSAweDFmZmY7XG4gICAgICAgIH1cbiAgICAgICAgZ1s5XSAtPSAxIDw8IDEzO1xuICAgICAgICBsZXQgbWFzayA9IChjIF4gMSkgLSAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspXG4gICAgICAgICAgICBnW2ldICY9IG1hc2s7XG4gICAgICAgIG1hc2sgPSB+bWFzaztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKVxuICAgICAgICAgICAgaFtpXSA9IChoW2ldICYgbWFzaykgfCBnW2ldO1xuICAgICAgICBoWzBdID0gKGhbMF0gfCAoaFsxXSA8PCAxMykpICYgMHhmZmZmO1xuICAgICAgICBoWzFdID0gKChoWzFdID4+PiAzKSB8IChoWzJdIDw8IDEwKSkgJiAweGZmZmY7XG4gICAgICAgIGhbMl0gPSAoKGhbMl0gPj4+IDYpIHwgKGhbM10gPDwgNykpICYgMHhmZmZmO1xuICAgICAgICBoWzNdID0gKChoWzNdID4+PiA5KSB8IChoWzRdIDw8IDQpKSAmIDB4ZmZmZjtcbiAgICAgICAgaFs0XSA9ICgoaFs0XSA+Pj4gMTIpIHwgKGhbNV0gPDwgMSkgfCAoaFs2XSA8PCAxNCkpICYgMHhmZmZmO1xuICAgICAgICBoWzVdID0gKChoWzZdID4+PiAyKSB8IChoWzddIDw8IDExKSkgJiAweGZmZmY7XG4gICAgICAgIGhbNl0gPSAoKGhbN10gPj4+IDUpIHwgKGhbOF0gPDwgOCkpICYgMHhmZmZmO1xuICAgICAgICBoWzddID0gKChoWzhdID4+PiA4KSB8IChoWzldIDw8IDUpKSAmIDB4ZmZmZjtcbiAgICAgICAgbGV0IGYgPSBoWzBdICsgcGFkWzBdO1xuICAgICAgICBoWzBdID0gZiAmIDB4ZmZmZjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCA4OyBpKyspIHtcbiAgICAgICAgICAgIGYgPSAoKChoW2ldICsgcGFkW2ldKSB8IDApICsgKGYgPj4+IDE2KSkgfCAwO1xuICAgICAgICAgICAgaFtpXSA9IGYgJiAweGZmZmY7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKGcpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmV4aXN0cykodGhpcyk7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9ICgwLCB1dGlsc19qc18xLnRvQnl0ZXMpKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0XG4gICAgICAgICAgICBpZiAodGFrZSA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhLCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3MoYnVmZmVyLCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAoMCwgdXRpbHNfanNfMS5jbGVhbikodGhpcy5oLCB0aGlzLnIsIHRoaXMuYnVmZmVyLCB0aGlzLnBhZCk7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgICgwLCBfYXNzZXJ0X2pzXzEuZXhpc3RzKSh0aGlzKTtcbiAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5vdXRwdXQpKG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgaCB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICBpZiAocG9zKSB7XG4gICAgICAgICAgICBidWZmZXJbcG9zKytdID0gMTtcbiAgICAgICAgICAgIGZvciAoOyBwb3MgPCAxNjsgcG9zKyspXG4gICAgICAgICAgICAgICAgYnVmZmVyW3Bvc10gPSAwO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGJ1ZmZlciwgMCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5hbGl6ZSgpO1xuICAgICAgICBsZXQgb3BvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICBvdXRbb3BvcysrXSA9IGhbaV0gPj4+IDA7XG4gICAgICAgICAgICBvdXRbb3BvcysrXSA9IGhbaV0gPj4+IDg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhLZXkoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIGtleSkgPT4gaGFzaENvbnMoa2V5KS51cGRhdGUoKDAsIHV0aWxzX2pzXzEudG9CeXRlcykobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMobmV3IFVpbnQ4QXJyYXkoMzIpKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChrZXkpID0+IGhhc2hDb25zKGtleSk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0cy5wb2x5MTMwNSA9IHdyYXBDb25zdHJ1Y3RvcldpdGhLZXkoKGtleSkgPT4gbmV3IFBvbHkxMzA1KGtleSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3BvbHkxMzA1LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy54Y2hhY2hhMjBwb2x5MTMwNSA9IGV4cG9ydHMuY2hhY2hhMjBwb2x5MTMwNSA9IGV4cG9ydHMuX3BvbHkxMzA1X2FlYWQgPSBleHBvcnRzLmNoYWNoYTEyID0gZXhwb3J0cy5jaGFjaGE4ID0gZXhwb3J0cy54Y2hhY2hhMjAgPSBleHBvcnRzLmNoYWNoYTIwID0gZXhwb3J0cy5jaGFjaGEyMG9yaWcgPSB2b2lkIDA7XG5leHBvcnRzLmhjaGFjaGEgPSBoY2hhY2hhO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfYXJ4X2pzXzEgPSByZXF1aXJlKFwiLi9fYXJ4LmpzXCIpO1xuY29uc3QgX2Fzc2VydF9qc18xID0gcmVxdWlyZShcIi4vX2Fzc2VydC5qc1wiKTtcbmNvbnN0IF9wb2x5MTMwNV9qc18xID0gcmVxdWlyZShcIi4vX3BvbHkxMzA1LmpzXCIpO1xuY29uc3QgdXRpbHNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xuLy8gQ2hhQ2hhMjAgc3RyZWFtIGNpcGhlciB3YXMgcmVsZWFzZWQgaW4gMjAwOC4gQ2hhQ2hhIGFpbXMgdG8gaW5jcmVhc2Vcbi8vIHRoZSBkaWZmdXNpb24gcGVyIHJvdW5kLCBidXQgaGFkIHNsaWdodGx5IGxlc3MgY3J5cHRhbmFseXNpcy5cbi8vIGh0dHBzOi8vY3IueXAudG8vY2hhY2hhLmh0bWwsIGh0dHA6Ly9jci55cC50by9jaGFjaGEvY2hhY2hhLTIwMDgwMTI4LnBkZlxuLyoqXG4gKiBDaGFDaGEgY29yZSBmdW5jdGlvbi5cbiAqL1xuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBjaGFjaGFDb3JlKHMsIGssIG4sIG91dCwgY250LCByb3VuZHMgPSAyMCkge1xuICAgIGxldCB5MDAgPSBzWzBdLCB5MDEgPSBzWzFdLCB5MDIgPSBzWzJdLCB5MDMgPSBzWzNdLCAvLyBcImV4cGFcIiAgIFwibmQgM1wiICBcIjItYnlcIiAgXCJ0ZSBrXCJcbiAgICB5MDQgPSBrWzBdLCB5MDUgPSBrWzFdLCB5MDYgPSBrWzJdLCB5MDcgPSBrWzNdLCAvLyBLZXkgICAgICBLZXkgICAgIEtleSAgICAgS2V5XG4gICAgeTA4ID0ga1s0XSwgeTA5ID0ga1s1XSwgeTEwID0ga1s2XSwgeTExID0ga1s3XSwgLy8gS2V5ICAgICAgS2V5ICAgICBLZXkgICAgIEtleVxuICAgIHkxMiA9IGNudCwgeTEzID0gblswXSwgeTE0ID0gblsxXSwgeTE1ID0gblsyXTsgLy8gQ291bnRlciAgQ291bnRlclx0Tm9uY2UgICBOb25jZVxuICAgIC8vIFNhdmUgc3RhdGUgdG8gdGVtcG9yYXJ5IHZhcmlhYmxlc1xuICAgIGxldCB4MDAgPSB5MDAsIHgwMSA9IHkwMSwgeDAyID0geTAyLCB4MDMgPSB5MDMsIHgwNCA9IHkwNCwgeDA1ID0geTA1LCB4MDYgPSB5MDYsIHgwNyA9IHkwNywgeDA4ID0geTA4LCB4MDkgPSB5MDksIHgxMCA9IHkxMCwgeDExID0geTExLCB4MTIgPSB5MTIsIHgxMyA9IHkxMywgeDE0ID0geTE0LCB4MTUgPSB5MTU7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCByb3VuZHM7IHIgKz0gMikge1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA0KSB8IDA7XG4gICAgICAgIHgxMiA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEyIF4geDAwLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDQgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNCkgfCAwO1xuICAgICAgICB4MTIgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxMiBeIHgwMCwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTIpIHwgMDtcbiAgICAgICAgeDA0ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDQgXiB4MDgsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA1KSB8IDA7XG4gICAgICAgIHgxMyA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEzIF4geDAxLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDUgXiB4MDksIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNSkgfCAwO1xuICAgICAgICB4MTMgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxMyBeIHgwMSwgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTMpIHwgMDtcbiAgICAgICAgeDA1ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDUgXiB4MDksIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA2KSB8IDA7XG4gICAgICAgIHgxNCA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE0IF4geDAyLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDYgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNikgfCAwO1xuICAgICAgICB4MTQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxNCBeIHgwMiwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA2ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDYgXiB4MTAsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA3KSB8IDA7XG4gICAgICAgIHgxNSA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE1IF4geDAzLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDcgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNykgfCAwO1xuICAgICAgICB4MTUgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxNSBeIHgwMywgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA3ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDcgXiB4MTEsIDcpO1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA1KSB8IDA7XG4gICAgICAgIHgxNSA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE1IF4geDAwLCAxNik7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDUgXiB4MTAsIDEyKTtcbiAgICAgICAgeDAwID0gKHgwMCArIHgwNSkgfCAwO1xuICAgICAgICB4MTUgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxNSBeIHgwMCwgOCk7XG4gICAgICAgIHgxMCA9ICh4MTAgKyB4MTUpIHwgMDtcbiAgICAgICAgeDA1ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDUgXiB4MTAsIDcpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA2KSB8IDA7XG4gICAgICAgIHgxMiA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEyIF4geDAxLCAxNik7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDYgXiB4MTEsIDEyKTtcbiAgICAgICAgeDAxID0gKHgwMSArIHgwNikgfCAwO1xuICAgICAgICB4MTIgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxMiBeIHgwMSwgOCk7XG4gICAgICAgIHgxMSA9ICh4MTEgKyB4MTIpIHwgMDtcbiAgICAgICAgeDA2ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDYgXiB4MTEsIDcpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA3KSB8IDA7XG4gICAgICAgIHgxMyA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEzIF4geDAyLCAxNik7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDcgXiB4MDgsIDEyKTtcbiAgICAgICAgeDAyID0gKHgwMiArIHgwNykgfCAwO1xuICAgICAgICB4MTMgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxMyBeIHgwMiwgOCk7XG4gICAgICAgIHgwOCA9ICh4MDggKyB4MTMpIHwgMDtcbiAgICAgICAgeDA3ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDcgXiB4MDgsIDcpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA0KSB8IDA7XG4gICAgICAgIHgxNCA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE0IF4geDAzLCAxNik7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDQgXiB4MDksIDEyKTtcbiAgICAgICAgeDAzID0gKHgwMyArIHgwNCkgfCAwO1xuICAgICAgICB4MTQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgxNCBeIHgwMywgOCk7XG4gICAgICAgIHgwOSA9ICh4MDkgKyB4MTQpIHwgMDtcbiAgICAgICAgeDA0ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MDQgXiB4MDksIDcpO1xuICAgIH1cbiAgICAvLyBXcml0ZSBvdXRwdXRcbiAgICBsZXQgb2kgPSAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDAgKyB4MDApIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTAxICsgeDAxKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwMiArIHgwMikgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDMgKyB4MDMpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA0ICsgeDA0KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwNSArIHgwNSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDYgKyB4MDYpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTA3ICsgeDA3KSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkwOCArIHgwOCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MDkgKyB4MDkpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEwICsgeDEwKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxMSArIHgxMSkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTIgKyB4MTIpIHwgMDtcbiAgICBvdXRbb2krK10gPSAoeTEzICsgeDEzKSB8IDA7XG4gICAgb3V0W29pKytdID0gKHkxNCArIHgxNCkgfCAwO1xuICAgIG91dFtvaSsrXSA9ICh5MTUgKyB4MTUpIHwgMDtcbn1cbi8qKlxuICogaGNoYWNoYSBoZWxwZXIgbWV0aG9kLCB1c2VkIHByaW1hcmlseSBpbiB4Y2hhY2hhLCB0byBoYXNoXG4gKiBrZXkgYW5kIG5vbmNlIGludG8ga2V5JyBhbmQgbm9uY2UnLlxuICogU2FtZSBhcyBjaGFjaGFDb3JlLCBidXQgdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgd2F5IHRvIG1vdmUgdGhlIGJsb2NrXG4gKiBvdXQgd2l0aG91dCAyNSUgcGVyZm9ybWFuY2UgaGl0LlxuICovXG4vLyBwcmV0dGllci1pZ25vcmVcbmZ1bmN0aW9uIGhjaGFjaGEocywgaywgaSwgbzMyKSB7XG4gICAgbGV0IHgwMCA9IHNbMF0sIHgwMSA9IHNbMV0sIHgwMiA9IHNbMl0sIHgwMyA9IHNbM10sIHgwNCA9IGtbMF0sIHgwNSA9IGtbMV0sIHgwNiA9IGtbMl0sIHgwNyA9IGtbM10sIHgwOCA9IGtbNF0sIHgwOSA9IGtbNV0sIHgxMCA9IGtbNl0sIHgxMSA9IGtbN10sIHgxMiA9IGlbMF0sIHgxMyA9IGlbMV0sIHgxNCA9IGlbMl0sIHgxNSA9IGlbM107XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCAyMDsgciArPSAyKSB7XG4gICAgICAgIHgwMCA9ICh4MDAgKyB4MDQpIHwgMDtcbiAgICAgICAgeDEyID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTIgXiB4MDAsIDE2KTtcbiAgICAgICAgeDA4ID0gKHgwOCArIHgxMikgfCAwO1xuICAgICAgICB4MDQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNCBeIHgwOCwgMTIpO1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA0KSB8IDA7XG4gICAgICAgIHgxMiA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEyIF4geDAwLCA4KTtcbiAgICAgICAgeDA4ID0gKHgwOCArIHgxMikgfCAwO1xuICAgICAgICB4MDQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNCBeIHgwOCwgNyk7XG4gICAgICAgIHgwMSA9ICh4MDEgKyB4MDUpIHwgMDtcbiAgICAgICAgeDEzID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTMgXiB4MDEsIDE2KTtcbiAgICAgICAgeDA5ID0gKHgwOSArIHgxMykgfCAwO1xuICAgICAgICB4MDUgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNSBeIHgwOSwgMTIpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA1KSB8IDA7XG4gICAgICAgIHgxMyA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEzIF4geDAxLCA4KTtcbiAgICAgICAgeDA5ID0gKHgwOSArIHgxMykgfCAwO1xuICAgICAgICB4MDUgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNSBeIHgwOSwgNyk7XG4gICAgICAgIHgwMiA9ICh4MDIgKyB4MDYpIHwgMDtcbiAgICAgICAgeDE0ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTQgXiB4MDIsIDE2KTtcbiAgICAgICAgeDEwID0gKHgxMCArIHgxNCkgfCAwO1xuICAgICAgICB4MDYgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNiBeIHgxMCwgMTIpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA2KSB8IDA7XG4gICAgICAgIHgxNCA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE0IF4geDAyLCA4KTtcbiAgICAgICAgeDEwID0gKHgxMCArIHgxNCkgfCAwO1xuICAgICAgICB4MDYgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNiBeIHgxMCwgNyk7XG4gICAgICAgIHgwMyA9ICh4MDMgKyB4MDcpIHwgMDtcbiAgICAgICAgeDE1ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTUgXiB4MDMsIDE2KTtcbiAgICAgICAgeDExID0gKHgxMSArIHgxNSkgfCAwO1xuICAgICAgICB4MDcgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNyBeIHgxMSwgMTIpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA3KSB8IDA7XG4gICAgICAgIHgxNSA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE1IF4geDAzLCA4KTtcbiAgICAgICAgeDExID0gKHgxMSArIHgxNSkgfCAwO1xuICAgICAgICB4MDcgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNyBeIHgxMSwgNyk7XG4gICAgICAgIHgwMCA9ICh4MDAgKyB4MDUpIHwgMDtcbiAgICAgICAgeDE1ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTUgXiB4MDAsIDE2KTtcbiAgICAgICAgeDEwID0gKHgxMCArIHgxNSkgfCAwO1xuICAgICAgICB4MDUgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNSBeIHgxMCwgMTIpO1xuICAgICAgICB4MDAgPSAoeDAwICsgeDA1KSB8IDA7XG4gICAgICAgIHgxNSA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE1IF4geDAwLCA4KTtcbiAgICAgICAgeDEwID0gKHgxMCArIHgxNSkgfCAwO1xuICAgICAgICB4MDUgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNSBeIHgxMCwgNyk7XG4gICAgICAgIHgwMSA9ICh4MDEgKyB4MDYpIHwgMDtcbiAgICAgICAgeDEyID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTIgXiB4MDEsIDE2KTtcbiAgICAgICAgeDExID0gKHgxMSArIHgxMikgfCAwO1xuICAgICAgICB4MDYgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNiBeIHgxMSwgMTIpO1xuICAgICAgICB4MDEgPSAoeDAxICsgeDA2KSB8IDA7XG4gICAgICAgIHgxMiA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEyIF4geDAxLCA4KTtcbiAgICAgICAgeDExID0gKHgxMSArIHgxMikgfCAwO1xuICAgICAgICB4MDYgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNiBeIHgxMSwgNyk7XG4gICAgICAgIHgwMiA9ICh4MDIgKyB4MDcpIHwgMDtcbiAgICAgICAgeDEzID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTMgXiB4MDIsIDE2KTtcbiAgICAgICAgeDA4ID0gKHgwOCArIHgxMykgfCAwO1xuICAgICAgICB4MDcgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNyBeIHgwOCwgMTIpO1xuICAgICAgICB4MDIgPSAoeDAyICsgeDA3KSB8IDA7XG4gICAgICAgIHgxMyA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDEzIF4geDAyLCA4KTtcbiAgICAgICAgeDA4ID0gKHgwOCArIHgxMykgfCAwO1xuICAgICAgICB4MDcgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNyBeIHgwOCwgNyk7XG4gICAgICAgIHgwMyA9ICh4MDMgKyB4MDQpIHwgMDtcbiAgICAgICAgeDE0ID0gKDAsIF9hcnhfanNfMS5yb3RsKSh4MTQgXiB4MDMsIDE2KTtcbiAgICAgICAgeDA5ID0gKHgwOSArIHgxNCkgfCAwO1xuICAgICAgICB4MDQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNCBeIHgwOSwgMTIpO1xuICAgICAgICB4MDMgPSAoeDAzICsgeDA0KSB8IDA7XG4gICAgICAgIHgxNCA9ICgwLCBfYXJ4X2pzXzEucm90bCkoeDE0IF4geDAzLCA4KTtcbiAgICAgICAgeDA5ID0gKHgwOSArIHgxNCkgfCAwO1xuICAgICAgICB4MDQgPSAoMCwgX2FyeF9qc18xLnJvdGwpKHgwNCBeIHgwOSwgNyk7XG4gICAgfVxuICAgIGxldCBvaSA9IDA7XG4gICAgbzMyW29pKytdID0geDAwO1xuICAgIG8zMltvaSsrXSA9IHgwMTtcbiAgICBvMzJbb2krK10gPSB4MDI7XG4gICAgbzMyW29pKytdID0geDAzO1xuICAgIG8zMltvaSsrXSA9IHgxMjtcbiAgICBvMzJbb2krK10gPSB4MTM7XG4gICAgbzMyW29pKytdID0geDE0O1xuICAgIG8zMltvaSsrXSA9IHgxNTtcbn1cbi8qKlxuICogT3JpZ2luYWwsIG5vbi1SRkMgY2hhY2hhMjAgZnJvbSBESkIuIDgtYnl0ZSBub25jZSwgOC1ieXRlIGNvdW50ZXIuXG4gKi9cbmV4cG9ydHMuY2hhY2hhMjBvcmlnID0gKDAsIF9hcnhfanNfMS5jcmVhdGVDaXBoZXIpKGNoYWNoYUNvcmUsIHtcbiAgICBjb3VudGVyUmlnaHQ6IGZhbHNlLFxuICAgIGNvdW50ZXJMZW5ndGg6IDgsXG4gICAgYWxsb3dTaG9ydEtleXM6IHRydWUsXG59KTtcbi8qKlxuICogQ2hhQ2hhIHN0cmVhbSBjaXBoZXIuIENvbmZvcm1zIHRvIFJGQyA4NDM5IChJRVRGLCBUTFMpLiAxMi1ieXRlIG5vbmNlLCA0LWJ5dGUgY291bnRlci5cbiAqIFdpdGggMTItYnl0ZSBub25jZSwgaXQncyBub3Qgc2FmZSB0byB1c2UgZmlsbCBpdCB3aXRoIHJhbmRvbSAoQ1NQUk5HKSwgZHVlIHRvIGNvbGxpc2lvbiBjaGFuY2UuXG4gKi9cbmV4cG9ydHMuY2hhY2hhMjAgPSAoMCwgX2FyeF9qc18xLmNyZWF0ZUNpcGhlcikoY2hhY2hhQ29yZSwge1xuICAgIGNvdW50ZXJSaWdodDogZmFsc2UsXG4gICAgY291bnRlckxlbmd0aDogNCxcbiAgICBhbGxvd1Nob3J0S2V5czogZmFsc2UsXG59KTtcbi8qKlxuICogWENoYUNoYSBlWHRlbmRlZC1ub25jZSBDaGFDaGEuIDI0LWJ5dGUgbm9uY2UuXG4gKiBXaXRoIDI0LWJ5dGUgbm9uY2UsIGl0J3Mgc2FmZSB0byB1c2UgZmlsbCBpdCB3aXRoIHJhbmRvbSAoQ1NQUk5HKS5cbiAqIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLXhjaGFjaGFcbiAqL1xuZXhwb3J0cy54Y2hhY2hhMjAgPSAoMCwgX2FyeF9qc18xLmNyZWF0ZUNpcGhlcikoY2hhY2hhQ29yZSwge1xuICAgIGNvdW50ZXJSaWdodDogZmFsc2UsXG4gICAgY291bnRlckxlbmd0aDogOCxcbiAgICBleHRlbmROb25jZUZuOiBoY2hhY2hhLFxuICAgIGFsbG93U2hvcnRLZXlzOiBmYWxzZSxcbn0pO1xuLyoqXG4gKiBSZWR1Y2VkIDgtcm91bmQgY2hhY2hhLCBkZXNjcmliZWQgaW4gb3JpZ2luYWwgcGFwZXIuXG4gKi9cbmV4cG9ydHMuY2hhY2hhOCA9ICgwLCBfYXJ4X2pzXzEuY3JlYXRlQ2lwaGVyKShjaGFjaGFDb3JlLCB7XG4gICAgY291bnRlclJpZ2h0OiBmYWxzZSxcbiAgICBjb3VudGVyTGVuZ3RoOiA0LFxuICAgIHJvdW5kczogOCxcbn0pO1xuLyoqXG4gKiBSZWR1Y2VkIDEyLXJvdW5kIGNoYWNoYSwgZGVzY3JpYmVkIGluIG9yaWdpbmFsIHBhcGVyLlxuICovXG5leHBvcnRzLmNoYWNoYTEyID0gKDAsIF9hcnhfanNfMS5jcmVhdGVDaXBoZXIpKGNoYWNoYUNvcmUsIHtcbiAgICBjb3VudGVyUmlnaHQ6IGZhbHNlLFxuICAgIGNvdW50ZXJMZW5ndGg6IDQsXG4gICAgcm91bmRzOiAxMixcbn0pO1xuY29uc3QgWkVST1MxNiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDhBcnJheSgxNik7XG4vLyBQYWQgdG8gZGlnZXN0IHNpemUgd2l0aCB6ZXJvc1xuY29uc3QgdXBkYXRlUGFkZGVkID0gKGgsIG1zZykgPT4ge1xuICAgIGgudXBkYXRlKG1zZyk7XG4gICAgY29uc3QgbGVmdCA9IG1zZy5sZW5ndGggJSAxNjtcbiAgICBpZiAobGVmdClcbiAgICAgICAgaC51cGRhdGUoWkVST1MxNi5zdWJhcnJheShsZWZ0KSk7XG59O1xuY29uc3QgWkVST1MzMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDhBcnJheSgzMik7XG5mdW5jdGlvbiBjb21wdXRlVGFnKGZuLCBrZXksIG5vbmNlLCBkYXRhLCBBQUQpIHtcbiAgICBjb25zdCBhdXRoS2V5ID0gZm4oa2V5LCBub25jZSwgWkVST1MzMik7XG4gICAgY29uc3QgaCA9IF9wb2x5MTMwNV9qc18xLnBvbHkxMzA1LmNyZWF0ZShhdXRoS2V5KTtcbiAgICBpZiAoQUFEKVxuICAgICAgICB1cGRhdGVQYWRkZWQoaCwgQUFEKTtcbiAgICB1cGRhdGVQYWRkZWQoaCwgZGF0YSk7XG4gICAgY29uc3QgbnVtID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuICAgIGNvbnN0IHZpZXcgPSAoMCwgdXRpbHNfanNfMS5jcmVhdGVWaWV3KShudW0pO1xuICAgICgwLCB1dGlsc19qc18xLnNldEJpZ1VpbnQ2NCkodmlldywgMCwgQmlnSW50KEFBRCA/IEFBRC5sZW5ndGggOiAwKSwgdHJ1ZSk7XG4gICAgKDAsIHV0aWxzX2pzXzEuc2V0QmlnVWludDY0KSh2aWV3LCA4LCBCaWdJbnQoZGF0YS5sZW5ndGgpLCB0cnVlKTtcbiAgICBoLnVwZGF0ZShudW0pO1xuICAgIGNvbnN0IHJlcyA9IGguZGlnZXN0KCk7XG4gICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKGF1dGhLZXksIG51bSk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQUVBRCBhbGdvcml0aG0gZnJvbSBSRkMgODQzOS5cbiAqIFNhbHNhMjAgYW5kIGNoYWNoYSAoUkZDIDg0MzkpIHVzZSBwb2x5MTMwNSBkaWZmZXJlbnRseS5cbiAqIFdlIGNvdWxkIGhhdmUgY29tcG9zZWQgdGhlbSBzaW1pbGFyIHRvOlxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9zY3VyZS1iYXNlL2Jsb2IvYjI2NmM3M2RkZTk3N2IxZGQ3ZWY0MGVmN2EyM2NjMTVhYWI1MjZiMy9pbmRleC50cyNMMjUwXG4gKiBCdXQgaXQncyBoYXJkIGJlY2F1c2Ugb2YgYXV0aEtleTpcbiAqIEluIHNhbHNhMjAsIGF1dGhLZXkgY2hhbmdlcyBwb3NpdGlvbiBpbiBzYWxzYSBzdHJlYW0uXG4gKiBJbiBjaGFjaGEsIGF1dGhLZXkgY2FuJ3QgYmUgY29tcHV0ZWQgaW5zaWRlIGNvbXB1dGVUYWcsIGl0IG1vZGlmaWVzIHRoZSBjb3VudGVyLlxuICovXG5jb25zdCBfcG9seTEzMDVfYWVhZCA9ICh4b3JTdHJlYW0pID0+IChrZXksIG5vbmNlLCBBQUQpID0+IHtcbiAgICBjb25zdCB0YWdMZW5ndGggPSAxNjtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShrZXksIDMyKTtcbiAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShub25jZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jcnlwdChwbGFpbnRleHQsIG91dHB1dCkge1xuICAgICAgICAgICAgY29uc3QgcGxlbmd0aCA9IHBsYWludGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBjbGVuZ3RoID0gcGxlbmd0aCArIHRhZ0xlbmd0aDtcbiAgICAgICAgICAgIGlmIChvdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAoMCwgX2Fzc2VydF9qc18xLmJ5dGVzKShvdXRwdXQsIGNsZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoY2xlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB4b3JTdHJlYW0oa2V5LCBub25jZSwgcGxhaW50ZXh0LCBvdXRwdXQsIDEpO1xuICAgICAgICAgICAgY29uc3QgdGFnID0gY29tcHV0ZVRhZyh4b3JTdHJlYW0sIGtleSwgbm9uY2UsIG91dHB1dC5zdWJhcnJheSgwLCAtdGFnTGVuZ3RoKSwgQUFEKTtcbiAgICAgICAgICAgIG91dHB1dC5zZXQodGFnLCBwbGVuZ3RoKTsgLy8gYXBwZW5kIHRhZ1xuICAgICAgICAgICAgKDAsIHV0aWxzX2pzXzEuY2xlYW4pKHRhZyk7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LFxuICAgICAgICBkZWNyeXB0KGNpcGhlcnRleHQsIG91dHB1dCkge1xuICAgICAgICAgICAgY29uc3QgY2xlbmd0aCA9IGNpcGhlcnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcGxlbmd0aCA9IGNsZW5ndGggLSB0YWdMZW5ndGg7XG4gICAgICAgICAgICBpZiAoY2xlbmd0aCA8IHRhZ0xlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGVuY3J5cHRlZCBkYXRhIG11c3QgYmUgYXQgbGVhc3QgJHt0YWdMZW5ndGh9IGJ5dGVzYCk7XG4gICAgICAgICAgICBpZiAob3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgKDAsIF9hc3NlcnRfanNfMS5ieXRlcykob3V0cHV0LCBwbGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IG5ldyBVaW50OEFycmF5KHBsZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNpcGhlcnRleHQuc3ViYXJyYXkoMCwgLXRhZ0xlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBwYXNzZWRUYWcgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KC10YWdMZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgdGFnID0gY29tcHV0ZVRhZyh4b3JTdHJlYW0sIGtleSwgbm9uY2UsIGRhdGEsIEFBRCk7XG4gICAgICAgICAgICBpZiAoISgwLCB1dGlsc19qc18xLmVxdWFsQnl0ZXMpKHBhc3NlZFRhZywgdGFnKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdGFnJyk7XG4gICAgICAgICAgICB4b3JTdHJlYW0oa2V5LCBub25jZSwgZGF0YSwgb3V0cHV0LCAxKTtcbiAgICAgICAgICAgICgwLCB1dGlsc19qc18xLmNsZWFuKSh0YWcpO1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcbmV4cG9ydHMuX3BvbHkxMzA1X2FlYWQgPSBfcG9seTEzMDVfYWVhZDtcbi8qKlxuICogQ2hhQ2hhMjAtUG9seTEzMDUgZnJvbSBSRkMgODQzOS5cbiAqIFVuc2FmZSB0byB1c2UgcmFuZG9tIG5vbmNlcyB1bmRlciB0aGUgc2FtZSBrZXksIGR1ZSB0byBjb2xsaXNpb24gY2hhbmNlLlxuICogUHJlZmVyIFhDaGFDaGEgaW5zdGVhZC5cbiAqL1xuZXhwb3J0cy5jaGFjaGEyMHBvbHkxMzA1ID0gKDAsIHV0aWxzX2pzXzEud3JhcENpcGhlcikoeyBibG9ja1NpemU6IDY0LCBub25jZUxlbmd0aDogMTIsIHRhZ0xlbmd0aDogMTYgfSwgKDAsIGV4cG9ydHMuX3BvbHkxMzA1X2FlYWQpKGV4cG9ydHMuY2hhY2hhMjApKTtcbi8qKlxuICogWENoYUNoYTIwLVBvbHkxMzA1IGV4dGVuZGVkLW5vbmNlIGNoYWNoYS5cbiAqIENhbiBiZSBzYWZlbHkgdXNlZCB3aXRoIHJhbmRvbSBub25jZXMgKENTUFJORykuXG4gKiBbSVJURiBkcmFmdF0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmcteGNoYWNoYSkuXG4gKi9cbmV4cG9ydHMueGNoYWNoYTIwcG9seTEzMDUgPSAoMCwgdXRpbHNfanNfMS53cmFwQ2lwaGVyKSh7IGJsb2NrU2l6ZTogNjQsIG5vbmNlTGVuZ3RoOiAyNCwgdGFnTGVuZ3RoOiAxNiB9LCAoMCwgZXhwb3J0cy5fcG9seTEzMDVfYWVhZCkoZXhwb3J0cy54Y2hhY2hhMjApKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNoYWNoYS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMueGNoYWNoYTIwID0gdm9pZCAwO1xudmFyIGNoYWNoYV8xID0gcmVxdWlyZShcIkBub2JsZS9jaXBoZXJzL2NoYWNoYVwiKTtcbnZhciB4Y2hhY2hhMjAgPSBmdW5jdGlvbiAoa2V5LCBub25jZSwgQUFEKSB7XG4gICAgcmV0dXJuICgwLCBjaGFjaGFfMS54Y2hhY2hhMjBwb2x5MTMwNSkoa2V5LCBub25jZSwgQUFEKTtcbn07XG5leHBvcnRzLnhjaGFjaGEyMCA9IHhjaGFjaGEyMDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZWxsaXB0aWNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hhc2hcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hleFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3ltbWV0cmljXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZXNEZWNyeXB0ID0gZXhwb3J0cy5hZXNFbmNyeXB0ID0gZXhwb3J0cy5zeW1EZWNyeXB0ID0gZXhwb3J0cy5zeW1FbmNyeXB0ID0gdm9pZCAwO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2NpcGhlcnMvdXRpbHNcIik7XG52YXIgd2ViY3J5cHRvXzEgPSByZXF1aXJlKFwiQG5vYmxlL2NpcGhlcnMvd2ViY3J5cHRvXCIpO1xudmFyIGFlc18xID0gcmVxdWlyZShcIkBlY2llcy9jaXBoZXJzL2Flc1wiKTtcbnZhciBjaGFjaGFfMSA9IHJlcXVpcmUoXCJAZWNpZXMvY2lwaGVycy9jaGFjaGFcIik7XG52YXIgY29uZmlnXzEgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xudmFyIGNvbnN0c18xID0gcmVxdWlyZShcIi4uL2NvbnN0c1wiKTtcbnZhciBzeW1FbmNyeXB0ID0gZnVuY3Rpb24gKGtleSwgcGxhaW5UZXh0LCBBQUQpIHsgcmV0dXJuIF9leGVjKF9lbmNyeXB0LCBrZXksIHBsYWluVGV4dCwgQUFEKTsgfTtcbmV4cG9ydHMuc3ltRW5jcnlwdCA9IHN5bUVuY3J5cHQ7XG52YXIgc3ltRGVjcnlwdCA9IGZ1bmN0aW9uIChrZXksIGNpcGhlclRleHQsIEFBRCkgeyByZXR1cm4gX2V4ZWMoX2RlY3J5cHQsIGtleSwgY2lwaGVyVGV4dCwgQUFEKTsgfTtcbmV4cG9ydHMuc3ltRGVjcnlwdCA9IHN5bURlY3J5cHQ7XG4vKiogQGRlcHJlY2F0ZWQgLSB1c2UgYHN5bUVuY3J5cHRgIGluc3RlYWQuICovXG5leHBvcnRzLmFlc0VuY3J5cHQgPSBleHBvcnRzLnN5bUVuY3J5cHQ7IC8vIFRPRE86IGRlbGV0ZVxuLyoqIEBkZXByZWNhdGVkIC0gdXNlIGBzeW1EZWNyeXB0YCBpbnN0ZWFkLiAqL1xuZXhwb3J0cy5hZXNEZWNyeXB0ID0gZXhwb3J0cy5zeW1EZWNyeXB0OyAvLyBUT0RPOiBkZWxldGVcbmZ1bmN0aW9uIF9leGVjKGNhbGxiYWNrLCBrZXksIGRhdGEsIEFBRCkge1xuICAgIHZhciBhbGdvcml0aG0gPSAoMCwgY29uZmlnXzEuc3ltbWV0cmljQWxnb3JpdGhtKSgpO1xuICAgIGlmIChhbGdvcml0aG0gPT09IFwiYWVzLTI1Ni1nY21cIikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soYWVzXzEuYWVzMjU2Z2NtLCBrZXksIGRhdGEsICgwLCBjb25maWdfMS5zeW1tZXRyaWNOb25jZUxlbmd0aCkoKSwgY29uc3RzXzEuQUVBRF9UQUdfTEVOR1RILCBBQUQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhbGdvcml0aG0gPT09IFwieGNoYWNoYTIwXCIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGNoYWNoYV8xLnhjaGFjaGEyMCwga2V5LCBkYXRhLCBjb25zdHNfMS5YQ0hBQ0hBMjBfTk9OQ0VfTEVOR1RILCBjb25zdHNfMS5BRUFEX1RBR19MRU5HVEgsIEFBRCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsZ29yaXRobSA9PT0gXCJhZXMtMjU2LWNiY1wiKSB7XG4gICAgICAgIC8vIE5PVCBSRUNPTU1FTkRFRC4gVGhlcmUgaXMgbmVpdGhlciBBQUQgbm9yIEFFQUQgdGFnIGluIGNiYyBtb2RlXG4gICAgICAgIC8vIGFlcy0yNTYtY2JjIGFsd2F5cyB1c2VzIDE2IGJ5dGVzIGl2XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhhZXNfMS5hZXMyNTZjYmMsIGtleSwgZGF0YSwgMTYsIDApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9lbmNyeXB0KGZ1bmMsIGtleSwgZGF0YSwgbm9uY2VMZW5ndGgsIHRhZ0xlbmd0aCwgQUFEKSB7XG4gICAgdmFyIG5vbmNlID0gKDAsIHdlYmNyeXB0b18xLnJhbmRvbUJ5dGVzKShub25jZUxlbmd0aCk7XG4gICAgdmFyIGNpcGhlciA9IGZ1bmMoa2V5LCBub25jZSwgQUFEKTtcbiAgICAvLyBAbm9ibGUvY2lwaGVycyBmb3JtYXQ6IGNpcGhlclRleHQgfHwgdGFnXG4gICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5lbmNyeXB0KGRhdGEpO1xuICAgIGlmICh0YWdMZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShub25jZSwgZW5jcnlwdGVkKTtcbiAgICB9XG4gICAgdmFyIGNpcGhlclRleHRMZW5ndGggPSBlbmNyeXB0ZWQubGVuZ3RoIC0gdGFnTGVuZ3RoO1xuICAgIHZhciBjaXBoZXJUZXh0ID0gZW5jcnlwdGVkLnN1YmFycmF5KDAsIGNpcGhlclRleHRMZW5ndGgpO1xuICAgIHZhciB0YWcgPSBlbmNyeXB0ZWQuc3ViYXJyYXkoY2lwaGVyVGV4dExlbmd0aCk7XG4gICAgLy8gZWNpZXMgcGF5bG9hZCBmb3JtYXQ6IHBrIHx8IG5vbmNlIHx8IHRhZyB8fCBjaXBoZXJUZXh0XG4gICAgcmV0dXJuICgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShub25jZSwgdGFnLCBjaXBoZXJUZXh0KTtcbn1cbmZ1bmN0aW9uIF9kZWNyeXB0KGZ1bmMsIGtleSwgZGF0YSwgbm9uY2VMZW5ndGgsIHRhZ0xlbmd0aCwgQUFEKSB7XG4gICAgdmFyIG5vbmNlID0gZGF0YS5zdWJhcnJheSgwLCBub25jZUxlbmd0aCk7XG4gICAgdmFyIGNpcGhlciA9IGZ1bmMoa2V5LCBVaW50OEFycmF5LmZyb20obm9uY2UpLCBBQUQpOyAvLyB0byByZXNldCBieXRlT2Zmc2V0XG4gICAgdmFyIGVuY3J5cHRlZCA9IGRhdGEuc3ViYXJyYXkobm9uY2VMZW5ndGgpO1xuICAgIGlmICh0YWdMZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGNpcGhlci5kZWNyeXB0KGVuY3J5cHRlZCk7XG4gICAgfVxuICAgIHZhciB0YWcgPSBlbmNyeXB0ZWQuc3ViYXJyYXkoMCwgdGFnTGVuZ3RoKTtcbiAgICB2YXIgY2lwaGVyVGV4dCA9IGVuY3J5cHRlZC5zdWJhcnJheSh0YWdMZW5ndGgpO1xuICAgIHJldHVybiBjaXBoZXIuZGVjcnlwdCgoMCwgdXRpbHNfMS5jb25jYXRCeXRlcykoY2lwaGVyVGV4dCwgdGFnKSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHVibGljS2V5ID0gdm9pZCAwO1xudmFyIHV0aWxzXzEgPSByZXF1aXJlKFwiQG5vYmxlL2NpcGhlcnMvdXRpbHNcIik7XG52YXIgdXRpbHNfMiA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbnZhciBQdWJsaWNLZXkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHVibGljS2V5KGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gKDAsIHV0aWxzXzIuY29udmVydFB1YmxpY0tleUZvcm1hdCkoZGF0YSwgdHJ1ZSk7XG4gICAgfVxuICAgIFB1YmxpY0tleS5mcm9tSGV4ID0gZnVuY3Rpb24gKGhleCkge1xuICAgICAgICByZXR1cm4gbmV3IFB1YmxpY0tleSgoMCwgdXRpbHNfMi5oZXhUb1B1YmxpY0tleSkoaGV4KSk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHVibGljS2V5LnByb3RvdHlwZSwgXCJ1bmNvbXByZXNzZWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFVpbnQ4QXJyYXlcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSgoMCwgdXRpbHNfMi5jb252ZXJ0UHVibGljS2V5Rm9ybWF0KSh0aGlzLmRhdGEsIGZhbHNlKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUHVibGljS2V5LnByb3RvdHlwZSwgXCJjb21wcmVzc2VkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBVaW50OEFycmF5XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5kYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFB1YmxpY0tleS5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbiAoY29tcHJlc3NlZCkge1xuICAgICAgICBpZiAoY29tcHJlc3NlZCA9PT0gdm9pZCAwKSB7IGNvbXByZXNzZWQgPSB0cnVlOyB9XG4gICAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuYnl0ZXNUb0hleCkodGhpcy5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KSh0aGlzLnVuY29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlcml2ZXMgYSBzaGFyZWQgc2VjcmV0IGZyb20gcmVjZWl2ZXIncyBwcml2YXRlIGtleSAoc2spIGFuZCBlcGhlbWVyYWwgcHVibGljIGtleSAodGhpcykuXG4gICAgICogT3Bwb3NpdGUgb2YgYGVuY2Fwc3VsYXRlYC5cbiAgICAgKiBAc2VlIFByaXZhdGVLZXkuZW5jYXBzdWxhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzayAtIFJlY2VpdmVyJ3MgcHJpdmF0ZSBrZXkuXG4gICAgICogQHBhcmFtIGNvbXByZXNzZWQgLSBXaGV0aGVyIHRvIHVzZSBjb21wcmVzc2VkIG9yIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5cyBpbiB0aGUga2V5IGRlcml2YXRpb24gKHNlY3AyNTZrMSBvbmx5KS5cbiAgICAgKiBAcmV0dXJucyBTaGFyZWQgc2VjcmV0LCBkZXJpdmVkIHdpdGggSEtERi1TSEEyNTYuXG4gICAgICovXG4gICAgUHVibGljS2V5LnByb3RvdHlwZS5kZWNhcHN1bGF0ZSA9IGZ1bmN0aW9uIChzaywgY29tcHJlc3NlZCkge1xuICAgICAgICBpZiAoY29tcHJlc3NlZCA9PT0gdm9pZCAwKSB7IGNvbXByZXNzZWQgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgc2VuZGVyUG9pbnQgPSBjb21wcmVzc2VkID8gdGhpcy5kYXRhIDogdGhpcy51bmNvbXByZXNzZWQ7XG4gICAgICAgIHZhciBzaGFyZWRQb2ludCA9IHNrLm11bHRpcGx5KHRoaXMsIGNvbXByZXNzZWQpO1xuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzIuZ2V0U2hhcmVkS2V5KShzZW5kZXJQb2ludCwgc2hhcmVkUG9pbnQpO1xuICAgIH07XG4gICAgUHVibGljS2V5LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmVxdWFsQnl0ZXMpKHRoaXMuZGF0YSwgb3RoZXIuZGF0YSk7XG4gICAgfTtcbiAgICByZXR1cm4gUHVibGljS2V5O1xufSgpKTtcbmV4cG9ydHMuUHVibGljS2V5ID0gUHVibGljS2V5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlByaXZhdGVLZXkgPSB2b2lkIDA7XG52YXIgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbm9ibGUvY2lwaGVycy91dGlsc1wiKTtcbnZhciB1dGlsc18yID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xudmFyIFB1YmxpY0tleV8xID0gcmVxdWlyZShcIi4vUHVibGljS2V5XCIpO1xudmFyIFByaXZhdGVLZXkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJpdmF0ZUtleShzZWNyZXQpIHtcbiAgICAgICAgaWYgKHNlY3JldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSAoMCwgdXRpbHNfMi5nZXRWYWxpZFNlY3JldCkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgdXRpbHNfMi5pc1ZhbGlkUHJpdmF0ZUtleSkoc2VjcmV0KSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gc2VjcmV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwcml2YXRlIGtleVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1YmxpY0tleSA9IG5ldyBQdWJsaWNLZXlfMS5QdWJsaWNLZXkoKDAsIHV0aWxzXzIuZ2V0UHVibGljS2V5KSh0aGlzLmRhdGEpKTtcbiAgICB9XG4gICAgUHJpdmF0ZUtleS5mcm9tSGV4ID0gZnVuY3Rpb24gKGhleCkge1xuICAgICAgICByZXR1cm4gbmV3IFByaXZhdGVLZXkoKDAsIHV0aWxzXzIuZGVjb2RlSGV4KShoZXgpKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQcml2YXRlS2V5LnByb3RvdHlwZSwgXCJzZWNyZXRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFVpbnQ4QXJyYXlcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh0aGlzLmRhdGEpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgUHJpdmF0ZUtleS5wcm90b3R5cGUudG9IZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5ieXRlc1RvSGV4KSh0aGlzLmRhdGEpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVyaXZlcyBhIHNoYXJlZCBzZWNyZXQgZnJvbSBlcGhlbWVyYWwgcHJpdmF0ZSBrZXkgKHRoaXMpIGFuZCByZWNlaXZlcidzIHB1YmxpYyBrZXkgKHBrKS5cbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIHNoYXJlZCBrZXkgaXMgMzIgYnl0ZXMsIGRlcml2ZWQgd2l0aCBgSEtERi1TSEEyNTYoc2VuZGVyUG9pbnQgfHwgc2hhcmVkUG9pbnQpYC4gU2VlIGltcGxlbWVudGF0aW9uIGZvciBkZXRhaWxzLlxuICAgICAqXG4gICAgICogVGhlcmUgYXJlIHNvbWUgdmFyaWF0aW9ucyBpbiBkaWZmZXJlbnQgRUNJRVMgaW1wbGVtZW50YXRpb25zOlxuICAgICAqIHdoaWNoIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIHRvIHVzZSwgY29tcHJlc3NlZCBvciB1bmNvbXByZXNzZWQgYHNlbmRlclBvaW50YC9gc2hhcmVkUG9pbnRgLCB3aGV0aGVyIHRvIGluY2x1ZGUgYHNlbmRlclBvaW50YCwgZXRjLlxuICAgICAqXG4gICAgICogQmVjYXVzZSB0aGUgZW50cm9weSBvZiBgc2VuZGVyUG9pbnRgLCBgc2hhcmVkUG9pbnRgIGlzIGVub3VnaCBoaWdoWzFdLCB3ZSBkb24ndCBuZWVkIHNhbHQgdG8gZGVyaXZlIGtleXMuXG4gICAgICpcbiAgICAgKiBbMV06IFR3byByZWFzb25zOiB0aGUgcHVibGljIGtleXMgYXJlIFwicmFuZG9tXCIgYnl0ZXMgKGFsYmVpdCBzZWNwMjU2azEgcHVibGljIGtleXMgYXJlICoqbm90IHVuaWZvcm1seSoqIHJhbmRvbSksIGFuZCBlcGhlbWVyYWwga2V5cyBhcmUgZ2VuZXJhdGVkIGluIGV2ZXJ5IGVuY3J5cHRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGsgLSBSZWNlaXZlcidzIHB1YmxpYyBrZXkuXG4gICAgICogQHBhcmFtIGNvbXByZXNzZWQgLSBXaGV0aGVyIHRvIHVzZSBjb21wcmVzc2VkIG9yIHVuY29tcHJlc3NlZCBwdWJsaWMga2V5cyBpbiB0aGUga2V5IGRlcml2YXRpb24gKHNlY3AyNTZrMSBvbmx5KS5cbiAgICAgKiBAcmV0dXJucyBTaGFyZWQgc2VjcmV0LCBkZXJpdmVkIHdpdGggSEtERi1TSEEyNTYuXG4gICAgICovXG4gICAgUHJpdmF0ZUtleS5wcm90b3R5cGUuZW5jYXBzdWxhdGUgPSBmdW5jdGlvbiAocGssIGNvbXByZXNzZWQpIHtcbiAgICAgICAgaWYgKGNvbXByZXNzZWQgPT09IHZvaWQgMCkgeyBjb21wcmVzc2VkID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIHNlbmRlclBvaW50ID0gY29tcHJlc3NlZFxuICAgICAgICAgICAgPyB0aGlzLnB1YmxpY0tleS5jb21wcmVzc2VkXG4gICAgICAgICAgICA6IHRoaXMucHVibGljS2V5LnVuY29tcHJlc3NlZDtcbiAgICAgICAgdmFyIHNoYXJlZFBvaW50ID0gdGhpcy5tdWx0aXBseShwaywgY29tcHJlc3NlZCk7XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMi5nZXRTaGFyZWRLZXkpKHNlbmRlclBvaW50LCBzaGFyZWRQb2ludCk7XG4gICAgfTtcbiAgICBQcml2YXRlS2V5LnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChwaywgY29tcHJlc3NlZCkge1xuICAgICAgICBpZiAoY29tcHJlc3NlZCA9PT0gdm9pZCAwKSB7IGNvbXByZXNzZWQgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzIuZ2V0U2hhcmVkUG9pbnQpKHRoaXMuZGF0YSwgcGsuY29tcHJlc3NlZCwgY29tcHJlc3NlZCk7XG4gICAgfTtcbiAgICBQcml2YXRlS2V5LnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dGlsc18xLmVxdWFsQnl0ZXMpKHRoaXMuZGF0YSwgb3RoZXIuZGF0YSk7XG4gICAgfTtcbiAgICByZXR1cm4gUHJpdmF0ZUtleTtcbn0oKSk7XG5leHBvcnRzLlByaXZhdGVLZXkgPSBQcml2YXRlS2V5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlB1YmxpY0tleSA9IGV4cG9ydHMuUHJpdmF0ZUtleSA9IHZvaWQgMDtcbi8vIHRyZWF0IEJ1ZmZlciBhcyBVaW50OGFycmF5LCBpLmUuIG5vIGNhbGwgb2YgQnVmZmVyIHNwZWNpZmljIGZ1bmN0aW9uc1xuLy8gZmluYWxseSBVaW50OEFycmF5IG9ubHlcbnZhciBQcml2YXRlS2V5XzEgPSByZXF1aXJlKFwiLi9Qcml2YXRlS2V5XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUHJpdmF0ZUtleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUHJpdmF0ZUtleV8xLlByaXZhdGVLZXk7IH0gfSk7XG52YXIgUHVibGljS2V5XzEgPSByZXF1aXJlKFwiLi9QdWJsaWNLZXlcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQdWJsaWNLZXlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFB1YmxpY0tleV8xLlB1YmxpY0tleTsgfSB9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51dGlscyA9IGV4cG9ydHMuUHVibGljS2V5ID0gZXhwb3J0cy5Qcml2YXRlS2V5ID0gZXhwb3J0cy5FQ0lFU19DT05GSUcgPSB2b2lkIDA7XG5leHBvcnRzLmVuY3J5cHQgPSBlbmNyeXB0O1xuZXhwb3J0cy5kZWNyeXB0ID0gZGVjcnlwdDtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIkBub2JsZS9jaXBoZXJzL3V0aWxzXCIpO1xudmFyIGNvbmZpZ18xID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xudmFyIGtleXNfMSA9IHJlcXVpcmUoXCIuL2tleXNcIik7XG52YXIgdXRpbHNfMiA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBFbmNyeXB0cyBhIG1lc3NhZ2UuXG4gKiBAZGVzY3JpcHRpb24gRnJvbSB2ZXJzaW9uIDAuNS4wLCBgVWludDhBcnJheWAgd2lsbCBiZSByZXR1cm5lZCBpbnN0ZWFkIG9mIGBCdWZmZXJgLlxuICogVG8ga2VlcCB0aGUgc2FtZSBiZWhhdmlvciwgdXNlIGBCdWZmZXIuZnJvbShlbmNyeXB0KC4uLikpYC5cbiAqXG4gKiBAcGFyYW0gcmVjZWl2ZXJSYXdQSyAtIFJhdyBwdWJsaWMga2V5IG9mIHRoZSByZWNlaXZlciwgZWl0aGVyIGFzIGEgaGV4IHN0cmluZyBvciBhIFVpbnQ4QXJyYXkuXG4gKiBAcGFyYW0gbXNnIC0gTWVzc2FnZSB0byBlbmNyeXB0LlxuICogQHJldHVybnMgRW5jcnlwdGVkIHBheWxvYWQsIGZvcm1hdDogYHB1YmxpYyBrZXkgfHwgZW5jcnlwdGVkYC5cbiAqL1xuZnVuY3Rpb24gZW5jcnlwdChyZWNlaXZlclJhd1BLLCBtc2cpIHtcbiAgICB2YXIgZXBoZW1lcmFsU0sgPSBuZXcga2V5c18xLlByaXZhdGVLZXkoKTtcbiAgICB2YXIgcmVjZWl2ZXJQSyA9IHJlY2VpdmVyUmF3UEsgaW5zdGFuY2VvZiBVaW50OEFycmF5XG4gICAgICAgID8gbmV3IGtleXNfMS5QdWJsaWNLZXkocmVjZWl2ZXJSYXdQSylcbiAgICAgICAgOiBrZXlzXzEuUHVibGljS2V5LmZyb21IZXgocmVjZWl2ZXJSYXdQSyk7XG4gICAgdmFyIHNoYXJlZEtleSA9IGVwaGVtZXJhbFNLLmVuY2Fwc3VsYXRlKHJlY2VpdmVyUEssICgwLCBjb25maWdfMS5pc0hrZGZLZXlDb21wcmVzc2VkKSgpKTtcbiAgICB2YXIgZXBoZW1lcmFsUEsgPSAoMCwgY29uZmlnXzEuaXNFcGhlbWVyYWxLZXlDb21wcmVzc2VkKSgpXG4gICAgICAgID8gZXBoZW1lcmFsU0sucHVibGljS2V5LmNvbXByZXNzZWRcbiAgICAgICAgOiBlcGhlbWVyYWxTSy5wdWJsaWNLZXkudW5jb21wcmVzc2VkO1xuICAgIHZhciBlbmNyeXB0ZWQgPSAoMCwgdXRpbHNfMi5zeW1FbmNyeXB0KShzaGFyZWRLZXksIG1zZyk7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKCgwLCB1dGlsc18xLmNvbmNhdEJ5dGVzKShlcGhlbWVyYWxQSywgZW5jcnlwdGVkKSk7XG59XG4vKipcbiAqIERlY3J5cHRzIGEgbWVzc2FnZS5cbiAqIEBkZXNjcmlwdGlvbiBGcm9tIHZlcnNpb24gMC41LjAsIGBVaW50OEFycmF5YCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2YgYEJ1ZmZlcmAuXG4gKiBUbyBrZWVwIHRoZSBzYW1lIGJlaGF2aW9yLCB1c2UgYEJ1ZmZlci5mcm9tKGRlY3J5cHQoLi4uKSlgLlxuICpcbiAqIEBwYXJhbSByZWNlaXZlclJhd1NLIC0gUmF3IHByaXZhdGUga2V5IG9mIHRoZSByZWNlaXZlciwgZWl0aGVyIGFzIGEgaGV4IHN0cmluZyBvciBhIFVpbnQ4QXJyYXkuXG4gKiBAcGFyYW0gbXNnIC0gTWVzc2FnZSB0byBkZWNyeXB0LlxuICogQHJldHVybnMgRGVjcnlwdGVkIHBsYWluIHRleHQuXG4gKi9cbmZ1bmN0aW9uIGRlY3J5cHQocmVjZWl2ZXJSYXdTSywgbXNnKSB7XG4gICAgdmFyIHJlY2VpdmVyU0sgPSByZWNlaXZlclJhd1NLIGluc3RhbmNlb2YgVWludDhBcnJheVxuICAgICAgICA/IG5ldyBrZXlzXzEuUHJpdmF0ZUtleShyZWNlaXZlclJhd1NLKVxuICAgICAgICA6IGtleXNfMS5Qcml2YXRlS2V5LmZyb21IZXgocmVjZWl2ZXJSYXdTSyk7XG4gICAgdmFyIGtleVNpemUgPSAoMCwgY29uZmlnXzEuZXBoZW1lcmFsS2V5U2l6ZSkoKTtcbiAgICB2YXIgZXBoZW1lcmFsUEsgPSBuZXcga2V5c18xLlB1YmxpY0tleShtc2cuc3ViYXJyYXkoMCwga2V5U2l6ZSkpO1xuICAgIHZhciBlbmNyeXB0ZWQgPSBtc2cuc3ViYXJyYXkoa2V5U2l6ZSk7XG4gICAgdmFyIHNoYXJlZEtleSA9IGVwaGVtZXJhbFBLLmRlY2Fwc3VsYXRlKHJlY2VpdmVyU0ssICgwLCBjb25maWdfMS5pc0hrZGZLZXlDb21wcmVzc2VkKSgpKTtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oKDAsIHV0aWxzXzIuc3ltRGVjcnlwdCkoc2hhcmVkS2V5LCBlbmNyeXB0ZWQpKTtcbn1cbnZhciBjb25maWdfMiA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkVDSUVTX0NPTkZJR1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uZmlnXzIuRUNJRVNfQ09ORklHOyB9IH0pO1xudmFyIGtleXNfMiA9IHJlcXVpcmUoXCIuL2tleXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcml2YXRlS2V5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBrZXlzXzIuUHJpdmF0ZUtleTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlB1YmxpY0tleVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4ga2V5c18yLlB1YmxpY0tleTsgfSB9KTtcbi8qKiBAZGVwcmVjYXRlZCAtIHVzZSBgaW1wb3J0IHV0aWxzIGZyb20gXCJlY2llc2pzL3V0aWxzXCJgIGluc3RlYWQuICovXG5leHBvcnRzLnV0aWxzID0ge1xuICAgIC8vIFRPRE86IHJlbW92ZSB0aGVzZSBhZnRlciAwLjUuMFxuICAgIGFlc0VuY3J5cHQ6IHV0aWxzXzIuYWVzRW5jcnlwdCxcbiAgICBhZXNEZWNyeXB0OiB1dGlsc18yLmFlc0RlY3J5cHQsXG4gICAgc3ltRW5jcnlwdDogdXRpbHNfMi5zeW1FbmNyeXB0LFxuICAgIHN5bURlY3J5cHQ6IHV0aWxzXzIuc3ltRGVjcnlwdCxcbiAgICBkZWNvZGVIZXg6IHV0aWxzXzIuZGVjb2RlSGV4LFxuICAgIGdldFZhbGlkU2VjcmV0OiB1dGlsc18yLmdldFZhbGlkU2VjcmV0LFxuICAgIHJlbW92ZTB4OiB1dGlsc18yLnJlbW92ZTB4LFxufTtcbiIsImltcG9ydHtfX2F3YWl0ZXIgYXMgZX1mcm9tXCJ0c2xpYlwiO2ltcG9ydCB0IGZyb21cImNyb3NzLWZldGNoXCI7aW1wb3J0IG4gZnJvbVwiZGVidWdcIjtpbXBvcnR7QnVmZmVyfWZyb21cImJ1ZmZlclwiO2ltcG9ydHtQcml2YXRlS2V5IGFzIGksZW5jcnlwdCBhcyBvLGRlY3J5cHQgYXMgYX1mcm9tXCJlY2llc2pzXCI7aW1wb3J0e2FuYWx5dGljcyBhcyBjfWZyb21cIkBtZXRhbWFzay9zZGstYW5hbHl0aWNzXCI7aW1wb3J0e0V2ZW50RW1pdHRlcjIgYXMgc31mcm9tXCJldmVudGVtaXR0ZXIyXCI7aW1wb3J0e3ZhbGlkYXRlIGFzIHIsdjQgYXMgbH1mcm9tXCJ1dWlkXCI7aW1wb3J0e2lvIGFzIGR9ZnJvbVwic29ja2V0LmlvLWNsaWVudFwiO2NvbnN0IHU9bihcIktleUV4Y2hhbmdlOkxheWVyXCIpLGg9bihcIlNvY2tldFNlcnZpY2U6TGF5ZXJcIiksbT1uKFwiRWNpZXM6TGF5ZXJcIiksRT1uKFwiUmVtb3RlQ29tbXVuaWNhdGlvbjpMYXllclwiKTt1LmNvbG9yPVwiIyM5NWM0NGVcIixoLmNvbG9yPVwiI2Y2MzhkN1wiLG0uY29sb3I9XCIjNDY1YjljXCIsRS5jb2xvcj1cIiM0N2EyYmVcIjtjb25zdCBnPXtLZXlFeGNoYW5nZTp1LFNvY2tldFNlcnZpY2U6aCxFY2llczptLFJlbW90ZUNvbW11bmljYXRpb246RX07bGV0IHYseT1bXSxTPVtdO2NvbnN0IEM9KG4saSk9PmUodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3Y9aSxTLnB1c2gobiksZnVuY3Rpb24obil7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtpZighdnx8IW4pcmV0dXJuOyFmdW5jdGlvbigpe2NvbnN0IGU9UztTPXkseT1lfSgpO2NvbnN0IGU9di5lbmRzV2l0aChcIi9cIik/YCR7dn1ldnRgOmAke3Z9L2V2dGAsaT1PYmplY3QuYXNzaWduKHt9LG4pO2lmKGRlbGV0ZSBpLnBhcmFtcyxuLnBhcmFtcylmb3IoY29uc3RbZSx0XW9mIE9iamVjdC5lbnRyaWVzKG4ucGFyYW1zKSlpW2VdPXQ7Y29uc3Qgbz1KU09OLnN0cmluZ2lmeShpKTtnLlJlbW90ZUNvbW11bmljYXRpb24oYFtzZW5kQnVmZmVyZWRFdmVudHNdIFNlbmRpbmcgJHt5Lmxlbmd0aH0gYW5hbHl0aWNzIGV2ZW50cyB0byAke2V9YCk7dHJ5e2NvbnN0IG49eWllbGQgdChlLHttZXRob2Q6XCJQT1NUXCIsaGVhZGVyczp7QWNjZXB0OlwiYXBwbGljYXRpb24vanNvblwiLFwiQ29udGVudC1UeXBlXCI6XCJhcHBsaWNhdGlvbi9qc29uXCJ9LGJvZHk6b30pLGk9eWllbGQgbi50ZXh0KCk7Zy5SZW1vdGVDb21tdW5pY2F0aW9uKGBbc2VuZEJ1ZmZlcmVkRXZlbnRzXSBSZXNwb25zZTogJHtpfWApLHkubGVuZ3RoPTB9Y2F0Y2goZSl7fX0pKX0obikuY2F0Y2goKCgpPT57fSkpfSkpO2NsYXNzIHB7Y29uc3RydWN0b3IoZSl7dGhpcy5lbmFibGVkPSEwLChudWxsPT1lP3ZvaWQgMDplLmRlYnVnKSYmbi5lbmFibGUoXCJFY2llczpMYXllclwiKSx0aGlzLmVjaWVzPShudWxsPT1lP3ZvaWQgMDplLnByaXZhdGVLZXkpP2kuZnJvbUhleChlLnByaXZhdGVLZXkpOm5ldyBpLGcuRWNpZXMoXCJbRUNJRVMgY29uc3RydWN0b3IoKV0gaW5pdGlhbGl6ZWQgc2VjcmV0OiBcIix0aGlzLmVjaWVzLnRvSGV4KCkpLGcuRWNpZXMoXCJbRUNJRVMgY29uc3RydWN0b3IoKV0gaW5pdGlhbGl6ZWQgcHVibGljOiBcIix0aGlzLmVjaWVzLnB1YmxpY0tleS50b0hleCgpKSxnLkVjaWVzKFwiW0VDSUVTIGNvbnN0cnVjdG9yKCldIGluaXQgd2l0aFwiLHRoaXMpfWdlbmVyYXRlRUNJRVMoKXt0aGlzLmVjaWVzPW5ldyBpfWdldFB1YmxpY0tleSgpe3JldHVybiB0aGlzLmVjaWVzLnB1YmxpY0tleS50b0hleCgpfWVuY3J5cHQoZSx0KXtsZXQgbj1lO2lmKHRoaXMuZW5hYmxlZCl0cnl7Zy5FY2llcyhcIltFQ0lFUzogZW5jcnlwdCgpXSB1c2luZyBvdGhlclB1YmxpY0tleVwiLHQpO2NvbnN0IGk9QnVmZmVyLmZyb20oZSksYT1vKHQsaSk7bj1CdWZmZXIuZnJvbShhKS50b1N0cmluZyhcImJhc2U2NFwiKX1jYXRjaChuKXt0aHJvdyBnLkVjaWVzKFwiW0VDSUVTOiBlbmNyeXB0KCldIGVycm9yIGVuY3J5cHQ6XCIsbiksZy5FY2llcyhcIltFQ0lFUzogZW5jcnlwdCgpXSBwcml2YXRlOiBcIix0aGlzLmVjaWVzLnRvSGV4KCkpLGcuRWNpZXMoXCJbRUNJRVM6IGVuY3J5cHQoKV0gZGF0YTogXCIsZSksZy5FY2llcyhcIltFQ0lFUzogZW5jcnlwdCgpXSBvdGhlcmtleTogXCIsdCksbn1yZXR1cm4gbn1kZWNyeXB0KGUpe2xldCB0PWU7aWYodGhpcy5lbmFibGVkKXRyeXtnLkVjaWVzKFwiW0VDSUVTOiBkZWNyeXB0KCldIHVzaW5nIHByaXZhdGVLZXlcIix0aGlzLmVjaWVzLnRvSGV4KCkpO2NvbnN0IG49QnVmZmVyLmZyb20oZS50b1N0cmluZygpLFwiYmFzZTY0XCIpO3Q9YSh0aGlzLmVjaWVzLnRvSGV4KCksbikudG9TdHJpbmcoKX1jYXRjaCh0KXt0aHJvdyBnLkVjaWVzKFwiW0VDSUVTOiBkZWNyeXB0KCldIGVycm9yIGRlY3J5cHRcIix0KSxnLkVjaWVzKFwiW0VDSUVTOiBkZWNyeXB0KCldIHByaXZhdGU6IFwiLHRoaXMuZWNpZXMudG9IZXgoKSksZy5FY2llcyhcIltFQ0lFUzogZGVjcnlwdCgpXSBlbmNyeXB0ZWREYXRhOiBcIixlKSx0fXJldHVybiB0fWdldEtleUluZm8oKXtyZXR1cm57cHJpdmF0ZTp0aGlzLmVjaWVzLnRvSGV4KCkscHVibGljOnRoaXMuZWNpZXMucHVibGljS2V5LnRvSGV4KCl9fXRvU3RyaW5nKCl7Zy5FY2llcyhcIltFQ0lFUzogdG9TdHJpbmcoKV1cIix0aGlzLmdldEtleUluZm8oKSl9fXZhciBmPXtuYW1lOlwiQG1ldGFtYXNrL3Nkay1jb21tdW5pY2F0aW9uLWxheWVyXCIsdmVyc2lvbjpcIjAuMzMuMVwiLGRlc2NyaXB0aW9uOlwiXCIsaG9tZXBhZ2U6XCJodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svbWV0YW1hc2stc2RrI3JlYWRtZVwiLGJ1Z3M6e3VybDpcImh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9tZXRhbWFzay1zZGsvaXNzdWVzXCJ9LHJlcG9zaXRvcnk6e3R5cGU6XCJnaXRcIix1cmw6XCJodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svbWV0YW1hc2stc2RrLmdpdFwiLGRpcmVjdG9yeTpcInBhY2thZ2VzL3Nkay1jb21tdW5pY2F0aW9uLWxheWVyXCJ9LG1haW46XCJkaXN0L25vZGUvY2pzL21ldGFtYXNrLXNkay1jb21tdW5pY2F0aW9uLWxheWVyLmpzXCIsdW5wa2c6XCJkaXN0L2Jyb3dzZXIvdW1kL21ldGFtYXNrLXNkay1jb21tdW5pY2F0aW9uLWxheWVyLmpzXCIsbW9kdWxlOlwiZGlzdC9ub2RlL2VzL21ldGFtYXNrLXNkay1jb21tdW5pY2F0aW9uLWxheWVyLmpzXCIsYnJvd3NlcjpcImRpc3QvYnJvd3Nlci9lcy9tZXRhbWFzay1zZGstY29tbXVuaWNhdGlvbi1sYXllci5qc1wiLFwicmVhY3QtbmF0aXZlXCI6XCJkaXN0L3JlYWN0LW5hdGl2ZS9lcy9tZXRhbWFzay1zZGstY29tbXVuaWNhdGlvbi1sYXllci5qc1wiLHR5cGVzOlwiZGlzdC90eXBlcy9zcmMvaW5kZXguZC50c1wiLGZpbGVzOltcIi9kaXN0XCJdLHNjcmlwdHM6e1wiYnVpbGQ6dHlwZXNcIjpcInRzYyAtLXByb2plY3QgdHNjb25maWcuYnVpbGQuanNvbiAtLWVtaXREZWNsYXJhdGlvbk9ubHkgLS1vdXREaXIgZGlzdC90eXBlc1wiLFwiYnVpbGQ6Y2xlYW5cIjpcInlhcm4gY2xlYW4gJiYgeWFybiBidWlsZFwiLGJ1aWxkOlwieWFybiBidWlsZDp0eXBlcyAmJiByb2xsdXAgLWMgLS1idW5kbGVDb25maWdBc0Nqc1wiLFwiYnVpbGQ6ZGV2XCI6XCJ5YXJuIGJ1aWxkOnR5cGVzICYmIE5PREVfRU5WPWRldiByb2xsdXAgLWMgLS1idW5kbGVDb25maWdBc0Nqc1wiLGRldjonY29uY3VycmVudGx5IFwidHNjIC0td2F0Y2hcIiBcInJvbGx1cCAtYyAtLWJ1bmRsZUNvbmZpZ0FzQ2pzIC13XCInLFwiYnVpbGQ6cG9zdC10c2NcIjpcImVjaG8gJ04vQSdcIixcImJ1aWxkOnByZS10c2NcIjpcImVjaG8gJ04vQSdcIixzaXplOlwic2l6ZS1saW1pdFwiLGNsZWFuOlwicmltcmFmIC4vZGlzdFwiLGxpbnQ6XCJ5YXJuIGxpbnQ6ZXNsaW50ICYmIHlhcm4gbGludDptaXNjIC0tY2hlY2tcIixcImxpbnQ6Y2hhbmdlbG9nXCI6XCIuLi8uLi9zY3JpcHRzL3ZhbGlkYXRlLWNoYW5nZWxvZy5zaCBAbWV0YW1hc2svc2RrLWNvbW11bmljYXRpb24tbGF5ZXJcIixcImxpbnQ6ZXNsaW50XCI6XCJlc2xpbnQgLiAtLWNhY2hlIC0tZXh0IGpzLHRzXCIsXCJsaW50OmZpeFwiOlwieWFybiBsaW50OmVzbGludCAtLWZpeCAmJiB5YXJuIGxpbnQ6bWlzYyAtLXdyaXRlXCIsXCJsaW50Om1pc2NcIjpcInByZXR0aWVyICcqKi8qLmpzb24nICcqKi8qLm1kJyAnIUNIQU5HRUxPRy5tZCcgLS1pZ25vcmUtcGF0aCAuLi8uLi8uZ2l0aWdub3JlXCIsXCJwdWJsaXNoOnByZXZpZXdcIjpcInlhcm4gbnBtIHB1Ymxpc2ggLS10YWcgcHJldmlld1wiLHByZXBhY2s6XCIuLi8uLi9zY3JpcHRzL3ByZXBhY2suc2hcIixyZXNldDpcInlhcm4gY2xlYW4gJiYgcmltcmFmIC4vbm9kZV9tb2R1bGVzL1wiLHRlc3Q6J2plc3QgLS10ZXN0UGF0aElnbm9yZVBhdHRlcm5zIFwiL2UyZS9cIicsXCJ0ZXN0OmUyZVwiOidqZXN0IC0tdGVzdFBhdGhQYXR0ZXJuIFwiL2UyZS9cIicsXCJ0ZXN0OmNvdmVyYWdlXCI6XCJqZXN0IC0tY292ZXJhZ2VcIixcInRlc3Q6Y2lcIjonamVzdCAtLWNvdmVyYWdlIC0tcGFzc1dpdGhOb1Rlc3RzIC0tc2V0dXBGaWxlc0FmdGVyRW52IC4vamVzdC1wcmVsb2FkLmpzIC0tdGVzdFBhdGhJZ25vcmVQYXR0ZXJucyBcIi9lMmUvXCInLFwidGVzdDpkZXZcIjpcImplc3RcIix3YXRjaDpcInJvbGx1cCAtYyAtLWJ1bmRsZUNvbmZpZ0FzQ2pzIC13XCJ9LGRlcGVuZGVuY2llczp7XCJAbWV0YW1hc2svc2RrLWFuYWx5dGljc1wiOlwid29ya3NwYWNlOipcIixidWZmZXJ1dGlsOlwiXjQuMC44XCIsXCJkYXRlLWZuc1wiOlwiXjIuMjkuM1wiLGRlYnVnOlwiNC4zLjRcIixcInV0Zi04LXZhbGlkYXRlXCI6XCJeNS4wLjJcIix1dWlkOlwiXjguMy4yXCJ9LGRldkRlcGVuZGVuY2llczp7XCJAamVzdC9nbG9iYWxzXCI6XCJeMjkuMy4xXCIsXCJAbGF2YW1vYXQvYWxsb3ctc2NyaXB0c1wiOlwiXjIuMy4xXCIsXCJAbWV0YW1hc2svYXV0by1jaGFuZ2Vsb2dcIjpcIjMuMS4wXCIsXCJAbWV0YW1hc2svZXNsaW50LWNvbmZpZ1wiOlwiXjYuMC4wXCIsXCJAbWV0YW1hc2svZXNsaW50LWNvbmZpZy1ub2RlanNcIjpcIl42LjAuMFwiLFwiQG1ldGFtYXNrL2VzbGludC1jb25maWctdHlwZXNjcmlwdFwiOlwiXjYuMC4wXCIsXCJAcm9sbHVwL3BsdWdpbi1jb21tb25qc1wiOlwiXjI1LjAuMFwiLFwiQHJvbGx1cC9wbHVnaW4tanNvblwiOlwiXjYuMC4wXCIsXCJAcm9sbHVwL3BsdWdpbi1ub2RlLXJlc29sdmVcIjpcIl4xNS4wLjJcIixcIkByb2xsdXAvcGx1Z2luLXJlcGxhY2VcIjpcIl42LjAuMVwiLFwiQHJvbGx1cC9wbHVnaW4tdGVyc2VyXCI6XCJeMC40LjRcIixcIkBzaXplLWxpbWl0L3ByZXNldC1iaWctbGliXCI6XCJeMTEuMC4yXCIsXCJAdHlwZXMvamVzdFwiOlwiXjI5LjIuNFwiLFwiQHR5cGVzL25vZGVcIjpcIl4yMC4xLjNcIixcIkB0eXBlcy91dWlkXCI6XCJeOS4wLjBcIixcIkB0eXBlc2NyaXB0LWVzbGludC9lc2xpbnQtcGx1Z2luXCI6XCJeNC4yNi4wXCIsXCJAdHlwZXNjcmlwdC1lc2xpbnQvcGFyc2VyXCI6XCJeNC4yNi4wXCIsY29uY3VycmVudGx5OlwiXjkuMS4yXCIsXCJjcm9zcy1mZXRjaFwiOlwiXjQuMC4wXCIsZWNpZXNqczpcIl4wLjQuMTFcIixlc2xpbnQ6XCJeNy4zMC4wXCIsXCJlc2xpbnQtY29uZmlnLXByZXR0aWVyXCI6XCJeOC4zLjBcIixcImVzbGludC1wbHVnaW4taW1wb3J0XCI6XCJeMi4yMy40XCIsXCJlc2xpbnQtcGx1Z2luLWplc3RcIjpcIl4yNC40LjBcIixcImVzbGludC1wbHVnaW4tanNkb2NcIjpcIl4zNi4xLjBcIixcImVzbGludC1wbHVnaW4tbm9kZVwiOlwiXjExLjEuMFwiLFwiZXNsaW50LXBsdWdpbi1wcmV0dGllclwiOlwiXjMuNC4wXCIsZXZlbnRlbWl0dGVyMjpcIl42LjQuOVwiLGplc3Q6XCJeMjkuMy4xXCIscHJldHRpZXI6XCJeMi4zLjBcIixyaW1yYWY6XCJeMy4wLjJcIixyb2xsdXA6XCJeNC4yNi4wXCIsXCJyb2xsdXAtcGx1Z2luLWpzY2NcIjpcIl4yLjAuMFwiLFwicm9sbHVwLXBsdWdpbi1uYXRpdmVzXCI6XCJeMC43LjVcIixcInJvbGx1cC1wbHVnaW4tbm9kZS1idWlsdGluc1wiOlwiXjIuMS4yXCIsXCJyb2xsdXAtcGx1Z2luLW5vZGUtZ2xvYmFsc1wiOlwiXjEuNC4wXCIsXCJyb2xsdXAtcGx1Z2luLXBlZXItZGVwcy1leHRlcm5hbFwiOlwiXjIuMi40XCIsXCJyb2xsdXAtcGx1Z2luLXBvbHlmaWxsLW5vZGVcIjpcIl4wLjEzLjBcIixcInJvbGx1cC1wbHVnaW4tc2l6ZXNcIjpcIl4xLjAuNlwiLFwicm9sbHVwLXBsdWdpbi10eXBlc2NyaXB0MlwiOlwiXjAuMzEuMlwiLFwicm9sbHVwLXBsdWdpbi12aXN1YWxpemVyXCI6XCJeNS4xMi4wXCIsXCJzaXplLWxpbWl0XCI6XCJeMTEuMS42XCIsXCJzb2NrZXQuaW8tY2xpZW50XCI6XCJeNC41LjFcIixcInN0cmVhbS1icm93c2VyaWZ5XCI6XCJeMy4wLjBcIixcInRzLWplc3RcIjpcIl4yOS4wLjNcIixcInRzLW5vZGVcIjpcIl4xMC45LjFcIix0eXBlc2NyaXB0OlwiXjUuNi4zXCJ9LHBlZXJEZXBlbmRlbmNpZXM6e1wiY3Jvc3MtZmV0Y2hcIjpcIl40LjAuMFwiLGVjaWVzanM6XCIqXCIsZXZlbnRlbWl0dGVyMjpcIl42LjQuOVwiLFwicmVhZGFibGUtc3RyZWFtXCI6XCJeMy42LjJcIixcInNvY2tldC5pby1jbGllbnRcIjpcIl40LjUuMVwifSxwdWJsaXNoQ29uZmlnOnthY2Nlc3M6XCJwdWJsaWNcIixyZWdpc3RyeTpcImh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL1wifSxsYXZhbW9hdDp7YWxsb3dTY3JpcHRzOntcIkBsYXZhbW9hdC9wcmVpbnN0YWxsLWFsd2F5cy1mYWlsXCI6ITEsY2FudmFzOiEwLFwiZWNpZXNqcz5zZWNwMjU2azFcIjohMSxcInNvY2tldC5pby1jbGllbnQ+ZW5naW5lLmlvLWNsaWVudD53cz5idWZmZXJ1dGlsXCI6ITEsXCJzb2NrZXQuaW8tY2xpZW50PmVuZ2luZS5pby1jbGllbnQ+d3M+dXRmLTgtdmFsaWRhdGVcIjohMSxidWZmZXJ1dGlsOiExLFwidXRmLTgtdmFsaWRhdGVcIjohMX19fTtjb25zdCBrPVwiaHR0cHM6Ly9tZXRhbWFzay1zZGsuYXBpLmN4Lm1ldGFtYXNrLmlvL1wiLF89W1wid2Vic29ja2V0XCJdLEk9NjA0OGU1LEs9M2UzLHg9e01FVEFNQVNLX0dFVFBST1ZJREVSU1RBVEU6XCJtZXRhbWFza19nZXRQcm92aWRlclN0YXRlXCIsTUVUQU1BU0tfQ09OTkVDVFNJR046XCJtZXRhbWFza19jb25uZWN0U2lnblwiLE1FVEFNQVNLX0NPTk5FQ1RXSVRIOlwibWV0YW1hc2tfY29ubmVjdFdpdGhcIixNRVRBTUFTS19PUEVOOlwibWV0YW1hc2tfb3BlblwiLE1FVEFNQVNLX0JBVENIOlwibWV0YW1hc2tfYmF0Y2hcIixQRVJTT05BTF9TSUdOOlwicGVyc29uYWxfc2lnblwiLFdBTExFVF9SRVFVRVNUUEVSTUlTU0lPTlM6XCJ3YWxsZXRfcmVxdWVzdFBlcm1pc3Npb25zXCIsV0FMTEVUX1JFVk9LRVBFUk1JU1NJT05TOlwid2FsbGV0X3Jldm9rZVBlcm1pc3Npb25zXCIsV0FMTEVUX0dFVFBFUk1JU1NJT05TOlwid2FsbGV0X2dldFBlcm1pc3Npb25zXCIsV0FMTEVUX1dBVENIQVNTRVQ6XCJ3YWxsZXRfd2F0Y2hBc3NldFwiLFdBTExFVF9TV0lUQ0hFVEhFUkVVTUNIQUlOOlwid2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW5cIixXQUxMRVRfQURERVRIRVJFVU1DSEFJTjpcIndhbGxldF9hZGRFdGhlcmV1bUNoYWluXCIsRVRIX1JFUVVFU1RBQ0NPVU5UUzpcImV0aF9yZXF1ZXN0QWNjb3VudHNcIixFVEhfQUNDT1VOVFM6XCJldGhfYWNjb3VudHNcIixFVEhfQ0hBSU5JRDpcImV0aF9jaGFpbklkXCIsRVRIX1NFTkRUUkFOU0FDVElPTjpcImV0aF9zZW5kVHJhbnNhY3Rpb25cIixFVEhfU0lHTlRZUEVEREFUQTpcImV0aF9zaWduVHlwZWREYXRhXCIsRVRIX1NJR05UWVBFRERBVEFfVjM6XCJldGhfc2lnblR5cGVkRGF0YV92M1wiLEVUSF9TSUdOVFlQRUREQVRBX1Y0OlwiZXRoX3NpZ25UeXBlZERhdGFfdjRcIixFVEhfU0lHTlRSQU5TQUNUSU9OOlwiZXRoX3NpZ25UcmFuc2FjdGlvblwiLEVUSF9TSUdOOlwiZXRoX3NpZ25cIixQRVJTT05BTF9FQ19SRUNPVkVSOlwicGVyc29uYWxfZWNSZWNvdmVyXCJ9LEE9W3guTUVUQU1BU0tfQ09OTkVDVFNJR04seC5NRVRBTUFTS19DT05ORUNUV0lUSCx4Lk1FVEFNQVNLX09QRU4seC5NRVRBTUFTS19CQVRDSCx4LlBFUlNPTkFMX1NJR04seC5XQUxMRVRfUkVRVUVTVFBFUk1JU1NJT05TLHguV0FMTEVUX1JFVk9LRVBFUk1JU1NJT05TLHguV0FMTEVUX1dBVENIQVNTRVQseC5FVEhfU0VORFRSQU5TQUNUSU9OLHguRVRIX1NJR05UWVBFRERBVEEseC5FVEhfU0lHTlRZUEVEREFUQV9WMyx4LkVUSF9TSUdOVFlQRUREQVRBX1Y0LHguRVRIX1NJR05UUkFOU0FDVElPTix4LkVUSF9TSUdOLHguUEVSU09OQUxfRUNfUkVDT1ZFUl07ZnVuY3Rpb24gTihlKXtyZXR1cm4gQS5pbmNsdWRlcyhlKX1mdW5jdGlvbiBUKGUpe2NvbnN0e2NvbnRleHQ6dH09ZTtnLlJlbW90ZUNvbW11bmljYXRpb24oYFtSZW1vdGVDb21tdW5pY2F0aW9uOiBjbGVhbigpXSBjb250ZXh0PSR7dH1gKSxlLmNoYW5uZWxDb25maWc9dm9pZCAwLGUucmVhZHk9ITEsZS5vcmlnaW5hdG9yQ29ubmVjdFN0YXJ0ZWQ9ITF9dmFyIE8sUixELFAsYixMOyFmdW5jdGlvbihlKXtlLkRJU0NPTk5FQ1RFRD1cImRpc2Nvbm5lY3RlZFwiLGUuV0FJVElORz1cIndhaXRpbmdcIixlLlRJTUVPVVQ9XCJ0aW1lb3V0XCIsZS5MSU5LRUQ9XCJsaW5rZWRcIixlLlBBVVNFRD1cInBhdXNlZFwiLGUuVEVSTUlOQVRFRD1cInRlcm1pbmF0ZWRcIn0oT3x8KE89e30pKSxmdW5jdGlvbihlKXtlLktFWV9JTkZPPVwia2V5X2luZm9cIixlLlNFUlZJQ0VfU1RBVFVTPVwic2VydmljZV9zdGF0dXNcIixlLlBST1ZJREVSX1VQREFURT1cInByb3ZpZGVyX3VwZGF0ZVwiLGUuUlBDX1VQREFURT1cInJwY191cGRhdGVcIixlLktFWVNfRVhDSEFOR0VEPVwia2V5c19leGNoYW5nZWRcIixlLkpPSU5fQ0hBTk5FTD1cImpvaW5fY2hhbm5lbFwiLGUuUFVCTElDX0tFWT1cInB1YmxpY19rZXlcIixlLkNIQU5ORUxfQ1JFQVRFRD1cImNoYW5uZWxfY3JlYXRlZFwiLGUuQ0xJRU5UU19DT05ORUNURUQ9XCJjbGllbnRzX2Nvbm5lY3RlZFwiLGUuQ0xJRU5UU19ESVNDT05ORUNURUQ9XCJjbGllbnRzX2Rpc2Nvbm5lY3RlZFwiLGUuQ0xJRU5UU19XQUlUSU5HPVwiY2xpZW50c193YWl0aW5nXCIsZS5DTElFTlRTX1JFQURZPVwiY2xpZW50c19yZWFkeVwiLGUuUkVKRUNURUQ9XCJyZWplY3RlZFwiLGUuV0FMTEVUX0lOSVQ9XCJ3YWxsZXRfaW5pdFwiLGUuQ0hBTk5FTF9QRVJTSVNURU5DRT1cImNoYW5uZWxfcGVyc2lzdGVuY2VcIixlLkNPTkZJRz1cImNvbmZpZ1wiLGUuTUVTU0FHRV9BQ0s9XCJhY2tcIixlLlNPQ0tFVF9ESVNDT05ORUNURUQ9XCJzb2NrZXRfZGlzY29ubmVjdGVkXCIsZS5TT0NLRVRfUkVDT05ORUNUPVwic29ja2V0X3JlY29ubmVjdFwiLGUuT1RQPVwib3RwXCIsZS5TREtfUlBDX0NBTEw9XCJzZGtfcnBjX2NhbGxcIixlLkFVVEhPUklaRUQ9XCJhdXRob3JpemVkXCIsZS5DT05ORUNUSU9OX1NUQVRVUz1cImNvbm5lY3Rpb25fc3RhdHVzXCIsZS5NRVNTQUdFPVwibWVzc2FnZVwiLGUuVEVSTUlOQVRFPVwidGVybWluYXRlXCJ9KFJ8fChSPXt9KSksZnVuY3Rpb24oZSl7ZS5LRVlfRVhDSEFOR0U9XCJrZXlfZXhjaGFuZ2VcIn0oRHx8KEQ9e30pKSxmdW5jdGlvbihlKXtlLktFWV9IQU5EU0hBS0VfU1RBUlQ9XCJrZXlfaGFuZHNoYWtlX3N0YXJ0XCIsZS5LRVlfSEFORFNIQUtFX0NIRUNLPVwia2V5X2hhbmRzaGFrZV9jaGVja1wiLGUuS0VZX0hBTkRTSEFLRV9TWU49XCJrZXlfaGFuZHNoYWtlX1NZTlwiLGUuS0VZX0hBTkRTSEFLRV9TWU5BQ0s9XCJrZXlfaGFuZHNoYWtlX1NZTkFDS1wiLGUuS0VZX0hBTkRTSEFLRV9BQ0s9XCJrZXlfaGFuZHNoYWtlX0FDS1wiLGUuS0VZX0hBTkRTSEFLRV9XQUxMRVQ9XCJrZXlfaGFuZHNoYWtlX3dhbGxldFwiLGUuS0VZX0hBTkRTSEFLRV9OT05FPVwibm9uZVwifShQfHwoUD17fSkpO2NsYXNzICQgZXh0ZW5kcyBze2NvbnN0cnVjdG9yKHtjb21tdW5pY2F0aW9uTGF5ZXI6ZSxvdGhlclB1YmxpY0tleTp0LGNvbnRleHQ6bixlY2llczppLGxvZ2dpbmc6b30pe3N1cGVyKCksdGhpcy5rZXlzRXhjaGFuZ2VkPSExLHRoaXMuc3RlcD1QLktFWV9IQU5EU0hBS0VfTk9ORSx0aGlzLmRlYnVnPSExLHRoaXMuY29udGV4dD1uLHRoaXMuY29tbXVuaWNhdGlvbkxheWVyPWUsKG51bGw9PWk/dm9pZCAwOmkucHJpdmF0ZUtleSkmJnQmJihnLktleUV4Y2hhbmdlKGBbS2V5RXhjaGFuZ2U6IGNvbnN0cnVjdG9yKCldIG90aGVyUHViS2V5PSR7dH0gc2V0IGtleXNFeGNoYW5nZWQgdG8gdHJ1ZSFgLGkpLHRoaXMua2V5c0V4Y2hhbmdlZD0hMCksdGhpcy5teUVDSUVTPW5ldyBwKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxpKSx7ZGVidWc6bnVsbD09bz92b2lkIDA6by5lY2llc0xheWVyfSkpLHRoaXMuY29tbXVuaWNhdGlvbkxheWVyLnN0YXRlLmVjaWVzSW5zdGFuY2U9dGhpcy5teUVDSUVTLHRoaXMubXlQdWJsaWNLZXk9dGhpcy5teUVDSUVTLmdldFB1YmxpY0tleSgpLHRoaXMuZGVidWc9ITA9PT0obnVsbD09bz92b2lkIDA6by5rZXlFeGNoYW5nZUxheWVyKSx0JiZ0aGlzLnNldE90aGVyUHVibGljS2V5KHQpLHRoaXMuY29tbXVuaWNhdGlvbkxheWVyLm9uKEQuS0VZX0VYQ0hBTkdFLHRoaXMub25LZXlFeGNoYW5nZU1lc3NhZ2UuYmluZCh0aGlzKSl9b25LZXlFeGNoYW5nZU1lc3NhZ2UoZSl7Y29uc3R7cmVsYXlQZXJzaXN0ZW5jZTp0fT10aGlzLmNvbW11bmljYXRpb25MYXllci5yZW1vdGUuc3RhdGU7aWYoZy5LZXlFeGNoYW5nZShgW0tleUV4Y2hhbmdlOiBvbktleUV4Y2hhbmdlTWVzc2FnZSgpXSBjb250ZXh0PSR7dGhpcy5jb250ZXh0fSBrZXlzRXhjaGFuZ2VkPSR7dGhpcy5rZXlzRXhjaGFuZ2VkfSByZWxheVBlcnNpc3RlbmNlPSR7dH1gLGUpLHQpcmV0dXJuIHZvaWQgZy5LZXlFeGNoYW5nZShcIltLZXlFeGNoYW5nZTogb25LZXlFeGNoYW5nZU1lc3NhZ2UoKV0gSWdub3Jpbmcga2V5IGV4Y2hhbmdlIG1lc3NhZ2UgYmVjYXVzZSByZWxheSBwZXJzaXN0ZW5jZSBpcyBhY3RpdmF0ZWRcIik7Y29uc3R7bWVzc2FnZTpufT1lO3RoaXMua2V5c0V4Y2hhbmdlZCYmZy5LZXlFeGNoYW5nZShgW0tleUV4Y2hhbmdlOiBvbktleUV4Y2hhbmdlTWVzc2FnZSgpXSBjb250ZXh0PSR7dGhpcy5jb250ZXh0fSByZWNlaXZlZCBoYW5kc2hha2Ugd2hpbGUgYWxyZWFkeSBleGNoYW5nZWQuIHN0ZXA9JHt0aGlzLnN0ZXB9IG90aGVyUHViS2V5PSR7dGhpcy5vdGhlclB1YmxpY0tleX1gKSx0aGlzLmVtaXQoUi5LRVlfSU5GTyxuLnR5cGUpLG4udHlwZT09PVAuS0VZX0hBTkRTSEFLRV9TWU4/KHRoaXMuY2hlY2tTdGVwKFtQLktFWV9IQU5EU0hBS0VfTk9ORSxQLktFWV9IQU5EU0hBS0VfQUNLXSksZy5LZXlFeGNoYW5nZShcIltLZXlFeGNoYW5nZTogb25LZXlFeGNoYW5nZU1lc3NhZ2UoKV0gS0VZX0hBTkRTSEFLRV9TWU5cIixuKSxuLnB1YmtleSYmdGhpcy5zZXRPdGhlclB1YmxpY0tleShuLnB1YmtleSksdGhpcy5jb21tdW5pY2F0aW9uTGF5ZXIuc2VuZE1lc3NhZ2Uoe3R5cGU6UC5LRVlfSEFORFNIQUtFX1NZTkFDSyxwdWJrZXk6dGhpcy5teVB1YmxpY0tleX0pLmNhdGNoKChlPT57Zy5LZXlFeGNoYW5nZShcIltLZXlFeGNoYW5nZTogb25LZXlFeGNoYW5nZU1lc3NhZ2UoKV0gRXJyb3Igc2VuZGluZyBLRVlfSEFORFNIQUtFX1NZTkFDS1wiLGUpfSkpLHRoaXMuc2V0U3RlcChQLktFWV9IQU5EU0hBS0VfQUNLKSk6bi50eXBlPT09UC5LRVlfSEFORFNIQUtFX1NZTkFDSz8odGhpcy5jaGVja1N0ZXAoW1AuS0VZX0hBTkRTSEFLRV9TWU5BQ0ssUC5LRVlfSEFORFNIQUtFX0FDSyxQLktFWV9IQU5EU0hBS0VfTk9ORV0pLGcuS2V5RXhjaGFuZ2UoXCJbS2V5RXhjaGFuZ2U6IG9uS2V5RXhjaGFuZ2VNZXNzYWdlKCldIEtFWV9IQU5EU0hBS0VfU1lOQUNLXCIpLG4ucHVia2V5JiZ0aGlzLnNldE90aGVyUHVibGljS2V5KG4ucHVia2V5KSx0aGlzLmNvbW11bmljYXRpb25MYXllci5zZW5kTWVzc2FnZSh7dHlwZTpQLktFWV9IQU5EU0hBS0VfQUNLfSkuY2F0Y2goKGU9PntnLktleUV4Y2hhbmdlKFwiW0tleUV4Y2hhbmdlOiBvbktleUV4Y2hhbmdlTWVzc2FnZSgpXSBFcnJvciBzZW5kaW5nIEtFWV9IQU5EU0hBS0VfQUNLXCIsZSl9KSksdGhpcy5rZXlzRXhjaGFuZ2VkPSEwLHRoaXMuc2V0U3RlcChQLktFWV9IQU5EU0hBS0VfQUNLKSx0aGlzLmVtaXQoUi5LRVlTX0VYQ0hBTkdFRCkpOm4udHlwZT09PVAuS0VZX0hBTkRTSEFLRV9BQ0smJihnLktleUV4Y2hhbmdlKFwiW0tleUV4Y2hhbmdlOiBvbktleUV4Y2hhbmdlTWVzc2FnZSgpXSBLRVlfSEFORFNIQUtFX0FDSyBzZXQga2V5c0V4Y2hhbmdlZCB0byB0cnVlIVwiKSx0aGlzLmNoZWNrU3RlcChbUC5LRVlfSEFORFNIQUtFX0FDSyxQLktFWV9IQU5EU0hBS0VfTk9ORV0pLHRoaXMua2V5c0V4Y2hhbmdlZD0hMCx0aGlzLnNldFN0ZXAoUC5LRVlfSEFORFNIQUtFX0FDSyksdGhpcy5lbWl0KFIuS0VZU19FWENIQU5HRUQpKX1yZXNldEtleXMoZSl7dGhpcy5jbGVhbigpLHRoaXMubXlFQ0lFUz1uZXcgcChlKX1jbGVhbigpe2cuS2V5RXhjaGFuZ2UoYFtLZXlFeGNoYW5nZTogY2xlYW4oKV0gY29udGV4dD0ke3RoaXMuY29udGV4dH0gcmVzZXQgaGFuZHNoYWtlIHN0YXRlYCksdGhpcy5zZXRTdGVwKFAuS0VZX0hBTkRTSEFLRV9OT05FKSx0aGlzLmVtaXQoUi5LRVlfSU5GTyx0aGlzLnN0ZXApLHRoaXMua2V5c0V4Y2hhbmdlZD0hMX1zdGFydCh7aXNPcmlnaW5hdG9yOmUsZm9yY2U6dH0pe2NvbnN0e3JlbGF5UGVyc2lzdGVuY2U6bixwcm90b2NvbFZlcnNpb246aX09dGhpcy5jb21tdW5pY2F0aW9uTGF5ZXIucmVtb3RlLnN0YXRlLG89aT49MjtuP2cuS2V5RXhjaGFuZ2UoXCJbS2V5RXhjaGFuZ2U6IHN0YXJ0KCldIElnbm9yaW5nIGtleSBleGNoYW5nZSBtZXNzYWdlIGJlY2F1c2UgcmVsYXkgcGVyc2lzdGVuY2UgaXMgYWN0aXZhdGVkXCIpOihnLktleUV4Y2hhbmdlKGBbS2V5RXhjaGFuZ2U6IHN0YXJ0KCldIGNvbnRleHQ9JHt0aGlzLmNvbnRleHR9IHByb3RvY29sVmVyc2lvbj0ke2l9IGlzT3JpZ2luYXRvcj0ke2V9IHN0ZXA9JHt0aGlzLnN0ZXB9IGZvcmNlPSR7dH0gcmVsYXlQZXJzaXN0ZW5jZT0ke259IGtleXNFeGNoYW5nZWQ9JHt0aGlzLmtleXNFeGNoYW5nZWR9YCksZT8hKHRoaXMua2V5c0V4Y2hhbmdlZHx8dGhpcy5zdGVwIT09UC5LRVlfSEFORFNIQUtFX05PTkUmJnRoaXMuc3RlcCE9PVAuS0VZX0hBTkRTSEFLRV9TWU5BQ0spfHx0PyhnLktleUV4Y2hhbmdlKGBbS2V5RXhjaGFuZ2U6IHN0YXJ0KCldIGNvbnRleHQ9JHt0aGlzLmNvbnRleHR9IC0tIHN0YXJ0IGtleSBleGNoYW5nZSAoZm9yY2U9JHt0fSkgLS0gc3RlcD0ke3RoaXMuc3RlcH1gLHRoaXMuc3RlcCksdGhpcy5jbGVhbigpLHRoaXMuc2V0U3RlcChQLktFWV9IQU5EU0hBS0VfU1lOQUNLKSx0aGlzLmNvbW11bmljYXRpb25MYXllci5zZW5kTWVzc2FnZSh7dHlwZTpQLktFWV9IQU5EU0hBS0VfU1lOLHB1YmtleTp0aGlzLm15UHVibGljS2V5LHY6Mn0pLmNhdGNoKChlPT57Zy5LZXlFeGNoYW5nZShcIltLZXlFeGNoYW5nZTogc3RhcnQoKV0gRXJyb3Igc2VuZGluZyBLRVlfSEFORFNIQUtFX1NZTlwiLGUpfSkpKTpnLktleUV4Y2hhbmdlKGBbS2V5RXhjaGFuZ2U6IHN0YXJ0KCldIGNvbnRleHQ9JHt0aGlzLmNvbnRleHR9IC0tIGtleSBleGNoYW5nZSBhbHJlYWR5ICR7dGhpcy5rZXlzRXhjaGFuZ2VkP1wiZG9uZVwiOlwiaW4gcHJvZ3Jlc3NcIn0gLS0gYWJvcnRlZC5gLHRoaXMuc3RlcCk6dGhpcy5rZXlzRXhjaGFuZ2VkJiYhMCE9PXQ/Zy5LZXlFeGNoYW5nZShcIltLZXlFeGNoYW5nZTogc3RhcnQoKV0gZG9uJ3Qgc2VuZCBLRVlfSEFORFNIQUtFX1NUQVJUIC0tIGV4Y2hhbmdlIGFscmVhZHkgZG9uZS5cIik6bz90aGlzLmNvbW11bmljYXRpb25MYXllci5zZW5kTWVzc2FnZSh7dHlwZTpQLktFWV9IQU5EU0hBS0VfU1lOQUNLLHB1YmtleTp0aGlzLm15UHVibGljS2V5LHY6Mn0pLmNhdGNoKChlPT57Zy5LZXlFeGNoYW5nZShcIltLZXlFeGNoYW5nZTogc3RhcnQoKV0gRXJyb3Igc2VuZGluZyBLRVlfSEFORFNIQUtFX1NZTkFDS1wiLGUpfSkpOih0aGlzLmNvbW11bmljYXRpb25MYXllci5zZW5kTWVzc2FnZSh7dHlwZTpQLktFWV9IQU5EU0hBS0VfU1RBUlR9KS5jYXRjaCgoZT0+e2cuS2V5RXhjaGFuZ2UoXCJbS2V5RXhjaGFuZ2U6IHN0YXJ0KCldIEVycm9yIHNlbmRpbmcgS0VZX0hBTkRTSEFLRV9TVEFSVFwiLGUpfSkpLHRoaXMuY2xlYW4oKSkpfXNldFN0ZXAoZSl7dGhpcy5zdGVwPWUsdGhpcy5lbWl0KFIuS0VZX0lORk8sZSl9Y2hlY2tTdGVwKGUpe2UubGVuZ3RoPjAmJmUuaW5kZXhPZih0aGlzLnN0ZXAudG9TdHJpbmcoKSl9c2V0UmVsYXlQZXJzaXN0ZW5jZSh7bG9jYWxLZXk6ZSxvdGhlcktleTp0fSl7dGhpcy5vdGhlclB1YmxpY0tleT10LHRoaXMubXlFQ0lFUz1uZXcgcCh7cHJpdmF0ZUtleTplLGRlYnVnOnRoaXMuZGVidWd9KSx0aGlzLmtleXNFeGNoYW5nZWQ9ITB9c2V0S2V5c0V4Y2hhbmdlZChlKXt0aGlzLmtleXNFeGNoYW5nZWQ9ZX1hcmVLZXlzRXhjaGFuZ2VkKCl7cmV0dXJuIHRoaXMua2V5c0V4Y2hhbmdlZH1nZXRNeVB1YmxpY0tleSgpe3JldHVybiB0aGlzLm15UHVibGljS2V5fWdldE90aGVyUHVibGljS2V5KCl7cmV0dXJuIHRoaXMub3RoZXJQdWJsaWNLZXl9c2V0T3RoZXJQdWJsaWNLZXkoZSl7Zy5LZXlFeGNoYW5nZShcIltLZXlFeGNoYW5nZTogc2V0T3RoZXJQdWJLZXkoKV1cIixlKSx0aGlzLm90aGVyUHVibGljS2V5PWV9ZW5jcnlwdE1lc3NhZ2UoZSl7aWYoIXRoaXMub3RoZXJQdWJsaWNLZXkpdGhyb3cgbmV3IEVycm9yKFwiZW5jcnlwdE1lc3NhZ2U6IEtleXMgbm90IGV4Y2hhbmdlZCAtIG1pc3Npbmcgb3RoZXJQdWJLZXlcIik7cmV0dXJuIHRoaXMubXlFQ0lFUy5lbmNyeXB0KGUsdGhpcy5vdGhlclB1YmxpY0tleSl9ZGVjcnlwdE1lc3NhZ2UoZSl7aWYoIXRoaXMub3RoZXJQdWJsaWNLZXkpdGhyb3cgbmV3IEVycm9yKFwiZGVjcnlwdE1lc3NhZ2U6IEtleXMgbm90IGV4Y2hhbmdlZCAtIG1pc3Npbmcgb3RoZXJQdWJLZXlcIik7cmV0dXJuIHRoaXMubXlFQ0lFUy5kZWNyeXB0KGUpfWdldEtleUluZm8oKXtyZXR1cm57ZWNpZXM6T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHRoaXMubXlFQ0lFUy5nZXRLZXlJbmZvKCkpLHtvdGhlclB1YktleTp0aGlzLm90aGVyUHVibGljS2V5fSksc3RlcDp0aGlzLnN0ZXAsa2V5c0V4Y2hhbmdlZDp0aGlzLmFyZUtleXNFeGNoYW5nZWQoKX19dG9TdHJpbmcoKXtjb25zdCBlPXtrZXlJbmZvOnRoaXMuZ2V0S2V5SW5mbygpLGtleXNFeGNoYW5nZWQ6dGhpcy5rZXlzRXhjaGFuZ2VkLHN0ZXA6dGhpcy5zdGVwfTtyZXR1cm4gSlNPTi5zdHJpbmdpZnkoZSl9fSFmdW5jdGlvbihlKXtlLlRFUk1JTkFURT1cInRlcm1pbmF0ZVwiLGUuQU5TV0VSPVwiYW5zd2VyXCIsZS5PRkZFUj1cIm9mZmVyXCIsZS5DQU5ESURBVEU9XCJjYW5kaWRhdGVcIixlLkpTT05SUEM9XCJqc29ucnBjXCIsZS5XQUxMRVRfSU5GTz1cIndhbGxldF9pbmZvXCIsZS5XQUxMRVRfSU5JVD1cIndhbGxldF9pbml0XCIsZS5PUklHSU5BVE9SX0lORk89XCJvcmlnaW5hdG9yX2luZm9cIixlLlBBVVNFPVwicGF1c2VcIixlLk9UUD1cIm90cFwiLGUuQVVUSE9SSVpFRD1cImF1dGhvcml6ZWRcIixlLlBJTkc9XCJwaW5nXCIsZS5SRUFEWT1cInJlYWR5XCJ9KGJ8fChiPXt9KSksZnVuY3Rpb24oZSl7ZS5SRVFVRVNUPVwic2RrX2Nvbm5lY3RfcmVxdWVzdF9zdGFydGVkXCIsZS5SRVFVRVNUX01PQklMRT1cInNka19jb25uZWN0X3JlcXVlc3Rfc3RhcnRlZF9tb2JpbGVcIixlLlJFQ09OTkVDVD1cInNka19yZWNvbm5lY3RfcmVxdWVzdF9zdGFydGVkXCIsZS5DT05ORUNURUQ9XCJzZGtfY29ubmVjdGlvbl9lc3RhYmxpc2hlZFwiLGUuQ09OTkVDVEVEX01PQklMRT1cInNka19jb25uZWN0aW9uX2VzdGFibGlzaGVkX21vYmlsZVwiLGUuQVVUSE9SSVpFRD1cInNka19jb25uZWN0aW9uX2F1dGhvcml6ZWRcIixlLlJFSkVDVEVEPVwic2RrX2Nvbm5lY3Rpb25fcmVqZWN0ZWRcIixlLlRFUk1JTkFURUQ9XCJzZGtfY29ubmVjdGlvbl90ZXJtaW5hdGVkXCIsZS5ESVNDT05ORUNURUQ9XCJzZGtfZGlzY29ubmVjdGVkXCIsZS5TREtfVVNFX0VYVEVOU0lPTj1cInNka191c2VfZXh0ZW5zaW9uXCIsZS5TREtfUlBDX1JFUVVFU1Q9XCJzZGtfcnBjX3JlcXVlc3RcIixlLlNES19SUENfUkVRVUVTVF9SRUNFSVZFRD1cInNka19ycGNfcmVxdWVzdF9yZWNlaXZlZFwiLGUuU0RLX1JQQ19SRVFVRVNUX0RPTkU9XCJzZGtfcnBjX3JlcXVlc3RfZG9uZVwiLGUuU0RLX0VYVEVOU0lPTl9VVElMSVpFRD1cInNka19leHRlbnNpb25fdXRpbGl6ZWRcIixlLlNES19VU0VfSU5BUFBfQlJPV1NFUj1cInNka191c2VfaW5hcHBfYnJvd3NlclwifShMfHwoTD17fSkpO2NvbnN0IHc9KHQsbixpKT0+ZSh2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7dmFyIGUsbyxhLGMscyxyO2NvbnN0e3JlbW90ZTpsLHN0YXRlOmR9PXQse2NoYW5uZWxJZDp1LGlzT3JpZ2luYXRvcjpofT1kO2lmKFwiZXJyb3JfdGVybWluYXRlZFwiPT09bilyZXR1cm4gZy5Tb2NrZXRTZXJ2aWNlKGBoYW5kbGVKb2luQ2hhbm5lbFJlc3VsdHM6IENoYW5uZWwgJHt1fSB0ZXJtaW5hdGVkYCksdm9pZCB0LmVtaXQoUi5URVJNSU5BVEUpO2lmKCFpKXJldHVybiB2b2lkIGcuU29ja2V0U2VydmljZShgaGFuZGxlSm9pbkNoYW5uZWxSZXN1bHRzOiBObyByZXN1bHQgZm9yIGNoYW5uZWwgJHt1fWApO2NvbnN0e3BlcnNpc3RlbmNlOm0sd2FsbGV0S2V5OkUscmVqZWN0ZWQ6dn09aTtpZihnLlNvY2tldFNlcnZpY2UoYGhhbmRsZUpvaW5DaGFubmVsUmVzdWx0czogQ2hhbm5lbCAke3V9IHBlcnNpc3RlbmNlPSR7bX0gd2FsbGV0S2V5PSR7RX0gcmVqZWN0ZWQ9JHt2fWApLHYpcmV0dXJuIGcuU29ja2V0U2VydmljZShgaGFuZGxlSm9pbkNoYW5uZWxSZXN1bHRzOiBDaGFubmVsICR7dX0gcmVqZWN0ZWRgKSx5aWVsZCB0LnJlbW90ZS5kaXNjb25uZWN0KHt0ZXJtaW5hdGU6ITB9KSx0LnJlbW90ZS5lbWl0KFIuUkVKRUNURUQse2NoYW5uZWxJZDp1fSksdm9pZCB0LnJlbW90ZS5lbWl0U2VydmljZVN0YXR1c0V2ZW50KCk7aWYoRSYmIShudWxsPT09KGU9bC5zdGF0ZS5jaGFubmVsQ29uZmlnKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5vdGhlcktleSkpe3QuZ2V0S2V5RXhjaGFuZ2UoKS5zZXRPdGhlclB1YmxpY0tleShFKSxudWxsPT09KG89dC5zdGF0ZS5rZXlFeGNoYW5nZSl8fHZvaWQgMD09PW98fG8uc2V0S2V5c0V4Y2hhbmdlZCghMCksbC5zdGF0ZS5yZWFkeT0hMCxsLnN0YXRlLmF1dGhvcml6ZWQ9ITAsbC5lbWl0KFIuQVVUSE9SSVpFRCk7Y29uc3R7Y29tbXVuaWNhdGlvbkxheWVyOmUsc3RvcmFnZU1hbmFnZXI6bn09bC5zdGF0ZSxpPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxsLnN0YXRlLmNoYW5uZWxDb25maWcpLHtjaGFubmVsSWQ6bnVsbCE9PShhPWwuc3RhdGUuY2hhbm5lbElkKSYmdm9pZCAwIT09YT9hOlwiXCIsdmFsaWRVbnRpbDpEYXRlLm5vdygpK0ksbG9jYWxLZXk6bnVsbD09ZT92b2lkIDA6ZS5nZXRLZXlJbmZvKCkuZWNpZXMucHJpdmF0ZSxvdGhlcktleTpFfSk7dC5zZW5kTWVzc2FnZSh7dHlwZTpQLktFWV9IQU5EU0hBS0VfQUNLfSkuY2F0Y2goKGU9Pnt9KSksbnVsbD09PShjPXQuc3RhdGUuc29ja2V0KXx8dm9pZCAwPT09Y3x8Yy5lbWl0KGIuUElORyx7aWQ6dSxjbGllbnRUeXBlOmg/XCJkYXBwXCI6XCJ3YWxsZXRcIixjb250ZXh0Olwib25fY2hhbm5lbF9yZWNvbm5lY3RcIixtZXNzYWdlOlwiXCJ9KSx5aWVsZCBudWxsPT1uP3ZvaWQgMDpuLnBlcnNpc3RDaGFubmVsQ29uZmlnKGkpLGwuZW1pdFNlcnZpY2VTdGF0dXNFdmVudCgpLGwuc2V0Q29ubmVjdGlvblN0YXR1cyhPLkxJTktFRCl9bSYmKHQuZW1pdChSLkNIQU5ORUxfUEVSU0lTVEVOQ0UpLG51bGw9PT0ocz10LnN0YXRlLmtleUV4Y2hhbmdlKXx8dm9pZCAwPT09c3x8cy5zZXRLZXlzRXhjaGFuZ2VkKCEwKSxsLnN0YXRlLnJlYWR5PSEwLGwuc3RhdGUuYXV0aG9yaXplZD0hMCxsLmVtaXQoUi5BVVRIT1JJWkVEKSxDKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7aWQ6bnVsbCE9dT91OlwiXCIsZXZlbnQ6aD9MLkNPTk5FQ1RFRDpMLkNPTk5FQ1RFRF9NT0JJTEV9LHQucmVtb3RlLnN0YXRlLm9yaWdpbmF0b3JJbmZvKSx7c2RrVmVyc2lvbjp0LnJlbW90ZS5zdGF0ZS5zZGtWZXJzaW9uLGNvbW1MYXllcjp0LnN0YXRlLmNvbW11bmljYXRpb25MYXllclByZWZlcmVuY2UsY29tbUxheWVyVmVyc2lvbjpmLnZlcnNpb24sd2FsbGV0VmVyc2lvbjpudWxsPT09KHI9dC5yZW1vdGUuc3RhdGUud2FsbGV0SW5mbyl8fHZvaWQgMD09PXI/dm9pZCAwOnIudmVyc2lvbn0pLGQuY29tbXVuaWNhdGlvblNlcnZlclVybCkuY2F0Y2goKGU9Pnt9KSkpfSkpLE09ZT0+bmV3IFByb21pc2UoKHQ9PntzZXRUaW1lb3V0KHQsZSl9KSksSD0odCxuLC4uLmkpPT5lKHZvaWQgMCxbdCxuLC4uLmldLHZvaWQgMCwoZnVuY3Rpb24qKGUsdCxuPTIwMCl7bGV0IGk7Y29uc3Qgbz1EYXRlLm5vdygpO2xldCBhPSExO2Zvcig7IWE7KXtpZihhPURhdGUubm93KCktbz4zZTUsaT10W2VdLHZvaWQgMCE9PWkuZWxhcHNlZFRpbWUpcmV0dXJuIGk7eWllbGQgTShuKX10aHJvdyBuZXcgRXJyb3IoYFJQQyAke2V9IHRpbWVkIG91dGApfSkpLGo9dD0+ZSh2b2lkIDAsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7Y29uc3R7c3RhdGU6bn09dCx7c29ja2V0OmksY2hhbm5lbElkOm8sY29udGV4dDphLGlzT3JpZ2luYXRvcjpjLGlzUmVjb25uZWN0aW5nOnN9PW47aWYocylyZXR1cm4gZy5Tb2NrZXRTZXJ2aWNlKFwiW1NvY2tldFNlcnZpY2U6IHJlY29ubmVjdFNvY2tldCgpXSBSZWNvbm5lY3Rpb24gYWxyZWFkeSBpbiBwcm9ncmVzcywgc2tpcHBpbmdcIix0KSwhMTtpZighaSlyZXR1cm4gZy5Tb2NrZXRTZXJ2aWNlKFwiW1NvY2tldFNlcnZpY2U6IHJlY29ubmVjdFNvY2tldCgpXSBzb2NrZXQgaXMgbm90IGRlZmluZWRcIix0KSwhMTtpZighbylyZXR1cm4hMTtjb25zdHtjb25uZWN0ZWQ6cn09aTtuLmlzUmVjb25uZWN0aW5nPSEwLG4ucmVjb25uZWN0aW9uQXR0ZW1wdHM9MCxnLlNvY2tldFNlcnZpY2UoYFtTb2NrZXRTZXJ2aWNlOiByZWNvbm5lY3RTb2NrZXQoKV0gY29ubmVjdGVkPSR7cn0gdHJ5aW5nIHRvIHJlY29ubmVjdCBhZnRlciBzb2NrZXRpbyBkaXNjb25uZWN0aW9uYCx0KTt0cnl7Zm9yKDszPm4ucmVjb25uZWN0aW9uQXR0ZW1wdHM7KXtpZihnLlNvY2tldFNlcnZpY2UoYFtTb2NrZXRTZXJ2aWNlOiByZWNvbm5lY3RTb2NrZXQoKV0gQXR0ZW1wdCAke24ucmVjb25uZWN0aW9uQXR0ZW1wdHMrMX0gb2YgM2AsdCkseWllbGQgTSgyMDApLGkuY29ubmVjdGVkKXJldHVybiBnLlNvY2tldFNlcnZpY2UoXCJTb2NrZXQgYWxyZWFkeSBjb25uZWN0ZWQgLS0tIHBpbmcgdG8gcmV0cmlldmUgbWVzc2FnZXNcIiksaS5lbWl0KGIuUElORyx7aWQ6byxjbGllbnRUeXBlOmM/XCJkYXBwXCI6XCJ3YWxsZXRcIixjb250ZXh0Olwib25fY2hhbm5lbF9jb25maWdcIixtZXNzYWdlOlwiXCJ9KSwhMDtuLnJlc3VtZWQ9ITAsaS5jb25uZWN0KCksdC5lbWl0KFIuU09DS0VUX1JFQ09OTkVDVCk7dHJ5e2lmKHlpZWxkIG5ldyBQcm9taXNlKCgobixzKT0+e2kuZW1pdChSLkpPSU5fQ0hBTk5FTCx7Y2hhbm5lbElkOm8sY29udGV4dDpgJHthfWNvbm5lY3RfYWdhaW5gLGNsaWVudFR5cGU6Yz9cImRhcHBcIjpcIndhbGxldFwifSwoKGksbyk9PmUodm9pZCAwLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3RyeXt5aWVsZCB3KHQsaSxvKSxuKCl9Y2F0Y2goZSl7cyhlKX19KSkpKX0pKSx5aWVsZCBNKDEwMCksaS5jb25uZWN0ZWQpcmV0dXJuIGcuU29ja2V0U2VydmljZShgUmVjb25uZWN0aW9uIHN1Y2Nlc3NmdWwgb24gYXR0ZW1wdCAke24ucmVjb25uZWN0aW9uQXR0ZW1wdHMrMX1gKSwhMH1jYXRjaChlKXtnLlNvY2tldFNlcnZpY2UoYEVycm9yIGR1cmluZyByZWNvbm5lY3Rpb24gYXR0ZW1wdCAke24ucmVjb25uZWN0aW9uQXR0ZW1wdHMrMX06YCxlKX1uLnJlY29ubmVjdGlvbkF0dGVtcHRzKz0xLDM+bi5yZWNvbm5lY3Rpb25BdHRlbXB0cyYmKHlpZWxkIE0oMjAwKSl9cmV0dXJuIGcuU29ja2V0U2VydmljZShcIkZhaWxlZCB0byByZWNvbm5lY3QgYWZ0ZXIgMyBhdHRlbXB0c1wiKSwhMX1maW5hbGx5e24uaXNSZWNvbm5lY3Rpbmc9ITEsbi5yZWNvbm5lY3Rpb25BdHRlbXB0cz0wfX0pKTtmdW5jdGlvbiBZKHQsbil7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXt2YXIgZTtjb25zdCBpPW51bGw9PT0oZT10LnN0YXRlLmtleUV4Y2hhbmdlKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5lbmNyeXB0TWVzc2FnZShKU09OLnN0cmluZ2lmeShuKSksbz17aWQ6dC5zdGF0ZS5jaGFubmVsSWQsY29udGV4dDp0LnN0YXRlLmNvbnRleHQsY2xpZW50VHlwZTp0LnN0YXRlLmlzT3JpZ2luYXRvcj9cImRhcHBcIjpcIndhbGxldFwiLG1lc3NhZ2U6aSxwbGFpbnRleHQ6dC5zdGF0ZS5oYXNQbGFpbnRleHQ/SlNPTi5zdHJpbmdpZnkobik6dm9pZCAwfTtyZXR1cm4gZy5Tb2NrZXRTZXJ2aWNlKGBbU29ja2V0U2VydmljZTogZW5jcnlwdEFuZFNlbmRNZXNzYWdlKCldIGNvbnRleHQ9JHt0LnN0YXRlLmNvbnRleHR9YCxvKSxuLnR5cGU9PT1iLlRFUk1JTkFURSYmKHQuc3RhdGUubWFudWFsRGlzY29ubmVjdD0hMCksbmV3IFByb21pc2UoKChlLG4pPT57dmFyIGk7bnVsbD09PShpPXQuc3RhdGUuc29ja2V0KXx8dm9pZCAwPT09aXx8aS5lbWl0KFIuTUVTU0FHRSxvLCgodCxpKT0+e3ZhciBvO3QmJihnLlNvY2tldFNlcnZpY2UoYFtTb2NrZXRTZXJ2aWNlOiBlbmNyeXB0QW5kU2VuZE1lc3NhZ2UoKV0gZXJyb3I9JHt0fWApLG4odCkpLGcuU29ja2V0U2VydmljZShcIltlbmNyeXB0QW5kU2VuZE1lc3NhZ2VdIHJlc3BvbnNlXCIsaSksZShudWxsIT09KG89bnVsbD09aT92b2lkIDA6aS5zdWNjZXNzKSYmdm9pZCAwIT09byYmbyl9KSl9KSl9KSl9dmFyIFU7IWZ1bmN0aW9uKGUpe2UuUlBDX0NIRUNLPVwicnBjQ2hlY2tcIixlLlNLSVBQRURfUlBDPVwic2tpcHBlZFJwY1wifShVfHwoVT17fSkpO2NvbnN0IEc9W1wiZXRoX3NlbmRUcmFuc2FjdGlvblwiLFwiZXRoX3NpZ25UeXBlZERhdGFcIixcImV0aF9zaWduVHJhbnNhY3Rpb25cIixcInBlcnNvbmFsX3NpZ25cIixcIndhbGxldF9yZXF1ZXN0UGVybWlzc2lvbnNcIixcIndhbGxldF9zd2l0Y2hFdGhlcmV1bUNoYWluXCIsXCJldGhfc2lnblR5cGVkRGF0YV92M1wiLFwiZXRoX3NpZ25UeXBlZERhdGFfdjRcIixcIm1ldGFtYXNrX2Nvbm5lY3RTaWduXCIsXCJtZXRhbWFza19jb25uZWN0V2l0aFwiLFwibWV0YW1hc2tfYmF0Y2hcIl0ubWFwKChlPT5lLnRvTG93ZXJDYXNlKCkpKTtmdW5jdGlvbiBWKHQsbil7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXt2YXIgaSxvLGE7aWYoIXQuc3RhdGUuY2hhbm5lbElkKXRocm93IGcuU29ja2V0U2VydmljZShcImhhbmRsZVNlbmRNZXNzYWdlOiBubyBjaGFubmVsSWQgLSBDcmVhdGUgYSBjaGFubmVsIGZpcnN0XCIpLG5ldyBFcnJvcihcIkNyZWF0ZSBhIGNoYW5uZWwgZmlyc3RcIik7aWYoZy5Tb2NrZXRTZXJ2aWNlKGBbU29ja2V0U2VydmljZTogaGFuZGxlU2VuZE1lc3NhZ2UoKV0gY29udGV4dD0ke3Quc3RhdGUuY29udGV4dH0gYXJlS2V5c0V4Y2hhbmdlZD0ke251bGw9PT0oaT10LnN0YXRlLmtleUV4Y2hhbmdlKXx8dm9pZCAwPT09aT92b2lkIDA6aS5hcmVLZXlzRXhjaGFuZ2VkKCl9YCxuKSxudWxsPT09KG89bnVsbD09bj92b2lkIDA6bi50eXBlKXx8dm9pZCAwPT09bz92b2lkIDA6by5zdGFydHNXaXRoKFwia2V5X2hhbmRzaGFrZVwiKSlyZXR1cm4gZnVuY3Rpb24oZSx0KXt2YXIgbjtnLlNvY2tldFNlcnZpY2UoYFtTb2NrZXRTZXJ2aWNlOiBoYW5kbGVLZXlIYW5kc2hha2UoKV0gY29udGV4dD0ke2Uuc3RhdGUuY29udGV4dH1gLHQpLG51bGw9PT0obj1lLnN0YXRlLnNvY2tldCl8fHZvaWQgMD09PW58fG4uZW1pdChSLk1FU1NBR0Use2lkOmUuc3RhdGUuY2hhbm5lbElkLGNvbnRleHQ6ZS5zdGF0ZS5jb250ZXh0LGNsaWVudFR5cGU6ZS5zdGF0ZS5pc09yaWdpbmF0b3I/XCJkYXBwXCI6XCJ3YWxsZXRcIixtZXNzYWdlOnR9KX0odCxuKSwhMDshZnVuY3Rpb24oZSx0KXt2YXIgbjtpZighKG51bGw9PT0obj1lLnN0YXRlLmtleUV4Y2hhbmdlKXx8dm9pZCAwPT09bj92b2lkIDA6bi5hcmVLZXlzRXhjaGFuZ2VkKCkpJiYhZS5yZW1vdGUuc3RhdGUucmVsYXlQZXJzaXN0ZW5jZSl0aHJvdyBnLlNvY2tldFNlcnZpY2UoYFtTb2NrZXRTZXJ2aWNlOiB2YWxpZGF0ZUtleUV4Y2hhbmdlKCldIGNvbnRleHQ9JHtlLnN0YXRlLmNvbnRleHR9IEVSUk9SIGtleXMgbm90IGV4Y2hhbmdlZGAsdCksbmV3IEVycm9yKFwiS2V5cyBub3QgZXhjaGFuZ2VkIEJCQlwiKX0odCxuKSxmdW5jdGlvbihlLHQpe3ZhciBuO2NvbnN0IGk9bnVsbCE9PShuPW51bGw9PXQ/dm9pZCAwOnQubWV0aG9kKSYmdm9pZCAwIT09bj9uOlwiXCIsbz1udWxsPT10P3ZvaWQgMDp0LmlkO2Uuc3RhdGUuaXNPcmlnaW5hdG9yJiZvJiYoZS5zdGF0ZS5ycGNNZXRob2RUcmFja2VyW29dPXtpZDpvLHRpbWVzdGFtcDpEYXRlLm5vdygpLG1ldGhvZDppfSxlLmVtaXQoUi5SUENfVVBEQVRFLGUuc3RhdGUucnBjTWV0aG9kVHJhY2tlcltvXSkpfSh0LG4pO2NvbnN0IHM9eWllbGQgWSh0LG4pO3JldHVybiB0LnJlbW90ZS5zdGF0ZS5hbmFseXRpY3MmJnQucmVtb3RlLnN0YXRlLmlzT3JpZ2luYXRvciYmbi5tZXRob2QmJkcuaW5jbHVkZXMobi5tZXRob2QudG9Mb3dlckNhc2UoKSkmJkMoe2lkOm51bGwhPT0oYT10LnJlbW90ZS5zdGF0ZS5jaGFubmVsSWQpJiZ2b2lkIDAhPT1hP2E6XCJcIixldmVudDpMLlNES19SUENfUkVRVUVTVCxwYXJhbXM6e21ldGhvZDpuLm1ldGhvZCxmcm9tOlwibW9iaWxlXCJ9fSx0LnJlbW90ZS5zdGF0ZS5jb21tdW5pY2F0aW9uU2VydmVyVXJsKS5jYXRjaCgoZT0+e30pKSx0LnJlbW90ZS5zdGF0ZS5pc09yaWdpbmF0b3ImJm4ubWV0aG9kJiZOKG4ubWV0aG9kKSYmYy50cmFjayhcInNka19hY3Rpb25fcmVxdWVzdGVkXCIse2FjdGlvbjpuLm1ldGhvZH0pLGZ1bmN0aW9uKHQsbil7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXt2YXIgaTtjb25zdCBvPW51bGw9PW4/dm9pZCAwOm4uaWQsYT1udWxsIT09KGk9bnVsbD09bj92b2lkIDA6bi5tZXRob2QpJiZ2b2lkIDAhPT1pP2k6XCJcIjtpZih0LnN0YXRlLmlzT3JpZ2luYXRvciYmbyl0cnl7Y29uc3QgaT1IKG8sdC5zdGF0ZS5ycGNNZXRob2RUcmFja2VyLDIwMCkudGhlbigoZT0+KHt0eXBlOlUuUlBDX0NIRUNLLHJlc3VsdDplfSkpKSxjPSgoKT0+ZSh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe2NvbnN0IG49eWllbGQodD0+ZSh2b2lkIDAsW3RdLHZvaWQgMCwoZnVuY3Rpb24qKHtycGNJZDplLGluc3RhbmNlOnR9KXtmb3IoO3Quc3RhdGUubGFzdFJwY0lkPT09ZXx8dm9pZCAwPT09dC5zdGF0ZS5sYXN0UnBjSWQ7KXlpZWxkIE0oMjAwKTtyZXR1cm4gdC5zdGF0ZS5sYXN0UnBjSWR9KSkpKHtpbnN0YW5jZTp0LHJwY0lkOm99KSxpPXlpZWxkIEgobix0LnN0YXRlLnJwY01ldGhvZFRyYWNrZXIsMjAwKTtyZXR1cm57dHlwZTpVLlNLSVBQRURfUlBDLHJlc3VsdDppfX0pKSkoKSxzPXlpZWxkIFByb21pc2UucmFjZShbaSxjXSk7aWYocy50eXBlPT09VS5SUENfQ0hFQ0spe2NvbnN0IGU9cy5yZXN1bHQ7Zy5Tb2NrZXRTZXJ2aWNlKGBbU29ja2V0U2VydmljZTpoYW5kbGVScGNSZXBsaWVzKCldIGlkPSR7bi5pZH0gJHthfSAoICR7ZS5lbGFwc2VkVGltZX0gbXMpYCxlLnJlc3VsdCl9ZWxzZXtpZihzLnR5cGUhPT1VLlNLSVBQRURfUlBDKXRocm93IG5ldyBFcnJvcihgRXJyb3IgaGFuZGxpbmcgUlBDIHJlcGxpZXMgZm9yICR7b31gKTt7Y29uc3QgZT1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdC5zdGF0ZS5ycGNNZXRob2RUcmFja2VyW29dKSx7ZXJyb3I6bmV3IEVycm9yKFwiU0RLX0NPTk5FQ1RJT05fSVNTVUVcIil9KTt0LmVtaXQoUi5SUENfVVBEQVRFLGUpO2NvbnN0IG49e2RhdGE6T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGUpLHtqc29ucnBjOlwiMi4wXCJ9KSxuYW1lOlwibWV0YW1hc2stcHJvdmlkZXJcIn07dC5lbWl0KFIuTUVTU0FHRSx7bWVzc2FnZTpufSl9fX1jYXRjaChlKXt0aHJvdyBlfX0pKX0odCxuKS5jYXRjaCgoZT0+e30pKSxzfSkpfWNvbnN0IHo9W3tldmVudDpSLkNMSUVOVFNfQ09OTkVDVEVELGhhbmRsZXI6ZnVuY3Rpb24odCxuKXtyZXR1cm4gaT0+ZSh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3ZhciBlLGksbyxhLGMscyxyLGwsZCx1LGg7Y29uc3QgbT1udWxsIT09KGk9bnVsbD09PShlPXQucmVtb3RlLnN0YXRlLmNoYW5uZWxDb25maWcpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLnJlbGF5UGVyc2lzdGVuY2UpJiZ2b2lkIDAhPT1pJiZpO2lmKGcuU29ja2V0U2VydmljZShgW1NvY2tldFNlcnZpY2U6IGhhbmRsZUNsaWVudHNDb25uZWN0ZWQoKV0gY29udGV4dD0ke3Quc3RhdGUuY29udGV4dH0gb24gJ2NsaWVudHNfY29ubmVjdGVkLSR7bn0nIHJlbGF5UGVyc2lzdGVuY2U9JHttfSByZXN1bWVkPSR7dC5zdGF0ZS5yZXN1bWVkfSAgY2xpZW50c1BhdXNlZD0ke3Quc3RhdGUuY2xpZW50c1BhdXNlZH0ga2V5c0V4Y2hhbmdlZD0ke251bGw9PT0obz10LnN0YXRlLmtleUV4Y2hhbmdlKXx8dm9pZCAwPT09bz92b2lkIDA6by5hcmVLZXlzRXhjaGFuZ2VkKCl9IGlzT3JpZ2luYXRvcj0ke3Quc3RhdGUuaXNPcmlnaW5hdG9yfWApLHQuZW1pdChSLkNMSUVOVFNfQ09OTkVDVEVELHtpc09yaWdpbmF0b3I6dC5zdGF0ZS5pc09yaWdpbmF0b3Isa2V5c0V4Y2hhbmdlZDpudWxsPT09KGE9dC5zdGF0ZS5rZXlFeGNoYW5nZSl8fHZvaWQgMD09PWE/dm9pZCAwOmEuYXJlS2V5c0V4Y2hhbmdlZCgpLGNvbnRleHQ6dC5zdGF0ZS5jb250ZXh0fSksdC5zdGF0ZS5yZXN1bWVkKXQuc3RhdGUuaXNPcmlnaW5hdG9yfHwoZy5Tb2NrZXRTZXJ2aWNlKGBbU29ja2V0U2VydmljZTogaGFuZGxlQ2xpZW50c0Nvbm5lY3RlZCgpXSBjb250ZXh0PSR7dC5zdGF0ZS5jb250ZXh0fSAnY2xpZW50c19jb25uZWN0ZWQnIC8ga2V5c0V4Y2hhbmdlZD0ke251bGw9PT0oYz10LnN0YXRlLmtleUV4Y2hhbmdlKXx8dm9pZCAwPT09Yz92b2lkIDA6Yy5hcmVLZXlzRXhjaGFuZ2VkKCl9IC0tIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlgKSxudWxsPT09KHM9dC5zdGF0ZS5rZXlFeGNoYW5nZSl8fHZvaWQgMD09PXN8fHMuc3RhcnQoe2lzT3JpZ2luYXRvcjpudWxsIT09KHI9dC5zdGF0ZS5pc09yaWdpbmF0b3IpJiZ2b2lkIDAhPT1yJiZyfSkpLHQuc3RhdGUucmVzdW1lZD0hMTtlbHNlIGlmKHQuc3RhdGUuY2xpZW50c1BhdXNlZClnLlNvY2tldFNlcnZpY2UoXCJbU29ja2V0U2VydmljZTogaGFuZGxlQ2xpZW50c0Nvbm5lY3RlZCgpXSAnY2xpZW50c19jb25uZWN0ZWQnIHNraXAgc2VuZGluZyBvcmlnaW5hdG9ySW5mbyBvbiBwYXVzZVwiKTtlbHNlIGlmKCF0LnN0YXRlLmlzT3JpZ2luYXRvcil7Y29uc3QgZT0hbTtnLlNvY2tldFNlcnZpY2UoYFtTb2NrZXRTZXJ2aWNlOiBoYW5kbGVDbGllbnRzQ29ubmVjdGVkKCldIGNvbnRleHQ9JHt0LnN0YXRlLmNvbnRleHR9IG9uICdjbGllbnRzX2Nvbm5lY3RlZCcgLyBrZXlzRXhjaGFuZ2VkPSR7bnVsbD09PShsPXQuc3RhdGUua2V5RXhjaGFuZ2UpfHx2b2lkIDA9PT1sP3ZvaWQgMDpsLmFyZUtleXNFeGNoYW5nZWQoKX0gLS0gZm9yY2U9JHtlfSAtLSBiYWNrd2FyZCBjb21wYXRpYmlsaXR5YCksZy5Tb2NrZXRTZXJ2aWNlKGBbU29ja2V0U2VydmljZTogaGFuZGxlQ2xpZW50c0Nvbm5lY3RlZCgpXSBjb250ZXh0PSR7dC5zdGF0ZS5jb250ZXh0fSBvbiAnY2xpZW50c19jb25uZWN0ZWQnIC8ga2V5c0V4Y2hhbmdlZD0ke251bGw9PT0oZD10LnN0YXRlLmtleUV4Y2hhbmdlKXx8dm9pZCAwPT09ZD92b2lkIDA6ZC5hcmVLZXlzRXhjaGFuZ2VkKCl9IC0tIGZvcmNlPSR7ZX0gLS0gYmFja3dhcmQgY29tcGF0aWJpbGl0eWApLG51bGw9PT0odT10LnN0YXRlLmtleUV4Y2hhbmdlKXx8dm9pZCAwPT09dXx8dS5zdGFydCh7aXNPcmlnaW5hdG9yOm51bGwhPT0oaD10LnN0YXRlLmlzT3JpZ2luYXRvcikmJnZvaWQgMCE9PWgmJmgsZm9yY2U6ZX0pfXQuc3RhdGUuY2xpZW50c0Nvbm5lY3RlZD0hMCx0LnN0YXRlLmNsaWVudHNQYXVzZWQ9ITF9KSl9fSx7ZXZlbnQ6Ui5DSEFOTkVMX0NSRUFURUQsaGFuZGxlcjpmdW5jdGlvbihlLHQpe3JldHVybiBuPT57Zy5Tb2NrZXRTZXJ2aWNlKGBbU29ja2V0U2VydmljZTogaGFuZGxlQ2hhbm5lbENyZWF0ZWQoKV0gY29udGV4dD0ke2Uuc3RhdGUuY29udGV4dH0gb24gJ2NoYW5uZWxfY3JlYXRlZC0ke3R9J2AsbiksZS5lbWl0KFIuQ0hBTk5FTF9DUkVBVEVELG4pfX19LHtldmVudDpSLkNMSUVOVFNfRElTQ09OTkVDVEVELGhhbmRsZXI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4oKT0+e3ZhciBuO2Uuc3RhdGUuY2xpZW50c0Nvbm5lY3RlZD0hMSxnLlNvY2tldFNlcnZpY2UoYFtTb2NrZXRTZXJ2aWNlOiBoYW5kbGVzQ2xpZW50c0Rpc2Nvbm5lY3RlZCgpXSBjb250ZXh0PSR7ZS5zdGF0ZS5jb250ZXh0fSBvbiAnY2xpZW50c19kaXNjb25uZWN0ZWQtJHt0fSdgKSxlLnJlbW90ZS5zdGF0ZS5yZWxheVBlcnNpc3RlbmNlP2cuU29ja2V0U2VydmljZShgW1NvY2tldFNlcnZpY2U6IGhhbmRsZXNDbGllbnRzRGlzY29ubmVjdGVkKCldIGNvbnRleHQ9JHtlLnN0YXRlLmNvbnRleHR9IG9uICdjbGllbnRzX2Rpc2Nvbm5lY3RlZC0ke3R9JyAtIHJlbGF5UGVyc2lzdGVuY2UgZW5hYmxlZCwgc2tpcHBpbmcga2V5IGV4Y2hhbmdlIGNsZWFudXAuYCk6KGUuc3RhdGUuaXNPcmlnaW5hdG9yJiYhZS5zdGF0ZS5jbGllbnRzUGF1c2VkJiYobnVsbD09PShuPWUuc3RhdGUua2V5RXhjaGFuZ2UpfHx2b2lkIDA9PT1ufHxuLmNsZWFuKCkpLGUuZW1pdChSLkNMSUVOVFNfRElTQ09OTkVDVEVELHQpKX19fSx7ZXZlbnQ6Ui5DT05GSUcsaGFuZGxlcjpmdW5jdGlvbih0LG4pe3JldHVybiBpPT5lKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7dmFyIGUsbyxhO2cuU29ja2V0U2VydmljZShgW1NvY2tldFNlcnZpY2U6IGhhbmRsZUNoYW5uZWxDb25maWcoKV0gdXBkYXRlIHJlbGF5UGVyc2lzdGVuY2Ugb24gJ2NvbmZpZy0ke259J2AsaSk7Y29uc3R7cGVyc2lzdGVuY2U6Yyx3YWxsZXRLZXk6c309aTt0LnN0YXRlLmlzT3JpZ2luYXRvciYmdC5yZW1vdGUuc3RhdGUuY2hhbm5lbENvbmZpZz8oaS53YWxsZXRLZXkmJiF0LnJlbW90ZS5zdGF0ZS5jaGFubmVsQ29uZmlnLm90aGVyS2V5JiYoZy5Tb2NrZXRTZXJ2aWNlKGBTZXR0aW5nIHdhbGxldCBrZXkgJHtzfWApLHQucmVtb3RlLnN0YXRlLmNoYW5uZWxDb25maWcub3RoZXJLZXk9cyx0LmdldEtleUV4Y2hhbmdlKCkuc2V0T3RoZXJQdWJsaWNLZXkoaS53YWxsZXRLZXkpLG51bGw9PT0oZT10LnN0YXRlLmtleUV4Y2hhbmdlKXx8dm9pZCAwPT09ZXx8ZS5zZXRLZXlzRXhjaGFuZ2VkKCEwKSx5aWVsZCB0LnJlbW90ZS5zZW5kTWVzc2FnZSh7dHlwZTpQLktFWV9IQU5EU0hBS0VfQUNLfSkseWllbGQgdC5yZW1vdGUuc2VuZE1lc3NhZ2Uoe3R5cGU6Yi5QSU5HfSkseWllbGQgbnVsbD09PShvPXQucmVtb3RlLnN0YXRlLnN0b3JhZ2VNYW5hZ2VyKXx8dm9pZCAwPT09bz92b2lkIDA6by5wZXJzaXN0Q2hhbm5lbENvbmZpZyh0LnJlbW90ZS5zdGF0ZS5jaGFubmVsQ29uZmlnKSksITAhPT1jfHx0LnJlbW90ZS5zdGF0ZS5jaGFubmVsQ29uZmlnLnJlbGF5UGVyc2lzdGVuY2V8fChnLlNvY2tldFNlcnZpY2UoYFNldHRpbmcgcmVsYXkgcGVyc2lzdGVuY2UgJHtjfWApLHQucmVtb3RlLnN0YXRlLmNoYW5uZWxDb25maWcucmVsYXlQZXJzaXN0ZW5jZT1jLHQucmVtb3RlLnN0YXRlLnJlbGF5UGVyc2lzdGVuY2U9ITAsdC5yZW1vdGUuZW1pdChSLkNIQU5ORUxfUEVSU0lTVEVOQ0UpLHQucmVtb3RlLnN0YXRlLmF1dGhvcml6ZWQ9ITAsdC5yZW1vdGUuc3RhdGUucmVhZHk9ITAsdC5yZW1vdGUuZW1pdChSLkFVVEhPUklaRUQpLHlpZWxkIG51bGw9PT0oYT10LnJlbW90ZS5zdGF0ZS5zdG9yYWdlTWFuYWdlcil8fHZvaWQgMD09PWE/dm9pZCAwOmEucGVyc2lzdENoYW5uZWxDb25maWcodC5yZW1vdGUuc3RhdGUuY2hhbm5lbENvbmZpZykpKTp0LnN0YXRlLmlzT3JpZ2luYXRvcnx8aS5wZXJzaXN0ZW5jZSYmKHQucmVtb3RlLnN0YXRlLnJlbGF5UGVyc2lzdGVuY2U9ITAsdC5yZW1vdGUuZW1pdChSLkNIQU5ORUxfUEVSU0lTVEVOQ0UpKX0pKX19LHtldmVudDpSLk1FU1NBR0UsaGFuZGxlcjpmdW5jdGlvbihlLHQpe3JldHVybiBuPT57dmFyIGksbyxhLHMscixsLGQsdSxoLG0sRSx2LHksUyxwLGssXyxJO2NvbnN0e2Fja0lkOkssbWVzc2FnZTp4LGVycm9yOkF9PW4sVD1udWxsIT09KGk9ZS5yZW1vdGUuc3RhdGUucmVsYXlQZXJzaXN0ZW5jZSkmJnZvaWQgMCE9PWkmJmk7aWYoZy5Tb2NrZXRTZXJ2aWNlKGBbU29ja2V0U2VydmljZSBoYW5kbGVNZXNzYWdlKCldICByZWxheVBlcnNpc3RlbmNlPSR7VH0gIGNvbnRleHQ9JHtlLnN0YXRlLmNvbnRleHR9IG9uICdtZXNzYWdlJyAke3R9IGtleXNFeGNoYW5nZWQ9JHtudWxsPT09KG89ZS5zdGF0ZS5rZXlFeGNoYW5nZSl8fHZvaWQgMD09PW8/dm9pZCAwOm8uYXJlS2V5c0V4Y2hhbmdlZCgpfWAsbiksQSl0aHJvdyBnLlNvY2tldFNlcnZpY2UoYFxcbiAgICAgIFtTb2NrZXRTZXJ2aWNlIGhhbmRsZU1lc3NhZ2UoKV0gY29udGV4dD0ke2Uuc3RhdGUuY29udGV4dH06Om9uICdtZXNzYWdlJyBlcnJvcj0ke0F9YCksbmV3IEVycm9yKEEpO2NvbnN0IE89XCJzdHJpbmdcIj09dHlwZW9mIHg7aWYoIU8mJihudWxsPT14P3ZvaWQgMDp4LnR5cGUpPT09UC5LRVlfSEFORFNIQUtFX1NUQVJUKXtpZihUKXJldHVybjtyZXR1cm4gZy5Tb2NrZXRTZXJ2aWNlKGBbU29ja2V0U2VydmljZSBoYW5kbGVNZXNzYWdlKCldIGNvbnRleHQ9JHtlLnN0YXRlLmNvbnRleHR9OjpvbiAnbWVzc2FnZScgcmVjZWl2ZWQgSEFORFNIQUtFX1NUQVJUIGlzT3JpZ2luYXRvcj0ke2Uuc3RhdGUuaXNPcmlnaW5hdG9yfWAseCksdm9pZChudWxsPT09KGE9ZS5zdGF0ZS5rZXlFeGNoYW5nZSl8fHZvaWQgMD09PWF8fGEuc3RhcnQoe2lzT3JpZ2luYXRvcjpudWxsIT09KHM9ZS5zdGF0ZS5pc09yaWdpbmF0b3IpJiZ2b2lkIDAhPT1zJiZzLGZvcmNlOiEwfSkpfWlmKCFPJiYobnVsbD09PShyPW51bGw9PXg/dm9pZCAwOngudHlwZSl8fHZvaWQgMD09PXI/dm9pZCAwOnIuc3RhcnRzV2l0aChcImtleV9oYW5kc2hha2VcIikpKXtpZihUKXJldHVybjtyZXR1cm4gZy5Tb2NrZXRTZXJ2aWNlKGBbU29ja2V0U2VydmljZSBoYW5kbGVNZXNzYWdlKCldIGNvbnRleHQ9JHtlLnN0YXRlLmNvbnRleHR9OjpvbiAnbWVzc2FnZScgZW1pdCBLRVlfRVhDSEFOR0VgLHgpLHZvaWQgZS5lbWl0KEQuS0VZX0VYQ0hBTkdFLHttZXNzYWdlOngsY29udGV4dDplLnN0YXRlLmNvbnRleHR9KX1pZihPJiYhKG51bGw9PT0obD1lLnN0YXRlLmtleUV4Y2hhbmdlKXx8dm9pZCAwPT09bD92b2lkIDA6bC5hcmVLZXlzRXhjaGFuZ2VkKCkpKXtsZXQgdD0hMTt0cnl7Zy5Tb2NrZXRTZXJ2aWNlKGBbU29ja2V0U2VydmljZSBoYW5kbGVNZXNzYWdlKCldIGNvbnRleHQ9JHtlLnN0YXRlLmNvbnRleHR9OjpvbiAnbWVzc2FnZScgdHJ5aW5nIHRvIGRlY3J5cHQgbWVzc2FnZWApLG51bGw9PT0oZD1lLnN0YXRlLmtleUV4Y2hhbmdlKXx8dm9pZCAwPT09ZHx8ZC5kZWNyeXB0TWVzc2FnZSh4KSx0PSEwfWNhdGNoKHQpe2cuU29ja2V0U2VydmljZShgW1NvY2tldFNlcnZpY2UgaGFuZGxlTWVzc2FnZSgpXSBjb250ZXh0PSR7ZS5zdGF0ZS5jb250ZXh0fTo6b24gJ21lc3NhZ2UnIGVycm9yYCx0KX1pZighdClyZXR1cm4gZS5zdGF0ZS5pc09yaWdpbmF0b3I/bnVsbD09PShoPWUuc3RhdGUua2V5RXhjaGFuZ2UpfHx2b2lkIDA9PT1ofHxoLnN0YXJ0KHtpc09yaWdpbmF0b3I6bnVsbCE9PShtPWUuc3RhdGUuaXNPcmlnaW5hdG9yKSYmdm9pZCAwIT09bSYmbX0pOmUuc2VuZE1lc3NhZ2Uoe3R5cGU6UC5LRVlfSEFORFNIQUtFX1NUQVJUfSkuY2F0Y2goKGU9Pnt9KSksdm9pZCBnLlNvY2tldFNlcnZpY2UoYE1lc3NhZ2UgaWdub3JlZCBiZWNhdXNlIGludmFsaWQga2V5IGV4Y2hhbmdlIHN0YXR1cy4gc3RlcD0ke251bGw9PT0oRT1lLnN0YXRlLmtleUV4Y2hhbmdlKXx8dm9pZCAwPT09RT92b2lkIDA6RS5nZXRLZXlJbmZvKCkuc3RlcH1gLG51bGw9PT0odj1lLnN0YXRlLmtleUV4Y2hhbmdlKXx8dm9pZCAwPT09dj92b2lkIDA6di5nZXRLZXlJbmZvKCkseCk7Zy5Tb2NrZXRTZXJ2aWNlKFwiSW52YWxpZCBrZXkgZXhjaGFuZ2Ugc3RhdHVzIGRldGVjdGVkIC0tLSB1cGRhdGluZyBpdC5cIiksbnVsbD09PSh1PWUuc3RhdGUua2V5RXhjaGFuZ2UpfHx2b2lkIDA9PT11fHx1LnNldEtleXNFeGNoYW5nZWQoITApfWVsc2UgaWYoIU8mJihudWxsPT14P3ZvaWQgMDp4LnR5cGUpKXJldHVybiB2b2lkIGUuZW1pdChSLk1FU1NBR0UseCk7aWYoIU8pcmV0dXJuIHZvaWQgZS5lbWl0KFIuTUVTU0FHRSx4KTtjb25zdCAkPW51bGw9PT0oeT1lLnN0YXRlLmtleUV4Y2hhbmdlKXx8dm9pZCAwPT09eT92b2lkIDA6eS5kZWNyeXB0TWVzc2FnZSh4KSx3PUpTT04ucGFyc2UobnVsbCE9JD8kOlwie31cIik7aWYoSyYmKG51bGw9PUs/dm9pZCAwOksubGVuZ3RoKT4wJiYoZy5Tb2NrZXRTZXJ2aWNlKGBbU29ja2V0U2VydmljZSBoYW5kbGVNZXNzYWdlKCldIGNvbnRleHQ9JHtlLnN0YXRlLmNvbnRleHR9OjpvbiAnbWVzc2FnZScgYWNraWQ9JHtLfSBjaGFubmVsSWQ9JHt0fWApLG51bGw9PT0oUz1lLnN0YXRlLnNvY2tldCl8fHZvaWQgMD09PVN8fFMuZW1pdChSLk1FU1NBR0VfQUNLLHthY2tJZDpLLGNoYW5uZWxJZDp0LGNsaWVudFR5cGU6ZS5zdGF0ZS5pc09yaWdpbmF0b3I/XCJkYXBwXCI6XCJ3YWxsZXRcIn0pKSxlLnN0YXRlLmNsaWVudHNQYXVzZWQ9KG51bGw9PXc/dm9pZCAwOncudHlwZSk9PT1iLlBBVVNFLGUuc3RhdGUuaXNPcmlnaW5hdG9yJiZ3LmRhdGEpe2NvbnN0IHQ9dy5kYXRhLG49ZS5zdGF0ZS5ycGNNZXRob2RUcmFja2VyW3QuaWRdO2lmKG4pe2NvbnN0IGk9RGF0ZS5ub3coKS1uLnRpbWVzdGFtcDtnLlNvY2tldFNlcnZpY2UoYFtTb2NrZXRTZXJ2aWNlIGhhbmRsZU1lc3NhZ2UoKV0gY29udGV4dD0ke2Uuc3RhdGUuY29udGV4dH06Om9uICdtZXNzYWdlJyByZWNlaXZlZCBhbnN3ZXIgZm9yIGlkPSR7dC5pZH0gbWV0aG9kPSR7bi5tZXRob2R9IHJlc3BvbnNlVGltZT0ke2l9YCx3KSxlLnJlbW90ZS5zdGF0ZS5hbmFseXRpY3MmJkcuaW5jbHVkZXMobi5tZXRob2QudG9Mb3dlckNhc2UoKSkmJkMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHtpZDpudWxsIT09KHA9ZS5yZW1vdGUuc3RhdGUuY2hhbm5lbElkKSYmdm9pZCAwIT09cD9wOlwiXCIsZXZlbnQ6TC5TREtfUlBDX1JFUVVFU1RfRE9ORSxzZGtWZXJzaW9uOmUucmVtb3RlLnN0YXRlLnNka1ZlcnNpb24sY29tbUxheWVyVmVyc2lvbjpmLnZlcnNpb259LGUucmVtb3RlLnN0YXRlLm9yaWdpbmF0b3JJbmZvKSx7d2FsbGV0VmVyc2lvbjpudWxsPT09KGs9ZS5yZW1vdGUuc3RhdGUud2FsbGV0SW5mbyl8fHZvaWQgMD09PWs/dm9pZCAwOmsudmVyc2lvbixwYXJhbXM6e21ldGhvZDpuLm1ldGhvZCxmcm9tOlwibW9iaWxlXCJ9fSksZS5yZW1vdGUuc3RhdGUuY29tbXVuaWNhdGlvblNlcnZlclVybCkuY2F0Y2goKGU9Pnt9KSksTihuLm1ldGhvZCkmJmMudHJhY2sodC5lcnJvcj80MDAxPT09dC5lcnJvci5jb2RlP1wic2RrX2FjdGlvbl9yZWplY3RlZFwiOlwic2RrX2FjdGlvbl9mYWlsZWRcIjpcInNka19hY3Rpb25fc3VjY2VlZGVkXCIse2FjdGlvbjpuLm1ldGhvZH0pO2NvbnN0IG89T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG4pLHtyZXN1bHQ6dC5yZXN1bHQsZXJyb3I6dC5lcnJvcj97Y29kZTpudWxsPT09KF89dC5lcnJvcil8fHZvaWQgMD09PV8/dm9pZCAwOl8uY29kZSxtZXNzYWdlOm51bGw9PT0oST10LmVycm9yKXx8dm9pZCAwPT09ST92b2lkIDA6SS5tZXNzYWdlfTp2b2lkIDAsZWxhcHNlZFRpbWU6aX0pO2Uuc3RhdGUucnBjTWV0aG9kVHJhY2tlclt0LmlkXT1vLGUuZW1pdChSLlJQQ19VUERBVEUsbyl9fWUuZW1pdChSLk1FU1NBR0Use21lc3NhZ2U6d30pfX19LHtldmVudDpSLlJFSkVDVEVELGhhbmRsZXI6ZnVuY3Rpb24odCxuKXtyZXR1cm4gaT0+ZSh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3ZhciBlO3Quc3RhdGUuaXNPcmlnaW5hdG9yJiYhdC5yZW1vdGUuc3RhdGUucmVhZHk/KGcuU29ja2V0U2VydmljZShgW1NvY2tldFNlcnZpY2U6IGhhbmRsZUNoYW5uZWxSZWplY3RlZCgpXSBjb250ZXh0PSR7dC5zdGF0ZS5jb250ZXh0fSBjaGFubmVsSWQ9JHtufSBpc09yaWdpbmF0b3I9JHt0LnN0YXRlLmlzT3JpZ2luYXRvcn0gcmVhZHk9JHt0LnJlbW90ZS5zdGF0ZS5yZWFkeX1gLHQucmVtb3RlLnN0YXRlLm9yaWdpbmF0b3JJbmZvKSxDKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7aWQ6bixldmVudDpMLlJFSkVDVEVEfSx0LnJlbW90ZS5zdGF0ZS5vcmlnaW5hdG9ySW5mbykse3Nka1ZlcnNpb246dC5yZW1vdGUuc3RhdGUuc2RrVmVyc2lvbixjb21tTGF5ZXI6dC5zdGF0ZS5jb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlLGNvbW1MYXllclZlcnNpb246Zi52ZXJzaW9uLHdhbGxldFZlcnNpb246bnVsbD09PShlPXQucmVtb3RlLnN0YXRlLndhbGxldEluZm8pfHx2b2lkIDA9PT1lP3ZvaWQgMDplLnZlcnNpb259KSx0LnJlbW90ZS5zdGF0ZS5jb21tdW5pY2F0aW9uU2VydmVyVXJsKS5jYXRjaCgoZT0+e30pKSxjLnRyYWNrKFwic2RrX2Nvbm5lY3Rpb25fcmVqZWN0ZWRcIix7dHJhbnNwb3J0X3R5cGU6XCJ3ZWJzb2NrZXRcIn0pLHlpZWxkIHQucmVtb3RlLmRpc2Nvbm5lY3Qoe3Rlcm1pbmF0ZTohMH0pLHQucmVtb3RlLmVtaXQoUi5SRUpFQ1RFRCx7Y2hhbm5lbElkOm59KSx0LnJlbW90ZS5zZXRDb25uZWN0aW9uU3RhdHVzKE8uRElTQ09OTkVDVEVEKSk6Zy5Tb2NrZXRTZXJ2aWNlKGBbU29ja2V0U2VydmljZTogaGFuZGxlQ2hhbm5lbFJlamVjdGVkKCldIFNLSVAgLS0gY2hhbm5lbElkPSR7bn0gaXNPcmlnaW5hdG9yPSR7dC5zdGF0ZS5pc09yaWdpbmF0b3J9IHJlYWR5PSR7dC5yZW1vdGUuc3RhdGUucmVhZHl9YCl9KSl9fSx7ZXZlbnQ6XCJjbGllbnRzX3dhaXRpbmdfdG9fam9pblwiLGhhbmRsZXI6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbj0+e2cuU29ja2V0U2VydmljZShgW1NvY2tldFNlcnZpY2U6IGhhbmRsZUNsaWVudHNXYWl0aW5nVG9Kb2luKCldIGNvbnRleHQ9JHtlLnN0YXRlLmNvbnRleHR9IG9uICdjbGllbnRzX3dhaXRpbmdfdG9fam9pbi0ke3R9J2AsbiksZS5lbWl0KFIuQ0xJRU5UU19XQUlUSU5HLG4pfX19XSxXPVt7ZXZlbnQ6Ui5LRVlfSU5GTyxoYW5kbGVyOmZ1bmN0aW9uKGUpe3JldHVybiB0PT57Zy5Tb2NrZXRTZXJ2aWNlKFwiW1NvY2tldFNlcnZpY2U6IGhhbmRsZUtleUluZm8oKV0gb24gJ0tFWV9JTkZPJ1wiLHQpLGUuZW1pdChSLktFWV9JTkZPLHQpfX19LHtldmVudDpSLktFWVNfRVhDSEFOR0VELGhhbmRsZXI6ZnVuY3Rpb24oZSl7cmV0dXJuKCk9Pnt2YXIgdCxuLGk7Zy5Tb2NrZXRTZXJ2aWNlKGBbU29ja2V0U2VydmljZTogaGFuZGxlS2V5c0V4Y2hhbmdlZCgpXSBvbiAna2V5c19leGNoYW5nZWQnIGtleXNjaGFuZ2VkPSR7bnVsbD09PSh0PWUuc3RhdGUua2V5RXhjaGFuZ2UpfHx2b2lkIDA9PT10P3ZvaWQgMDp0LmFyZUtleXNFeGNoYW5nZWQoKX1gKTtjb25zdHtjaGFubmVsQ29uZmlnOm99PWUucmVtb3RlLnN0YXRlO2lmKG8pe2NvbnN0IHQ9ZS5nZXRLZXlFeGNoYW5nZSgpLmdldEtleUluZm8oKS5lY2llcztvLmxvY2FsS2V5PXQucHJpdmF0ZSxvLm90aGVyS2V5PXQub3RoZXJQdWJLZXksZS5yZW1vdGUuc3RhdGUuY2hhbm5lbENvbmZpZz1vLG51bGw9PT0obj1lLnJlbW90ZS5zdGF0ZS5zdG9yYWdlTWFuYWdlcil8fHZvaWQgMD09PW58fG4ucGVyc2lzdENoYW5uZWxDb25maWcobykuY2F0Y2goKGU9Pnt9KSl9ZS5lbWl0KFIuS0VZU19FWENIQU5HRUQse2tleXNFeGNoYW5nZWQ6bnVsbD09PShpPWUuc3RhdGUua2V5RXhjaGFuZ2UpfHx2b2lkIDA9PT1pP3ZvaWQgMDppLmFyZUtleXNFeGNoYW5nZWQoKSxpc09yaWdpbmF0b3I6ZS5zdGF0ZS5pc09yaWdpbmF0b3J9KTtjb25zdCBhPXtrZXlJbmZvOmUuZ2V0S2V5SW5mbygpfTtlLmVtaXQoUi5TRVJWSUNFX1NUQVRVUyxhKX19fV07ZnVuY3Rpb24gRihlLHQpe2cuU29ja2V0U2VydmljZShgW1NvY2tldFNlcnZpY2U6IHNldHVwQ2hhbm5lbExpc3RlbmVyKCldIGNvbnRleHQ9JHtlLnN0YXRlLmNvbnRleHR9IHNldHRpbmcgc29ja2V0IGxpc3RlbmVycyBmb3IgY2hhbm5lbCAke3R9Li4uYCk7Y29uc3R7c29ja2V0Om59PWUuc3RhdGUse2tleUV4Y2hhbmdlOml9PWUuc3RhdGU7biYmZS5zdGF0ZS5pc09yaWdpbmF0b3ImJihlLnN0YXRlLmRlYnVnJiYobnVsbD09bnx8bi5pby5vbihcImVycm9yXCIsKHQ9PntnLlNvY2tldFNlcnZpY2UoYFtTb2NrZXRTZXJ2aWNlOiBzZXR1cENoYW5uZWxMaXN0ZW5lcigpXSBjb250ZXh0PSR7ZS5zdGF0ZS5jb250ZXh0fSBzb2NrZXQgZXZlbnQ9ZXJyb3JgLHQpfSkpLG51bGw9PW58fG4uaW8ub24oXCJyZWNvbm5lY3RcIiwodD0+e2cuU29ja2V0U2VydmljZShgW1NvY2tldFNlcnZpY2U6IHNldHVwQ2hhbm5lbExpc3RlbmVyKCldIGNvbnRleHQ9JHtlLnN0YXRlLmNvbnRleHR9IHNvY2tldCBldmVudD1yZWNvbm5lY3RgLHQpLGooZSkuY2F0Y2goKGU9Pnt9KSl9KSksbnVsbD09bnx8bi5pby5vbihcInJlY29ubmVjdF9lcnJvclwiLCh0PT57Zy5Tb2NrZXRTZXJ2aWNlKGBbU29ja2V0U2VydmljZTogc2V0dXBDaGFubmVsTGlzdGVuZXIoKV0gY29udGV4dD0ke2Uuc3RhdGUuY29udGV4dH0gc29ja2V0IGV2ZW50PXJlY29ubmVjdF9lcnJvcmAsdCl9KSksbnVsbD09bnx8bi5pby5vbihcInJlY29ubmVjdF9mYWlsZWRcIiwoKCk9PntnLlNvY2tldFNlcnZpY2UoYFtTb2NrZXRTZXJ2aWNlOiBzZXR1cENoYW5uZWxMaXN0ZW5lcigpXSBjb250ZXh0PSR7ZS5zdGF0ZS5jb250ZXh0fSBzb2NrZXQgZXZlbnQ9cmVjb25uZWN0X2ZhaWxlZGApfSkpKSxudWxsPT1ufHxuLm9uKFwiZGlzY29ubmVjdFwiLCh0PT4oZy5Tb2NrZXRTZXJ2aWNlKGBbU29ja2V0U2VydmljZTogc2V0dXBDaGFubmVsTGlzdGVuZXIoKV0gb24gJ2Rpc2Nvbm5lY3QnIC0tIE1ldGFNYXNrU0RLIHNvY2tldCBkaXNjb25uZWN0ZWQgJyR7dH0nIGJlZ2luIHJlY292ZXJ5Li4uYCksZnVuY3Rpb24oZSl7cmV0dXJuIHQ9PntnLlNvY2tldFNlcnZpY2UoYFtTb2NrZXRTZXJ2aWNlOiBoYW5kbGVEaXNjb25uZWN0KCldIG9uICdkaXNjb25uZWN0JyBtYW51YWxEaXNjb25uZWN0PSR7ZS5zdGF0ZS5tYW51YWxEaXNjb25uZWN0fWAsdCksZS5zdGF0ZS5tYW51YWxEaXNjb25uZWN0fHwoZS5lbWl0KFIuU09DS0VUX0RJU0NPTk5FQ1RFRCksaihlKS5jYXRjaCgoZT0+e30pKSl9fShlKSh0KSkpKSksei5mb3JFYWNoKCgoe2V2ZW50OmksaGFuZGxlcjpvfSk9PntudWxsPT1ufHxuLm9uKGAke2l9LSR7dH1gLG8oZSx0KSl9KSksVy5mb3JFYWNoKCgoe2V2ZW50OnQsaGFuZGxlcjpufSk9PntudWxsPT1pfHxpLm9uKHQsbihlKSl9KSksZS5zdGF0ZS5zZXR1cENoYW5uZWxMaXN0ZW5lcnM9ITB9Y2xhc3MgSiBleHRlbmRzIHN7Y29uc3RydWN0b3IoZSl7c3VwZXIoKSx0aGlzLnN0YXRlPXtjbGllbnRzQ29ubmVjdGVkOiExLGNsaWVudHNQYXVzZWQ6ITEsbWFudWFsRGlzY29ubmVjdDohMSxsYXN0UnBjSWQ6dm9pZCAwLHJwY01ldGhvZFRyYWNrZXI6e30saGFzUGxhaW50ZXh0OiExLGNvbW11bmljYXRpb25TZXJ2ZXJVcmw6XCJcIixmb2N1c0xpc3RlbmVyQWRkZWQ6ITEscmVtb3ZlRm9jdXNMaXN0ZW5lcjp2b2lkIDAsaXNSZWNvbm5lY3Rpbmc6ITEscmVjb25uZWN0aW9uQXR0ZW1wdHM6MH0sdGhpcy5vcHRpb25zPWU7Y29uc3R7cmVjb25uZWN0OnQsY29tbXVuaWNhdGlvbkxheWVyUHJlZmVyZW5jZTppLGNvbW11bmljYXRpb25TZXJ2ZXJVcmw6byxjb250ZXh0OmEscmVtb3RlOmMsbG9nZ2luZzpzfT1lO3RoaXMuc3RhdGUucmVzdW1lZD10LHRoaXMuc3RhdGUuY29udGV4dD1hLHRoaXMuc3RhdGUuaXNPcmlnaW5hdG9yPWMuc3RhdGUuaXNPcmlnaW5hdG9yLHRoaXMuc3RhdGUuY29tbXVuaWNhdGlvbkxheWVyUHJlZmVyZW5jZT1pLHRoaXMuc3RhdGUuZGVidWc9ITA9PT0obnVsbD09cz92b2lkIDA6cy5zZXJ2aWNlTGF5ZXIpLHRoaXMucmVtb3RlPWMsITA9PT0obnVsbD09cz92b2lkIDA6cy5zZXJ2aWNlTGF5ZXIpJiZuLmVuYWJsZShcIlNvY2tldFNlcnZpY2U6TGF5ZXJcIiksdGhpcy5zdGF0ZS5jb21tdW5pY2F0aW9uU2VydmVyVXJsPW8sdGhpcy5zdGF0ZS5oYXNQbGFpbnRleHQ9dGhpcy5zdGF0ZS5jb21tdW5pY2F0aW9uU2VydmVyVXJsIT09ayYmITA9PT0obnVsbD09cz92b2lkIDA6cy5wbGFpbnRleHQpLGcuU29ja2V0U2VydmljZShgW1NvY2tldFNlcnZpY2U6IGNvbnN0cnVjdG9yKCldIFNvY2tldCBJTyB1cmw6ICR7dGhpcy5zdGF0ZS5jb21tdW5pY2F0aW9uU2VydmVyVXJsfWApLHRoaXMuaW5pdFNvY2tldCgpfWluaXRTb2NrZXQoKXt2YXIgZTtjb25zdHtvdGhlclB1YmxpY0tleTp0LGVjaWVzOm4sbG9nZ2luZzppfT10aGlzLm9wdGlvbnMsbz17YXV0b0Nvbm5lY3Q6ITEsdHJhbnNwb3J0czpfLHdpdGhDcmVkZW50aWFsczohMH0sYT10aGlzLnN0YXRlLmNvbW11bmljYXRpb25TZXJ2ZXJVcmw7Zy5Tb2NrZXRTZXJ2aWNlKGBbU29ja2V0U2VydmljZTogaW5pdFNvY2tldCgpXSBTb2NrZXQgSU8gdXJsOiAke2F9YCksdGhpcy5zdGF0ZS5zb2NrZXQ9ZChhLG8pLGZ1bmN0aW9uKGUpe2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmKGcuU29ja2V0U2VydmljZShgW1NvY2tldFNlcnZpY2U6IHNldHVwU29ja2V0Rm9jdXNMaXN0ZW5lcigpXSBoYXNGb2N1cz0ke2RvY3VtZW50Lmhhc0ZvY3VzKCl9YCxlKSwhZS5zdGF0ZS5mb2N1c0xpc3RlbmVyQWRkZWQpKXtjb25zdCB0PSgpPT57Zy5Tb2NrZXRTZXJ2aWNlKFwiRG9jdW1lbnQgaGFzIGZvY3VzIC0tLSByZWNvbm5lY3Rpbmcgc29ja2V0XCIpLGooZSkuY2F0Y2goKGU9Pnt9KSl9O3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIix0KSxlLnN0YXRlLmZvY3VzTGlzdGVuZXJBZGRlZD0hMCxlLnN0YXRlLnJlbW92ZUZvY3VzTGlzdGVuZXI9KCk9Pnt3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsdCksZS5zdGF0ZS5mb2N1c0xpc3RlbmVyQWRkZWQ9ITF9fX0odGhpcyk7Y29uc3QgYz17Y29tbXVuaWNhdGlvbkxheWVyOnRoaXMsb3RoZXJQdWJsaWNLZXk6dCxzZW5kUHVibGljS2V5OiExLGNvbnRleHQ6bnVsbCE9PShlPXRoaXMuc3RhdGUuY29udGV4dCkmJnZvaWQgMCE9PWU/ZTpcIlwiLGVjaWVzOm4sbG9nZ2luZzppfTt0aGlzLnN0YXRlLmtleUV4Y2hhbmdlPW5ldyAkKGMpfXJlc2V0S2V5cygpe3JldHVybiB0aGlzLGcuU29ja2V0U2VydmljZShcIltTb2NrZXRTZXJ2aWNlOiByZXNldEtleXMoKV0gUmVzZXR0aW5nIGtleXMuXCIpLHZvaWQobnVsbD09PShlPXRoaXMuc3RhdGUua2V5RXhjaGFuZ2UpfHx2b2lkIDA9PT1lfHxlLnJlc2V0S2V5cygpKTt2YXIgZX1jcmVhdGVDaGFubmVsKCl7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXt2YXIgbixpLG87aWYoZy5Tb2NrZXRTZXJ2aWNlKGBbU29ja2V0U2VydmljZTogY3JlYXRlQ2hhbm5lbCgpXSBjb250ZXh0PSR7dC5zdGF0ZS5jb250ZXh0fWApLHQuc3RhdGUuc29ja2V0fHx0LmluaXRTb2NrZXQoKSxudWxsPT09KG49dC5zdGF0ZS5zb2NrZXQpfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLmNvbm5lY3RlZCl0aHJvdyBuZXcgRXJyb3IoXCJzb2NrZXQgYWxyZWFkeSBjb25uZWN0ZWRcIik7bnVsbD09PShpPXQuc3RhdGUuc29ja2V0KXx8dm9pZCAwPT09aXx8aS5jb25uZWN0KCksdC5zdGF0ZS5tYW51YWxEaXNjb25uZWN0PSExLHQuc3RhdGUuaXNPcmlnaW5hdG9yPSEwO2NvbnN0IGE9bCgpO3Quc3RhdGUuY2hhbm5lbElkPWEsRih0LGEpLHlpZWxkIG5ldyBQcm9taXNlKCgobixpKT0+e3ZhciBvO251bGw9PT0obz10LnN0YXRlLnNvY2tldCl8fHZvaWQgMD09PW98fG8uZW1pdChSLkpPSU5fQ0hBTk5FTCx7Y2hhbm5lbElkOmEsY29udGV4dDpgJHt0LnN0YXRlLmNvbnRleHR9Y3JlYXRlQ2hhbm5lbGAsY2xpZW50VHlwZTpcImRhcHBcIn0sKChvLGEpPT5lKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7dHJ5e3lpZWxkIHcodCxvLGEpLG4oKX1jYXRjaChlKXtpKGUpfX0pKSkpfSkpO2NvbnN0IGM9bnVsbD09PShvPXQuc3RhdGUua2V5RXhjaGFuZ2UpfHx2b2lkIDA9PT1vP3ZvaWQgMDpvLmdldEtleUluZm8oKTtyZXR1cm57Y2hhbm5lbElkOmEscHViS2V5OihudWxsPT1jP3ZvaWQgMDpjLmVjaWVzLnB1YmxpYyl8fFwiXCIscHJpdktleToobnVsbD09Yz92b2lkIDA6Yy5lY2llcy5wcml2YXRlKXx8XCJcIn19KSl9KHRoaXMpfSkpfWNvbm5lY3RUb0NoYW5uZWwoe2NoYW5uZWxJZDp0LHdpdGhLZXlFeGNoYW5nZTpuPSExLGF1dGhvcml6ZWQ6aX0pe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gZSh0aGlzLGFyZ3VtZW50cyx2b2lkIDAsKGZ1bmN0aW9uKih7b3B0aW9uczp0LGluc3RhbmNlOm59KXtjb25zdHtjaGFubmVsSWQ6aSxhdXRob3JpemVkOm8sd2l0aEtleUV4Y2hhbmdlOmF9PXQse3N0YXRlOmMscmVtb3RlOnN9PW4se2lzT3JpZ2luYXRvcjpyPSExLHNvY2tldDpsLGtleUV4Y2hhbmdlOmR9PWMse2NoYW5uZWxDb25maWc6dX09cy5zdGF0ZTtpZihudWxsPT1sP3ZvaWQgMDpsLmNvbm5lY3RlZCl0aHJvdyBuZXcgRXJyb3IoXCJzb2NrZXQgYWxyZWFkeSBjb25uZWN0ZWRcIik7aWYociYmKG51bGw9PXU/dm9pZCAwOnUucmVsYXlQZXJzaXN0ZW5jZSkpe2NvbnN0e2xvY2FsS2V5OmUsb3RoZXJLZXk6dH09dTtlJiZ0JiYobnVsbD09ZHx8ZC5zZXRSZWxheVBlcnNpc3RlbmNlKHtsb2NhbEtleTplLG90aGVyS2V5OnR9KSl9cmV0dXJuIE9iamVjdC5hc3NpZ24oYyx7bWFudWFsRGlzY29ubmVjdDohMSx3aXRoS2V5RXhjaGFuZ2U6YSxpc09yaWdpbmF0b3I6cixjaGFubmVsSWQ6aX0pLG51bGw9PWx8fGwuY29ubmVjdCgpLEYobixpKSwhciYmbyYmKG51bGw9PWR8fGQuc2V0S2V5c0V4Y2hhbmdlZCghMCksT2JqZWN0LmFzc2lnbihzLnN0YXRlLHtyZWFkeTohMCxhdXRob3JpemVkOiEwfSkpLG5ldyBQcm9taXNlKCh0PT57dmFyIGE7Y29uc3Qgcz1udWxsPT09KGE9bnVsbD09ZD92b2lkIDA6ZC5nZXRLZXlJbmZvKCkpfHx2b2lkIDA9PT1hP3ZvaWQgMDphLmVjaWVzLnB1YmxpYztudWxsPT1sfHxsLmVtaXQoUi5KT0lOX0NIQU5ORUwse2NoYW5uZWxJZDppLGNvbnRleHQ6YCR7Yy5jb250ZXh0fV9jb25uZWN0VG9DaGFubmVsYCxjbGllbnRUeXBlOnI/XCJkYXBwXCI6XCJ3YWxsZXRcIixwdWJsaWNLZXk6byYmIXI/czp2b2lkIDB9LCgoaSxvKT0+ZSh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3lpZWxkIHcobixpLG8pLHQoKX0pKSkpfSkpfSkpfSh7b3B0aW9uczp7Y2hhbm5lbElkOnQsd2l0aEtleUV4Y2hhbmdlOm4sYXV0aG9yaXplZDppfSxpbnN0YW5jZTp0aGlzfSl9Z2V0S2V5SW5mbygpe3JldHVybiB0aGlzLnN0YXRlLmtleUV4Y2hhbmdlLmdldEtleUluZm8oKX1rZXlDaGVjaygpe3ZhciBlLHQ7bnVsbD09PSh0PShlPXRoaXMpLnN0YXRlLnNvY2tldCl8fHZvaWQgMD09PXR8fHQuZW1pdChSLk1FU1NBR0Use2lkOmUuc3RhdGUuY2hhbm5lbElkLGNvbnRleHQ6ZS5zdGF0ZS5jb250ZXh0LG1lc3NhZ2U6e3R5cGU6UC5LRVlfSEFORFNIQUtFX0NIRUNLLHB1YmtleTplLmdldEtleUluZm8oKS5lY2llcy5vdGhlclB1YktleX19KX1nZXRLZXlFeGNoYW5nZSgpe3JldHVybiB0aGlzLnN0YXRlLmtleUV4Y2hhbmdlfXNlbmRNZXNzYWdlKHQpe3JldHVybiBlKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7cmV0dXJuIFYodGhpcyx0KX0pKX1waW5nKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBlKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7dmFyIGUsbjtnLlNvY2tldFNlcnZpY2UoYFtTb2NrZXRTZXJ2aWNlOiBwaW5nKCldIGNvbnRleHQ9JHt0LnN0YXRlLmNvbnRleHR9IG9yaWdpbmF0b3I9JHt0LnN0YXRlLmlzT3JpZ2luYXRvcn0ga2V5c0V4Y2hhbmdlZD0ke251bGw9PT0oZT10LnN0YXRlLmtleUV4Y2hhbmdlKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5hcmVLZXlzRXhjaGFuZ2VkKCl9YCksbnVsbD09PShuPXQuc3RhdGUuc29ja2V0KXx8dm9pZCAwPT09bnx8bi5lbWl0KGIuUElORyx7aWQ6dC5zdGF0ZS5jaGFubmVsSWQsY29udGV4dDpcInBpbmdcIixjbGllbnRUeXBlOnQucmVtb3RlLnN0YXRlLmlzT3JpZ2luYXRvcj9cImRhcHBcIjpcIndhbGxldFwiLG1lc3NhZ2U6XCJcIn0pfSkpfSh0aGlzKX1wYXVzZSgpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gZSh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3ZhciBlLG47Zy5Tb2NrZXRTZXJ2aWNlKGBbU29ja2V0U2VydmljZTogcGF1c2UoKV0gY29udGV4dD0ke3Quc3RhdGUuY29udGV4dH1gKSx0LnN0YXRlLm1hbnVhbERpc2Nvbm5lY3Q9ITAsKG51bGw9PT0oZT10LnN0YXRlLmtleUV4Y2hhbmdlKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5hcmVLZXlzRXhjaGFuZ2VkKCkpJiYoeWllbGQgdC5zZW5kTWVzc2FnZSh7dHlwZTpiLlBBVVNFfSkpLG51bGw9PT0obj10LnN0YXRlLnNvY2tldCl8fHZvaWQgMD09PW58fG4uZGlzY29ubmVjdCgpfSkpfSh0aGlzKX1pc0Nvbm5lY3RlZCgpe3ZhciBlO3JldHVybiBudWxsPT09KGU9dGhpcy5zdGF0ZS5zb2NrZXQpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLmNvbm5lY3RlZH1yZXN1bWUoKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtjb25zdHtzdGF0ZTpuLHJlbW90ZTppfT10LHtzb2NrZXQ6byxjaGFubmVsSWQ6YSxjb250ZXh0OmMsa2V5RXhjaGFuZ2U6cyxpc09yaWdpbmF0b3I6cn09bix7aXNPcmlnaW5hdG9yOmx9PWkuc3RhdGU7aWYoZy5Tb2NrZXRTZXJ2aWNlKGBbU29ja2V0U2VydmljZTogcmVzdW1lKCldIGNoYW5uZWxJZD0ke2F9IGNvbnRleHQ9JHtjfSBjb25uZWN0ZWQ9JHtudWxsPT1vP3ZvaWQgMDpvLmNvbm5lY3RlZH0gbWFudWFsRGlzY29ubmVjdD0ke24ubWFudWFsRGlzY29ubmVjdH0gcmVzdW1lZD0ke24ucmVzdW1lZH0ga2V5c0V4Y2hhbmdlZD0ke251bGw9PXM/dm9pZCAwOnMuYXJlS2V5c0V4Y2hhbmdlZCgpfWApLCFhKXRocm93IGcuU29ja2V0U2VydmljZShcIltTb2NrZXRTZXJ2aWNlOiByZXN1bWUoKV0gY2hhbm5lbElkIGlzIG5vdCBkZWZpbmVkXCIpLG5ldyBFcnJvcihcIkNoYW5uZWxJZCBpcyBub3QgZGVmaW5lZFwiKTsobnVsbD09bz92b2lkIDA6by5jb25uZWN0ZWQpPyhnLlNvY2tldFNlcnZpY2UoXCJbU29ja2V0U2VydmljZTogcmVzdW1lKCldIGFscmVhZHkgY29ubmVjdGVkLlwiKSxvLmVtaXQoYi5QSU5HLHtpZDphLGNsaWVudFR5cGU6bD9cImRhcHBcIjpcIndhbGxldFwiLGNvbnRleHQ6XCJvbl9jaGFubmVsX2NvbmZpZ1wiLG1lc3NhZ2U6XCJcIn0pLGkuaGFzUmVsYXlQZXJzaXN0ZW5jZSgpfHwobnVsbD09cz92b2lkIDA6cy5hcmVLZXlzRXhjaGFuZ2VkKCkpfHwocj95aWVsZCB0LnNlbmRNZXNzYWdlKHt0eXBlOmIuUkVBRFl9KTpudWxsPT1zfHxzLnN0YXJ0KHtpc09yaWdpbmF0b3I6ITF9KSkpOihudWxsPT1vfHxvLmNvbm5lY3QoKSxnLlNvY2tldFNlcnZpY2UoYFtTb2NrZXRTZXJ2aWNlOiByZXN1bWUoKV0gYWZ0ZXIgY29ubmVjdGluZyBzb2NrZXQgLS1cXHgzZSBjb25uZWN0ZWQ9JHtudWxsPT1vP3ZvaWQgMDpvLmNvbm5lY3RlZH1gKSxudWxsPT1vfHxvLmVtaXQoUi5KT0lOX0NIQU5ORUwse2NoYW5uZWxJZDphLGNvbnRleHQ6YCR7Y31fcmVzdW1lYCxjbGllbnRUeXBlOmw/XCJkYXBwXCI6XCJ3YWxsZXRcIn0sKChuLGkpPT5lKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7dHJ5e3lpZWxkIHcodCxuLGkpfWNhdGNoKGUpe319KSkpKSksbi5tYW51YWxEaXNjb25uZWN0PSExLG4ucmVzdW1lZD0hMH0pKX0odGhpcyl9Z2V0UlBDTWV0aG9kVHJhY2tlcigpe3JldHVybiB0aGlzLnN0YXRlLnJwY01ldGhvZFRyYWNrZXJ9ZGlzY29ubmVjdChlKXtyZXR1cm4gZnVuY3Rpb24oZSx0KXt2YXIgbixpLG8sYSxjO2cuU29ja2V0U2VydmljZShgW1NvY2tldFNlcnZpY2U6IGRpc2Nvbm5lY3QoKV0gY29udGV4dD0ke2Uuc3RhdGUuY29udGV4dH1gLHQpLChudWxsPT10P3ZvaWQgMDp0LnRlcm1pbmF0ZSkmJihudWxsPT09KGk9KG49ZS5zdGF0ZSkucmVtb3ZlRm9jdXNMaXN0ZW5lcil8fHZvaWQgMD09PWl8fGkuY2FsbChuKSxlLnN0YXRlLmNoYW5uZWxJZD10LmNoYW5uZWxJZCxudWxsPT09KG89ZS5zdGF0ZS5zb2NrZXQpfHx2b2lkIDA9PT1vfHxvLnJlbW92ZUFsbExpc3RlbmVycygpLG51bGw9PT0oYT1lLnN0YXRlLmtleUV4Y2hhbmdlKXx8dm9pZCAwPT09YXx8YS5jbGVhbigpLGUucmVtb3RlLnN0YXRlLnJlYWR5PSExLGUuc3RhdGUuc29ja2V0PXZvaWQgMCxlLnN0YXRlLnJwY01ldGhvZFRyYWNrZXI9e30pLGUuc3RhdGUubWFudWFsRGlzY29ubmVjdD0hMCxudWxsPT09KGM9ZS5zdGF0ZS5zb2NrZXQpfHx2b2lkIDA9PT1jfHxjLmRpc2Nvbm5lY3QoKX0odGhpcyxlKX19dmFyIEIsWixRO2Z1bmN0aW9uIFgodCl7cmV0dXJuKCk9PmUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXt2YXIgbixpLG87Y29uc3R7c3RhdGU6YX09dDtpZihhLmF1dGhvcml6ZWQpcmV0dXJuO3lpZWxkKCgpPT5lKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7Zm9yKDshYS53YWxsZXRJbmZvOyl5aWVsZCBNKDUwMCl9KSkpKCk7Y29uc3QgYz1cIjcuM1wiLmxvY2FsZUNvbXBhcmUoKG51bGw9PT0obj1hLndhbGxldEluZm8pfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLnZlcnNpb24pfHxcIlwiKTtpZihnLlJlbW90ZUNvbW11bmljYXRpb24oYFtSZW1vdGVDb21tdW5pY2F0aW9uOiBoYW5kbGVBdXRob3JpemVkRXZlbnQoKV0gSEFDSyAnYXV0aG9yaXplZCcgdmVyc2lvbj0ke251bGw9PT0oaT1hLndhbGxldEluZm8pfHx2b2lkIDA9PT1pP3ZvaWQgMDppLnZlcnNpb259IGNvbXBhcmVWYWx1ZT0ke2N9YCksMSE9PWMpcmV0dXJuO2NvbnN0IHM9YS5wbGF0Zm9ybVR5cGU9PT1aLk1vYmlsZVdlYnx8YS5wbGF0Zm9ybVR5cGU9PT1aLlJlYWN0TmF0aXZlfHxhLnBsYXRmb3JtVHlwZT09PVouTWV0YU1hc2tNb2JpbGVXZWJ2aWV3O2cuUmVtb3RlQ29tbXVuaWNhdGlvbihgW1JlbW90ZUNvbW11bmljYXRpb246IGhhbmRsZUF1dGhvcml6ZWRFdmVudCgpXSBIQUNLICdhdXRob3JpemVkJyBwbGF0Zm9ybT0ke2EucGxhdGZvcm1UeXBlfSBzZWN1cmU9JHtzfSBjaGFubmVsPSR7YS5jaGFubmVsSWR9IHdhbGxldFZlcnNpb249JHtudWxsPT09KG89YS53YWxsZXRJbmZvKXx8dm9pZCAwPT09bz92b2lkIDA6by52ZXJzaW9ufWApLHMmJihhLmF1dGhvcml6ZWQ9ITAsdC5lbWl0KFIuQVVUSE9SSVpFRCkpfSkpfWZ1bmN0aW9uIHEoZSl7cmV0dXJuIHQ9Pntjb25zdHtzdGF0ZTpufT1lO2cuUmVtb3RlQ29tbXVuaWNhdGlvbihgW1JlbW90ZUNvbW11bmljYXRpb246IGhhbmRsZUNoYW5uZWxDcmVhdGVkRXZlbnQoKV0gY29udGV4dD0ke24uY29udGV4dH0gb24gJ2NoYW5uZWxfY3JlYXRlZCcgY2hhbm5lbElkPSR7dH1gKSxlLmVtaXQoUi5DSEFOTkVMX0NSRUFURUQsdCl9fWZ1bmN0aW9uIGVlKGUsdCl7cmV0dXJuKCk9Pnt2YXIgbixpLG8sYTtjb25zdHtzdGF0ZTpzfT1lO2cuUmVtb3RlQ29tbXVuaWNhdGlvbihgW1JlbW90ZUNvbW11bmljYXRpb246IGhhbmRsZUNsaWVudHNDb25uZWN0ZWRFdmVudCgpXSBvbiAnY2xpZW50c19jb25uZWN0ZWQnIGNoYW5uZWw9JHtzLmNoYW5uZWxJZH0ga2V5c0V4Y2hhbmdlZD0ke251bGw9PT0oaT1udWxsPT09KG49cy5jb21tdW5pY2F0aW9uTGF5ZXIpfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLmdldEtleUluZm8oKSl8fHZvaWQgMD09PWk/dm9pZCAwOmkua2V5c0V4Y2hhbmdlZH1gKSxzLmFuYWx5dGljcyYmQyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe2lkOm51bGwhPT0obz1zLmNoYW5uZWxJZCkmJnZvaWQgMCE9PW8/bzpcIlwiLGV2ZW50OnMucmVjb25uZWN0aW9uP0wuUkVDT05ORUNUOnMuaXNPcmlnaW5hdG9yP0wuUkVRVUVTVDpMLlJFUVVFU1RfTU9CSUxFfSxzLm9yaWdpbmF0b3JJbmZvKSx7Y29tbUxheWVyOnQsc2RrVmVyc2lvbjpzLnNka1ZlcnNpb24sd2FsbGV0VmVyc2lvbjpudWxsPT09KGE9cy53YWxsZXRJbmZvKXx8dm9pZCAwPT09YT92b2lkIDA6YS52ZXJzaW9uLGNvbW1MYXllclZlcnNpb246Zi52ZXJzaW9ufSkscy5jb21tdW5pY2F0aW9uU2VydmVyVXJsKS5jYXRjaCgoZT0+e30pKSxzLmlzT3JpZ2luYXRvciYmIXMucmVjb25uZWN0aW9uJiZjLnRyYWNrKFwic2RrX2Nvbm5lY3Rpb25fZXN0YWJsaXNoZWRcIix7dHJhbnNwb3J0X3R5cGU6XCJ3ZWJzb2NrZXRcIn0pLHMuY2xpZW50c0Nvbm5lY3RlZD0hMCxzLm9yaWdpbmF0b3JJbmZvU2VudD0hMSxlLmVtaXQoUi5DTElFTlRTX0NPTk5FQ1RFRCl9fWZ1bmN0aW9uIHRlKGUpe3JldHVybiB0PT57Y29uc3R7c3RhdGU6bn09ZTtnLlJlbW90ZUNvbW11bmljYXRpb24oYFtSZW1vdGVDb21tdW5pY2F0aW9uOiBoYW5kbGVDbGllbnRzRGlzY29ubmVjdGVkRXZlbnQoKV0gY29udGV4dD0ke24uY29udGV4dH0gb24gJ2NsaWVudHNfZGlzY29ubmVjdGVkJyBjaGFubmVsSWQ9JHt0fWApLG4ucmVsYXlQZXJzaXN0ZW5jZXx8KG4uY2xpZW50c0Nvbm5lY3RlZD0hMSxuLnJlYWR5PSExLG4uYXV0aG9yaXplZD0hMSksZS5lbWl0KFIuQ0xJRU5UU19ESVNDT05ORUNURUQsbi5jaGFubmVsSWQpLGUuc2V0Q29ubmVjdGlvblN0YXR1cyhPLkRJU0NPTk5FQ1RFRCl9fWZ1bmN0aW9uIG5lKGUpe3JldHVybiB0PT57dmFyIG47Y29uc3R7c3RhdGU6aX09ZTtpZihnLlJlbW90ZUNvbW11bmljYXRpb24oYFtSZW1vdGVDb21tdW5pY2F0aW9uOiBoYW5kbGVDbGllbnRzV2FpdGluZ0V2ZW50KCldIGNvbnRleHQ9JHtpLmNvbnRleHR9IG9uICdjbGllbnRzX3dhaXRpbmcnIG51bWJlclVzZXJzPSR7dH0gcmVhZHk9JHtpLnJlYWR5fSBhdXRvU3RhcnRlZD0ke2kub3JpZ2luYXRvckNvbm5lY3RTdGFydGVkfWApLGUuc2V0Q29ubmVjdGlvblN0YXR1cyhPLldBSVRJTkcpLGUuZW1pdChSLkNMSUVOVFNfV0FJVElORyx0KSxpLm9yaWdpbmF0b3JDb25uZWN0U3RhcnRlZCl7Zy5SZW1vdGVDb21tdW5pY2F0aW9uKGBbUmVtb3RlQ29tbXVuaWNhdGlvbjogaGFuZGxlQ2xpZW50c1dhaXRpbmdFdmVudCgpXSBvbiAnY2xpZW50c193YWl0aW5nJyB3YXRjaCBhdXRvU3RhcnRlZD0ke2kub3JpZ2luYXRvckNvbm5lY3RTdGFydGVkfSB0aW1lb3V0YCxpLmF1dG9Db25uZWN0T3B0aW9ucyk7Y29uc3QgdD0obnVsbD09PShuPWkuYXV0b0Nvbm5lY3RPcHRpb25zKXx8dm9pZCAwPT09bj92b2lkIDA6bi50aW1lb3V0KXx8M2UzLG89c2V0VGltZW91dCgoKCk9PntnLlJlbW90ZUNvbW11bmljYXRpb24oYFtSZW1vdGVDb21tdW5pY2F0aW9uOiBoYW5kbGVDbGllbnRzV2FpdGluZ0V2ZW50KCldIHNldFRpbWVvdXQoJHt0fSkgdGVybWluYXRlIGNoYW5uZWxDb25maWdgLGkuYXV0b0Nvbm5lY3RPcHRpb25zKSxpLm9yaWdpbmF0b3JDb25uZWN0U3RhcnRlZD0hMSxpLnJlYWR5fHxlLnNldENvbm5lY3Rpb25TdGF0dXMoTy5USU1FT1VUKSxjbGVhclRpbWVvdXQobyl9KSx0KX19fWZ1bmN0aW9uIGllKGUsdCl7cmV0dXJuIG49Pnt2YXIgaSxvLGEsYyxzLHIsbCxkO2NvbnN0e3N0YXRlOnV9PWU7aWYoZy5SZW1vdGVDb21tdW5pY2F0aW9uKGBbUmVtb3RlQ29tbXVuaWNhdGlvbjogaGFuZGxlS2V5c0V4Y2hhbmdlZEV2ZW50KCldIGNvbnRleHQ9JHt1LmNvbnRleHR9IG9uIGNvbW1MYXllci4na2V5c19leGNoYW5nZWQnIGNoYW5uZWw9JHt1LmNoYW5uZWxJZH1gLG4pLG51bGw9PT0obz1udWxsPT09KGk9dS5jb21tdW5pY2F0aW9uTGF5ZXIpfHx2b2lkIDA9PT1pP3ZvaWQgMDppLmdldEtleUluZm8oKSl8fHZvaWQgMD09PW8/dm9pZCAwOm8ua2V5c0V4Y2hhbmdlZCl7Y29uc3QgdD1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdS5jaGFubmVsQ29uZmlnKSx7Y2hhbm5lbElkOm51bGwhPT0oYT11LmNoYW5uZWxJZCkmJnZvaWQgMCE9PWE/YTpcIlwiLHZhbGlkVW50aWw6KG51bGw9PT0oYz11LmNoYW5uZWxDb25maWcpfHx2b2lkIDA9PT1jP3ZvaWQgMDpjLnZhbGlkVW50aWwpfHxJLGxvY2FsS2V5OnUuY29tbXVuaWNhdGlvbkxheWVyLmdldEtleUluZm8oKS5lY2llcy5wcml2YXRlLG90aGVyS2V5OnUuY29tbXVuaWNhdGlvbkxheWVyLmdldEtleUluZm8oKS5lY2llcy5vdGhlclB1YktleX0pO251bGw9PT0ocz11LnN0b3JhZ2VNYW5hZ2VyKXx8dm9pZCAwPT09c3x8cy5wZXJzaXN0Q2hhbm5lbENvbmZpZyh0KS5jYXRjaCgoZT0+e30pKSxlLnNldENvbm5lY3Rpb25TdGF0dXMoTy5MSU5LRUQpfSFmdW5jdGlvbihlLHQpe3ZhciBuLGksbyxhLGMscyxyLGw7Y29uc3R7c3RhdGU6ZH09ZTtnLlJlbW90ZUNvbW11bmljYXRpb24oYFtSZW1vdGVDb21tdW5pY2F0aW9uOiBzZXRMYXN0QWN0aXZlRGF0ZSgpXSBjaGFubmVsPSR7ZC5jaGFubmVsSWR9YCx0KTtjb25zdCB1PU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxkLmNoYW5uZWxDb25maWcpLHtjaGFubmVsSWQ6bnVsbCE9PShuPWQuY2hhbm5lbElkKSYmdm9pZCAwIT09bj9uOlwiXCIsdmFsaWRVbnRpbDpudWxsIT09KG89bnVsbD09PShpPWQuY2hhbm5lbENvbmZpZyl8fHZvaWQgMD09PWk/dm9pZCAwOmkudmFsaWRVbnRpbCkmJnZvaWQgMCE9PW8/bzowLHJlbGF5UGVyc2lzdGVuY2U6ZC5yZWxheVBlcnNpc3RlbmNlLGxvY2FsS2V5Om51bGw9PT0oYz1udWxsPT09KGE9ZC5jb21tdW5pY2F0aW9uTGF5ZXIpfHx2b2lkIDA9PT1hP3ZvaWQgMDphLnN0YXRlLmtleUV4Y2hhbmdlKXx8dm9pZCAwPT09Yz92b2lkIDA6Yy5nZXRLZXlJbmZvKCkuZWNpZXMucHJpdmF0ZSxvdGhlcktleTpudWxsPT09KHI9bnVsbD09PShzPWQuY29tbXVuaWNhdGlvbkxheWVyKXx8dm9pZCAwPT09cz92b2lkIDA6cy5zdGF0ZS5rZXlFeGNoYW5nZSl8fHZvaWQgMD09PXI/dm9pZCAwOnIuZ2V0S2V5SW5mbygpLmVjaWVzLm90aGVyUHViS2V5LGxhc3RBY3RpdmU6dC5nZXRUaW1lKCl9KTtudWxsPT09KGw9ZC5zdG9yYWdlTWFuYWdlcil8fHZvaWQgMD09PWx8fGwucGVyc2lzdENoYW5uZWxDb25maWcodSl9KGUsbmV3IERhdGUpLHUuYW5hbHl0aWNzJiZ1LmNoYW5uZWxJZCYmQyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe2lkOnUuY2hhbm5lbElkLGV2ZW50Om4uaXNPcmlnaW5hdG9yP0wuQ09OTkVDVEVEOkwuQ09OTkVDVEVEX01PQklMRX0sdS5vcmlnaW5hdG9ySW5mbykse3Nka1ZlcnNpb246dS5zZGtWZXJzaW9uLGNvbW1MYXllcjp0LGNvbW1MYXllclZlcnNpb246Zi52ZXJzaW9uLHdhbGxldFZlcnNpb246bnVsbD09PShyPXUud2FsbGV0SW5mbyl8fHZvaWQgMD09PXI/dm9pZCAwOnIudmVyc2lvbn0pLHUuY29tbXVuaWNhdGlvblNlcnZlclVybCkuY2F0Y2goKGU9Pnt9KSksdS5pc09yaWdpbmF0b3I9bi5pc09yaWdpbmF0b3Isbi5pc09yaWdpbmF0b3J8fChudWxsPT09KGw9dS5jb21tdW5pY2F0aW9uTGF5ZXIpfHx2b2lkIDA9PT1sfHxsLnNlbmRNZXNzYWdlKHt0eXBlOmIuUkVBRFl9KSx1LnJlYWR5PSEwLHUucGF1c2VkPSExKSxuLmlzT3JpZ2luYXRvciYmIXUub3JpZ2luYXRvckluZm9TZW50JiYobnVsbD09PShkPXUuY29tbXVuaWNhdGlvbkxheWVyKXx8dm9pZCAwPT09ZHx8ZC5zZW5kTWVzc2FnZSh7dHlwZTpiLk9SSUdJTkFUT1JfSU5GTyxvcmlnaW5hdG9ySW5mbzp1Lm9yaWdpbmF0b3JJbmZvLG9yaWdpbmF0b3I6dS5vcmlnaW5hdG9ySW5mb30pLHUub3JpZ2luYXRvckluZm9TZW50PSEwKX19ZnVuY3Rpb24gb2UodCl7cmV0dXJuIG49PntsZXQgaT1uO24ubWVzc2FnZSYmKGk9aS5tZXNzYWdlKSxmdW5jdGlvbih0LG4pe2NvbnN0e3N0YXRlOml9PW47aWYoZy5SZW1vdGVDb21tdW5pY2F0aW9uKGBbUmVtb3RlQ29tbXVuaWNhdGlvbjogb25Db21tdW5pY2F0aW9uTGF5ZXJNZXNzYWdlKCldIGNvbnRleHQ9JHtpLmNvbnRleHR9IG9uICdtZXNzYWdlJyB0eXBlb2Y9JHt0eXBlb2YgdH1gLHQpLG4uc3RhdGUucmVhZHk9ITAsaS5pc09yaWdpbmF0b3J8fHQudHlwZSE9PWIuT1JJR0lOQVRPUl9JTkZPKWlmKGkuaXNPcmlnaW5hdG9yJiZ0LnR5cGU9PT1iLldBTExFVF9JTkZPKSFmdW5jdGlvbihlLHQpe2NvbnN0e3N0YXRlOm59PWU7bi53YWxsZXRJbmZvPXQud2FsbGV0SW5mbyxuLnBhdXNlZD0hMX0obix0KTtlbHNle2lmKGkuaXNPcmlnaW5hdG9yJiZ0LnR5cGU9PT1iLldBTExFVF9JTklUKShmdW5jdGlvbih0LG4pe3JldHVybiBlKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7dmFyIGUsaSxvO2NvbnN0e3N0YXRlOmF9PXQ7aWYoYS5pc09yaWdpbmF0b3Ipe2NvbnN0IGE9bi5kYXRhfHx7fTtpZihcIm9iamVjdFwiPT10eXBlb2YgYSYmXCJhY2NvdW50c1wiaW4gYSYmXCJjaGFpbklkXCJpbiBhJiZcIndhbGxldEtleVwiaW4gYSl0cnl7Y29uc3R7Y2hhbm5lbENvbmZpZzpufT10LnN0YXRlO2lmKGcuUmVtb3RlQ29tbXVuaWNhdGlvbihcIldBTExFVF9JTklUOiBjaGFubmVsQ29uZmlnXCIsSlNPTi5zdHJpbmdpZnkobixudWxsLDIpKSxuKXtjb25zdCBjPWEuYWNjb3VudHMscz1hLmNoYWluSWQscj1hLndhbGxldEtleTtsZXQgbCxkPSExO1wiZGVlcGxpbmtQcm90b2NvbFwiaW4gYSYmKGQ9Qm9vbGVhbihhLmRlZXBsaW5rUHJvdG9jb2wpLHQuc3RhdGUuZGVlcGxpbmtQcm90b2NvbEF2YWlsYWJsZT1kKSxcIndhbGxldFZlcnNpb25cImluIGEmJihsPWEud2FsbGV0VmVyc2lvbikseWllbGQgbnVsbD09PShlPXQuc3RhdGUuc3RvcmFnZU1hbmFnZXIpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLnBlcnNpc3RDaGFubmVsQ29uZmlnKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxuKSx7b3RoZXJLZXk6cix3YWxsZXRWZXJzaW9uOmwsZGVlcGxpbmtQcm90b2NvbEF2YWlsYWJsZTpkLHJlbGF5UGVyc2lzdGVuY2U6ITB9KSkseWllbGQgbnVsbD09PShpPXQuc3RhdGUuc3RvcmFnZU1hbmFnZXIpfHx2b2lkIDA9PT1pP3ZvaWQgMDppLnBlcnNpc3RBY2NvdW50cyhjKSx5aWVsZCBudWxsPT09KG89dC5zdGF0ZS5zdG9yYWdlTWFuYWdlcil8fHZvaWQgMD09PW8/dm9pZCAwOm8ucGVyc2lzdENoYWluSWQocyl9dC5lbWl0KFIuV0FMTEVUX0lOSVQse2FjY291bnRzOmEuYWNjb3VudHMsY2hhaW5JZDphLmNoYWluSWR9KX1jYXRjaChlKXt9fX0pKX0pKG4sdCkuY2F0Y2goKGU9PntnLlJlbW90ZUNvbW11bmljYXRpb24oYFtSZW1vdGVDb21tdW5pY2F0aW9uOiBvbkNvbW11bmljYXRpb25MYXllck1lc3NhZ2UoKV0gZXJyb3I9JHtlfWApfSkpO2Vsc2UgaWYodC50eXBlPT09Yi5URVJNSU5BVEUpKGZ1bmN0aW9uKHQpe3JldHVybiBlKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7Y29uc3R7c3RhdGU6ZX09dDtlLmlzT3JpZ2luYXRvciYmKHlpZWxkIGxlKHtvcHRpb25zOnt0ZXJtaW5hdGU6ITAsc2VuZE1lc3NhZ2U6ITF9LGluc3RhbmNlOnR9KSx0LmVtaXQoUi5URVJNSU5BVEUpKX0pKX0pKG4pLmNhdGNoKChlPT57Zy5SZW1vdGVDb21tdW5pY2F0aW9uKGBbUmVtb3RlQ29tbXVuaWNhdGlvbjogb25Db21tdW5pY2F0aW9uTGF5ZXJNZXNzYWdlKCldIGVycm9yPSR7ZX1gKX0pKTtlbHNlIGlmKHQudHlwZT09PWIuUEFVU0UpIWZ1bmN0aW9uKGUpe2NvbnN0e3N0YXRlOnR9PWU7dC5wYXVzZWQ9ITAsZS5zZXRDb25uZWN0aW9uU3RhdHVzKE8uUEFVU0VEKX0obik7ZWxzZSBpZih0LnR5cGU9PT1iLlJFQURZJiZpLmlzT3JpZ2luYXRvcikhZnVuY3Rpb24oZSl7Y29uc3R7c3RhdGU6dH09ZTtlLnNldENvbm5lY3Rpb25TdGF0dXMoTy5MSU5LRUQpO2NvbnN0IG49dC5wYXVzZWQ7dC5wYXVzZWQ9ITEsZS5lbWl0KFIuQ0xJRU5UU19SRUFEWSx7aXNPcmlnaW5hdG9yOnQuaXNPcmlnaW5hdG9yLHdhbGxldEluZm86dC53YWxsZXRJbmZvfSksbiYmKHQuYXV0aG9yaXplZD0hMCxlLmVtaXQoUi5BVVRIT1JJWkVEKSl9KG4pO2Vsc2V7aWYodC50eXBlPT09Yi5PVFAmJmkuaXNPcmlnaW5hdG9yKXJldHVybiB2b2lkIGZ1bmN0aW9uKGUsdCl7dmFyIG47Y29uc3R7c3RhdGU6aX09ZTtlLmVtaXQoUi5PVFAsdC5vdHBBbnN3ZXIpLDE9PT1cIjYuNlwiLmxvY2FsZUNvbXBhcmUoKG51bGw9PT0obj1pLndhbGxldEluZm8pfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLnZlcnNpb24pfHxcIlwiKSYmZS5lbWl0KFIuU0RLX1JQQ19DQUxMLHttZXRob2Q6eC5FVEhfUkVRVUVTVEFDQ09VTlRTLHBhcmFtczpbXX0pfShuLHQpO3QudHlwZT09PWIuQVVUSE9SSVpFRCYmaS5pc09yaWdpbmF0b3ImJmZ1bmN0aW9uKGUpe2NvbnN0e3N0YXRlOnR9PWU7dC5hdXRob3JpemVkPSEwLGUuZW1pdChSLkFVVEhPUklaRUQpfShuKX1uLmVtaXQoUi5NRVNTQUdFLHQpfWVsc2UhZnVuY3Rpb24oZSx0KXt2YXIgbjtjb25zdHtzdGF0ZTppfT1lO251bGw9PT0obj1pLmNvbW11bmljYXRpb25MYXllcil8fHZvaWQgMD09PW58fG4uc2VuZE1lc3NhZ2Uoe3R5cGU6Yi5XQUxMRVRfSU5GTyx3YWxsZXRJbmZvOmkud2FsbGV0SW5mb30pLGkub3JpZ2luYXRvckluZm89dC5vcmlnaW5hdG9ySW5mb3x8dC5vcmlnaW5hdG9yLGUuZW1pdChSLkNMSUVOVFNfUkVBRFkse2lzT3JpZ2luYXRvcjppLmlzT3JpZ2luYXRvcixvcmlnaW5hdG9ySW5mbzppLm9yaWdpbmF0b3JJbmZvfSksaS5wYXVzZWQ9ITF9KG4sdCl9KGksdCl9fWZ1bmN0aW9uIGFlKGUpe3JldHVybigpPT57Y29uc3R7c3RhdGU6dH09ZTtnLlJlbW90ZUNvbW11bmljYXRpb24oXCJbUmVtb3RlQ29tbXVuaWNhdGlvbjogaGFuZGxlU29ja2V0UmVjb25uZWN0RXZlbnQoKV0gb24gJ3NvY2tldF9yZWNvbm5lY3QnIC0tIHJlc2V0IGtleSBleGNoYW5nZSBzdGF0dXMgLyBzZXQgcmVhZHkgdG8gZmFsc2VcIiksdC5yZWFkeT0hMSx0LmF1dGhvcml6ZWQ9ITEsVCh0KSxlLmVtaXRTZXJ2aWNlU3RhdHVzRXZlbnQoe2NvbnRleHQ6XCJzb2NrZXRfcmVjb25uZWN0XCJ9KX19ZnVuY3Rpb24gY2UoZSl7cmV0dXJuKCk9Pntjb25zdHtzdGF0ZTp0fT1lO2cuUmVtb3RlQ29tbXVuaWNhdGlvbihcIltSZW1vdGVDb21tdW5pY2F0aW9uOiBoYW5kbGVTb2NrZXREaXNjb25uZWN0ZWRFdmVudCgpXSBvbiAnc29ja2V0X0Rpc2Nvbm5lY3RlZCcgc2V0IHJlYWR5IHRvIGZhbHNlXCIpLHQucmVhZHk9ITF9fWZ1bmN0aW9uIHNlKHQpe3JldHVybigpPT5lKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7dmFyIGUsbixpLG8sYSxjLHM7Y29uc3R7c3RhdGU6cn09dDtnLlJlbW90ZUNvbW11bmljYXRpb24oYFtSZW1vdGVDb21tdW5pY2F0aW9uOiBoYW5kbGVGdWxsUGVyc2lzdGVuY2VFdmVudCgpXSBjb250ZXh0PSR7ci5jb250ZXh0fWApLHQuc3RhdGUucmVhZHk9ITAsdC5zdGF0ZS5jbGllbnRzQ29ubmVjdGVkPSEwLHQuc3RhdGUuYXV0aG9yaXplZD0hMCx0LnN0YXRlLnJlbGF5UGVyc2lzdGVuY2U9ITAsbnVsbD09PShlPXQuc3RhdGUuY29tbXVuaWNhdGlvbkxheWVyKXx8dm9pZCAwPT09ZXx8ZS5nZXRLZXlFeGNoYW5nZSgpLnNldEtleXNFeGNoYW5nZWQoITApLHQuZW1pdChSLktFWVNfRVhDSEFOR0VELHtrZXlzRXhjaGFuZ2VkOiEwLGlzT3JpZ2luYXRvcjohMH0pLHQuZW1pdChSLkFVVEhPUklaRUQpLHQuZW1pdChSLkNMSUVOVFNfUkVBRFkpLHQuZW1pdChSLkNIQU5ORUxfUEVSU0lTVEVOQ0UpO3RyeXtyLmNoYW5uZWxDb25maWc9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHIuY2hhbm5lbENvbmZpZykse2xvY2FsS2V5Om51bGw9PT0obj1yLmNvbW11bmljYXRpb25MYXllcil8fHZvaWQgMD09PW4/dm9pZCAwOm4uZ2V0S2V5RXhjaGFuZ2UoKS5nZXRLZXlJbmZvKCkuZWNpZXMucHJpdmF0ZSxvdGhlcktleTpudWxsPT09KGk9ci5jb21tdW5pY2F0aW9uTGF5ZXIpfHx2b2lkIDA9PT1pP3ZvaWQgMDppLmdldEtleUV4Y2hhbmdlKCkuZ2V0T3RoZXJQdWJsaWNLZXkoKSxjaGFubmVsSWQ6bnVsbCE9PShvPXIuY2hhbm5lbElkKSYmdm9pZCAwIT09bz9vOlwiXCIsdmFsaWRVbnRpbDpudWxsIT09KGM9bnVsbD09PShhPXIuY2hhbm5lbENvbmZpZyl8fHZvaWQgMD09PWE/dm9pZCAwOmEudmFsaWRVbnRpbCkmJnZvaWQgMCE9PWM/YzpJLHJlbGF5UGVyc2lzdGVuY2U6ITB9KSx5aWVsZCBudWxsPT09KHM9ci5zdG9yYWdlTWFuYWdlcil8fHZvaWQgMD09PXM/dm9pZCAwOnMucGVyc2lzdENoYW5uZWxDb25maWcoci5jaGFubmVsQ29uZmlnKX1jYXRjaChlKXt9fSkpfWZ1bmN0aW9uIHJlKHtjb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlOmUsb3RoZXJQdWJsaWNLZXk6dCxyZWNvbm5lY3Q6bixlY2llczppLGNvbW11bmljYXRpb25TZXJ2ZXJVcmw6bz1rLGluc3RhbmNlOmF9KXt2YXIgYyxzLHIsbCxkLHUsaCxtLEUsdix5O2NvbnN0e3N0YXRlOlN9PWE7aWYoZy5SZW1vdGVDb21tdW5pY2F0aW9uKFwiW2luaXRDb21tdW5pY2F0aW9uTGF5ZXIoKV0gXCIsSlNPTi5zdHJpbmdpZnkoUyxudWxsLDIpKSxlIT09Qi5TT0NLRVQpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb21tdW5pY2F0aW9uIHByb3RvY29sXCIpO1MuY29tbXVuaWNhdGlvbkxheWVyPW5ldyBKKHtjb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlOmUsb3RoZXJQdWJsaWNLZXk6dCxyZWNvbm5lY3Q6bix0cmFuc3BvcnRzOlMudHJhbnNwb3J0cyxjb21tdW5pY2F0aW9uU2VydmVyVXJsOm8sY29udGV4dDpTLmNvbnRleHQsZWNpZXM6aSxsb2dnaW5nOlMubG9nZ2luZyxyZW1vdGU6YX0pO2xldCBDPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuVVJMfHxcIlwiLHA9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGRvY3VtZW50JiZkb2N1bWVudC50aXRsZXx8XCJcIjsobnVsbD09PShjPVMuZGFwcE1ldGFkYXRhKXx8dm9pZCAwPT09Yz92b2lkIDA6Yy51cmwpJiYoQz1TLmRhcHBNZXRhZGF0YS51cmwpLChudWxsPT09KHM9Uy5kYXBwTWV0YWRhdGEpfHx2b2lkIDA9PT1zP3ZvaWQgMDpzLm5hbWUpJiYocD1TLmRhcHBNZXRhZGF0YS5uYW1lKTtjb25zdCBfPW51bGwhPT0odT1udWxsIT09KGw9bnVsbD09PShyPVMuZGFwcE1ldGFkYXRhKXx8dm9pZCAwPT09cj92b2lkIDA6ci5uYW1lKSYmdm9pZCAwIT09bD9sOm51bGw9PT0oZD1TLmRhcHBNZXRhZGF0YSl8fHZvaWQgMD09PWQ/dm9pZCAwOmQudXJsKSYmdm9pZCAwIT09dT91OlwiTi9BXCIsST1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ2b2lkIDAhPT13aW5kb3cubG9jYXRpb24mJm51bGwhPT0oaD13aW5kb3cubG9jYXRpb24uaG9zdG5hbWUpJiZ2b2lkIDAhPT1oP2g6XyxLPXt1cmw6Qyx0aXRsZTpwLHNvdXJjZTpudWxsPT09KG09Uy5kYXBwTWV0YWRhdGEpfHx2b2lkIDA9PT1tP3ZvaWQgMDptLnNvdXJjZSxkYXBwSWQ6SSxhbm9uSWQ6Uy5hbm9uSWQsaWNvbjoobnVsbD09PShFPVMuZGFwcE1ldGFkYXRhKXx8dm9pZCAwPT09RT92b2lkIDA6RS5pY29uVXJsKXx8KG51bGw9PT0odj1TLmRhcHBNZXRhZGF0YSl8fHZvaWQgMD09PXY/dm9pZCAwOnYuYmFzZTY0SWNvbikscGxhdGZvcm06Uy5wbGF0Zm9ybVR5cGUsYXBpVmVyc2lvbjpmLnZlcnNpb24sY29ubmVjdG9yOm51bGw9PT0oeT1TLmRhcHBNZXRhZGF0YSl8fHZvaWQgMD09PXk/dm9pZCAwOnkuY29ubmVjdG9yfTtTLm9yaWdpbmF0b3JJbmZvPUs7Y29uc3QgeD17W1IuQVVUSE9SSVpFRF06WChhKSxbUi5NRVNTQUdFXTpvZShhKSxbUi5DSEFOTkVMX1BFUlNJU1RFTkNFXTpzZShhKSxbUi5DTElFTlRTX0NPTk5FQ1RFRF06ZWUoYSxlKSxbUi5LRVlTX0VYQ0hBTkdFRF06aWUoYSxlKSxbUi5TT0NLRVRfRElTQ09OTkVDVEVEXTpjZShhKSxbUi5TT0NLRVRfUkVDT05ORUNUXTphZShhKSxbUi5DTElFTlRTX0RJU0NPTk5FQ1RFRF06dGUoYSksW1IuS0VZX0lORk9dOigpPT57fSxbUi5DSEFOTkVMX0NSRUFURURdOnEoYSksW1IuQ0xJRU5UU19XQUlUSU5HXTpuZShhKSxbUi5SUENfVVBEQVRFXTplPT57YS5lbWl0KFIuUlBDX1VQREFURSxlKX19O2Zvcihjb25zdFtlLHRdb2YgT2JqZWN0LmVudHJpZXMoeCkpdHJ5e1MuY29tbXVuaWNhdGlvbkxheWVyLm9uKGUsdCl9Y2F0Y2goZSl7fX1mdW5jdGlvbiBsZSh0KXtyZXR1cm4gZSh0aGlzLGFyZ3VtZW50cyx2b2lkIDAsKGZ1bmN0aW9uKih7b3B0aW9uczplLGluc3RhbmNlOnR9KXtjb25zdHtzdGF0ZTpufT10O3JldHVybiBnLlJlbW90ZUNvbW11bmljYXRpb24oYFtSZW1vdGVDb21tdW5pY2F0aW9uOiBkaXNjb25uZWN0KCldIGNoYW5uZWw9JHtuLmNoYW5uZWxJZH1gLGUpLG5ldyBQcm9taXNlKCgoaSxvKT0+e3ZhciBhLGMscyxyLGQsdTsobnVsbD09ZT92b2lkIDA6ZS50ZXJtaW5hdGUpPyh0LnN0YXRlLnJlYWR5JiZDKHtpZDpudWxsIT09KGE9dC5zdGF0ZS5jaGFubmVsSWQpJiZ2b2lkIDAhPT1hP2E6XCJcIixldmVudDpMLlRFUk1JTkFURUR9LHQuc3RhdGUuY29tbXVuaWNhdGlvblNlcnZlclVybCkuY2F0Y2goKGU9Pnt9KSksbi5yZWFkeT0hMSxuLnBhdXNlZD0hMSxudWxsPT09KGM9bi5zdG9yYWdlTWFuYWdlcil8fHZvaWQgMD09PWN8fGMudGVybWluYXRlKG51bGwhPT0ocz1uLmNoYW5uZWxJZCkmJnZvaWQgMCE9PXM/czpcIlwiKSx0LnN0YXRlLnRlcm1pbmF0ZWQ9ITAsZS5zZW5kTWVzc2FnZT8obnVsbD09PShyPW4uY29tbXVuaWNhdGlvbkxheWVyKXx8dm9pZCAwPT09cj92b2lkIDA6ci5nZXRLZXlJbmZvKCkua2V5c0V4Y2hhbmdlZCkmJnQuc3RhdGUuY29tbXVuaWNhdGlvbkxheWVyJiZZKHQuc3RhdGUuY29tbXVuaWNhdGlvbkxheWVyLHt0eXBlOmIuVEVSTUlOQVRFfSkudGhlbigoKCk9PntpKCEwKX0pKS5jYXRjaCgoZT0+e28oZSl9KSk6aSghMCksbi5hdXRob3JpemVkPSExLG4ucmVsYXlQZXJzaXN0ZW5jZT0hMSxuLmNoYW5uZWxJZD1sKCksZS5jaGFubmVsSWQ9bi5jaGFubmVsSWQsbi5jaGFubmVsQ29uZmlnPXZvaWQgMCxuLm9yaWdpbmF0b3JDb25uZWN0U3RhcnRlZD0hMSxudWxsPT09KGQ9bi5jb21tdW5pY2F0aW9uTGF5ZXIpfHx2b2lkIDA9PT1kfHxkLmRpc2Nvbm5lY3QoZSksdC5zZXRDb25uZWN0aW9uU3RhdHVzKE8uVEVSTUlOQVRFRCkpOihudWxsPT09KHU9bi5jb21tdW5pY2F0aW9uTGF5ZXIpfHx2b2lkIDA9PT11fHx1LmRpc2Nvbm5lY3QoZSksdC5zZXRDb25uZWN0aW9uU3RhdHVzKE8uRElTQ09OTkVDVEVEKSxpKCEwKSl9KSl9KSl9IWZ1bmN0aW9uKGUpe2UuU09DS0VUPVwic29ja2V0XCJ9KEJ8fChCPXt9KSksZnVuY3Rpb24oZSl7ZS5Ob25Ccm93c2VyPVwibm9kZWpzXCIsZS5NZXRhTWFza01vYmlsZVdlYnZpZXc9XCJpbi1hcHAtYnJvd3NlclwiLGUuRGVza3RvcFdlYj1cIndlYi1kZXNrdG9wXCIsZS5Nb2JpbGVXZWI9XCJ3ZWItbW9iaWxlXCIsZS5SZWFjdE5hdGl2ZT1cInJlYWN0LW5hdGl2ZVwifShafHwoWj17fSkpO2NsYXNzIGRlIGV4dGVuZHMgc3tjb25zdHJ1Y3RvcihlKXtzdXBlcigpLHRoaXMuc3RhdGU9e3JlYWR5OiExLGFub25JZDpcIlwiLGF1dGhvcml6ZWQ6ITEsaXNPcmlnaW5hdG9yOiExLHRlcm1pbmF0ZWQ6ITEscHJvdG9jb2xWZXJzaW9uOjEscGF1c2VkOiExLGRlZXBsaW5rUHJvdG9jb2xBdmFpbGFibGU6ITEscGxhdGZvcm1UeXBlOlwibWV0YW1hc2stbW9iaWxlXCIsYW5hbHl0aWNzOiExLHJlY29ubmVjdGlvbjohMSxvcmlnaW5hdG9ySW5mb1NlbnQ6ITEsY29tbXVuaWNhdGlvblNlcnZlclVybDprLGNvbnRleHQ6XCJcIixwZXJzaXN0OiExLGNsaWVudHNDb25uZWN0ZWQ6ITEsc2Vzc2lvbkR1cmF0aW9uOkksb3JpZ2luYXRvckNvbm5lY3RTdGFydGVkOiExLGRlYnVnOiExLF9jb25uZWN0aW9uU3RhdHVzOk8uRElTQ09OTkVDVEVEfSx0aGlzLl9vcHRpb25zPWU7Y29uc3R7YW5vbklkOnQscGxhdGZvcm1UeXBlOmksY29tbXVuaWNhdGlvbkxheWVyUHJlZmVyZW5jZTpvLG90aGVyUHVibGljS2V5OmEscmVjb25uZWN0OmMsd2FsbGV0SW5mbzpzLGRhcHBNZXRhZGF0YTpyLHByb3RvY29sVmVyc2lvbjpsLHRyYW5zcG9ydHM6ZCxjb250ZXh0OnUscmVsYXlQZXJzaXN0ZW5jZTpoLGVjaWVzOm0sYW5hbHl0aWNzOkU9ITEsc3RvcmFnZTp2LHNka1ZlcnNpb246eSxjb21tdW5pY2F0aW9uU2VydmVyVXJsOlM9ayxsb2dnaW5nOkMsYXV0b0Nvbm5lY3Q6cD17dGltZW91dDpLfX09ZTt0aGlzLnN0YXRlLmFub25JZD10LHRoaXMuc3RhdGUub3RoZXJQdWJsaWNLZXk9YSx0aGlzLnN0YXRlLmRhcHBNZXRhZGF0YT1yLHRoaXMuc3RhdGUud2FsbGV0SW5mbz1zLHRoaXMuc3RhdGUudHJhbnNwb3J0cz1kLHRoaXMuc3RhdGUucGxhdGZvcm1UeXBlPWksdGhpcy5zdGF0ZS5hbmFseXRpY3M9RSx0aGlzLnN0YXRlLnByb3RvY29sVmVyc2lvbj1udWxsIT1sP2w6MSx0aGlzLnN0YXRlLmlzT3JpZ2luYXRvcj0hYSx0aGlzLnN0YXRlLnJlbGF5UGVyc2lzdGVuY2U9aCx0aGlzLnN0YXRlLmNvbW11bmljYXRpb25TZXJ2ZXJVcmw9Uyx0aGlzLnN0YXRlLmNvbnRleHQ9dSx0aGlzLnN0YXRlLnRlcm1pbmF0ZWQ9ITEsdGhpcy5zdGF0ZS5zZGtWZXJzaW9uPXksdGhpcy5zZXRNYXhMaXN0ZW5lcnMoNTApLHRoaXMuc2V0Q29ubmVjdGlvblN0YXR1cyhPLkRJU0NPTk5FQ1RFRCksKG51bGw9PXY/dm9pZCAwOnYuZHVyYXRpb24pJiYodGhpcy5zdGF0ZS5zZXNzaW9uRHVyYXRpb249SSksdGhpcy5zdGF0ZS5zdG9yYWdlT3B0aW9ucz12LHRoaXMuc3RhdGUuYXV0b0Nvbm5lY3RPcHRpb25zPXAsdGhpcy5zdGF0ZS5kZWJ1Zz0hMD09PShudWxsPT1DP3ZvaWQgMDpDLnJlbW90ZUxheWVyKSwhMD09PShudWxsPT1DP3ZvaWQgMDpDLnJlbW90ZUxheWVyKSYmbi5lbmFibGUoXCJSZW1vdGVDb21tdW5pY2F0aW9uOkxheWVyXCIpLCEwPT09KG51bGw9PUM/dm9pZCAwOkMuc2VydmljZUxheWVyKSYmbi5lbmFibGUoXCJTb2NrZXRTZXJ2aWNlOkxheWVyXCIpLCEwPT09KG51bGw9PUM/dm9pZCAwOkMuZWNpZXNMYXllcikmJm4uZW5hYmxlKFwiRUNJRVM6TGF5ZXJcIiksITA9PT0obnVsbD09Qz92b2lkIDA6Qy5rZXlFeGNoYW5nZUxheWVyKSYmbi5lbmFibGUoXCJLZXlFeGNoYW5nZTpMYXllclwiKSx0aGlzLnN0YXRlLmxvZ2dpbmc9QywobnVsbD09dj92b2lkIDA6di5zdG9yYWdlTWFuYWdlcikmJih0aGlzLnN0YXRlLnN0b3JhZ2VNYW5hZ2VyPXYuc3RvcmFnZU1hbmFnZXIpLGcuUmVtb3RlQ29tbXVuaWNhdGlvbihgW1JlbW90ZUNvbW11bmljYXRpb246IGNvbnN0cnVjdG9yKCldIHByb3RvY29sVmVyc2lvbj0ke2x9IHJlbGF5UGVyc2lzdGVuY2U9JHtofSBpc09yaWdpbmF0b3I9JHt0aGlzLnN0YXRlLmlzT3JpZ2luYXRvcn0gY29tbXVuaWNhdGlvbkxheWVyUHJlZmVyZW5jZT0ke299IG90aGVyUHVibGljS2V5PSR7YX0gcmVjb25uZWN0PSR7Y31gKSx0aGlzLnN0YXRlLmlzT3JpZ2luYXRvcnx8cmUoe2NvbW11bmljYXRpb25MYXllclByZWZlcmVuY2U6byxvdGhlclB1YmxpY0tleTphLHJlY29ubmVjdDpjLGVjaWVzOm0sY29tbXVuaWNhdGlvblNlcnZlclVybDpTLGluc3RhbmNlOnRoaXN9KSx0aGlzLmVtaXRTZXJ2aWNlU3RhdHVzRXZlbnQoe2NvbnRleHQ6XCJjb25zdHJ1Y3RvclwifSl9aW5pdEZyb21EYXBwU3RvcmFnZSgpe3JldHVybiBlKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7dmFyIGU7aWYodGhpcy5zdGF0ZS5zdG9yYWdlTWFuYWdlcil7Y29uc3QgdD15aWVsZCB0aGlzLnN0YXRlLnN0b3JhZ2VNYW5hZ2VyLmdldFBlcnNpc3RlZENoYW5uZWxDb25maWcoe30pO3QmJih0aGlzLnN0YXRlLmNoYW5uZWxDb25maWc9dCx0aGlzLnN0YXRlLmNoYW5uZWxJZD10LmNoYW5uZWxJZCx0aGlzLnN0YXRlLmRlZXBsaW5rUHJvdG9jb2xBdmFpbGFibGU9bnVsbCE9PShlPXQuZGVlcGxpbmtQcm90b2NvbEF2YWlsYWJsZSkmJnZvaWQgMCE9PWUmJmUsdC5yZWxheVBlcnNpc3RlbmNlJiYodGhpcy5zdGF0ZS5hdXRob3JpemVkPSEwLHRoaXMuc3RhdGUucmVhZHk9ITAsdGhpcy5zZXRDb25uZWN0aW9uU3RhdHVzKE8uTElOS0VEKSx5aWVsZCB0aGlzLmNvbm5lY3RUb0NoYW5uZWwoe2NoYW5uZWxJZDp0LmNoYW5uZWxJZH0pKSl9cmUoe2NvbW11bmljYXRpb25MYXllclByZWZlcmVuY2U6Qi5TT0NLRVQsb3RoZXJQdWJsaWNLZXk6dGhpcy5zdGF0ZS5vdGhlclB1YmxpY0tleSxyZWNvbm5lY3Q6dGhpcy5fb3B0aW9ucy5yZWNvbm5lY3QsZWNpZXM6dGhpcy5fb3B0aW9ucy5lY2llcyxjb21tdW5pY2F0aW9uU2VydmVyVXJsOnRoaXMuc3RhdGUuY29tbXVuaWNhdGlvblNlcnZlclVybCxpbnN0YW5jZTp0aGlzfSl9KSl9b3JpZ2luYXRvclNlc3Npb25Db25uZWN0KCl7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtyZXR1cm4geWllbGQgZnVuY3Rpb24odCl7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXt2YXIgZTtjb25zdHtzdGF0ZTpufT10O2lmKCFuLnN0b3JhZ2VNYW5hZ2VyKXJldHVybiB2b2lkIGcuUmVtb3RlQ29tbXVuaWNhdGlvbihcIltSZW1vdGVDb21tdW5pY2F0aW9uOiBvcmlnaW5hdG9yU2Vzc2lvbkNvbm5lY3QoKV0gbm8gc3RvcmFnZSBtYW5hZ2VyIGRlZmluZWQgLSBza2lwXCIpO2NvbnN0IGk9eWllbGQgbi5zdG9yYWdlTWFuYWdlci5nZXRQZXJzaXN0ZWRDaGFubmVsQ29uZmlnKHt9KTtpZihnLlJlbW90ZUNvbW11bmljYXRpb24oYFtSZW1vdGVDb21tdW5pY2F0aW9uOiBvcmlnaW5hdG9yU2Vzc2lvbkNvbm5lY3QoKV0gYXV0b1N0YXJ0ZWQ9JHtuLm9yaWdpbmF0b3JDb25uZWN0U3RhcnRlZH0gY2hhbm5lbENvbmZpZ2AsaSksbnVsbD09PShlPW4uY29tbXVuaWNhdGlvbkxheWVyKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5pc0Nvbm5lY3RlZCgpKXJldHVybiBnLlJlbW90ZUNvbW11bmljYXRpb24oXCJbUmVtb3RlQ29tbXVuaWNhdGlvbjogb3JpZ2luYXRvclNlc3Npb25Db25uZWN0KCldIHNvY2tldCBhbHJlYWR5IGNvbm5lY3RlZCAtIHNraXBcIiksaTtpZihpKXtpZihpLnZhbGlkVW50aWw+RGF0ZS5ub3coKSlyZXR1cm4gbi5jaGFubmVsQ29uZmlnPWksbi5vcmlnaW5hdG9yQ29ubmVjdFN0YXJ0ZWQ9ITAsbi5jaGFubmVsSWQ9bnVsbD09aT92b2lkIDA6aS5jaGFubmVsSWQsbi5yZWNvbm5lY3Rpb249ITAsaTtnLlJlbW90ZUNvbW11bmljYXRpb24oXCJbUmVtb3RlQ29tbXVuaWNhdGlvbjogYXV0b0Nvbm5lY3QoKV0gU2Vzc2lvbiBoYXMgZXhwaXJlZFwiKX1uLm9yaWdpbmF0b3JDb25uZWN0U3RhcnRlZD0hMX0pKX0odGhpcyl9KSl9Z2VuZXJhdGVDaGFubmVsSWRDb25uZWN0KCl7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXt2YXIgZSxuLGksbyxhLGM7aWYoIXQuY29tbXVuaWNhdGlvbkxheWVyKXRocm93IG5ldyBFcnJvcihcImNvbW11bmljYXRpb24gbGF5ZXIgbm90IGluaXRpYWxpemVkXCIpO2lmKHQucmVhZHkpdGhyb3cgbmV3IEVycm9yKFwiQ2hhbm5lbCBhbHJlYWR5IGNvbm5lY3RlZFwiKTtpZih0LmNoYW5uZWxJZCYmKG51bGw9PT0oZT10LmNvbW11bmljYXRpb25MYXllcil8fHZvaWQgMD09PWU/dm9pZCAwOmUuaXNDb25uZWN0ZWQoKSkpcmV0dXJuIHQuY2hhbm5lbENvbmZpZz1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdC5jaGFubmVsQ29uZmlnKSx7Y2hhbm5lbElkOnQuY2hhbm5lbElkLHZhbGlkVW50aWw6RGF0ZS5ub3coKSt0LnNlc3Npb25EdXJhdGlvbn0pLG51bGw9PT0obj10LnN0b3JhZ2VNYW5hZ2VyKXx8dm9pZCAwPT09bnx8bi5wZXJzaXN0Q2hhbm5lbENvbmZpZyh0LmNoYW5uZWxDb25maWcpLHtjaGFubmVsSWQ6dC5jaGFubmVsSWQscHJpdktleTpudWxsPT09KG89bnVsbD09PShpPXQuY29tbXVuaWNhdGlvbkxheWVyKXx8dm9pZCAwPT09aT92b2lkIDA6aS5nZXRLZXlJbmZvKCkpfHx2b2lkIDA9PT1vP3ZvaWQgMDpvLmVjaWVzLnByaXZhdGUscHViS2V5Om51bGw9PT0oYz1udWxsPT09KGE9dC5jb21tdW5pY2F0aW9uTGF5ZXIpfHx2b2lkIDA9PT1hP3ZvaWQgMDphLmdldEtleUluZm8oKSl8fHZvaWQgMD09PWM/dm9pZCAwOmMuZWNpZXMucHVibGljfTtnLlJlbW90ZUNvbW11bmljYXRpb24oXCJbUmVtb3RlQ29tbXVuaWNhdGlvbjogZ2VuZXJhdGVDaGFubmVsSWQoKV1cIik7Y29uc3Qgcz15aWVsZCB0LmNvbW11bmljYXRpb25MYXllci5jcmVhdGVDaGFubmVsKCk7Zy5SZW1vdGVDb21tdW5pY2F0aW9uKFwiW1JlbW90ZUNvbW11bmljYXRpb246IGdlbmVyYXRlQ2hhbm5lbElkKCldIGNoYW5uZWwgY3JlYXRlZFwiLHMpO2NvbnN0IHI9T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHQuY2hhbm5lbENvbmZpZykse2NoYW5uZWxJZDpzLmNoYW5uZWxJZCxsb2NhbEtleTpzLnByaXZLZXksdmFsaWRVbnRpbDpEYXRlLm5vdygpK3Quc2Vzc2lvbkR1cmF0aW9ufSk7cmV0dXJuIHQuY2hhbm5lbElkPXMuY2hhbm5lbElkLHQuY2hhbm5lbENvbmZpZz1yLHtjaGFubmVsSWQ6dC5jaGFubmVsSWQscHViS2V5OnMucHViS2V5LHByaXZLZXk6cy5wcml2S2V5fX0pKX0odGhpcy5zdGF0ZSl9KSl9Y2xlYW4oKXtyZXR1cm4gVCh0aGlzLnN0YXRlKX1jb25uZWN0VG9DaGFubmVsKHtjaGFubmVsSWQ6dCx3aXRoS2V5RXhjaGFuZ2U6bixhdXRob3JpemVkOml9KXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIGUodGhpcyxhcmd1bWVudHMsdm9pZCAwLChmdW5jdGlvbiooe2NoYW5uZWxJZDplLHdpdGhLZXlFeGNoYW5nZTp0LGF1dGhvcml6ZWQ6bixzdGF0ZTppfSl7dmFyIG8sYSxjO2lmKCFyKGUpKXRocm93IGcuUmVtb3RlQ29tbXVuaWNhdGlvbihgW1JlbW90ZUNvbW11bmljYXRpb246IGNvbm5lY3RUb0NoYW5uZWwoKV0gY29udGV4dD0ke2kuY29udGV4dH0gaW52YWxpZCBjaGFubmVsIGNoYW5uZWxJZD0ke2V9YCksbmV3IEVycm9yKGBJbnZhbGlkIGNoYW5uZWwgJHtlfWApO2lmKGcuUmVtb3RlQ29tbXVuaWNhdGlvbihgW1JlbW90ZUNvbW11bmljYXRpb246IGNvbm5lY3RUb0NoYW5uZWwoKV0gY29udGV4dD0ke2kuY29udGV4dH0gY2hhbm5lbElkPSR7ZX0gd2l0aEtleUV4Y2hhbmdlPSR7dH1gKSxudWxsPT09KG89aS5jb21tdW5pY2F0aW9uTGF5ZXIpfHx2b2lkIDA9PT1vP3ZvaWQgMDpvLmlzQ29ubmVjdGVkKCkpcmV0dXJuIHZvaWQgZy5SZW1vdGVDb21tdW5pY2F0aW9uKGBbUmVtb3RlQ29tbXVuaWNhdGlvbjogY29ubmVjdFRvQ2hhbm5lbCgpXSBjb250ZXh0PSR7aS5jb250ZXh0fSBhbHJlYWR5IGNvbm5lY3RlZCAtIGludGVycnVwdCBjb25uZWN0aW9uLmApO2kuY2hhbm5lbElkPWUseWllbGQgbnVsbD09PShhPWkuY29tbXVuaWNhdGlvbkxheWVyKXx8dm9pZCAwPT09YT92b2lkIDA6YS5jb25uZWN0VG9DaGFubmVsKHtjaGFubmVsSWQ6ZSxhdXRob3JpemVkOm4sd2l0aEtleUV4Y2hhbmdlOnR9KTtjb25zdCBzPU9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxpLmNoYW5uZWxDb25maWcpLHtjaGFubmVsSWQ6ZSx2YWxpZFVudGlsOkRhdGUubm93KCkraS5zZXNzaW9uRHVyYXRpb259KTtpLmNoYW5uZWxDb25maWc9cyxudWxsPT09KGM9aS5zdG9yYWdlTWFuYWdlcil8fHZvaWQgMD09PWN8fGMucGVyc2lzdENoYW5uZWxDb25maWcocyl9KSl9KHtjaGFubmVsSWQ6dCxhdXRob3JpemVkOmksd2l0aEtleUV4Y2hhbmdlOm4sc3RhdGU6dGhpcy5zdGF0ZX0pfXNlbmRNZXNzYWdlKHQpe3JldHVybiBlKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7Y29uc3Qgbj10aGlzLnN0YXRlLmlzT3JpZ2luYXRvciYmdC5tZXRob2QmJk4odC5tZXRob2QpO24mJmMudHJhY2soXCJzZGtfYWN0aW9uX3JlcXVlc3RlZFwiLHthY3Rpb246dC5tZXRob2R9KTt0cnl7cmV0dXJuIHlpZWxkIGZ1bmN0aW9uKHQsbil7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXt2YXIgaSxvO2NvbnN0e3N0YXRlOmF9PXQ7Zy5SZW1vdGVDb21tdW5pY2F0aW9uKGBbUmVtb3RlQ29tbXVuaWNhdGlvbjogc2VuZE1lc3NhZ2UoKV0gY29udGV4dD0ke2EuY29udGV4dH0gcGF1c2VkPSR7YS5wYXVzZWR9IHJlYWR5PSR7YS5yZWFkeX0gcmVsYXlQZXJzaXN0ZW5jZT0ke2EucmVsYXlQZXJzaXN0ZW5jZX0gYXV0aG9yaXplZD0ke2EuYXV0aG9yaXplZH0gc29ja2V0PSR7bnVsbD09PShpPWEuY29tbXVuaWNhdGlvbkxheWVyKXx8dm9pZCAwPT09aT92b2lkIDA6aS5pc0Nvbm5lY3RlZCgpfSBjbGllbnRzQ29ubmVjdGVkPSR7YS5jbGllbnRzQ29ubmVjdGVkfSBzdGF0dXM9JHthLl9jb25uZWN0aW9uU3RhdHVzfWAsbiksYS5yZWxheVBlcnNpc3RlbmNlfHxhLnJlYWR5JiYobnVsbD09PShvPWEuY29tbXVuaWNhdGlvbkxheWVyKXx8dm9pZCAwPT09bz92b2lkIDA6by5pc0Nvbm5lY3RlZCgpKSYmYS5jbGllbnRzQ29ubmVjdGVkfHwoZy5SZW1vdGVDb21tdW5pY2F0aW9uKGBbUmVtb3RlQ29tbXVuaWNhdGlvbjogc2VuZE1lc3NhZ2UoKV0gY29udGV4dD0ke2EuY29udGV4dH0gIFNLSVAgbWVzc2FnZSB3YWl0aW5nIGZvciBNTSBtb2JpbGUgcmVhZGluZXNzLmApLHlpZWxkIG5ldyBQcm9taXNlKChlPT57dC5vbmNlKFIuQ0xJRU5UU19SRUFEWSxlKX0pKSxnLlJlbW90ZUNvbW11bmljYXRpb24oYFtSZW1vdGVDb21tdW5pY2F0aW9uOiBzZW5kTWVzc2FnZSgpXSBjb250ZXh0PSR7YS5jb250ZXh0fSAgQUZURVIgU0tJUCAvIFJFQURZIC0tIHNlbmRpbmcgcGVuZGluZyBtZXNzYWdlYCkpO3RyeXtjb25zdCBpPXlpZWxkIGZ1bmN0aW9uKHQsbil7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtyZXR1cm4gbmV3IFByb21pc2UoKGU9Pnt2YXIgaTtjb25zdHtzdGF0ZTpvfT10O2cuUmVtb3RlQ29tbXVuaWNhdGlvbihgW1JlbW90ZUNvbW11bmljYXRpb246IGhhbmRsZUF1dGhvcml6YXRpb24oKV0gY29udGV4dD0ke28uY29udGV4dH0gcmVhZHk9JHtvLnJlYWR5fSBhdXRob3JpemVkPSR7by5hdXRob3JpemVkfSBtZXRob2Q9JHtuLm1ldGhvZH1gKSwhby5pc09yaWdpbmF0b3J8fG8uYXV0aG9yaXplZHx8by5yZWxheVBlcnNpc3RlbmNlP251bGw9PT0oaT1vLmNvbW11bmljYXRpb25MYXllcil8fHZvaWQgMD09PWl8fGkuc2VuZE1lc3NhZ2UobikudGhlbigodD0+e2UodCl9KSkuY2F0Y2goKHQ9PntlKCExKX0pKTp0Lm9uY2UoUi5BVVRIT1JJWkVELCgoKT0+e3ZhciB0O2cuUmVtb3RlQ29tbXVuaWNhdGlvbihgW1JlbW90ZUNvbW11bmljYXRpb246IGhhbmRsZUF1dGhvcml6YXRpb24oKV0gY29udGV4dD0ke28uY29udGV4dH0gIEFGVEVSIFNLSVAgLyBBVVRIT1JJWkVEIC0tIHNlbmRpbmcgcGVuZGluZyBtZXNzYWdlYCksbnVsbD09PSh0PW8uY29tbXVuaWNhdGlvbkxheWVyKXx8dm9pZCAwPT09dHx8dC5zZW5kTWVzc2FnZShuKS50aGVuKCh0PT57ZSh0KX0pKS5jYXRjaCgodD0+e2UoITEpfSkpfSkpfSkpfSkpfSh0LG4pO3JldHVybiBpfWNhdGNoKGUpe3Rocm93IGV9fSkpfSh0aGlzLHQpfWNhdGNoKGUpe3Rocm93IG4mJmMudHJhY2soXCJzZGtfYWN0aW9uX2ZhaWxlZFwiLHthY3Rpb246dC5tZXRob2R9KSxlfX0pKX10ZXN0U3RvcmFnZSgpe3JldHVybiBlKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBlKHRoaXMsdm9pZCAwLHZvaWQgMCwoZnVuY3Rpb24qKCl7dmFyIGU7Y29uc3Qgbj15aWVsZCBudWxsPT09KGU9dC5zdG9yYWdlTWFuYWdlcil8fHZvaWQgMD09PWU/dm9pZCAwOmUuZ2V0UGVyc2lzdGVkQ2hhbm5lbENvbmZpZygpO2cuUmVtb3RlQ29tbXVuaWNhdGlvbihcIltSZW1vdGVDb21tdW5pY2F0aW9uOiB0ZXN0U3RvcmFnZSgpXSByZXNcIixuKX0pKX0odGhpcy5zdGF0ZSl9KSl9aGFzRGVlcGxpbmtQcm90b2NvbCgpe3JldHVybiB0aGlzLnN0YXRlLmRlZXBsaW5rUHJvdG9jb2xBdmFpbGFibGV9Z2V0Q2hhbm5lbENvbmZpZygpe3JldHVybiB0aGlzLnN0YXRlLmNoYW5uZWxDb25maWd9aXNSZWFkeSgpe3JldHVybiB0aGlzLnN0YXRlLnJlYWR5fWlzQ29ubmVjdGVkKCl7dmFyIGU7cmV0dXJuIG51bGw9PT0oZT10aGlzLnN0YXRlLmNvbW11bmljYXRpb25MYXllcil8fHZvaWQgMD09PWU/dm9pZCAwOmUuaXNDb25uZWN0ZWQoKX1pc0F1dGhvcml6ZWQoKXtyZXR1cm4gdGhpcy5zdGF0ZS5hdXRob3JpemVkfWlzUGF1c2VkKCl7cmV0dXJuIHRoaXMuc3RhdGUucGF1c2VkfWdldENvbW11bmljYXRpb25MYXllcigpe3JldHVybiB0aGlzLnN0YXRlLmNvbW11bmljYXRpb25MYXllcn1waW5nKCl7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXt2YXIgZTtnLlJlbW90ZUNvbW11bmljYXRpb24oYFtSZW1vdGVDb21tdW5pY2F0aW9uOiBwaW5nKCldIGNoYW5uZWw9JHt0aGlzLnN0YXRlLmNoYW5uZWxJZH1gKSx5aWVsZCBudWxsPT09KGU9dGhpcy5zdGF0ZS5jb21tdW5pY2F0aW9uTGF5ZXIpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLnBpbmcoKX0pKX10ZXN0TG9nZ2VyKCl7Zy5SZW1vdGVDb21tdW5pY2F0aW9uKGB0ZXN0TG9nZ2VyKCkgY2hhbm5lbD0ke3RoaXMuc3RhdGUuY2hhbm5lbElkfWApLGcuU29ja2V0U2VydmljZShgdGVzdExvZ2dlcigpIGNoYW5uZWw9JHt0aGlzLnN0YXRlLmNoYW5uZWxJZH1gKSxnLkVjaWVzKGB0ZXN0TG9nZ2VyKCkgY2hhbm5lbD0ke3RoaXMuc3RhdGUuY2hhbm5lbElkfWApLGcuS2V5RXhjaGFuZ2UoYHRlc3RMb2dnZXIoKSBjaGFubmVsPSR7dGhpcy5zdGF0ZS5jaGFubmVsSWR9YCl9a2V5Q2hlY2soKXt2YXIgZTtnLlJlbW90ZUNvbW11bmljYXRpb24oYFtSZW1vdGVDb21tdW5pY2F0aW9uOiBrZXlDaGVjaygpXSBjaGFubmVsPSR7dGhpcy5zdGF0ZS5jaGFubmVsSWR9YCksbnVsbD09PShlPXRoaXMuc3RhdGUuY29tbXVuaWNhdGlvbkxheWVyKXx8dm9pZCAwPT09ZXx8ZS5rZXlDaGVjaygpfXNldENvbm5lY3Rpb25TdGF0dXMoZSl7dGhpcy5zdGF0ZS5fY29ubmVjdGlvblN0YXR1cyE9PWUmJih0aGlzLnN0YXRlLl9jb25uZWN0aW9uU3RhdHVzPWUsdGhpcy5lbWl0KFIuQ09OTkVDVElPTl9TVEFUVVMsZSksdGhpcy5lbWl0U2VydmljZVN0YXR1c0V2ZW50KHtjb250ZXh0Olwic2V0Q29ubmVjdGlvblN0YXR1c1wifSkpfWVtaXRTZXJ2aWNlU3RhdHVzRXZlbnQoZT17fSl7dGhpcy5lbWl0KFIuU0VSVklDRV9TVEFUVVMsdGhpcy5nZXRTZXJ2aWNlU3RhdHVzKCkpfWdldENvbm5lY3Rpb25TdGF0dXMoKXtyZXR1cm4gdGhpcy5zdGF0ZS5fY29ubmVjdGlvblN0YXR1c31nZXRTZXJ2aWNlU3RhdHVzKCl7cmV0dXJue29yaWdpbmF0b3JJbmZvOnRoaXMuc3RhdGUub3JpZ2luYXRvckluZm8sa2V5SW5mbzp0aGlzLmdldEtleUluZm8oKSxjb25uZWN0aW9uU3RhdHVzOnRoaXMuc3RhdGUuX2Nvbm5lY3Rpb25TdGF0dXMsY2hhbm5lbENvbmZpZzp0aGlzLnN0YXRlLmNoYW5uZWxDb25maWcsY2hhbm5lbElkOnRoaXMuc3RhdGUuY2hhbm5lbElkfX1nZXRLZXlJbmZvKCl7dmFyIGU7cmV0dXJuIG51bGw9PT0oZT10aGlzLnN0YXRlLmNvbW11bmljYXRpb25MYXllcil8fHZvaWQgMD09PWU/dm9pZCAwOmUuZ2V0S2V5SW5mbygpfXJlc2V0S2V5cygpe3ZhciBlO251bGw9PT0oZT10aGlzLnN0YXRlLmNvbW11bmljYXRpb25MYXllcil8fHZvaWQgMD09PWV8fGUucmVzZXRLZXlzKCl9c2V0T3RoZXJQdWJsaWNLZXkoZSl7dmFyIHQ7Y29uc3Qgbj1udWxsPT09KHQ9dGhpcy5zdGF0ZS5jb21tdW5pY2F0aW9uTGF5ZXIpfHx2b2lkIDA9PT10P3ZvaWQgMDp0LmdldEtleUV4Y2hhbmdlKCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiS2V5RXhjaGFuZ2UgaXMgbm90IGluaXRpYWxpemVkLlwiKTtuLmdldE90aGVyUHVibGljS2V5KCkhPT1lJiZuLnNldE90aGVyUHVibGljS2V5KGUpfXBhdXNlKCl7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXt2YXIgZTtnLlJlbW90ZUNvbW11bmljYXRpb24oYFtSZW1vdGVDb21tdW5pY2F0aW9uOiBwYXVzZSgpXSBjaGFubmVsPSR7dGhpcy5zdGF0ZS5jaGFubmVsSWR9YCkseWllbGQgbnVsbD09PShlPXRoaXMuc3RhdGUuY29tbXVuaWNhdGlvbkxheWVyKXx8dm9pZCAwPT09ZT92b2lkIDA6ZS5wYXVzZSgpLHRoaXMuc2V0Q29ubmVjdGlvblN0YXR1cyhPLlBBVVNFRCl9KSl9Z2V0VmVyc2lvbigpe3JldHVybiBmLnZlcnNpb259aGFzUmVsYXlQZXJzaXN0ZW5jZSgpe3ZhciBlO3JldHVybiBudWxsIT09KGU9dGhpcy5zdGF0ZS5yZWxheVBlcnNpc3RlbmNlKSYmdm9pZCAwIT09ZSYmZX1yZXN1bWUoKXtyZXR1cm4gZSh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4gZSh0aGlzLHZvaWQgMCx2b2lkIDAsKGZ1bmN0aW9uKigpe3ZhciBlO2NvbnN0e3N0YXRlOm59PXQ7Zy5SZW1vdGVDb21tdW5pY2F0aW9uKGBbUmVtb3RlQ29tbXVuaWNhdGlvbjogcmVzdW1lKCldIGNoYW5uZWw9JHtuLmNoYW5uZWxJZH1gKSx5aWVsZCBudWxsPT09KGU9bi5jb21tdW5pY2F0aW9uTGF5ZXIpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLnJlc3VtZSgpLHQuc2V0Q29ubmVjdGlvblN0YXR1cyhPLkxJTktFRCl9KSl9KHRoaXMpfSkpfWVuY3J5cHQoZSl7dmFyIHQsbixpO2NvbnN0IG89bnVsbD09PSh0PXRoaXMuc3RhdGUuY29tbXVuaWNhdGlvbkxheWVyKXx8dm9pZCAwPT09dD92b2lkIDA6dC5nZXRLZXlFeGNoYW5nZSgpLGE9bnVsbD09bz92b2lkIDA6by5nZXRPdGhlclB1YmxpY0tleSgpO2lmKCFhKXRocm93IG5ldyBFcnJvcihcIktleUV4Y2hhbmdlIG5vdCBjb21wbGV0ZWRcIik7cmV0dXJuIG51bGw9PT0oaT1udWxsPT09KG49dGhpcy5zdGF0ZS5jb21tdW5pY2F0aW9uTGF5ZXIpfHx2b2lkIDA9PT1uP3ZvaWQgMDpuLnN0YXRlLmVjaWVzSW5zdGFuY2UpfHx2b2lkIDA9PT1pP3ZvaWQgMDppLmVuY3J5cHQoZSxhKX1kZWNyeXB0KGUpe3ZhciB0LG4saTtpZighKG51bGw9PT0odD10aGlzLnN0YXRlLmNvbW11bmljYXRpb25MYXllcil8fHZvaWQgMD09PXQ/dm9pZCAwOnQuc3RhdGUuZWNpZXNJbnN0YW5jZSkpdGhyb3cgbmV3IEVycm9yKFwiRUNJRVMgaW5zdGFuY2UgaXMgbm90IGluaXRpYWxpemVkXCIpO3JldHVybiBudWxsPT09KGk9bnVsbD09PShuPXRoaXMuc3RhdGUuY29tbXVuaWNhdGlvbkxheWVyKXx8dm9pZCAwPT09bj92b2lkIDA6bi5zdGF0ZS5lY2llc0luc3RhbmNlKXx8dm9pZCAwPT09aT92b2lkIDA6aS5kZWNyeXB0KGUpfWdldENoYW5uZWxJZCgpe3JldHVybiB0aGlzLnN0YXRlLmNoYW5uZWxJZH1nZXRSUENNZXRob2RUcmFja2VyKCl7dmFyIGU7cmV0dXJuIG51bGw9PT0oZT10aGlzLnN0YXRlLmNvbW11bmljYXRpb25MYXllcil8fHZvaWQgMD09PWU/dm9pZCAwOmUuZ2V0UlBDTWV0aG9kVHJhY2tlcigpfXJlamVjdCh7Y2hhbm5lbElkOnR9KXtyZXR1cm4gZnVuY3Rpb24odCl7cmV0dXJuIGUodGhpcyxhcmd1bWVudHMsdm9pZCAwLChmdW5jdGlvbiooe2NoYW5uZWxJZDplLHN0YXRlOnR9KXt2YXIgbixpLG87aWYoIXIoZSkpdGhyb3cgZy5SZW1vdGVDb21tdW5pY2F0aW9uKGBbUmVtb3RlQ29tbXVuaWNhdGlvbjogY29ubmVjdFRvQ2hhbm5lbCgpXSBjb250ZXh0PSR7dC5jb250ZXh0fSBpbnZhbGlkIGNoYW5uZWwgY2hhbm5lbElkPSR7ZX1gKSxuZXcgRXJyb3IoYEludmFsaWQgY2hhbm5lbCAke2V9YCk7aWYodC5pc09yaWdpbmF0b3IpcmV0dXJuIHZvaWQgZy5SZW1vdGVDb21tdW5pY2F0aW9uKGBbUmVtb3RlQ29tbXVuaWNhdGlvbjogcmVqZWN0KCldIGNvbnRleHQ9JHt0LmNvbnRleHR9IGlzT3JpZ2luYXRvcj0ke3QuaXNPcmlnaW5hdG9yfSBjaGFubmVsSWQ9JHtlfWApO2NvbnN0e3NvY2tldDphfT1udWxsIT09KGk9bnVsbD09PShuPXQuY29tbXVuaWNhdGlvbkxheWVyKXx8dm9pZCAwPT09bj92b2lkIDA6bi5zdGF0ZSkmJnZvaWQgMCE9PWk/aTp7fTsobnVsbD09YT92b2lkIDA6YS5jb25uZWN0ZWQpfHwoZy5SZW1vdGVDb21tdW5pY2F0aW9uKGBbUmVtb3RlQ29tbXVuaWNhdGlvbjogcmVqZWN0KCldIGNvbnRleHQ9JHt0LmNvbnRleHR9IHNvY2tldCBhbHJlYWR5IGNvbm5lY3RlZGApLG51bGw9PWF8fGEuY29ubmVjdCgpKSxDKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7aWQ6ZSxldmVudDpMLlJFSkVDVEVEfSx0Lm9yaWdpbmF0b3JJbmZvKSx7c2RrVmVyc2lvbjp0LnNka1ZlcnNpb24sY29tbUxheWVyVmVyc2lvbjpmLnZlcnNpb24sd2FsbGV0VmVyc2lvbjpudWxsPT09KG89dC53YWxsZXRJbmZvKXx8dm9pZCAwPT09bz92b2lkIDA6by52ZXJzaW9ufSksdC5jb21tdW5pY2F0aW9uU2VydmVyVXJsKS5jYXRjaCgoZT0+e30pKSx5aWVsZCBuZXcgUHJvbWlzZSgoKG4saSk9PntudWxsPT1hfHxhLmVtaXQoUi5SRUpFQ1RFRCx7Y2hhbm5lbElkOmV9LCgoZSxvKT0+e2cuUmVtb3RlQ29tbXVuaWNhdGlvbihgW1JlbW90ZUNvbW11bmljYXRpb246IHJlamVjdCgpXSBjb250ZXh0PSR7dC5jb250ZXh0fSBzb2NrZXQ9JHtudWxsPT1hP3ZvaWQgMDphLmlkfWAse2Vycm9yOmUscmVzcG9uc2U6b30pLGU/aShlKTpuKG8pfSkpfSkpfSkpfSh7Y2hhbm5lbElkOnQsc3RhdGU6dGhpcy5zdGF0ZX0pfWRpc2Nvbm5lY3QodCl7cmV0dXJuIGUodGhpcyx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbiooKXtyZXR1cm4gbGUoe29wdGlvbnM6dCxpbnN0YW5jZTp0aGlzfSl9KSl9fSFmdW5jdGlvbihlKXtlLlJFTkVXPVwicmVuZXdcIixlLkxJTks9XCJsaW5rXCJ9KFF8fChRPXt9KSk7ZXhwb3J0e1EgYXMgQXV0b0Nvbm5lY3RUeXBlLEIgYXMgQ29tbXVuaWNhdGlvbkxheWVyUHJlZmVyZW5jZSxPIGFzIENvbm5lY3Rpb25TdGF0dXMsayBhcyBERUZBVUxUX1NFUlZFUl9VUkwsSSBhcyBERUZBVUxUX1NFU1NJT05fVElNRU9VVF9NUyxwIGFzIEVDSUVTLFIgYXMgRXZlbnRUeXBlLFAgYXMgS2V5RXhjaGFuZ2VNZXNzYWdlVHlwZSxiIGFzIE1lc3NhZ2VUeXBlLFogYXMgUGxhdGZvcm1UeXBlLGRlIGFzIFJlbW90ZUNvbW11bmljYXRpb24sQyBhcyBTZW5kQW5hbHl0aWNzLEogYXMgU29ja2V0U2VydmljZSxMIGFzIFRyYWNraW5nRXZlbnRzLE4gYXMgaXNBbmFseXRpY3NUcmFja2VkUnBjTWV0aG9kfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGFtYXNrLXNkay1jb21tdW5pY2F0aW9uLWxheWVyLmpzLm1hcFxuIiwiLy8gc3JjL2NvbnN0YW50cy50c1xudmFyIEVSQzcyMSA9IFwiRVJDNzIxXCI7XG52YXIgRVJDMTE1NSA9IFwiRVJDMTE1NVwiO1xudmFyIEVSQzIwID0gXCJFUkMyMFwiO1xuXG5leHBvcnQge1xuICBFUkM3MjEsXG4gIEVSQzExNTUsXG4gIEVSQzIwXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstSTZIWEdaUkQubWpzLm1hcCIsIi8vIHNyYy9tZXNzYWdlcy50c1xudmFyIG1lc3NhZ2VzID0ge1xuICBlcnJvcnM6IHtcbiAgICBkaXNjb25uZWN0ZWQ6ICgpID0+IFwiTWV0YU1hc2s6IERpc2Nvbm5lY3RlZCBmcm9tIGNoYWluLiBBdHRlbXB0aW5nIHRvIGNvbm5lY3QuXCIsXG4gICAgcGVybWFuZW50bHlEaXNjb25uZWN0ZWQ6ICgpID0+IFwiTWV0YU1hc2s6IERpc2Nvbm5lY3RlZCBmcm9tIE1ldGFNYXNrIGJhY2tncm91bmQuIFBhZ2UgcmVsb2FkIHJlcXVpcmVkLlwiLFxuICAgIHNlbmRTaXRlTWV0YWRhdGE6ICgpID0+IGBNZXRhTWFzazogRmFpbGVkIHRvIHNlbmQgc2l0ZSBtZXRhZGF0YS4gVGhpcyBpcyBhbiBpbnRlcm5hbCBlcnJvciwgcGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy5gLFxuICAgIHVuc3VwcG9ydGVkU3luYzogKG1ldGhvZCkgPT4gYE1ldGFNYXNrOiBUaGUgTWV0YU1hc2sgRXRoZXJldW0gcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBzeW5jaHJvbm91cyBtZXRob2RzIGxpa2UgJHttZXRob2R9IHdpdGhvdXQgYSBjYWxsYmFjayBwYXJhbWV0ZXIuYCxcbiAgICBpbnZhbGlkRHVwbGV4U3RyZWFtOiAoKSA9PiBcIk11c3QgcHJvdmlkZSBhIE5vZGUuanMtc3R5bGUgZHVwbGV4IHN0cmVhbS5cIixcbiAgICBpbnZhbGlkTmV0d29ya1BhcmFtczogKCkgPT4gXCJNZXRhTWFzazogUmVjZWl2ZWQgaW52YWxpZCBuZXR3b3JrIHBhcmFtZXRlcnMuIFBsZWFzZSByZXBvcnQgdGhpcyBidWcuXCIsXG4gICAgaW52YWxpZFJlcXVlc3RBcmdzOiAoKSA9PiBgRXhwZWN0ZWQgYSBzaW5nbGUsIG5vbi1hcnJheSwgb2JqZWN0IGFyZ3VtZW50LmAsXG4gICAgaW52YWxpZFJlcXVlc3RNZXRob2Q6ICgpID0+IGAnYXJncy5tZXRob2QnIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLmAsXG4gICAgaW52YWxpZFJlcXVlc3RQYXJhbXM6ICgpID0+IGAnYXJncy5wYXJhbXMnIG11c3QgYmUgYW4gb2JqZWN0IG9yIGFycmF5IGlmIHByb3ZpZGVkLmAsXG4gICAgaW52YWxpZExvZ2dlck9iamVjdDogKCkgPT4gYCdhcmdzLmxvZ2dlcicgbXVzdCBiZSBhbiBvYmplY3QgaWYgcHJvdmlkZWQuYCxcbiAgICBpbnZhbGlkTG9nZ2VyTWV0aG9kOiAobWV0aG9kKSA9PiBgJ2FyZ3MubG9nZ2VyJyBtdXN0IGluY2x1ZGUgcmVxdWlyZWQgbWV0aG9kICcke21ldGhvZH0nLmBcbiAgfSxcbiAgaW5mbzoge1xuICAgIGNvbm5lY3RlZDogKGNoYWluSWQpID0+IGBNZXRhTWFzazogQ29ubmVjdGVkIHRvIGNoYWluIHdpdGggSUQgXCIke2NoYWluSWR9XCIuYFxuICB9LFxuICB3YXJuaW5nczoge1xuICAgIC8vIGRlcHJlY2F0ZWQgcHJvcGVydGllc1xuICAgIGNoYWluSWREZXByZWNhdGlvbjogYE1ldGFNYXNrOiAnZXRoZXJldW0uY2hhaW5JZCcgaXMgZGVwcmVjYXRlZCBhbmQgbWF5IGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4gUGxlYXNlIHVzZSB0aGUgJ2V0aF9jaGFpbklkJyBSUEMgbWV0aG9kIGluc3RlYWQuXG5Gb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svbWV0YW1hc2staW1wcm92ZW1lbnQtcHJvcG9zYWxzL2Rpc2N1c3Npb25zLzIzYCxcbiAgICBuZXR3b3JrVmVyc2lvbkRlcHJlY2F0aW9uOiBgTWV0YU1hc2s6ICdldGhlcmV1bS5uZXR3b3JrVmVyc2lvbicgaXMgZGVwcmVjYXRlZCBhbmQgbWF5IGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS4gUGxlYXNlIHVzZSB0aGUgJ25ldF92ZXJzaW9uJyBSUEMgbWV0aG9kIGluc3RlYWQuXG5Gb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svbWV0YW1hc2staW1wcm92ZW1lbnQtcHJvcG9zYWxzL2Rpc2N1c3Npb25zLzIzYCxcbiAgICBzZWxlY3RlZEFkZHJlc3NEZXByZWNhdGlvbjogYE1ldGFNYXNrOiAnZXRoZXJldW0uc2VsZWN0ZWRBZGRyZXNzJyBpcyBkZXByZWNhdGVkIGFuZCBtYXkgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLiBQbGVhc2UgdXNlIHRoZSAnZXRoX2FjY291bnRzJyBSUEMgbWV0aG9kIGluc3RlYWQuXG5Gb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svbWV0YW1hc2staW1wcm92ZW1lbnQtcHJvcG9zYWxzL2Rpc2N1c3Npb25zLzIzYCxcbiAgICAvLyBkZXByZWNhdGVkIG1ldGhvZHNcbiAgICBlbmFibGVEZXByZWNhdGlvbjogYE1ldGFNYXNrOiAnZXRoZXJldW0uZW5hYmxlKCknIGlzIGRlcHJlY2F0ZWQgYW5kIG1heSBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuIFBsZWFzZSB1c2UgdGhlICdldGhfcmVxdWVzdEFjY291bnRzJyBSUEMgbWV0aG9kIGluc3RlYWQuXG5Gb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlOiBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTExMDJgLFxuICAgIHNlbmREZXByZWNhdGlvbjogYE1ldGFNYXNrOiAnZXRoZXJldW0uc2VuZCguLi4pJyBpcyBkZXByZWNhdGVkIGFuZCBtYXkgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLiBQbGVhc2UgdXNlICdldGhlcmV1bS5zZW5kQXN5bmMoLi4uKScgb3IgJ2V0aGVyZXVtLnJlcXVlc3QoLi4uKScgaW5zdGVhZC5cbkZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWU6IGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTE5M2AsXG4gICAgLy8gZGVwcmVjYXRlZCBldmVudHNcbiAgICBldmVudHM6IHtcbiAgICAgIGNsb3NlOiBgTWV0YU1hc2s6IFRoZSBldmVudCAnY2xvc2UnIGlzIGRlcHJlY2F0ZWQgYW5kIG1heSBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuIFBsZWFzZSB1c2UgJ2Rpc2Nvbm5lY3QnIGluc3RlYWQuXG5Gb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlOiBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTExOTMjZGlzY29ubmVjdGAsXG4gICAgICBkYXRhOiBgTWV0YU1hc2s6IFRoZSBldmVudCAnZGF0YScgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuIFVzZSAnbWVzc2FnZScgaW5zdGVhZC5cbkZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWU6IGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTE5MyNtZXNzYWdlYCxcbiAgICAgIG5ldHdvcmtDaGFuZ2VkOiBgTWV0YU1hc2s6IFRoZSBldmVudCAnbmV0d29ya0NoYW5nZWQnIGlzIGRlcHJlY2F0ZWQgYW5kIG1heSBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuIFVzZSAnY2hhaW5DaGFuZ2VkJyBpbnN0ZWFkLlxuRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZTogaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC0xMTkzI2NoYWluY2hhbmdlZGAsXG4gICAgICBub3RpZmljYXRpb246IGBNZXRhTWFzazogVGhlIGV2ZW50ICdub3RpZmljYXRpb24nIGlzIGRlcHJlY2F0ZWQgYW5kIG1heSBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuIFVzZSAnbWVzc2FnZScgaW5zdGVhZC5cbkZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWU6IGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTE5MyNtZXNzYWdlYFxuICAgIH0sXG4gICAgcnBjOiB7XG4gICAgICBldGhEZWNyeXB0RGVwcmVjYXRpb246IGBNZXRhTWFzazogVGhlIFJQQyBtZXRob2QgJ2V0aF9kZWNyeXB0JyBpcyBkZXByZWNhdGVkIGFuZCBtYXkgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlxuRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZTogaHR0cHM6Ly9tZWRpdW0uY29tL21ldGFtYXNrL21ldGFtYXNrLWFwaS1tZXRob2QtZGVwcmVjYXRpb24tMmIwNTY0YTg0Njg2YCxcbiAgICAgIGV0aEdldEVuY3J5cHRpb25QdWJsaWNLZXlEZXByZWNhdGlvbjogYE1ldGFNYXNrOiBUaGUgUlBDIG1ldGhvZCAnZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXknIGlzIGRlcHJlY2F0ZWQgYW5kIG1heSBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXG5Gb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlOiBodHRwczovL21lZGl1bS5jb20vbWV0YW1hc2svbWV0YW1hc2stYXBpLW1ldGhvZC1kZXByZWNhdGlvbi0yYjA1NjRhODQ2ODZgLFxuICAgICAgd2FsbGV0V2F0Y2hBc3NldE5GVEV4cGVyaW1lbnRhbDogYE1ldGFNYXNrOiBUaGUgUlBDIG1ldGhvZCAnd2FsbGV0X3dhdGNoQXNzZXQnIGlzIGV4cGVyaW1lbnRhbCBmb3IgRVJDNzIxL0VSQzExNTUgYXNzZXRzIGFuZCBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5Gb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlOiBodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svbWV0YW1hc2staW1wcm92ZW1lbnQtcHJvcG9zYWxzL2Jsb2IvbWFpbi9NSVBzL21pcC0xLm1kIGFuZCBodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svbWV0YW1hc2staW1wcm92ZW1lbnQtcHJvcG9zYWxzL2Jsb2IvbWFpbi9QUk9DRVNTLUdVSURFLm1kI3Byb3Bvc2FsLWxpZmVjeWNsZWBcbiAgICB9LFxuICAgIC8vIG1pc2NcbiAgICBleHBlcmltZW50YWxNZXRob2RzOiBgTWV0YU1hc2s6ICdldGhlcmV1bS5fbWV0YW1hc2snIGV4cG9zZXMgbm9uLXN0YW5kYXJkLCBleHBlcmltZW50YWwgbWV0aG9kcy4gVGhleSBtYXkgYmUgcmVtb3ZlZCBvciBjaGFuZ2VkIHdpdGhvdXQgd2FybmluZy5gXG4gIH1cbn07XG52YXIgbWVzc2FnZXNfZGVmYXVsdCA9IG1lc3NhZ2VzO1xuXG5leHBvcnQge1xuICBtZXNzYWdlc19kZWZhdWx0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstWkdEUTNJWUQubWpzLm1hcCIsImltcG9ydCB7XG4gIEVSQzExNTUsXG4gIEVSQzcyMVxufSBmcm9tIFwiLi9jaHVuay1JNkhYR1pSRC5tanNcIjtcbmltcG9ydCB7XG4gIG1lc3NhZ2VzX2RlZmF1bHRcbn0gZnJvbSBcIi4vY2h1bmstWkdEUTNJWUQubWpzXCI7XG5cbi8vIHNyYy9taWRkbGV3YXJlL2NyZWF0ZVJwY1dhcm5pbmdNaWRkbGV3YXJlLnRzXG5mdW5jdGlvbiBjcmVhdGVScGNXYXJuaW5nTWlkZGxld2FyZShsb2cpIHtcbiAgY29uc3Qgc2VudFdhcm5pbmdzID0ge1xuICAgIGV0aERlY3J5cHREZXByZWNhdGlvbjogZmFsc2UsXG4gICAgZXRoR2V0RW5jcnlwdGlvblB1YmxpY0tleURlcHJlY2F0aW9uOiBmYWxzZSxcbiAgICB3YWxsZXRXYXRjaEFzc2V0TkZURXhwZXJpbWVudGFsOiBmYWxzZVxuICB9O1xuICByZXR1cm4gKHJlcSwgX3JlcywgbmV4dCkgPT4ge1xuICAgIGlmICghc2VudFdhcm5pbmdzLmV0aERlY3J5cHREZXByZWNhdGlvbiAmJiByZXEubWV0aG9kID09PSBcImV0aF9kZWNyeXB0XCIpIHtcbiAgICAgIGxvZy53YXJuKG1lc3NhZ2VzX2RlZmF1bHQud2FybmluZ3MucnBjLmV0aERlY3J5cHREZXByZWNhdGlvbik7XG4gICAgICBzZW50V2FybmluZ3MuZXRoRGVjcnlwdERlcHJlY2F0aW9uID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCFzZW50V2FybmluZ3MuZXRoR2V0RW5jcnlwdGlvblB1YmxpY0tleURlcHJlY2F0aW9uICYmIHJlcS5tZXRob2QgPT09IFwiZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXlcIikge1xuICAgICAgbG9nLndhcm4obWVzc2FnZXNfZGVmYXVsdC53YXJuaW5ncy5ycGMuZXRoR2V0RW5jcnlwdGlvblB1YmxpY0tleURlcHJlY2F0aW9uKTtcbiAgICAgIHNlbnRXYXJuaW5ncy5ldGhHZXRFbmNyeXB0aW9uUHVibGljS2V5RGVwcmVjYXRpb24gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXNlbnRXYXJuaW5ncy53YWxsZXRXYXRjaEFzc2V0TkZURXhwZXJpbWVudGFsICYmIHJlcS5tZXRob2QgPT09IFwid2FsbGV0X3dhdGNoQXNzZXRcIiAmJiBbRVJDNzIxLCBFUkMxMTU1XS5pbmNsdWRlcyhcbiAgICAgIHJlcS5wYXJhbXM/LnR5cGUgfHwgXCJcIlxuICAgICkpIHtcbiAgICAgIGxvZy53YXJuKG1lc3NhZ2VzX2RlZmF1bHQud2FybmluZ3MucnBjLndhbGxldFdhdGNoQXNzZXRORlRFeHBlcmltZW50YWwpO1xuICAgICAgc2VudFdhcm5pbmdzLndhbGxldFdhdGNoQXNzZXRORlRFeHBlcmltZW50YWwgPSB0cnVlO1xuICAgIH1cbiAgICBuZXh0KCk7XG4gIH07XG59XG5cbmV4cG9ydCB7XG4gIGNyZWF0ZVJwY1dhcm5pbmdNaWRkbGV3YXJlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstNUZMNlZSSkoubWpzLm1hcCIsIi8vIHNyYy9nZXRVbmlxdWVJZC50c1xudmFyIE1BWCA9IDQyOTQ5NjcyOTU7XG52YXIgaWRDb3VudGVyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTUFYKTtcbmZ1bmN0aW9uIGdldFVuaXF1ZUlkKCkge1xuICBpZENvdW50ZXIgPSAoaWRDb3VudGVyICsgMSkgJSBNQVg7XG4gIHJldHVybiBpZENvdW50ZXI7XG59XG5cbmV4cG9ydCB7XG4gIGdldFVuaXF1ZUlkXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstNlhYUFRaVjYubWpzLm1hcCIsImltcG9ydCB7XG4gIGdldFVuaXF1ZUlkXG59IGZyb20gXCIuL2NodW5rLTZYWFBUWlY2Lm1qc1wiO1xuXG4vLyBzcmMvaWRSZW1hcE1pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlKCkge1xuICByZXR1cm4gKHJlcXVlc3QsIHJlc3BvbnNlLCBuZXh0LCBfZW5kKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxJZCA9IHJlcXVlc3QuaWQ7XG4gICAgY29uc3QgbmV3SWQgPSBnZXRVbmlxdWVJZCgpO1xuICAgIHJlcXVlc3QuaWQgPSBuZXdJZDtcbiAgICByZXNwb25zZS5pZCA9IG5ld0lkO1xuICAgIG5leHQoKGRvbmUpID0+IHtcbiAgICAgIHJlcXVlc3QuaWQgPSBvcmlnaW5hbElkO1xuICAgICAgcmVzcG9uc2UuaWQgPSBvcmlnaW5hbElkO1xuICAgICAgZG9uZSgpO1xuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnQge1xuICBjcmVhdGVJZFJlbWFwTWlkZGxld2FyZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLVI3TEtJNUg1Lm1qcy5tYXAiLCJ2YXIgX19hY2Nlc3NDaGVjayA9IChvYmosIG1lbWJlciwgbXNnKSA9PiB7XG4gIGlmICghbWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBcIiArIG1zZyk7XG59O1xudmFyIF9fcHJpdmF0ZUdldCA9IChvYmosIG1lbWJlciwgZ2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwicmVhZCBmcm9tIHByaXZhdGUgZmllbGRcIik7XG4gIHJldHVybiBnZXR0ZXIgPyBnZXR0ZXIuY2FsbChvYmopIDogbWVtYmVyLmdldChvYmopO1xufTtcbnZhciBfX3ByaXZhdGVBZGQgPSAob2JqLCBtZW1iZXIsIHZhbHVlKSA9PiB7XG4gIGlmIChtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IGFkZCB0aGUgc2FtZSBwcml2YXRlIG1lbWJlciBtb3JlIHRoYW4gb25jZVwiKTtcbiAgbWVtYmVyIGluc3RhbmNlb2YgV2Vha1NldCA/IG1lbWJlci5hZGQob2JqKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG59O1xudmFyIF9fcHJpdmF0ZVNldCA9IChvYmosIG1lbWJlciwgdmFsdWUsIHNldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcIndyaXRlIHRvIHByaXZhdGUgZmllbGRcIik7XG4gIHNldHRlciA/IHNldHRlci5jYWxsKG9iaiwgdmFsdWUpIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX3ByaXZhdGVNZXRob2QgPSAob2JqLCBtZW1iZXIsIG1ldGhvZCkgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcImFjY2VzcyBwcml2YXRlIG1ldGhvZFwiKTtcbiAgcmV0dXJuIG1ldGhvZDtcbn07XG5cbmV4cG9ydCB7XG4gIF9fcHJpdmF0ZUdldCxcbiAgX19wcml2YXRlQWRkLFxuICBfX3ByaXZhdGVTZXQsXG4gIF9fcHJpdmF0ZU1ldGhvZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLVhVSTQzTEVaLm1qcy5tYXAiLCIvLyBzcmMvZXJyb3ItY29uc3RhbnRzLnRzXG52YXIgZXJyb3JDb2RlcyA9IHtcbiAgcnBjOiB7XG4gICAgaW52YWxpZElucHV0OiAtMzJlMyxcbiAgICByZXNvdXJjZU5vdEZvdW5kOiAtMzIwMDEsXG4gICAgcmVzb3VyY2VVbmF2YWlsYWJsZTogLTMyMDAyLFxuICAgIHRyYW5zYWN0aW9uUmVqZWN0ZWQ6IC0zMjAwMyxcbiAgICBtZXRob2ROb3RTdXBwb3J0ZWQ6IC0zMjAwNCxcbiAgICBsaW1pdEV4Y2VlZGVkOiAtMzIwMDUsXG4gICAgcGFyc2U6IC0zMjcwMCxcbiAgICBpbnZhbGlkUmVxdWVzdDogLTMyNjAwLFxuICAgIG1ldGhvZE5vdEZvdW5kOiAtMzI2MDEsXG4gICAgaW52YWxpZFBhcmFtczogLTMyNjAyLFxuICAgIGludGVybmFsOiAtMzI2MDNcbiAgfSxcbiAgcHJvdmlkZXI6IHtcbiAgICB1c2VyUmVqZWN0ZWRSZXF1ZXN0OiA0MDAxLFxuICAgIHVuYXV0aG9yaXplZDogNDEwMCxcbiAgICB1bnN1cHBvcnRlZE1ldGhvZDogNDIwMCxcbiAgICBkaXNjb25uZWN0ZWQ6IDQ5MDAsXG4gICAgY2hhaW5EaXNjb25uZWN0ZWQ6IDQ5MDFcbiAgfVxufTtcbnZhciBlcnJvclZhbHVlcyA9IHtcbiAgXCItMzI3MDBcIjoge1xuICAgIHN0YW5kYXJkOiBcIkpTT04gUlBDIDIuMFwiLFxuICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBKU09OIHdhcyByZWNlaXZlZCBieSB0aGUgc2VydmVyLiBBbiBlcnJvciBvY2N1cnJlZCBvbiB0aGUgc2VydmVyIHdoaWxlIHBhcnNpbmcgdGhlIEpTT04gdGV4dC5cIlxuICB9LFxuICBcIi0zMjYwMFwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiSlNPTiBSUEMgMi4wXCIsXG4gICAgbWVzc2FnZTogXCJUaGUgSlNPTiBzZW50IGlzIG5vdCBhIHZhbGlkIFJlcXVlc3Qgb2JqZWN0LlwiXG4gIH0sXG4gIFwiLTMyNjAxXCI6IHtcbiAgICBzdGFuZGFyZDogXCJKU09OIFJQQyAyLjBcIixcbiAgICBtZXNzYWdlOiBcIlRoZSBtZXRob2QgZG9lcyBub3QgZXhpc3QgLyBpcyBub3QgYXZhaWxhYmxlLlwiXG4gIH0sXG4gIFwiLTMyNjAyXCI6IHtcbiAgICBzdGFuZGFyZDogXCJKU09OIFJQQyAyLjBcIixcbiAgICBtZXNzYWdlOiBcIkludmFsaWQgbWV0aG9kIHBhcmFtZXRlcihzKS5cIlxuICB9LFxuICBcIi0zMjYwM1wiOiB7XG4gICAgc3RhbmRhcmQ6IFwiSlNPTiBSUEMgMi4wXCIsXG4gICAgbWVzc2FnZTogXCJJbnRlcm5hbCBKU09OLVJQQyBlcnJvci5cIlxuICB9LFxuICBcIi0zMjAwMFwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTE0NzRcIixcbiAgICBtZXNzYWdlOiBcIkludmFsaWQgaW5wdXQuXCJcbiAgfSxcbiAgXCItMzIwMDFcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xNDc0XCIsXG4gICAgbWVzc2FnZTogXCJSZXNvdXJjZSBub3QgZm91bmQuXCJcbiAgfSxcbiAgXCItMzIwMDJcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xNDc0XCIsXG4gICAgbWVzc2FnZTogXCJSZXNvdXJjZSB1bmF2YWlsYWJsZS5cIlxuICB9LFxuICBcIi0zMjAwM1wiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTE0NzRcIixcbiAgICBtZXNzYWdlOiBcIlRyYW5zYWN0aW9uIHJlamVjdGVkLlwiXG4gIH0sXG4gIFwiLTMyMDA0XCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTQ3NFwiLFxuICAgIG1lc3NhZ2U6IFwiTWV0aG9kIG5vdCBzdXBwb3J0ZWQuXCJcbiAgfSxcbiAgXCItMzIwMDVcIjoge1xuICAgIHN0YW5kYXJkOiBcIkVJUC0xNDc0XCIsXG4gICAgbWVzc2FnZTogXCJSZXF1ZXN0IGxpbWl0IGV4Y2VlZGVkLlwiXG4gIH0sXG4gIFwiNDAwMVwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTExOTNcIixcbiAgICBtZXNzYWdlOiBcIlVzZXIgcmVqZWN0ZWQgdGhlIHJlcXVlc3QuXCJcbiAgfSxcbiAgXCI0MTAwXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTE5M1wiLFxuICAgIG1lc3NhZ2U6IFwiVGhlIHJlcXVlc3RlZCBhY2NvdW50IGFuZC9vciBtZXRob2QgaGFzIG5vdCBiZWVuIGF1dGhvcml6ZWQgYnkgdGhlIHVzZXIuXCJcbiAgfSxcbiAgXCI0MjAwXCI6IHtcbiAgICBzdGFuZGFyZDogXCJFSVAtMTE5M1wiLFxuICAgIG1lc3NhZ2U6IFwiVGhlIHJlcXVlc3RlZCBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIEV0aGVyZXVtIHByb3ZpZGVyLlwiXG4gIH0sXG4gIFwiNDkwMFwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTExOTNcIixcbiAgICBtZXNzYWdlOiBcIlRoZSBwcm92aWRlciBpcyBkaXNjb25uZWN0ZWQgZnJvbSBhbGwgY2hhaW5zLlwiXG4gIH0sXG4gIFwiNDkwMVwiOiB7XG4gICAgc3RhbmRhcmQ6IFwiRUlQLTExOTNcIixcbiAgICBtZXNzYWdlOiBcIlRoZSBwcm92aWRlciBpcyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgc3BlY2lmaWVkIGNoYWluLlwiXG4gIH1cbn07XG5cbmV4cG9ydCB7XG4gIGVycm9yQ29kZXMsXG4gIGVycm9yVmFsdWVzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstTUlXNE5NWTYubWpzLm1hcCIsIi8vIHNyYy9taXNjLnRzXG5mdW5jdGlvbiBpc05vbkVtcHR5QXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA+IDA7XG59XG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBCb29sZWFuKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxudmFyIGhhc1Byb3BlcnR5ID0gKG9iamVjdFRvQ2hlY2ssIG5hbWUpID0+IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdFRvQ2hlY2ssIG5hbWUpO1xuZnVuY3Rpb24gZ2V0S25vd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KTtcbn1cbnZhciBKc29uU2l6ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEpzb25TaXplMikgPT4ge1xuICBKc29uU2l6ZTJbSnNvblNpemUyW1wiTnVsbFwiXSA9IDRdID0gXCJOdWxsXCI7XG4gIEpzb25TaXplMltKc29uU2l6ZTJbXCJDb21tYVwiXSA9IDFdID0gXCJDb21tYVwiO1xuICBKc29uU2l6ZTJbSnNvblNpemUyW1wiV3JhcHBlclwiXSA9IDFdID0gXCJXcmFwcGVyXCI7XG4gIEpzb25TaXplMltKc29uU2l6ZTJbXCJUcnVlXCJdID0gNF0gPSBcIlRydWVcIjtcbiAgSnNvblNpemUyW0pzb25TaXplMltcIkZhbHNlXCJdID0gNV0gPSBcIkZhbHNlXCI7XG4gIEpzb25TaXplMltKc29uU2l6ZTJbXCJRdW90ZVwiXSA9IDFdID0gXCJRdW90ZVwiO1xuICBKc29uU2l6ZTJbSnNvblNpemUyW1wiQ29sb25cIl0gPSAxXSA9IFwiQ29sb25cIjtcbiAgSnNvblNpemUyW0pzb25TaXplMltcIkRhdGVcIl0gPSAyNF0gPSBcIkRhdGVcIjtcbiAgcmV0dXJuIEpzb25TaXplMjtcbn0pKEpzb25TaXplIHx8IHt9KTtcbnZhciBFU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFAgPSAvXCJ8XFxcXHxcXG58XFxyfFxcdC9ndTtcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgIGxldCBwcm90byA9IHZhbHVlO1xuICAgIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBwcm90bztcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNBU0NJSShjaGFyYWN0ZXIpIHtcbiAgcmV0dXJuIGNoYXJhY3Rlci5jaGFyQ29kZUF0KDApIDw9IDEyNztcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVN0cmluZ1NpemUodmFsdWUpIHtcbiAgY29uc3Qgc2l6ZSA9IHZhbHVlLnNwbGl0KFwiXCIpLnJlZHVjZSgodG90YWwsIGNoYXJhY3RlcikgPT4ge1xuICAgIGlmIChpc0FTQ0lJKGNoYXJhY3RlcikpIHtcbiAgICAgIHJldHVybiB0b3RhbCArIDE7XG4gICAgfVxuICAgIHJldHVybiB0b3RhbCArIDI7XG4gIH0sIDApO1xuICByZXR1cm4gc2l6ZSArICh2YWx1ZS5tYXRjaChFU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFApID8/IFtdKS5sZW5ndGg7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVOdW1iZXJTaXplKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS50b1N0cmluZygpLmxlbmd0aDtcbn1cblxuZXhwb3J0IHtcbiAgaXNOb25FbXB0eUFycmF5LFxuICBpc051bGxPclVuZGVmaW5lZCxcbiAgaXNPYmplY3QsXG4gIGhhc1Byb3BlcnR5LFxuICBnZXRLbm93blByb3BlcnR5TmFtZXMsXG4gIEpzb25TaXplLFxuICBFU0NBUEVfQ0hBUkFDVEVSU19SRUdFWFAsXG4gIGlzUGxhaW5PYmplY3QsXG4gIGlzQVNDSUksXG4gIGNhbGN1bGF0ZVN0cmluZ1NpemUsXG4gIGNhbGN1bGF0ZU51bWJlclNpemVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1INFlGRExCNy5tanMubWFwIiwiLyoqXG4gKiBBIGBTdHJ1Y3RGYWlsdXJlYCByZXByZXNlbnRzIGEgc2luZ2xlIHNwZWNpZmljIGZhaWx1cmUgaW4gdmFsaWRhdGlvbi5cbiAqL1xuLyoqXG4gKiBgU3RydWN0RXJyb3JgIG9iamVjdHMgYXJlIHRocm93biAob3IgcmV0dXJuZWQpIHdoZW4gdmFsaWRhdGlvbiBmYWlscy5cbiAqXG4gKiBWYWxpZGF0aW9uIGxvZ2ljIGlzIGRlc2lnbiB0byBleGl0IGVhcmx5IGZvciBtYXhpbXVtIHBlcmZvcm1hbmNlLiBUaGUgZXJyb3JcbiAqIHJlcHJlc2VudHMgdGhlIGZpcnN0IGVycm9yIGVuY291bnRlcmVkIGR1cmluZyB2YWxpZGF0aW9uLiBGb3IgbW9yZSBkZXRhaWwsXG4gKiB0aGUgYGVycm9yLmZhaWx1cmVzYCBwcm9wZXJ0eSBpcyBhIGdlbmVyYXRvciBmdW5jdGlvbiB0aGF0IGNhbiBiZSBydW4gdG9cbiAqIGNvbnRpbnVlIHZhbGlkYXRpb24gYW5kIHJlY2VpdmUgYWxsIHRoZSBmYWlsdXJlcyBpbiB0aGUgZGF0YS5cbiAqL1xuY2xhc3MgU3RydWN0RXJyb3IgZXh0ZW5kcyBUeXBlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZhaWx1cmUsIGZhaWx1cmVzKSB7XG4gICAgICAgIGxldCBjYWNoZWQ7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSwgZXhwbGFuYXRpb24sIC4uLnJlc3QgfSA9IGZhaWx1cmU7XG4gICAgICAgIGNvbnN0IHsgcGF0aCB9ID0gZmFpbHVyZTtcbiAgICAgICAgY29uc3QgbXNnID0gcGF0aC5sZW5ndGggPT09IDAgPyBtZXNzYWdlIDogYEF0IHBhdGg6ICR7cGF0aC5qb2luKCcuJyl9IC0tICR7bWVzc2FnZX1gO1xuICAgICAgICBzdXBlcihleHBsYW5hdGlvbiA/PyBtc2cpO1xuICAgICAgICBpZiAoZXhwbGFuYXRpb24gIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuY2F1c2UgPSBtc2c7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgcmVzdCk7XG4gICAgICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdGhpcy5mYWlsdXJlcyA9ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoY2FjaGVkID8/IChjYWNoZWQgPSBbZmFpbHVyZSwgLi4uZmFpbHVyZXMoKV0pKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBpdGVyYXRvci5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYWJsZSh4KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIHR5cGVvZiB4W1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT0gbnVsbDtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh4KSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCk7XG4gICAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG4vKipcbiAqIFJldHVybiBhIHZhbHVlIGFzIGEgcHJpbnRhYmxlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gcHJpbnQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3ltYm9sJykge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiBgJHt2YWx1ZX1gO1xufVxuLyoqXG4gKiBTaGlmdHMgKHJlbW92ZXMgYW5kIHJldHVybnMpIHRoZSBmaXJzdCB2YWx1ZSBmcm9tIHRoZSBgaW5wdXRgIGl0ZXJhdG9yLlxuICogTGlrZSBgQXJyYXkucHJvdG90eXBlLnNoaWZ0KClgIGJ1dCBmb3IgYW4gYEl0ZXJhdG9yYC5cbiAqL1xuZnVuY3Rpb24gc2hpZnRJdGVyYXRvcihpbnB1dCkge1xuICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGlucHV0Lm5leHQoKTtcbiAgICByZXR1cm4gZG9uZSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgc2luZ2xlIHZhbGlkYXRpb24gcmVzdWx0IHRvIGEgZmFpbHVyZS5cbiAqL1xuZnVuY3Rpb24gdG9GYWlsdXJlKHJlc3VsdCwgY29udGV4dCwgc3RydWN0LCB2YWx1ZSkge1xuICAgIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIHJlc3VsdCA9IHt9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXN1bHQgPSB7IG1lc3NhZ2U6IHJlc3VsdCB9O1xuICAgIH1cbiAgICBjb25zdCB7IHBhdGgsIGJyYW5jaCB9ID0gY29udGV4dDtcbiAgICBjb25zdCB7IHR5cGUgfSA9IHN0cnVjdDtcbiAgICBjb25zdCB7IHJlZmluZW1lbnQsIG1lc3NhZ2UgPSBgRXhwZWN0ZWQgYSB2YWx1ZSBvZiB0eXBlIFxcYCR7dHlwZX1cXGAke3JlZmluZW1lbnQgPyBgIHdpdGggcmVmaW5lbWVudCBcXGAke3JlZmluZW1lbnR9XFxgYCA6ICcnfSwgYnV0IHJlY2VpdmVkOiBcXGAke3ByaW50KHZhbHVlKX1cXGBgLCB9ID0gcmVzdWx0O1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0eXBlLFxuICAgICAgICByZWZpbmVtZW50LFxuICAgICAgICBrZXk6IHBhdGhbcGF0aC5sZW5ndGggLSAxXSxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgYnJhbmNoLFxuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydCBhIHZhbGlkYXRpb24gcmVzdWx0IHRvIGFuIGl0ZXJhYmxlIG9mIGZhaWx1cmVzLlxuICovXG5mdW5jdGlvbiogdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgICBpZiAoIWlzSXRlcmFibGUocmVzdWx0KSkge1xuICAgICAgICByZXN1bHQgPSBbcmVzdWx0XTtcbiAgICB9XG4gICAgZm9yIChjb25zdCByIG9mIHJlc3VsdCkge1xuICAgICAgICBjb25zdCBmYWlsdXJlID0gdG9GYWlsdXJlKHIsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpO1xuICAgICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICAgICAgeWllbGQgZmFpbHVyZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQ2hlY2sgYSB2YWx1ZSBhZ2FpbnN0IGEgc3RydWN0LCB0cmF2ZXJzaW5nIGRlZXBseSBpbnRvIG5lc3RlZCB2YWx1ZXMsIGFuZFxuICogcmV0dXJuaW5nIGFuIGl0ZXJhdG9yIG9mIGZhaWx1cmVzIG9yIHN1Y2Nlc3MuXG4gKi9cbmZ1bmN0aW9uKiBydW4odmFsdWUsIHN0cnVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBwYXRoID0gW10sIGJyYW5jaCA9IFt2YWx1ZV0sIGNvZXJjZSA9IGZhbHNlLCBtYXNrID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgY3R4ID0geyBwYXRoLCBicmFuY2ggfTtcbiAgICBpZiAoY29lcmNlKSB7XG4gICAgICAgIHZhbHVlID0gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIGlmIChtYXNrICYmXG4gICAgICAgICAgICBzdHJ1Y3QudHlwZSAhPT0gJ3R5cGUnICYmXG4gICAgICAgICAgICBpc09iamVjdChzdHJ1Y3Quc2NoZW1hKSAmJlxuICAgICAgICAgICAgaXNPYmplY3QodmFsdWUpICYmXG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cnVjdC5zY2hlbWFba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RhdHVzID0gJ3ZhbGlkJztcbiAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSkge1xuICAgICAgICBmYWlsdXJlLmV4cGxhbmF0aW9uID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgICAgICBzdGF0dXMgPSAnbm90X3ZhbGlkJztcbiAgICAgICAgeWllbGQgW2ZhaWx1cmUsIHVuZGVmaW5lZF07XG4gICAgfVxuICAgIGZvciAobGV0IFtrLCB2LCBzXSBvZiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KSkge1xuICAgICAgICBjb25zdCB0cyA9IHJ1bih2LCBzLCB7XG4gICAgICAgICAgICBwYXRoOiBrID09PSB1bmRlZmluZWQgPyBwYXRoIDogWy4uLnBhdGgsIGtdLFxuICAgICAgICAgICAgYnJhbmNoOiBrID09PSB1bmRlZmluZWQgPyBicmFuY2ggOiBbLi4uYnJhbmNoLCB2XSxcbiAgICAgICAgICAgIGNvZXJjZSxcbiAgICAgICAgICAgIG1hc2ssXG4gICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLm1lc3NhZ2UsXG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IHQgb2YgdHMpIHtcbiAgICAgICAgICAgIGlmICh0WzBdKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzID0gdFswXS5yZWZpbmVtZW50ICE9IG51bGwgPyAnbm90X3JlZmluZWQnIDogJ25vdF92YWxpZCc7XG4gICAgICAgICAgICAgICAgeWllbGQgW3RbMF0sIHVuZGVmaW5lZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2VyY2UpIHtcbiAgICAgICAgICAgICAgICB2ID0gdFsxXTtcbiAgICAgICAgICAgICAgICBpZiAoayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2V0KGssIHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5hZGQodik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkIHx8IGsgaW4gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0dXMgIT09ICdub3RfdmFsaWQnKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSkge1xuICAgICAgICAgICAgZmFpbHVyZS5leHBsYW5hdGlvbiA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICAgICAgICAgIHN0YXR1cyA9ICdub3RfcmVmaW5lZCc7XG4gICAgICAgICAgICB5aWVsZCBbZmFpbHVyZSwgdW5kZWZpbmVkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSAndmFsaWQnKSB7XG4gICAgICAgIHlpZWxkIFt1bmRlZmluZWQsIHZhbHVlXTtcbiAgICB9XG59XG5cbi8qKlxuICogYFN0cnVjdGAgb2JqZWN0cyBlbmNhcHN1bGF0ZSB0aGUgdmFsaWRhdGlvbiBsb2dpYyBmb3IgYSBzcGVjaWZpYyB0eXBlIG9mXG4gKiB2YWx1ZXMuIE9uY2UgY29uc3RydWN0ZWQsIHlvdSB1c2UgdGhlIGBhc3NlcnRgLCBgaXNgIG9yIGB2YWxpZGF0ZWAgaGVscGVycyB0b1xuICogdmFsaWRhdGUgdW5rbm93biBpbnB1dCBkYXRhIGFnYWluc3QgdGhlIHN0cnVjdC5cbiAqL1xuY2xhc3MgU3RydWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICBjb25zdCB7IHR5cGUsIHNjaGVtYSwgdmFsaWRhdG9yLCByZWZpbmVyLCBjb2VyY2VyID0gKHZhbHVlKSA9PiB2YWx1ZSwgZW50cmllcyA9IGZ1bmN0aW9uKiAoKSB7IH0sIH0gPSBwcm9wcztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuZW50cmllcyA9IGVudHJpZXM7XG4gICAgICAgIHRoaXMuY29lcmNlciA9IGNvZXJjZXI7XG4gICAgICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdG9yID0gKHZhbHVlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRvciA9ICgpID0+IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWZpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLnJlZmluZXIgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWZpbmVyKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlZmluZXIgPSAoKSA9PiBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbiwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAgICAgKi9cbiAgICBhc3NlcnQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIGFzc2VydCh2YWx1ZSwgdGhpcywgbWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHZhbHVlIHdpdGggdGhlIHN0cnVjdCdzIGNvZXJjaW9uIGxvZ2ljLCB0aGVuIHZhbGlkYXRlIGl0LlxuICAgICAqL1xuICAgIGNyZWF0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSB2YWx1ZSBwYXNzZXMgdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgaXModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzKHZhbHVlLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFzayBhIHZhbHVlLCBjb2VyY2luZyBhbmQgdmFsaWRhdGluZyBpdCwgYnV0IHJldHVybmluZyBvbmx5IHRoZSBzdWJzZXQgb2ZcbiAgICAgKiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgdGhlIHN0cnVjdCdzIHNjaGVtYS5cbiAgICAgKi9cbiAgICBtYXNrKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBtYXNrKHZhbHVlLCB0aGlzLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGUgYSB2YWx1ZSB3aXRoIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uIGxvZ2ljLCByZXR1cm5pbmcgYSB0dXBsZVxuICAgICAqIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogWW91IG1heSBvcHRpb25hbGx5IHBhc3MgYHRydWVgIGZvciB0aGUgYHdpdGhDb2VyY2lvbmAgYXJndW1lbnQgdG8gY29lcmNlXG4gICAgICogdGhlIHZhbHVlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHZhbGlkYXRlIGl0LiBJZiB5b3UgZG8sIHRoZSByZXN1bHQgd2lsbFxuICAgICAqIGNvbnRhaW4gdGhlIGNvZXJjZWQgcmVzdWx0IHdoZW4gc3VjY2Vzc2Z1bC5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZSh2YWx1ZSwgdGhpcywgb3B0aW9ucyk7XG4gICAgfVxufVxuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyBhIHN0cnVjdCwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBzdHJ1Y3QsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7IG1lc3NhZ2UgfSk7XG4gICAgaWYgKHJlc3VsdFswXSkge1xuICAgICAgICB0aHJvdyByZXN1bHRbMF07XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSB2YWx1ZSB3aXRoIHRoZSBjb2VyY2lvbiBsb2dpYyBvZiBzdHJ1Y3QgYW5kIHZhbGlkYXRlIGl0LlxuICovXG5mdW5jdGlvbiBjcmVhdGUodmFsdWUsIHN0cnVjdCwgbWVzc2FnZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgY29lcmNlOiB0cnVlLCBtZXNzYWdlIH0pO1xuICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0WzBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFsxXTtcbiAgICB9XG59XG4vKipcbiAqIE1hc2sgYSB2YWx1ZSwgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgYSBzdHJ1Y3QuXG4gKi9cbmZ1bmN0aW9uIG1hc2sodmFsdWUsIHN0cnVjdCwgbWVzc2FnZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHsgY29lcmNlOiB0cnVlLCBtYXNrOiB0cnVlLCBtZXNzYWdlIH0pO1xuICAgIGlmIChyZXN1bHRbMF0pIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0WzBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFsxXTtcbiAgICB9XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgcGFzc2VzIGEgc3RydWN0LlxuICovXG5mdW5jdGlvbiBpcyh2YWx1ZSwgc3RydWN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCk7XG4gICAgcmV0dXJuICFyZXN1bHRbMF07XG59XG4vKipcbiAqIFZhbGlkYXRlIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgcmV0dXJuaW5nIGFuIGVycm9yIGlmIGludmFsaWQsIG9yIHRoZVxuICogdmFsdWUgKHdpdGggcG90ZW50aWFsIGNvZXJjaW9uKSBpZiB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdHVwbGVzID0gcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHR1cGxlID0gc2hpZnRJdGVyYXRvcih0dXBsZXMpO1xuICAgIGlmICh0dXBsZVswXSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBTdHJ1Y3RFcnJvcih0dXBsZVswXSwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdCBvZiB0dXBsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodFswXSkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0WzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbZXJyb3IsIHVuZGVmaW5lZF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB2ID0gdHVwbGVbMV07XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCB2XTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbiguLi5TdHJ1Y3RzKSB7XG4gICAgY29uc3QgaXNUeXBlID0gU3RydWN0c1swXS50eXBlID09PSAndHlwZSc7XG4gICAgY29uc3Qgc2NoZW1hcyA9IFN0cnVjdHMubWFwKChzKSA9PiBzLnNjaGVtYSk7XG4gICAgY29uc3Qgc2NoZW1hID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uc2NoZW1hcyk7XG4gICAgcmV0dXJuIGlzVHlwZSA/IHR5cGUoc2NoZW1hKSA6IG9iamVjdChzY2hlbWEpO1xufVxuLyoqXG4gKiBEZWZpbmUgYSBuZXcgc3RydWN0IHR5cGUgd2l0aCBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBkZWZpbmUobmFtZSwgdmFsaWRhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3QoeyB0eXBlOiBuYW1lLCBzY2hlbWE6IG51bGwsIHZhbGlkYXRvciB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBzdHJ1Y3QsIGJ1dCB0aGUgdmFsdWUgaXMgYWxsb3dlZCB0b1xuICogYmUgYHVuZGVmaW5lZGAuIGBsb2dgIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSB2YWx1ZSBpcyBub3QgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQoc3RydWN0LCBsb2cpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCksXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBkeW5hbWljIHZhbGlkYXRpb24gbG9naWMuXG4gKlxuICogVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSB0aGUgdmFsdWUgY3VycmVudGx5IGJlaW5nIHZhbGlkYXRlZCwgYW5kIG11c3RcbiAqIHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdmFsaWRhdGUgaXQgd2l0aC4gVGhpcyBjYW4gYmUgdXNlZnVsIHRvIG1vZGVsXG4gKiB2YWxpZGF0aW9uIGxvZ2ljIHRoYXQgY2hhbmdlcyBiYXNlZCBvbiBpdHMgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIGR5bmFtaWMoZm4pIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdkeW5hbWljJyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIHlpZWxkKiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHN0cnVjdCB3aXRoIGxhemlseSBldmFsdWF0ZWQgdmFsaWRhdGlvbiBsb2dpYy5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB2YWxpZGF0aW9uIGlzIHJ1biB3aXRoIHRoZSBzdHJ1Y3QsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxuICogYW5kIG11c3QgcmV0dXJuIGEgc3RydWN0IG9iamVjdCB0byB1c2UuIFRoaXMgaXMgdXNlZnVsIGZvciBjYXNlcyB3aGVyZSB5b3VcbiAqIHdhbnQgdG8gaGF2ZSBzZWxmLXJlZmVyZW50aWFsIHN0cnVjdHMgZm9yIG5lc3RlZCBkYXRhIHN0cnVjdHVyZXMgdG8gYXZvaWQgYVxuICogY2lyY3VsYXIgZGVmaW5pdGlvbiBwcm9ibGVtLlxuICovXG5mdW5jdGlvbiBsYXp5KGZuKSB7XG4gICAgbGV0IHN0cnVjdDtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdsYXp5JyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBzdHJ1Y3QgPz8gKHN0cnVjdCA9IGZuKCkpO1xuICAgICAgICAgICAgeWllbGQqIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIHN0cnVjdCA/PyAoc3RydWN0ID0gZm4oKSk7XG4gICAgICAgICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgICAgICAgIHJldHVybiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgZXhjbHVkaW5nXG4gKiBzcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBPbWl0YCB1dGlsaXR5LlxuICovXG5mdW5jdGlvbiBvbWl0KHN0cnVjdCwga2V5cykge1xuICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBzdHJ1Y3Q7XG4gICAgY29uc3Qgc3Vic2NoZW1hID0geyAuLi5zY2hlbWEgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgIGRlbGV0ZSBzdWJzY2hlbWFba2V5XTtcbiAgICB9XG4gICAgc3dpdGNoIChzdHJ1Y3QudHlwZSkge1xuICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgICAgIHJldHVybiB0eXBlKHN1YnNjaGVtYSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0KHN1YnNjaGVtYSk7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCB3aXRoIGFsbCBvZiBpdHNcbiAqIHByb3BlcnRpZXMgYWxsb3dlZCB0byBiZSBgdW5kZWZpbmVkYC5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgUGFydGlhbGAgdXRpbGl0eS5cbiAqL1xuZnVuY3Rpb24gcGFydGlhbChzdHJ1Y3QpIHtcbiAgICBjb25zdCBzY2hlbWEgPSBzdHJ1Y3QgaW5zdGFuY2VvZiBTdHJ1Y3QgPyB7IC4uLnN0cnVjdC5zY2hlbWEgfSA6IHsgLi4uc3RydWN0IH07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgIHNjaGVtYVtrZXldID0gb3B0aW9uYWwoc2NoZW1hW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0KHNjaGVtYSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb2JqZWN0IHN0cnVjdCwgYnV0IG9ubHkgaW5jbHVkaW5nXG4gKiBzcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBQaWNrYCB1dGlsaXR5LlxuICovXG5mdW5jdGlvbiBwaWNrKHN0cnVjdCwga2V5cykge1xuICAgIGNvbnN0IHsgc2NoZW1hIH0gPSBzdHJ1Y3Q7XG4gICAgY29uc3Qgc3Vic2NoZW1hID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBzdWJzY2hlbWFba2V5XSA9IHNjaGVtYVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0KHN1YnNjaGVtYSk7XG59XG4vKipcbiAqIERlZmluZSBhIG5ldyBzdHJ1Y3QgdHlwZSB3aXRoIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gKlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIGBkZWZpbmVgLlxuICovXG5mdW5jdGlvbiBzdHJ1Y3QobmFtZSwgdmFsaWRhdG9yKSB7XG4gICAgY29uc29sZS53YXJuKCdzdXBlcnN0cnVjdEAwLjExIC0gVGhlIGBzdHJ1Y3RgIGhlbHBlciBoYXMgYmVlbiByZW5hbWVkIHRvIGBkZWZpbmVgLicpO1xuICAgIHJldHVybiBkZWZpbmUobmFtZSwgdmFsaWRhdG9yKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhbnkgdmFsdWUgcGFzc2VzIHZhbGlkYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGFueSgpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdhbnknLCAoKSA9PiB0cnVlKTtcbn1cbmZ1bmN0aW9uIGFycmF5KEVsZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgIHNjaGVtYTogRWxlbWVudCxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChFbGVtZW50ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaSwgdl0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtpLCB2LCBFbGVtZW50XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLnNsaWNlKCkgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGFuIGFycmF5IHZhbHVlLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYmlnaW50LlxuICovXG5mdW5jdGlvbiBiaWdpbnQoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnYmlnaW50JywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYm9vbGVhbi5cbiAqL1xuZnVuY3Rpb24gYm9vbGVhbigpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdib29sZWFuJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIGBEYXRlYC5cbiAqXG4gKiBOb3RlOiB0aGlzIGFsc28gZW5zdXJlcyB0aGF0IHRoZSB2YWx1ZSBpcyAqbm90KiBhbiBpbnZhbGlkIGBEYXRlYCBvYmplY3QsXG4gKiB3aGljaCBjYW4gb2NjdXIgd2hlbiBwYXJzaW5nIGEgZGF0ZSBmYWlscyBidXQgc3RpbGwgcmV0dXJucyBhIGBEYXRlYC5cbiAqL1xuZnVuY3Rpb24gZGF0ZSgpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdkYXRlJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAoKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKSkgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhIHZhbGlkIFxcYERhdGVcXGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZW51bXModmFsdWVzKSB7XG4gICAgY29uc3Qgc2NoZW1hID0ge307XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB2YWx1ZXMubWFwKCh2KSA9PiBwcmludCh2KSkuam9pbigpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHZhbHVlcykge1xuICAgICAgICBzY2hlbWFba2V5XSA9IGtleTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnZW51bXMnLFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZXMuaW5jbHVkZXModmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIG9uZSBvZiBcXGAke2Rlc2NyaXB0aW9ufVxcYCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBmdW5jKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ2Z1bmMnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhIGZ1bmN0aW9uLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIGEgc3BlY2lmaWMgY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIGluc3RhbmNlKENsYXNzKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnaW5zdGFuY2UnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mIENsYXNzIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYSBcXGAke0NsYXNzLm5hbWV9XFxgIGluc3RhbmNlLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKi9cbmZ1bmN0aW9uIGludGVnZXIoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnaW50ZWdlcicsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKCh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkpIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYW4gaW50ZWdlciwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBtYXRjaGVzIGFsbCBvZiBhIHNldCBvZiB0eXBlcy5cbiAqL1xuZnVuY3Rpb24gaW50ZXJzZWN0aW9uKFN0cnVjdHMpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdpbnRlcnNlY3Rpb24nLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlLCBjdHgpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQqIFMuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKnZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICAgICAgICAgIHlpZWxkKiBTLnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKnJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCogUy5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gbGl0ZXJhbChjb25zdGFudCkge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gcHJpbnQoY29uc3RhbnQpO1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgY29uc3RhbnQ7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgICAgIHNjaGVtYTogdCA9PT0gJ3N0cmluZycgfHwgdCA9PT0gJ251bWJlcicgfHwgdCA9PT0gJ2Jvb2xlYW4nID8gY29uc3RhbnQgOiBudWxsLFxuICAgICAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUgPT09IGNvbnN0YW50IHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIHRoZSBsaXRlcmFsIFxcYCR7ZGVzY3JpcHRpb259XFxgLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gbWFwKEtleSwgVmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICdtYXAnLFxuICAgICAgICBzY2hlbWE6IG51bGwsXG4gICAgICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoS2V5ICYmIFZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCBrLCBLZXldO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgdiwgVmFsdWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTWFwID8gbmV3IE1hcCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgXFxgTWFwXFxgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgbm8gdmFsdWUgZXZlciBwYXNzZXMgdmFsaWRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gbmV2ZXIoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgnbmV2ZXInLCAoKSA9PiBmYWxzZSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYW4gZXhpc3Rpbmcgc3RydWN0IHRvIGFsbG93IGBudWxsYCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIG51bGxhYmxlKHN0cnVjdCkge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgICAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IG51bGwgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCksXG4gICAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIG51bWJlcigpIHtcbiAgICByZXR1cm4gZGVmaW5lKCdudW1iZXInLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuICgodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpKSB8fFxuICAgICAgICAgICAgYEV4cGVjdGVkIGEgbnVtYmVyLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gb2JqZWN0KHNjaGVtYSkge1xuICAgIGNvbnN0IGtub3ducyA9IHNjaGVtYSA/IE9iamVjdC5rZXlzKHNjaGVtYSkgOiBbXTtcbiAgICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgc2NoZW1hOiBzY2hlbWEgPyBzY2hlbWEgOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHNjaGVtYSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmtub3ducyA9IG5ldyBTZXQoT2JqZWN0LmtleXModmFsdWUpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrbm93bnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5rbm93bnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlW2tleV0sIHNjaGVtYVtrZXldXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdW5rbm93bnMpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgTmV2ZXJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgICAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8geyAuLi52YWx1ZSB9IDogdmFsdWU7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBzdHJ1Y3QgdG8gYWxsb3cgYHVuZGVmaW5lZGAgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBvcHRpb25hbChzdHJ1Y3QpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgdmFsaWRhdG9yOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgICAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBrZXlzIGFuZCB2YWx1ZXMgb2Ygc3BlY2lmaWMgdHlwZXMsIGJ1dFxuICogd2l0aG91dCBlbnN1cmluZyBhbnkgc3BlY2lmaWMgc2hhcGUgb2YgcHJvcGVydGllcy5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgUmVjb3JkYCB1dGlsaXR5LlxuICovXG5mdW5jdGlvbiByZWNvcmQoS2V5LCBWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ3JlY29yZCcsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHZhbHVlW2tdO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaywgaywgS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW2ssIHYsIFZhbHVlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIChpc09iamVjdCh2YWx1ZSkgfHwgYEV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGBSZWdFeHBgLlxuICpcbiAqIE5vdGU6IHRoaXMgZG9lcyBub3QgdGVzdCB0aGUgdmFsdWUgYWdhaW5zdCB0aGUgcmVndWxhciBleHByZXNzaW9uISBGb3IgdGhhdFxuICogeW91IG5lZWQgdG8gdXNlIHRoZSBgcGF0dGVybigpYCByZWZpbmVtZW50LlxuICovXG5mdW5jdGlvbiByZWdleHAoKSB7XG4gICAgcmV0dXJuIGRlZmluZSgncmVnZXhwJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNldChFbGVtZW50KSB7XG4gICAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgICAgICB0eXBlOiAnc2V0JyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKEVsZW1lbnQgJiYgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgW3YsIHYsIEVsZW1lbnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2V0ID8gbmV3IFNldCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlIGluc3RhbmNlb2YgU2V0IHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgXFxgU2V0XFxgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nKCkge1xuICAgIHJldHVybiBkZWZpbmUoJ3N0cmluZycsICh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIGBFeHBlY3RlZCBhIHN0cmluZywgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHR1cGxlIG9mIGEgc3BlY2lmaWMgbGVuZ3RoLCBhbmQgdGhhdCBlYWNoIG9mIGl0c1xuICogZWxlbWVudHMgaXMgb2YgYSBzcGVjaWZpYyB0eXBlLlxuICovXG5mdW5jdGlvbiB0dXBsZShTdHJ1Y3RzKSB7XG4gICAgY29uc3QgTmV2ZXIgPSBuZXZlcigpO1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgdHlwZTogJ3R1cGxlJyxcbiAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoU3RydWN0cy5sZW5ndGgsIHZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBbaSwgdmFsdWVbaV0sIFN0cnVjdHNbaV0gfHwgTmV2ZXJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGFuIGFycmF5LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWApO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGhhcyBhIHNldCBvZiBrbm93biBwcm9wZXJ0aWVzIG9mIHNwZWNpZmljIHR5cGVzLlxuICpcbiAqIE5vdGU6IFVucmVjb2duaXplZCBwcm9wZXJ0aWVzIGFyZSBhbGxvd2VkIGFuZCB1bnRvdWNoZWQuIFRoaXMgaXMgc2ltaWxhciB0b1xuICogaG93IFR5cGVTY3JpcHQncyBzdHJ1Y3R1cmFsIHR5cGluZyB3b3Jrcy5cbiAqL1xuZnVuY3Rpb24gdHlwZShzY2hlbWEpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hKTtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICd0eXBlJyxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIFtrLCB2YWx1ZVtrXSwgc2NoZW1hW2tdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIChpc09iamVjdCh2YWx1ZSkgfHwgYEV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gKTtcbiAgICAgICAgfSxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSA/IHsgLi4udmFsdWUgfSA6IHZhbHVlO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIG1hdGNoZXMgb25lIG9mIGEgc2V0IG9mIHR5cGVzLlxuICovXG5mdW5jdGlvbiB1bmlvbihTdHJ1Y3RzKSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBTdHJ1Y3RzLm1hcCgocykgPT4gcy50eXBlKS5qb2luKCcgfCAnKTtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIHR5cGU6ICd1bmlvbicsXG4gICAgICAgIHNjaGVtYTogbnVsbCxcbiAgICAgICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbZXJyb3IsIGNvZXJjZWRdID0gUy52YWxpZGF0ZSh2YWx1ZSwgeyBjb2VyY2U6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29lcmNlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbLi4udHVwbGVzXSA9IHJ1bih2YWx1ZSwgUywgY3R4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBbZmlyc3RdID0gdHVwbGVzO1xuICAgICAgICAgICAgICAgIGlmICghZmlyc3RbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBbZmFpbHVyZV0gb2YgdHVwbGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhaWx1cmVzLnB1c2goZmFpbHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGBFeHBlY3RlZCB0aGUgdmFsdWUgdG8gc2F0aXNmeSBhIHVuaW9uIG9mIFxcYCR7ZGVzY3JpcHRpb259XFxgLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWAsXG4gICAgICAgICAgICAgICAgLi4uZmFpbHVyZXMsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhbnkgdmFsdWUgcGFzc2VzIHZhbGlkYXRpb24sIHdpdGhvdXQgd2lkZW5pbmcgaXRzIHR5cGUgdG8gYGFueWAuXG4gKi9cbmZ1bmN0aW9uIHVua25vd24oKSB7XG4gICAgcmV0dXJuIGRlZmluZSgndW5rbm93bicsICgpID0+IHRydWUpO1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYSBgU3RydWN0YCB0byBhZGQgYW4gYWRkaXRpb25hbCBjb2VyY2lvbiBzdGVwIHRvIGl0cyBpbnB1dC5cbiAqXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gdHJhbnNmb3JtIGlucHV0IGRhdGEgYmVmb3JlIHZhbGlkYXRpbmcgaXQsIHRvIGluY3JlYXNlIHRoZVxuICogbGlrZWxpaG9vZCB0aGF0IGl0IHBhc3NlcyB2YWxpZGF0aW9u4oCUZm9yIGV4YW1wbGUgZm9yIGRlZmF1bHQgdmFsdWVzLCBwYXJzaW5nXG4gKiBkaWZmZXJlbnQgZm9ybWF0cywgZXRjLlxuICpcbiAqIE5vdGU6IFlvdSBtdXN0IHVzZSBgY3JlYXRlKHZhbHVlLCBTdHJ1Y3QpYCBvbiB0aGUgdmFsdWUgdG8gaGF2ZSB0aGUgY29lcmNpb25cbiAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICovXG5mdW5jdGlvbiBjb2VyY2Uoc3RydWN0LCBjb25kaXRpb24sIGNvZXJjZXIpIHtcbiAgICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgICAgIC4uLnN0cnVjdCxcbiAgICAgICAgY29lcmNlcjogKHZhbHVlLCBjdHgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpcyh2YWx1ZSwgY29uZGl0aW9uKVxuICAgICAgICAgICAgICAgID8gc3RydWN0LmNvZXJjZXIoY29lcmNlcih2YWx1ZSwgY3R4KSwgY3R4KVxuICAgICAgICAgICAgICAgIDogc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBzdHJ1Y3QgdG8gcmVwbGFjZSBgdW5kZWZpbmVkYCB2YWx1ZXMgd2l0aCBhIGRlZmF1bHQuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRlZChzdHJ1Y3QsIGZhbGxiYWNrLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gY29lcmNlKHN0cnVjdCwgdW5rbm93bigpLCAoeCkgPT4ge1xuICAgICAgICBjb25zdCBmID0gdHlwZW9mIGZhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gZmFsbGJhY2soKSA6IGZhbGxiYWNrO1xuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9wdGlvbnMuc3RyaWN0ICYmIGlzUGxhaW5PYmplY3QoeCkgJiYgaXNQbGFpbk9iamVjdChmKSkge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0geyAuLi54IH07XG4gICAgICAgICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZikge1xuICAgICAgICAgICAgICAgIGlmIChyZXRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldFtrZXldID0gZltrZXldO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBzdHJ1Y3QgdG8gdHJpbSBzdHJpbmcgaW5wdXRzLlxuICpcbiAqIE5vdGU6IFlvdSBtdXN0IHVzZSBgY3JlYXRlKHZhbHVlLCBTdHJ1Y3QpYCBvbiB0aGUgdmFsdWUgdG8gaGF2ZSB0aGUgY29lcmNpb25cbiAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICovXG5mdW5jdGlvbiB0cmltbWVkKHN0cnVjdCkge1xuICAgIHJldHVybiBjb2VyY2Uoc3RydWN0LCBzdHJpbmcoKSwgKHgpID0+IHgudHJpbSgpKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG1hcCwgb3Igc2V0IGlzIGVtcHR5LlxuICovXG5mdW5jdGlvbiBlbXB0eShzdHJ1Y3QpIHtcbiAgICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ2VtcHR5JywgKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHNpemUgPSBnZXRTaXplKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIChzaXplID09PSAwIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYW4gZW1wdHkgJHtzdHJ1Y3QudHlwZX0gYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgc2l6ZSBvZiBcXGAke3NpemV9XFxgYCk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRTaXplKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5zaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcbiAgICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgbnVtYmVyIG9yIGRhdGUgaXMgYmVsb3cgYSB0aHJlc2hvbGQuXG4gKi9cbmZ1bmN0aW9uIG1heChzdHJ1Y3QsIHRocmVzaG9sZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBleGNsdXNpdmUgfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdtYXgnLCAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIGV4Y2x1c2l2ZVxuICAgICAgICAgICAgPyB2YWx1ZSA8IHRocmVzaG9sZFxuICAgICAgICAgICAgOiB2YWx1ZSA8PSB0aHJlc2hvbGQgfHxcbiAgICAgICAgICAgICAgICBgRXhwZWN0ZWQgYSAke3N0cnVjdC50eXBlfSBsZXNzIHRoYW4gJHtleGNsdXNpdmUgPyAnJyA6ICdvciBlcXVhbCB0byAnfSR7dGhyZXNob2xkfSBidXQgcmVjZWl2ZWQgXFxgJHt2YWx1ZX1cXGBgO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIG51bWJlciBvciBkYXRlIGlzIGFib3ZlIGEgdGhyZXNob2xkLlxuICovXG5mdW5jdGlvbiBtaW4oc3RydWN0LCB0aHJlc2hvbGQsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgZXhjbHVzaXZlIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnbWluJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiBleGNsdXNpdmVcbiAgICAgICAgICAgID8gdmFsdWUgPiB0aHJlc2hvbGRcbiAgICAgICAgICAgIDogdmFsdWUgPj0gdGhyZXNob2xkIHx8XG4gICAgICAgICAgICAgICAgYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX0gZ3JlYXRlciB0aGFuICR7ZXhjbHVzaXZlID8gJycgOiAnb3IgZXF1YWwgdG8gJ30ke3RocmVzaG9sZH0gYnV0IHJlY2VpdmVkIFxcYCR7dmFsdWV9XFxgYDtcbiAgICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBzdHJpbmcsIGFycmF5LCBtYXAgb3Igc2V0IGlzIG5vdCBlbXB0eS5cbiAqL1xuZnVuY3Rpb24gbm9uZW1wdHkoc3RydWN0KSB7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdub25lbXB0eScsICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBzaXplID0gZ2V0U2l6ZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiAoc2l6ZSA+IDAgfHwgYEV4cGVjdGVkIGEgbm9uZW1wdHkgJHtzdHJ1Y3QudHlwZX0gYnV0IHJlY2VpdmVkIGFuIGVtcHR5IG9uZWApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZyBtYXRjaGVzIGEgcmVndWxhciBleHByZXNzaW9uLlxuICovXG5mdW5jdGlvbiBwYXR0ZXJuKHN0cnVjdCwgcmVnZXhwKSB7XG4gICAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdwYXR0ZXJuJywgKHZhbHVlKSA9PiB7XG4gICAgICAgIHJldHVybiAocmVnZXhwLnRlc3QodmFsdWUpIHx8XG4gICAgICAgICAgICBgRXhwZWN0ZWQgYSAke3N0cnVjdC50eXBlfSBtYXRjaGluZyBcXGAvJHtyZWdleHAuc291cmNlfS9cXGAgYnV0IHJlY2VpdmVkIFwiJHt2YWx1ZX1cImApO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG51bWJlciwgZGF0ZSwgbWFwLCBvciBzZXQgaGFzIGEgc2l6ZSAob3IgbGVuZ3RoLCBvciB0aW1lKSBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YC5cbiAqL1xuZnVuY3Rpb24gc2l6ZShzdHJ1Y3QsIG1pbiwgbWF4ID0gbWluKSB7XG4gICAgY29uc3QgZXhwZWN0ZWQgPSBgRXhwZWN0ZWQgYSAke3N0cnVjdC50eXBlfWA7XG4gICAgY29uc3Qgb2YgPSBtaW4gPT09IG1heCA/IGBvZiBcXGAke21pbn1cXGBgIDogYGJldHdlZW4gXFxgJHttaW59XFxgIGFuZCBcXGAke21heH1cXGBgO1xuICAgIHJldHVybiByZWZpbmUoc3RydWN0LCAnc2l6ZScsICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAoKG1pbiA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBtYXgpIHx8XG4gICAgICAgICAgICAgICAgYCR7ZXhwZWN0ZWR9ICR7b2Z9IGJ1dCByZWNlaXZlZCBcXGAke3ZhbHVlfVxcYGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBjb25zdCB7IHNpemUgfSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuICgobWluIDw9IHNpemUgJiYgc2l6ZSA8PSBtYXgpIHx8XG4gICAgICAgICAgICAgICAgYCR7ZXhwZWN0ZWR9IHdpdGggYSBzaXplICR7b2Z9IGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIHNpemUgb2YgXFxgJHtzaXplfVxcYGApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgeyBsZW5ndGggfSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuICgobWluIDw9IGxlbmd0aCAmJiBsZW5ndGggPD0gbWF4KSB8fFxuICAgICAgICAgICAgICAgIGAke2V4cGVjdGVkfSB3aXRoIGEgbGVuZ3RoICR7b2Z9IGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIGxlbmd0aCBvZiBcXGAke2xlbmd0aH1cXGBgKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBBdWdtZW50IGEgYFN0cnVjdGAgdG8gYWRkIGFuIGFkZGl0aW9uYWwgcmVmaW5lbWVudCB0byB0aGUgdmFsaWRhdGlvbi5cbiAqXG4gKiBUaGUgcmVmaW5lciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJlY2VpdmUgYSB2YWx1ZSBvZiB0aGUgc3RydWN0J3MgdHlwZSxcbiAqIGJlY2F1c2UgdGhlIHN0cnVjdCdzIGV4aXN0aW5nIHZhbGlkYXRpb24gd2lsbCBhbHJlYWR5IGhhdmUgcGFzc2VkLiBUaGlzXG4gKiBhbGxvd3MgeW91IHRvIGxheWVyIGFkZGl0aW9uYWwgdmFsaWRhdGlvbiBvbiB0b3Agb2YgZXhpc3Rpbmcgc3RydWN0cy5cbiAqL1xuZnVuY3Rpb24gcmVmaW5lKHN0cnVjdCwgbmFtZSwgcmVmaW5lcikge1xuICAgIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICAgICAgLi4uc3RydWN0LFxuICAgICAgICAqcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICAgICAgICB5aWVsZCogc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgICAgICAgY29uc3QgZmFpbHVyZXMgPSB0b0ZhaWx1cmVzKHJlc3VsdCwgY3R4LCBzdHJ1Y3QsIHZhbHVlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBmYWlsdXJlcykge1xuICAgICAgICAgICAgICAgIHlpZWxkIHsgLi4uZmFpbHVyZSwgcmVmaW5lbWVudDogbmFtZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG5leHBvcnQgeyBTdHJ1Y3QsIFN0cnVjdEVycm9yLCBhbnksIGFycmF5LCBhc3NlcnQsIGFzc2lnbiwgYmlnaW50LCBib29sZWFuLCBjb2VyY2UsIGNyZWF0ZSwgZGF0ZSwgZGVmYXVsdGVkLCBkZWZpbmUsIGRlcHJlY2F0ZWQsIGR5bmFtaWMsIGVtcHR5LCBlbnVtcywgZnVuYywgaW5zdGFuY2UsIGludGVnZXIsIGludGVyc2VjdGlvbiwgaXMsIGxhenksIGxpdGVyYWwsIG1hcCwgbWFzaywgbWF4LCBtaW4sIG5ldmVyLCBub25lbXB0eSwgbnVsbGFibGUsIG51bWJlciwgb2JqZWN0LCBvbWl0LCBvcHRpb25hbCwgcGFydGlhbCwgcGF0dGVybiwgcGljaywgcmVjb3JkLCByZWZpbmUsIHJlZ2V4cCwgc2V0LCBzaXplLCBzdHJpbmcsIHN0cnVjdCwgdHJpbW1lZCwgdHVwbGUsIHR5cGUsIHVuaW9uLCB1bmtub3duLCB2YWxpZGF0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuIiwiaW1wb3J0IHtcbiAgZ2V0RXJyb3JNZXNzYWdlXG59IGZyb20gXCIuL2NodW5rLVhZR1VPWTZOLm1qc1wiO1xuXG4vLyBzcmMvYXNzZXJ0LnRzXG5pbXBvcnQgeyBhc3NlcnQgYXMgYXNzZXJ0U3VwZXJzdHJ1Y3QgfSBmcm9tIFwic3VwZXJzdHJ1Y3RcIjtcbmZ1bmN0aW9uIGlzQ29uc3RydWN0YWJsZShmbikge1xuICByZXR1cm4gQm9vbGVhbih0eXBlb2YgZm4/LnByb3RvdHlwZT8uY29uc3RydWN0b3I/Lm5hbWUgPT09IFwic3RyaW5nXCIpO1xufVxuZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlV2l0aG91dFRyYWlsaW5nUGVyaW9kKGVycm9yKSB7XG4gIHJldHVybiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpLnJlcGxhY2UoL1xcLiQvdSwgXCJcIik7XG59XG5mdW5jdGlvbiBnZXRFcnJvcihFcnJvcldyYXBwZXIsIG1lc3NhZ2UpIHtcbiAgaWYgKGlzQ29uc3RydWN0YWJsZShFcnJvcldyYXBwZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcldyYXBwZXIoe1xuICAgICAgbWVzc2FnZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBFcnJvcldyYXBwZXIoe1xuICAgIG1lc3NhZ2VcbiAgfSk7XG59XG52YXIgQXNzZXJ0aW9uRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMubWVzc2FnZSk7XG4gICAgdGhpcy5jb2RlID0gXCJFUlJfQVNTRVJUSU9OXCI7XG4gIH1cbn07XG5mdW5jdGlvbiBhc3NlcnQodmFsdWUsIG1lc3NhZ2UgPSBcIkFzc2VydGlvbiBmYWlsZWQuXCIsIEVycm9yV3JhcHBlciA9IEFzc2VydGlvbkVycm9yKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBtZXNzYWdlO1xuICAgIH1cbiAgICB0aHJvdyBnZXRFcnJvcihFcnJvcldyYXBwZXIsIG1lc3NhZ2UpO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRTdHJ1Y3QodmFsdWUsIHN0cnVjdCwgZXJyb3JQcmVmaXggPSBcIkFzc2VydGlvbiBmYWlsZWRcIiwgRXJyb3JXcmFwcGVyID0gQXNzZXJ0aW9uRXJyb3IpIHtcbiAgdHJ5IHtcbiAgICBhc3NlcnRTdXBlcnN0cnVjdCh2YWx1ZSwgc3RydWN0KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBnZXRFcnJvcihcbiAgICAgIEVycm9yV3JhcHBlcixcbiAgICAgIGAke2Vycm9yUHJlZml4fTogJHtnZXRFcnJvck1lc3NhZ2VXaXRob3V0VHJhaWxpbmdQZXJpb2QoZXJyb3IpfS5gXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0RXhoYXVzdGl2ZShfb2JqZWN0KSB7XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICBcIkludmFsaWQgYnJhbmNoIHJlYWNoZWQuIFNob3VsZCBiZSBkZXRlY3RlZCBkdXJpbmcgY29tcGlsYXRpb24uXCJcbiAgKTtcbn1cblxuZXhwb3J0IHtcbiAgQXNzZXJ0aW9uRXJyb3IsXG4gIGFzc2VydCxcbiAgYXNzZXJ0U3RydWN0LFxuICBhc3NlcnRFeGhhdXN0aXZlXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstNzRER1ZKVkUubWpzLm1hcCIsImltcG9ydCB7XG4gIGlzTnVsbE9yVW5kZWZpbmVkLFxuICBpc09iamVjdFxufSBmcm9tIFwiLi9jaHVuay1INFlGRExCNy5tanNcIjtcblxuLy8gc3JjL2Vycm9ycy50c1xuaW1wb3J0IHsgRXJyb3JXaXRoQ2F1c2UgfSBmcm9tIFwicG9ueS1jYXVzZVwiO1xuZnVuY3Rpb24gaXNFcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciB8fCBpc09iamVjdChlcnJvcikgJiYgZXJyb3IuY29uc3RydWN0b3IubmFtZSA9PT0gXCJFcnJvclwiO1xufVxuZnVuY3Rpb24gaXNFcnJvcldpdGhDb2RlKGVycm9yKSB7XG4gIHJldHVybiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgZXJyb3IgIT09IG51bGwgJiYgXCJjb2RlXCIgaW4gZXJyb3I7XG59XG5mdW5jdGlvbiBpc0Vycm9yV2l0aE1lc3NhZ2UoZXJyb3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBlcnJvciAhPT0gbnVsbCAmJiBcIm1lc3NhZ2VcIiBpbiBlcnJvcjtcbn1cbmZ1bmN0aW9uIGlzRXJyb3JXaXRoU3RhY2soZXJyb3IpIHtcbiAgcmV0dXJuIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBlcnJvciAhPT0gbnVsbCAmJiBcInN0YWNrXCIgaW4gZXJyb3I7XG59XG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpIHtcbiAgaWYgKGlzRXJyb3JXaXRoTWVzc2FnZShlcnJvcikgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgfVxuICBpZiAoaXNOdWxsT3JVbmRlZmluZWQoZXJyb3IpKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyhlcnJvcik7XG59XG5mdW5jdGlvbiB3cmFwRXJyb3Iob3JpZ2luYWxFcnJvciwgbWVzc2FnZSkge1xuICBpZiAoaXNFcnJvcihvcmlnaW5hbEVycm9yKSkge1xuICAgIGxldCBlcnJvcjtcbiAgICBpZiAoRXJyb3IubGVuZ3RoID09PSAyKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlLCB7IGNhdXNlOiBvcmlnaW5hbEVycm9yIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcldpdGhDYXVzZShtZXNzYWdlLCB7IGNhdXNlOiBvcmlnaW5hbEVycm9yIH0pO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcldpdGhDb2RlKG9yaWdpbmFsRXJyb3IpKSB7XG4gICAgICBlcnJvci5jb2RlID0gb3JpZ2luYWxFcnJvci5jb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG4gIH1cbiAgaWYgKG1lc3NhZ2UubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBuZXcgRXJyb3IoYCR7U3RyaW5nKG9yaWdpbmFsRXJyb3IpfTogJHttZXNzYWdlfWApO1xuICB9XG4gIHJldHVybiBuZXcgRXJyb3IoU3RyaW5nKG9yaWdpbmFsRXJyb3IpKTtcbn1cblxuZXhwb3J0IHtcbiAgaXNFcnJvcldpdGhDb2RlLFxuICBpc0Vycm9yV2l0aE1lc3NhZ2UsXG4gIGlzRXJyb3JXaXRoU3RhY2ssXG4gIGdldEVycm9yTWVzc2FnZSxcbiAgd3JhcEVycm9yXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstWFlHVU9ZNk4ubWpzLm1hcCIsImltcG9ydCB7XG4gIGFzc2VydFN0cnVjdFxufSBmcm9tIFwiLi9jaHVuay03NERHVkpWRS5tanNcIjtcbmltcG9ydCB7XG4gIGhhc1Byb3BlcnR5XG59IGZyb20gXCIuL2NodW5rLUg0WUZETEI3Lm1qc1wiO1xuXG4vLyBzcmMvanNvbi50c1xuaW1wb3J0IHtcbiAgYW55LFxuICBhcnJheSxcbiAgYm9vbGVhbixcbiAgY29lcmNlLFxuICBjcmVhdGUsXG4gIGRlZmluZSxcbiAgaW50ZWdlcixcbiAgaXMsXG4gIGxhenksXG4gIGxpdGVyYWwsXG4gIG51bGxhYmxlLFxuICBudW1iZXIsXG4gIG9iamVjdCBhcyBzdXBlcnN0cnVjdE9iamVjdCxcbiAgb3B0aW9uYWwsXG4gIHJlY29yZCxcbiAgc3RyaW5nLFxuICB1bmlvbixcbiAgdW5rbm93bixcbiAgU3RydWN0XG59IGZyb20gXCJzdXBlcnN0cnVjdFwiO1xudmFyIG9iamVjdCA9IChzY2hlbWEpID0+IChcbiAgLy8gVGhlIHR5cGUgaXMgc2xpZ2h0bHkgZGlmZmVyZW50IGZyb20gYSByZWd1bGFyIG9iamVjdCBzdHJ1Y3QsIGJlY2F1c2Ugd2VcbiAgLy8gd2FudCB0byBtYWtlIHByb3BlcnRpZXMgd2l0aCBgdW5kZWZpbmVkYCBpbiB0aGVpciB0eXBlIG9wdGlvbmFsLCBidXQgbm90XG4gIC8vIGB1bmRlZmluZWRgIGl0c2VsZi4gVGhpcyBtZWFucyB0aGF0IHdlIG5lZWQgYSB0eXBlIGNhc3QuXG4gIHN1cGVyc3RydWN0T2JqZWN0KHNjaGVtYSlcbik7XG5mdW5jdGlvbiBoYXNPcHRpb25hbCh7IHBhdGgsIGJyYW5jaCB9KSB7XG4gIGNvbnN0IGZpZWxkID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gaGFzUHJvcGVydHkoYnJhbmNoW2JyYW5jaC5sZW5ndGggLSAyXSwgZmllbGQpO1xufVxuZnVuY3Rpb24gZXhhY3RPcHRpb25hbChzdHJ1Y3QpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIC4uLnN0cnVjdCxcbiAgICB0eXBlOiBgb3B0aW9uYWwgJHtzdHJ1Y3QudHlwZX1gLFxuICAgIHZhbGlkYXRvcjogKHZhbHVlLCBjb250ZXh0KSA9PiAhaGFzT3B0aW9uYWwoY29udGV4dCkgfHwgc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY29udGV4dCksXG4gICAgcmVmaW5lcjogKHZhbHVlLCBjb250ZXh0KSA9PiAhaGFzT3B0aW9uYWwoY29udGV4dCkgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGNvbnRleHQpXG4gIH0pO1xufVxudmFyIGZpbml0ZU51bWJlciA9ICgpID0+IGRlZmluZShcImZpbml0ZSBudW1iZXJcIiwgKHZhbHVlKSA9PiB7XG4gIHJldHVybiBpcyh2YWx1ZSwgbnVtYmVyKCkpICYmIE51bWJlci5pc0Zpbml0ZSh2YWx1ZSk7XG59KTtcbnZhciBVbnNhZmVKc29uU3RydWN0ID0gdW5pb24oW1xuICBsaXRlcmFsKG51bGwpLFxuICBib29sZWFuKCksXG4gIGZpbml0ZU51bWJlcigpLFxuICBzdHJpbmcoKSxcbiAgYXJyYXkobGF6eSgoKSA9PiBVbnNhZmVKc29uU3RydWN0KSksXG4gIHJlY29yZChcbiAgICBzdHJpbmcoKSxcbiAgICBsYXp5KCgpID0+IFVuc2FmZUpzb25TdHJ1Y3QpXG4gIClcbl0pO1xudmFyIEpzb25TdHJ1Y3QgPSBjb2VyY2UoVW5zYWZlSnNvblN0cnVjdCwgYW55KCksICh2YWx1ZSkgPT4ge1xuICBhc3NlcnRTdHJ1Y3QodmFsdWUsIFVuc2FmZUpzb25TdHJ1Y3QpO1xuICByZXR1cm4gSlNPTi5wYXJzZShcbiAgICBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgKHByb3BLZXksIHByb3BWYWx1ZSkgPT4ge1xuICAgICAgaWYgKHByb3BLZXkgPT09IFwiX19wcm90b19fXCIgfHwgcHJvcEtleSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcFZhbHVlO1xuICAgIH0pXG4gICk7XG59KTtcbmZ1bmN0aW9uIGlzVmFsaWRKc29uKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgZ2V0U2FmZUpzb24odmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFNhZmVKc29uKHZhbHVlKSB7XG4gIHJldHVybiBjcmVhdGUodmFsdWUsIEpzb25TdHJ1Y3QpO1xufVxuZnVuY3Rpb24gZ2V0SnNvblNpemUodmFsdWUpIHtcbiAgYXNzZXJ0U3RydWN0KHZhbHVlLCBKc29uU3RydWN0LCBcIkludmFsaWQgSlNPTiB2YWx1ZVwiKTtcbiAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShqc29uKS5ieXRlTGVuZ3RoO1xufVxudmFyIGpzb25ycGMyID0gXCIyLjBcIjtcbnZhciBKc29uUnBjVmVyc2lvblN0cnVjdCA9IGxpdGVyYWwoanNvbnJwYzIpO1xudmFyIEpzb25ScGNJZFN0cnVjdCA9IG51bGxhYmxlKHVuaW9uKFtudW1iZXIoKSwgc3RyaW5nKCldKSk7XG52YXIgSnNvblJwY0Vycm9yU3RydWN0ID0gb2JqZWN0KHtcbiAgY29kZTogaW50ZWdlcigpLFxuICBtZXNzYWdlOiBzdHJpbmcoKSxcbiAgZGF0YTogZXhhY3RPcHRpb25hbChKc29uU3RydWN0KSxcbiAgc3RhY2s6IGV4YWN0T3B0aW9uYWwoc3RyaW5nKCkpXG59KTtcbnZhciBKc29uUnBjUGFyYW1zU3RydWN0ID0gdW5pb24oW3JlY29yZChzdHJpbmcoKSwgSnNvblN0cnVjdCksIGFycmF5KEpzb25TdHJ1Y3QpXSk7XG52YXIgSnNvblJwY1JlcXVlc3RTdHJ1Y3QgPSBvYmplY3Qoe1xuICBpZDogSnNvblJwY0lkU3RydWN0LFxuICBqc29ucnBjOiBKc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgbWV0aG9kOiBzdHJpbmcoKSxcbiAgcGFyYW1zOiBleGFjdE9wdGlvbmFsKEpzb25ScGNQYXJhbXNTdHJ1Y3QpXG59KTtcbnZhciBKc29uUnBjTm90aWZpY2F0aW9uU3RydWN0ID0gb2JqZWN0KHtcbiAganNvbnJwYzogSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gIG1ldGhvZDogc3RyaW5nKCksXG4gIHBhcmFtczogZXhhY3RPcHRpb25hbChKc29uUnBjUGFyYW1zU3RydWN0KVxufSk7XG5mdW5jdGlvbiBpc0pzb25ScGNOb3RpZmljYXRpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzKHZhbHVlLCBKc29uUnBjTm90aWZpY2F0aW9uU3RydWN0KTtcbn1cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY05vdGlmaWNhdGlvbih2YWx1ZSwgRXJyb3JXcmFwcGVyKSB7XG4gIGFzc2VydFN0cnVjdChcbiAgICB2YWx1ZSxcbiAgICBKc29uUnBjTm90aWZpY2F0aW9uU3RydWN0LFxuICAgIFwiSW52YWxpZCBKU09OLVJQQyBub3RpZmljYXRpb25cIixcbiAgICBFcnJvcldyYXBwZXJcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzSnNvblJwY1JlcXVlc3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzKHZhbHVlLCBKc29uUnBjUmVxdWVzdFN0cnVjdCk7XG59XG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNSZXF1ZXN0KHZhbHVlLCBFcnJvcldyYXBwZXIpIHtcbiAgYXNzZXJ0U3RydWN0KFxuICAgIHZhbHVlLFxuICAgIEpzb25ScGNSZXF1ZXN0U3RydWN0LFxuICAgIFwiSW52YWxpZCBKU09OLVJQQyByZXF1ZXN0XCIsXG4gICAgRXJyb3JXcmFwcGVyXG4gICk7XG59XG52YXIgUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCA9IHN1cGVyc3RydWN0T2JqZWN0KHtcbiAgaWQ6IEpzb25ScGNJZFN0cnVjdCxcbiAganNvbnJwYzogSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gIHJlc3VsdDogb3B0aW9uYWwodW5rbm93bigpKSxcbiAgZXJyb3I6IG9wdGlvbmFsKEpzb25ScGNFcnJvclN0cnVjdClcbn0pO1xudmFyIEpzb25ScGNTdWNjZXNzU3RydWN0ID0gb2JqZWN0KHtcbiAgaWQ6IEpzb25ScGNJZFN0cnVjdCxcbiAganNvbnJwYzogSnNvblJwY1ZlcnNpb25TdHJ1Y3QsXG4gIHJlc3VsdDogSnNvblN0cnVjdFxufSk7XG52YXIgSnNvblJwY0ZhaWx1cmVTdHJ1Y3QgPSBvYmplY3Qoe1xuICBpZDogSnNvblJwY0lkU3RydWN0LFxuICBqc29ucnBjOiBKc29uUnBjVmVyc2lvblN0cnVjdCxcbiAgZXJyb3I6IEpzb25ScGNFcnJvclN0cnVjdFxufSk7XG52YXIgSnNvblJwY1Jlc3BvbnNlU3RydWN0ID0gdW5pb24oW1xuICBKc29uUnBjU3VjY2Vzc1N0cnVjdCxcbiAgSnNvblJwY0ZhaWx1cmVTdHJ1Y3Rcbl0pO1xuZnVuY3Rpb24gaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIHJldHVybiBpcyhyZXNwb25zZSwgUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCk7XG59XG5mdW5jdGlvbiBhc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UocmVzcG9uc2UsIEVycm9yV3JhcHBlcikge1xuICBhc3NlcnRTdHJ1Y3QoXG4gICAgcmVzcG9uc2UsXG4gICAgUGVuZGluZ0pzb25ScGNSZXNwb25zZVN0cnVjdCxcbiAgICBcIkludmFsaWQgcGVuZGluZyBKU09OLVJQQyByZXNwb25zZVwiLFxuICAgIEVycm9yV3JhcHBlclxuICApO1xufVxuZnVuY3Rpb24gaXNKc29uUnBjUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgcmV0dXJuIGlzKHJlc3BvbnNlLCBKc29uUnBjUmVzcG9uc2VTdHJ1Y3QpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNKc29uUnBjUmVzcG9uc2UodmFsdWUsIEVycm9yV3JhcHBlcikge1xuICBhc3NlcnRTdHJ1Y3QoXG4gICAgdmFsdWUsXG4gICAgSnNvblJwY1Jlc3BvbnNlU3RydWN0LFxuICAgIFwiSW52YWxpZCBKU09OLVJQQyByZXNwb25zZVwiLFxuICAgIEVycm9yV3JhcHBlclxuICApO1xufVxuZnVuY3Rpb24gaXNKc29uUnBjU3VjY2Vzcyh2YWx1ZSkge1xuICByZXR1cm4gaXModmFsdWUsIEpzb25ScGNTdWNjZXNzU3RydWN0KTtcbn1cbmZ1bmN0aW9uIGFzc2VydElzSnNvblJwY1N1Y2Nlc3ModmFsdWUsIEVycm9yV3JhcHBlcikge1xuICBhc3NlcnRTdHJ1Y3QoXG4gICAgdmFsdWUsXG4gICAgSnNvblJwY1N1Y2Nlc3NTdHJ1Y3QsXG4gICAgXCJJbnZhbGlkIEpTT04tUlBDIHN1Y2Nlc3MgcmVzcG9uc2VcIixcbiAgICBFcnJvcldyYXBwZXJcbiAgKTtcbn1cbmZ1bmN0aW9uIGlzSnNvblJwY0ZhaWx1cmUodmFsdWUpIHtcbiAgcmV0dXJuIGlzKHZhbHVlLCBKc29uUnBjRmFpbHVyZVN0cnVjdCk7XG59XG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNGYWlsdXJlKHZhbHVlLCBFcnJvcldyYXBwZXIpIHtcbiAgYXNzZXJ0U3RydWN0KFxuICAgIHZhbHVlLFxuICAgIEpzb25ScGNGYWlsdXJlU3RydWN0LFxuICAgIFwiSW52YWxpZCBKU09OLVJQQyBmYWlsdXJlIHJlc3BvbnNlXCIsXG4gICAgRXJyb3JXcmFwcGVyXG4gICk7XG59XG5mdW5jdGlvbiBpc0pzb25ScGNFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gaXModmFsdWUsIEpzb25ScGNFcnJvclN0cnVjdCk7XG59XG5mdW5jdGlvbiBhc3NlcnRJc0pzb25ScGNFcnJvcih2YWx1ZSwgRXJyb3JXcmFwcGVyKSB7XG4gIGFzc2VydFN0cnVjdChcbiAgICB2YWx1ZSxcbiAgICBKc29uUnBjRXJyb3JTdHJ1Y3QsXG4gICAgXCJJbnZhbGlkIEpTT04tUlBDIGVycm9yXCIsXG4gICAgRXJyb3JXcmFwcGVyXG4gICk7XG59XG5mdW5jdGlvbiBnZXRKc29uUnBjSWRWYWxpZGF0b3Iob3B0aW9ucykge1xuICBjb25zdCB7IHBlcm1pdEVtcHR5U3RyaW5nLCBwZXJtaXRGcmFjdGlvbnMsIHBlcm1pdE51bGwgfSA9IHtcbiAgICBwZXJtaXRFbXB0eVN0cmluZzogdHJ1ZSxcbiAgICBwZXJtaXRGcmFjdGlvbnM6IGZhbHNlLFxuICAgIHBlcm1pdE51bGw6IHRydWUsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBjb25zdCBpc1ZhbGlkSnNvblJwY0lkID0gKGlkKSA9PiB7XG4gICAgcmV0dXJuIEJvb2xlYW4oXG4gICAgICB0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIgJiYgKHBlcm1pdEZyYWN0aW9ucyB8fCBOdW1iZXIuaXNJbnRlZ2VyKGlkKSkgfHwgdHlwZW9mIGlkID09PSBcInN0cmluZ1wiICYmIChwZXJtaXRFbXB0eVN0cmluZyB8fCBpZC5sZW5ndGggPiAwKSB8fCBwZXJtaXROdWxsICYmIGlkID09PSBudWxsXG4gICAgKTtcbiAgfTtcbiAgcmV0dXJuIGlzVmFsaWRKc29uUnBjSWQ7XG59XG5cbmV4cG9ydCB7XG4gIG9iamVjdCxcbiAgZXhhY3RPcHRpb25hbCxcbiAgVW5zYWZlSnNvblN0cnVjdCxcbiAgSnNvblN0cnVjdCxcbiAgaXNWYWxpZEpzb24sXG4gIGdldFNhZmVKc29uLFxuICBnZXRKc29uU2l6ZSxcbiAganNvbnJwYzIsXG4gIEpzb25ScGNWZXJzaW9uU3RydWN0LFxuICBKc29uUnBjSWRTdHJ1Y3QsXG4gIEpzb25ScGNFcnJvclN0cnVjdCxcbiAgSnNvblJwY1BhcmFtc1N0cnVjdCxcbiAgSnNvblJwY1JlcXVlc3RTdHJ1Y3QsXG4gIEpzb25ScGNOb3RpZmljYXRpb25TdHJ1Y3QsXG4gIGlzSnNvblJwY05vdGlmaWNhdGlvbixcbiAgYXNzZXJ0SXNKc29uUnBjTm90aWZpY2F0aW9uLFxuICBpc0pzb25ScGNSZXF1ZXN0LFxuICBhc3NlcnRJc0pzb25ScGNSZXF1ZXN0LFxuICBQZW5kaW5nSnNvblJwY1Jlc3BvbnNlU3RydWN0LFxuICBKc29uUnBjU3VjY2Vzc1N0cnVjdCxcbiAgSnNvblJwY0ZhaWx1cmVTdHJ1Y3QsXG4gIEpzb25ScGNSZXNwb25zZVN0cnVjdCxcbiAgaXNQZW5kaW5nSnNvblJwY1Jlc3BvbnNlLFxuICBhc3NlcnRJc1BlbmRpbmdKc29uUnBjUmVzcG9uc2UsXG4gIGlzSnNvblJwY1Jlc3BvbnNlLFxuICBhc3NlcnRJc0pzb25ScGNSZXNwb25zZSxcbiAgaXNKc29uUnBjU3VjY2VzcyxcbiAgYXNzZXJ0SXNKc29uUnBjU3VjY2VzcyxcbiAgaXNKc29uUnBjRmFpbHVyZSxcbiAgYXNzZXJ0SXNKc29uUnBjRmFpbHVyZSxcbiAgaXNKc29uUnBjRXJyb3IsXG4gIGFzc2VydElzSnNvblJwY0Vycm9yLFxuICBnZXRKc29uUnBjSWRWYWxpZGF0b3Jcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay02QzM1WFFPRi5tanMubWFwIiwiaW1wb3J0IHtcbiAgZXJyb3JDb2RlcyxcbiAgZXJyb3JWYWx1ZXNcbn0gZnJvbSBcIi4vY2h1bmstTUlXNE5NWTYubWpzXCI7XG5cbi8vIHNyYy91dGlscy50c1xuaW1wb3J0IHtcbiAgaGFzUHJvcGVydHksXG4gIGlzVmFsaWRKc29uLFxuICBpc09iamVjdCxcbiAgaXNKc29uUnBjRXJyb3Jcbn0gZnJvbSBcIkBtZXRhbWFzay91dGlsc1wiO1xudmFyIEZBTExCQUNLX0VSUk9SX0NPREUgPSBlcnJvckNvZGVzLnJwYy5pbnRlcm5hbDtcbnZhciBGQUxMQkFDS19NRVNTQUdFID0gXCJVbnNwZWNpZmllZCBlcnJvciBtZXNzYWdlLiBUaGlzIGlzIGEgYnVnLCBwbGVhc2UgcmVwb3J0IGl0LlwiO1xudmFyIEZBTExCQUNLX0VSUk9SID0ge1xuICBjb2RlOiBGQUxMQkFDS19FUlJPUl9DT0RFLFxuICBtZXNzYWdlOiBnZXRNZXNzYWdlRnJvbUNvZGUoRkFMTEJBQ0tfRVJST1JfQ09ERSlcbn07XG52YXIgSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0UgPSBcIlVuc3BlY2lmaWVkIHNlcnZlciBlcnJvci5cIjtcbmZ1bmN0aW9uIGdldE1lc3NhZ2VGcm9tQ29kZShjb2RlLCBmYWxsYmFja01lc3NhZ2UgPSBGQUxMQkFDS19NRVNTQUdFKSB7XG4gIGlmIChpc1ZhbGlkQ29kZShjb2RlKSkge1xuICAgIGNvbnN0IGNvZGVTdHJpbmcgPSBjb2RlLnRvU3RyaW5nKCk7XG4gICAgaWYgKGhhc1Byb3BlcnR5KGVycm9yVmFsdWVzLCBjb2RlU3RyaW5nKSkge1xuICAgICAgcmV0dXJuIGVycm9yVmFsdWVzW2NvZGVTdHJpbmddLm1lc3NhZ2U7XG4gICAgfVxuICAgIGlmIChpc0pzb25ScGNTZXJ2ZXJFcnJvcihjb2RlKSkge1xuICAgICAgcmV0dXJuIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9NRVNTQUdFO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsbGJhY2tNZXNzYWdlO1xufVxuZnVuY3Rpb24gaXNWYWxpZENvZGUoY29kZSkge1xuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihjb2RlKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9yKGVycm9yLCB7IGZhbGxiYWNrRXJyb3IgPSBGQUxMQkFDS19FUlJPUiwgc2hvdWxkSW5jbHVkZVN0YWNrID0gdHJ1ZSB9ID0ge30pIHtcbiAgaWYgKCFpc0pzb25ScGNFcnJvcihmYWxsYmFja0Vycm9yKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiTXVzdCBwcm92aWRlIGZhbGxiYWNrIGVycm9yIHdpdGggaW50ZWdlciBudW1iZXIgY29kZSBhbmQgc3RyaW5nIG1lc3NhZ2UuXCJcbiAgICApO1xuICB9XG4gIGNvbnN0IHNlcmlhbGl6ZWQgPSBidWlsZEVycm9yKGVycm9yLCBmYWxsYmFja0Vycm9yKTtcbiAgaWYgKCFzaG91bGRJbmNsdWRlU3RhY2spIHtcbiAgICBkZWxldGUgc2VyaWFsaXplZC5zdGFjaztcbiAgfVxuICByZXR1cm4gc2VyaWFsaXplZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXJyb3IoZXJyb3IsIGZhbGxiYWNrRXJyb3IpIHtcbiAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIiAmJiBcInNlcmlhbGl6ZVwiIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5zZXJpYWxpemUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBlcnJvci5zZXJpYWxpemUoKTtcbiAgfVxuICBpZiAoaXNKc29uUnBjRXJyb3IoZXJyb3IpKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGNvbnN0IGNhdXNlID0gc2VyaWFsaXplQ2F1c2UoZXJyb3IpO1xuICBjb25zdCBmYWxsYmFja1dpdGhDYXVzZSA9IHtcbiAgICAuLi5mYWxsYmFja0Vycm9yLFxuICAgIGRhdGE6IHsgY2F1c2UgfVxuICB9O1xuICByZXR1cm4gZmFsbGJhY2tXaXRoQ2F1c2U7XG59XG5mdW5jdGlvbiBpc0pzb25ScGNTZXJ2ZXJFcnJvcihjb2RlKSB7XG4gIHJldHVybiBjb2RlID49IC0zMjA5OSAmJiBjb2RlIDw9IC0zMmUzO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQ2F1c2UoZXJyb3IpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZXJyb3IpKSB7XG4gICAgcmV0dXJuIGVycm9yLm1hcCgoZW50cnkpID0+IHtcbiAgICAgIGlmIChpc1ZhbGlkSnNvbihlbnRyeSkpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChlbnRyeSkpIHtcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZU9iamVjdChlbnRyeSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc09iamVjdChlcnJvcikpIHtcbiAgICByZXR1cm4gc2VyaWFsaXplT2JqZWN0KGVycm9yKTtcbiAgfVxuICBpZiAoaXNWYWxpZEpzb24oZXJyb3IpKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KS5yZWR1Y2UoXG4gICAgKGFjYywga2V5KSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgaWYgKGlzVmFsaWRKc29uKHZhbHVlKSkge1xuICAgICAgICBhY2Nba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LFxuICAgIHt9XG4gICk7XG59XG5cbmV4cG9ydCB7XG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9NRVNTQUdFLFxuICBnZXRNZXNzYWdlRnJvbUNvZGUsXG4gIGlzVmFsaWRDb2RlLFxuICBzZXJpYWxpemVFcnJvcixcbiAgc2VyaWFsaXplQ2F1c2Vcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1NUFUzQ1ZYMy5tanMubWFwIiwibW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdpZnlcbnN0cmluZ2lmeS5kZWZhdWx0ID0gc3RyaW5naWZ5XG5zdHJpbmdpZnkuc3RhYmxlID0gZGV0ZXJtaW5pc3RpY1N0cmluZ2lmeVxuc3RyaW5naWZ5LnN0YWJsZVN0cmluZ2lmeSA9IGRldGVybWluaXN0aWNTdHJpbmdpZnlcblxudmFyIExJTUlUX1JFUExBQ0VfTk9ERSA9ICdbLi4uXSdcbnZhciBDSVJDVUxBUl9SRVBMQUNFX05PREUgPSAnW0NpcmN1bGFyXSdcblxudmFyIGFyciA9IFtdXG52YXIgcmVwbGFjZXJTdGFjayA9IFtdXG5cbmZ1bmN0aW9uIGRlZmF1bHRPcHRpb25zICgpIHtcbiAgcmV0dXJuIHtcbiAgICBkZXB0aExpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICBlZGdlc0xpbWl0OiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICB9XG59XG5cbi8vIFJlZ3VsYXIgc3RyaW5naWZ5XG5mdW5jdGlvbiBzdHJpbmdpZnkgKG9iaiwgcmVwbGFjZXIsIHNwYWNlciwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zKClcbiAgfVxuXG4gIGRlY2lyYyhvYmosICcnLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKVxuICB2YXIgcmVzXG4gIHRyeSB7XG4gICAgaWYgKHJlcGxhY2VyU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeShvYmosIHJlcGxhY2VyLCBzcGFjZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IEpTT04uc3RyaW5naWZ5KG9iaiwgcmVwbGFjZUdldHRlclZhbHVlcyhyZXBsYWNlciksIHNwYWNlcilcbiAgICB9XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoJ1t1bmFibGUgdG8gc2VyaWFsaXplLCBjaXJjdWxhciByZWZlcmVuY2UgaXMgdG9vIGNvbXBsZXggdG8gYW5hbHl6ZV0nKVxuICB9IGZpbmFsbHkge1xuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgcGFydCA9IGFyci5wb3AoKVxuICAgICAgaWYgKHBhcnQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBzZXRSZXBsYWNlIChyZXBsYWNlLCB2YWwsIGssIHBhcmVudCkge1xuICB2YXIgcHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIGspXG4gIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IuZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAocHJvcGVydHlEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHBhcmVudCwgaywgeyB2YWx1ZTogcmVwbGFjZSB9KVxuICAgICAgYXJyLnB1c2goW3BhcmVudCwgaywgdmFsLCBwcm9wZXJ0eURlc2NyaXB0b3JdKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlclN0YWNrLnB1c2goW3ZhbCwgaywgcmVwbGFjZV0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcmVudFtrXSA9IHJlcGxhY2VcbiAgICBhcnIucHVzaChbcGFyZW50LCBrLCB2YWxdKVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlY2lyYyAodmFsLCBrLCBlZGdlSW5kZXgsIHN0YWNrLCBwYXJlbnQsIGRlcHRoLCBvcHRpb25zKSB7XG4gIGRlcHRoICs9IDFcbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHN0YWNrW2ldID09PSB2YWwpIHtcbiAgICAgICAgc2V0UmVwbGFjZShDSVJDVUxBUl9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygb3B0aW9ucy5kZXB0aExpbWl0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgZGVwdGggPiBvcHRpb25zLmRlcHRoTGltaXRcbiAgICApIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLmVkZ2VzTGltaXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBlZGdlSW5kZXggKyAxID4gb3B0aW9ucy5lZGdlc0xpbWl0XG4gICAgKSB7XG4gICAgICBzZXRSZXBsYWNlKExJTUlUX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzdGFjay5wdXNoKHZhbClcbiAgICAvLyBPcHRpbWl6ZSBmb3IgQXJyYXlzLiBCaWcgYXJyYXlzIGNvdWxkIGtpbGwgdGhlIHBlcmZvcm1hbmNlIG90aGVyd2lzZSFcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbClcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldXG4gICAgICAgIGRlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhY2sucG9wKClcbiAgfVxufVxuXG4vLyBTdGFibGUtc3RyaW5naWZ5XG5mdW5jdGlvbiBjb21wYXJlRnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljU3RyaW5naWZ5IChvYmosIHJlcGxhY2VyLCBzcGFjZXIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucygpXG4gIH1cblxuICB2YXIgdG1wID0gZGV0ZXJtaW5pc3RpY0RlY2lyYyhvYmosICcnLCAwLCBbXSwgdW5kZWZpbmVkLCAwLCBvcHRpb25zKSB8fCBvYmpcbiAgdmFyIHJlc1xuICB0cnkge1xuICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmVzID0gSlNPTi5zdHJpbmdpZnkodG1wLCByZXBsYWNlciwgc3BhY2VyKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSBKU09OLnN0cmluZ2lmeSh0bXAsIHJlcGxhY2VHZXR0ZXJWYWx1ZXMocmVwbGFjZXIpLCBzcGFjZXIpXG4gICAgfVxuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KCdbdW5hYmxlIHRvIHNlcmlhbGl6ZSwgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIHRvbyBjb21wbGV4IHRvIGFuYWx5emVdJylcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXN0b3JlIHRoZSBvYmplY3QgYXMgaXQgd2FzLlxuICAgIHdoaWxlIChhcnIubGVuZ3RoICE9PSAwKSB7XG4gICAgICB2YXIgcGFydCA9IGFyci5wb3AoKVxuICAgICAgaWYgKHBhcnQubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwYXJ0WzBdLCBwYXJ0WzFdLCBwYXJ0WzNdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydFswXVtwYXJ0WzFdXSA9IHBhcnRbMl1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmlzdGljRGVjaXJjICh2YWwsIGssIGVkZ2VJbmRleCwgc3RhY2ssIHBhcmVudCwgZGVwdGgsIG9wdGlvbnMpIHtcbiAgZGVwdGggKz0gMVxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgJiYgdmFsICE9PSBudWxsKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc3RhY2tbaV0gPT09IHZhbCkge1xuICAgICAgICBzZXRSZXBsYWNlKENJUkNVTEFSX1JFUExBQ0VfTk9ERSwgdmFsLCBrLCBwYXJlbnQpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiB2YWwudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLmRlcHRoTGltaXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBkZXB0aCA+IG9wdGlvbnMuZGVwdGhMaW1pdFxuICAgICkge1xuICAgICAgc2V0UmVwbGFjZShMSU1JVF9SRVBMQUNFX05PREUsIHZhbCwgaywgcGFyZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnMuZWRnZXNMaW1pdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIGVkZ2VJbmRleCArIDEgPiBvcHRpb25zLmVkZ2VzTGltaXRcbiAgICApIHtcbiAgICAgIHNldFJlcGxhY2UoTElNSVRfUkVQTEFDRV9OT0RFLCB2YWwsIGssIHBhcmVudClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHN0YWNrLnB1c2godmFsKVxuICAgIC8vIE9wdGltaXplIGZvciBBcnJheXMuIEJpZyBhcnJheXMgY291bGQga2lsbCB0aGUgcGVyZm9ybWFuY2Ugb3RoZXJ3aXNlIVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxbaV0sIGksIGksIHN0YWNrLCB2YWwsIGRlcHRoLCBvcHRpb25zKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgYSB0ZW1wb3Jhcnkgb2JqZWN0IGluIHRoZSByZXF1aXJlZCB3YXlcbiAgICAgIHZhciB0bXAgPSB7fVxuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpLnNvcnQoY29tcGFyZUZ1bmN0aW9uKVxuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV1cbiAgICAgICAgZGV0ZXJtaW5pc3RpY0RlY2lyYyh2YWxba2V5XSwga2V5LCBpLCBzdGFjaywgdmFsLCBkZXB0aCwgb3B0aW9ucylcbiAgICAgICAgdG1wW2tleV0gPSB2YWxba2V5XVxuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJlbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGFyci5wdXNoKFtwYXJlbnQsIGssIHZhbF0pXG4gICAgICAgIHBhcmVudFtrXSA9IHRtcFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRtcFxuICAgICAgfVxuICAgIH1cbiAgICBzdGFjay5wb3AoKVxuICB9XG59XG5cbi8vIHdyYXBzIHJlcGxhY2VyIGZ1bmN0aW9uIHRvIGhhbmRsZSB2YWx1ZXMgd2UgY291bGRuJ3QgcmVwbGFjZVxuLy8gYW5kIG1hcmsgdGhlbSBhcyByZXBsYWNlZCB2YWx1ZVxuZnVuY3Rpb24gcmVwbGFjZUdldHRlclZhbHVlcyAocmVwbGFjZXIpIHtcbiAgcmVwbGFjZXIgPVxuICAgIHR5cGVvZiByZXBsYWNlciAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gcmVwbGFjZXJcbiAgICAgIDogZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgICAgcmV0dXJuIHZcbiAgICAgIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbCkge1xuICAgIGlmIChyZXBsYWNlclN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwbGFjZXJTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IHJlcGxhY2VyU3RhY2tbaV1cbiAgICAgICAgaWYgKHBhcnRbMV0gPT09IGtleSAmJiBwYXJ0WzBdID09PSB2YWwpIHtcbiAgICAgICAgICB2YWwgPSBwYXJ0WzJdXG4gICAgICAgICAgcmVwbGFjZXJTdGFjay5zcGxpY2UoaSwgMSlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsKVxuICB9XG59XG4iLCJpbXBvcnQge1xuICBzZXJpYWxpemVDYXVzZVxufSBmcm9tIFwiLi9jaHVuay1NUFUzQ1ZYMy5tanNcIjtcblxuLy8gc3JjL2NsYXNzZXMudHNcbmltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tIFwiQG1ldGFtYXNrL3V0aWxzXCI7XG5pbXBvcnQgc2FmZVN0cmluZ2lmeSBmcm9tIFwiZmFzdC1zYWZlLXN0cmluZ2lmeVwiO1xudmFyIEpzb25ScGNFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlci4nKTtcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWVzc2FnZVwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLicpO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIGlmIChkYXRhICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGVycm9yIGFzIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMgQSBwbGFpbiBvYmplY3Qgd2l0aCBhbGwgcHVibGljIGNsYXNzIHByb3BlcnRpZXMuXG4gICAqL1xuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZVxuICAgIH07XG4gICAgaWYgKHRoaXMuZGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICBzZXJpYWxpemVkLmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdCh0aGlzLmRhdGEpKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQuZGF0YS5jYXVzZSA9IHNlcmlhbGl6ZUNhdXNlKHRoaXMuZGF0YS5jYXVzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YWNrKSB7XG4gICAgICBzZXJpYWxpemVkLnN0YWNrID0gdGhpcy5zdGFjaztcbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2VyaWFsaXplZCBlcnJvciwgb21pdHRpbmcgYW55IGNpcmN1bGFyXG4gICAqIHJlZmVyZW5jZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzZXJpYWxpemVkIGVycm9yLlxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHNhZmVTdHJpbmdpZnkodGhpcy5zZXJpYWxpemUoKSwgc3RyaW5naWZ5UmVwbGFjZXIsIDIpO1xuICB9XG59O1xudmFyIEV0aGVyZXVtUHJvdmlkZXJFcnJvciA9IGNsYXNzIGV4dGVuZHMgSnNvblJwY0Vycm9yIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBFdGhlcmV1bSBQcm92aWRlciBKU09OLVJQQyBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGNvZGUgLSBUaGUgSlNPTi1SUEMgZXJyb3IgY29kZS4gTXVzdCBiZSBhbiBpbnRlZ2VyIGluIHRoZVxuICAgKiBgMTAwMCA8PSBuIDw9IDQ5OTlgIHJhbmdlLlxuICAgKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBKU09OLVJQQyBlcnJvciBtZXNzYWdlLlxuICAgKiBAcGFyYW0gZGF0YSAtIE9wdGlvbmFsIGRhdGEgdG8gaW5jbHVkZSBpbiB0aGUgZXJyb3IuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgaWYgKCFpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImNvZGVcIiBtdXN0IGJlIGFuIGludGVnZXIgc3VjaCB0aGF0OiAxMDAwIDw9IGNvZGUgPD0gNDk5OSdcbiAgICAgICk7XG4gICAgfVxuICAgIHN1cGVyKGNvZGUsIG1lc3NhZ2UsIGRhdGEpO1xuICB9XG59O1xuZnVuY3Rpb24gaXNWYWxpZEV0aFByb3ZpZGVyQ29kZShjb2RlKSB7XG4gIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpICYmIGNvZGUgPj0gMWUzICYmIGNvZGUgPD0gNDk5OTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeVJlcGxhY2VyKF8sIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gXCJbQ2lyY3VsYXJdXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IHtcbiAgSnNvblJwY0Vycm9yLFxuICBFdGhlcmV1bVByb3ZpZGVyRXJyb3Jcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1YU0tPM0dYWi5tanMubWFwIiwiaW1wb3J0IHtcbiAgRXRoZXJldW1Qcm92aWRlckVycm9yLFxuICBKc29uUnBjRXJyb3Jcbn0gZnJvbSBcIi4vY2h1bmstWFNLTzNHWFoubWpzXCI7XG5pbXBvcnQge1xuICBnZXRNZXNzYWdlRnJvbUNvZGVcbn0gZnJvbSBcIi4vY2h1bmstTVBVM0NWWDMubWpzXCI7XG5pbXBvcnQge1xuICBlcnJvckNvZGVzXG59IGZyb20gXCIuL2NodW5rLU1JVzROTVk2Lm1qc1wiO1xuXG4vLyBzcmMvZXJyb3JzLnRzXG52YXIgcnBjRXJyb3JzID0ge1xuICAvKipcbiAgICogR2V0IGEgSlNPTiBSUEMgMi4wIFBhcnNlICgtMzI3MDApIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIHBhcnNlOiAoYXJnKSA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMucGFyc2UsIGFyZyksXG4gIC8qKlxuICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgSW52YWxpZCBSZXF1ZXN0ICgtMzI2MDApIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIGludmFsaWRSZXF1ZXN0OiAoYXJnKSA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMuaW52YWxpZFJlcXVlc3QsIGFyZyksXG4gIC8qKlxuICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgSW52YWxpZCBQYXJhbXMgKC0zMjYwMikgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgaW52YWxpZFBhcmFtczogKGFyZykgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLmludmFsaWRQYXJhbXMsIGFyZyksXG4gIC8qKlxuICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgTWV0aG9kIE5vdCBGb3VuZCAoLTMyNjAxKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICBtZXRob2ROb3RGb3VuZDogKGFyZykgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLm1ldGhvZE5vdEZvdW5kLCBhcmcpLFxuICAvKipcbiAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludGVybmFsICgtMzI2MDMpIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gYXJnIC0gVGhlIGVycm9yIG1lc3NhZ2Ugb3Igb3B0aW9ucyBiYWcuXG4gICAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgSnNvblJwY0Vycm9yfSBjbGFzcy5cbiAgICovXG4gIGludGVybmFsOiAoYXJnKSA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMuaW50ZXJuYWwsIGFyZyksXG4gIC8qKlxuICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgU2VydmVyIGVycm9yLlxuICAgKiBQZXJtaXRzIGludGVnZXIgZXJyb3IgY29kZXMgaW4gdGhlIFsgLTMyMDk5IDw9IC0zMjAwNSBdIHJhbmdlLlxuICAgKiBDb2RlcyAtMzIwMDAgdGhyb3VnaCAtMzIwMDQgYXJlIHJlc2VydmVkIGJ5IEVJUC0xNDc0LlxuICAgKlxuICAgKiBAcGFyYW0gb3B0cyAtIFRoZSBlcnJvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgc2VydmVyOiAob3B0cykgPT4ge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRXRoZXJldW0gUlBDIFNlcnZlciBlcnJvcnMgbXVzdCBwcm92aWRlIHNpbmdsZSBvYmplY3QgYXJndW1lbnQuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHsgY29kZSB9ID0gb3B0cztcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoY29kZSkgfHwgY29kZSA+IC0zMjAwNSB8fCBjb2RlIDwgLTMyMDk5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImNvZGVcIiBtdXN0IGJlIGFuIGludGVnZXIgc3VjaCB0aGF0OiAtMzIwOTkgPD0gY29kZSA8PSAtMzIwMDUnXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0SnNvblJwY0Vycm9yKGNvZGUsIG9wdHMpO1xuICB9LFxuICAvKipcbiAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIEludmFsaWQgSW5wdXQgKC0zMjAwMCkgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgaW52YWxpZElucHV0OiAoYXJnKSA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMuaW52YWxpZElucHV0LCBhcmcpLFxuICAvKipcbiAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIFJlc291cmNlIE5vdCBGb3VuZCAoLTMyMDAxKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICByZXNvdXJjZU5vdEZvdW5kOiAoYXJnKSA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMucmVzb3VyY2VOb3RGb3VuZCwgYXJnKSxcbiAgLyoqXG4gICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBSZXNvdXJjZSBVbmF2YWlsYWJsZSAoLTMyMDAyKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICByZXNvdXJjZVVuYXZhaWxhYmxlOiAoYXJnKSA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMucmVzb3VyY2VVbmF2YWlsYWJsZSwgYXJnKSxcbiAgLyoqXG4gICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBUcmFuc2FjdGlvbiBSZWplY3RlZCAoLTMyMDAzKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICB0cmFuc2FjdGlvblJlamVjdGVkOiAoYXJnKSA9PiBnZXRKc29uUnBjRXJyb3IoZXJyb3JDb2Rlcy5ycGMudHJhbnNhY3Rpb25SZWplY3RlZCwgYXJnKSxcbiAgLyoqXG4gICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBNZXRob2QgTm90IFN1cHBvcnRlZCAoLTMyMDA0KSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEpzb25ScGNFcnJvcn0gY2xhc3MuXG4gICAqL1xuICBtZXRob2ROb3RTdXBwb3J0ZWQ6IChhcmcpID0+IGdldEpzb25ScGNFcnJvcihlcnJvckNvZGVzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQsIGFyZyksXG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgTGltaXQgRXhjZWVkZWQgKC0zMjAwNSkgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBKc29uUnBjRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgbGltaXRFeGNlZWRlZDogKGFyZykgPT4gZ2V0SnNvblJwY0Vycm9yKGVycm9yQ29kZXMucnBjLmxpbWl0RXhjZWVkZWQsIGFyZylcbn07XG52YXIgcHJvdmlkZXJFcnJvcnMgPSB7XG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgVXNlciBSZWplY3RlZCBSZXF1ZXN0ICg0MDAxKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEV0aGVyZXVtUHJvdmlkZXJFcnJvcn0gY2xhc3MuXG4gICAqL1xuICB1c2VyUmVqZWN0ZWRSZXF1ZXN0OiAoYXJnKSA9PiB7XG4gICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JDb2Rlcy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0LCBhcmcpO1xuICB9LFxuICAvKipcbiAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVuYXV0aG9yaXplZCAoNDEwMCkgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgdW5hdXRob3JpemVkOiAoYXJnKSA9PiB7XG4gICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JDb2Rlcy5wcm92aWRlci51bmF1dGhvcml6ZWQsIGFyZyk7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgVW5zdXBwb3J0ZWQgTWV0aG9kICg0MjAwKSBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZyAtIFRoZSBlcnJvciBtZXNzYWdlIG9yIG9wdGlvbnMgYmFnLlxuICAgKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiB0aGUge0BsaW5rIEV0aGVyZXVtUHJvdmlkZXJFcnJvcn0gY2xhc3MuXG4gICAqL1xuICB1bnN1cHBvcnRlZE1ldGhvZDogKGFyZykgPT4ge1xuICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yQ29kZXMucHJvdmlkZXIudW5zdXBwb3J0ZWRNZXRob2QsIGFyZyk7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgTm90IENvbm5lY3RlZCAoNDkwMCkgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgZGlzY29ubmVjdGVkOiAoYXJnKSA9PiB7XG4gICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JDb2Rlcy5wcm92aWRlci5kaXNjb25uZWN0ZWQsIGFyZyk7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgQ2hhaW4gTm90IENvbm5lY3RlZCAoNDkwMSkgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmcgLSBUaGUgZXJyb3IgbWVzc2FnZSBvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgY2hhaW5EaXNjb25uZWN0ZWQ6IChhcmcpID0+IHtcbiAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihlcnJvckNvZGVzLnByb3ZpZGVyLmNoYWluRGlzY29ubmVjdGVkLCBhcmcpO1xuICB9LFxuICAvKipcbiAgICogR2V0IGEgY3VzdG9tIEV0aGVyZXVtIFByb3ZpZGVyIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0cyAtIFRoZSBlcnJvciBvcHRpb25zIGJhZy5cbiAgICogQHJldHVybnMgQW4gaW5zdGFuY2Ugb2YgdGhlIHtAbGluayBFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IGNsYXNzLlxuICAgKi9cbiAgY3VzdG9tOiAob3B0cykgPT4ge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiRXRoZXJldW0gUHJvdmlkZXIgY3VzdG9tIGVycm9ycyBtdXN0IHByb3ZpZGUgc2luZ2xlIG9iamVjdCBhcmd1bWVudC5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgeyBjb2RlLCBtZXNzYWdlLCBkYXRhIH0gPSBvcHRzO1xuICAgIGlmICghbWVzc2FnZSB8fCB0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VcIiBtdXN0IGJlIGEgbm9uZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRXRoZXJldW1Qcm92aWRlckVycm9yKGNvZGUsIG1lc3NhZ2UsIGRhdGEpO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0SnNvblJwY0Vycm9yKGNvZGUsIGFyZykge1xuICBjb25zdCBbbWVzc2FnZSwgZGF0YV0gPSBwYXJzZU9wdHMoYXJnKTtcbiAgcmV0dXJuIG5ldyBKc29uUnBjRXJyb3IoY29kZSwgbWVzc2FnZSA/PyBnZXRNZXNzYWdlRnJvbUNvZGUoY29kZSksIGRhdGEpO1xufVxuZnVuY3Rpb24gZ2V0RXRoUHJvdmlkZXJFcnJvcihjb2RlLCBhcmcpIHtcbiAgY29uc3QgW21lc3NhZ2UsIGRhdGFdID0gcGFyc2VPcHRzKGFyZyk7XG4gIHJldHVybiBuZXcgRXRoZXJldW1Qcm92aWRlckVycm9yKFxuICAgIGNvZGUsXG4gICAgbWVzc2FnZSA/PyBnZXRNZXNzYWdlRnJvbUNvZGUoY29kZSksXG4gICAgZGF0YVxuICApO1xufVxuZnVuY3Rpb24gcGFyc2VPcHRzKGFyZykge1xuICBpZiAoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBbYXJnXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgY29uc3QgeyBtZXNzYWdlLCBkYXRhIH0gPSBhcmc7XG4gICAgICBpZiAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHNwZWNpZnkgc3RyaW5nIG1lc3NhZ2UuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFttZXNzYWdlID8/IHZvaWQgMCwgZGF0YV07XG4gICAgfVxuICB9XG4gIHJldHVybiBbXTtcbn1cblxuZXhwb3J0IHtcbiAgcnBjRXJyb3JzLFxuICBwcm92aWRlckVycm9yc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLUtZUDI3VTNDLm1qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmZ1bmN0aW9uIHNhZmVBcHBseShoYW5kbGVyLCBjb250ZXh0LCBhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgUmVmbGVjdC5hcHBseShoYW5kbGVyLCBjb250ZXh0LCBhcmdzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBUaHJvdyBlcnJvciBhZnRlciB0aW1lb3V0IHNvIGFzIG5vdCB0byBpbnRlcnJ1cHQgdGhlIHN0YWNrXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcnJheUNsb25lKGFycikge1xuICAgIGNvbnN0IG4gPSBhcnIubGVuZ3RoO1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpICs9IDEpIHtcbiAgICAgICAgY29weVtpXSA9IGFycltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5jbGFzcyBTYWZlRXZlbnRFbWl0dGVyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBlbWl0KHR5cGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IGRvRXJyb3IgPSB0eXBlID09PSAnZXJyb3InO1xuICAgICAgICBjb25zdCBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICAgIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZG9FcnJvciA9IGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWRvRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gICAgICAgIGlmIChkb0Vycm9yKSB7XG4gICAgICAgICAgICBsZXQgZXI7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgW2VyXSA9IGFyZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgICAgICAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICAgICAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYFVuaGFuZGxlZCBlcnJvci4ke2VyID8gYCAoJHtlci5tZXNzYWdlfSlgIDogJyd9YCk7XG4gICAgICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICAgICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG4gICAgICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNhZmVBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBzYWZlQXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTYWZlRXZlbnRFbWl0dGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHtcbiAgX19wcml2YXRlQWRkLFxuICBfX3ByaXZhdGVHZXQsXG4gIF9fcHJpdmF0ZU1ldGhvZCxcbiAgX19wcml2YXRlU2V0XG59IGZyb20gXCIuL2NodW5rLVhVSTQzTEVaLm1qc1wiO1xuXG4vLyBzcmMvSnNvblJwY0VuZ2luZS50c1xuaW1wb3J0IHsgZXJyb3JDb2RlcywgSnNvblJwY0Vycm9yLCBzZXJpYWxpemVFcnJvciB9IGZyb20gXCJAbWV0YW1hc2svcnBjLWVycm9yc1wiO1xuaW1wb3J0IFNhZmVFdmVudEVtaXR0ZXIgZnJvbSBcIkBtZXRhbWFzay9zYWZlLWV2ZW50LWVtaXR0ZXJcIjtcbmltcG9ydCB7XG4gIGhhc1Byb3BlcnR5LFxuICBpc0pzb25ScGNOb3RpZmljYXRpb24sXG4gIGlzSnNvblJwY1JlcXVlc3Rcbn0gZnJvbSBcIkBtZXRhbWFzay91dGlsc1wiO1xudmFyIERFU1RST1lFRF9FUlJPUl9NRVNTQUdFID0gXCJUaGlzIGVuZ2luZSBpcyBkZXN0cm95ZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZC5cIjtcbnZhciBfaXNEZXN0cm95ZWQsIF9taWRkbGV3YXJlLCBfbm90aWZpY2F0aW9uSGFuZGxlciwgX2Fzc2VydElzTm90RGVzdHJveWVkLCBhc3NlcnRJc05vdERlc3Ryb3llZF9mbiwgX2hhbmRsZUJhdGNoLCBoYW5kbGVCYXRjaF9mbiwgX2hhbmRsZSwgaGFuZGxlX2ZuLCBfcHJvY2Vzc1JlcXVlc3QsIHByb2Nlc3NSZXF1ZXN0X2ZuLCBfcnVuQWxsTWlkZGxld2FyZSwgcnVuQWxsTWlkZGxld2FyZV9mbiwgX3J1bk1pZGRsZXdhcmUsIHJ1bk1pZGRsZXdhcmVfZm4sIF9ydW5SZXR1cm5IYW5kbGVycywgcnVuUmV0dXJuSGFuZGxlcnNfZm4sIF9jaGVja0ZvckNvbXBsZXRpb24sIGNoZWNrRm9yQ29tcGxldGlvbl9mbjtcbnZhciBfSnNvblJwY0VuZ2luZSA9IGNsYXNzIF9Kc29uUnBjRW5naW5lIGV4dGVuZHMgU2FmZUV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEge0BsaW5rIEpzb25ScGNFbmdpbmV9IGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYmFnLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5ub3RpZmljYXRpb25IYW5kbGVyIC0gQSBmdW5jdGlvbiBmb3IgaGFuZGxpbmcgSlNPTi1SUENcbiAgICogbm90aWZpY2F0aW9ucy4gQSBKU09OLVJQQyBub3RpZmljYXRpb24gaXMgZGVmaW5lZCBhcyBhIEpTT04tUlBDIHJlcXVlc3RcbiAgICogd2l0aG91dCBhbiBgaWRgIHByb3BlcnR5LiBJZiB0aGlzIG9wdGlvbiBpcyBfbm90XyBwcm92aWRlZCwgbm90aWZpY2F0aW9uc1xuICAgKiB3aWxsIGJlIHRyZWF0ZWQgdGhlIHNhbWUgYXMgcmVxdWVzdHMuIElmIHRoaXMgb3B0aW9uIF9pc18gcHJvdmlkZWQsXG4gICAqIG5vdGlmaWNhdGlvbnMgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGhhbmRsZXIgZnVuY3Rpb24gd2l0aG91dCB0b3VjaGluZ1xuICAgKiB0aGUgZW5naW5lJ3MgbWlkZGxld2FyZSBzdGFjay4gVGhpcyBmdW5jdGlvbiBzaG91bGQgbm90IHRocm93IG9yIHJlamVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHsgbm90aWZpY2F0aW9uSGFuZGxlciB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiB0aGlzIGVuZ2luZSBpcyBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9hc3NlcnRJc05vdERlc3Ryb3llZCk7XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhIGJhdGNoIG9mIEpTT04tUlBDIHJlcXVlc3RzLCBlaXRoZXIgaW4gYGFzeW5jYCBvciBjYWxsYmFja1xuICAgICAqIGZhc2hpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxdWVzdHMgLSBUaGUgcmVxdWVzdCBvYmplY3RzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNvbXBsZXRpb24gY2FsbGJhY2suXG4gICAgICogQHJldHVybnMgVGhlIGFycmF5IG9mIHJlc3BvbnNlcywgb3Igbm90aGluZyBpZiBhIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQuXG4gICAgICovXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGVCYXRjaCk7XG4gICAgLyoqXG4gICAgICogRW5zdXJlcyB0aGF0IHRoZSByZXF1ZXN0IC8gbm90aWZpY2F0aW9uIG9iamVjdCBpcyB2YWxpZCwgcHJvY2Vzc2VzIGl0LCBhbmRcbiAgICAgKiBwYXNzZXMgYW55IGVycm9yIGFuZCByZXNwb25zZSBvYmplY3QgdG8gdGhlIGdpdmVuIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogRG9lcyBub3QgcmVqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxlclJlcSAtIFRoZSByZXF1ZXN0IG9iamVjdCBmcm9tIHRoZSBjYWxsZXIuXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIE5vdGhpbmcuXG4gICAgICovXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9oYW5kbGUpO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRpbmcgd2hldGhlciB0aGlzIGVuZ2luZSBpcyBkZXN0cm95ZWQgb3Igbm90LlxuICAgICAqL1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfaXNEZXN0cm95ZWQsIGZhbHNlKTtcbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX21pZGRsZXdhcmUsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9ub3RpZmljYXRpb25IYW5kbGVyLCB2b2lkIDApO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbWlkZGxld2FyZSwgW10pO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbm90aWZpY2F0aW9uSGFuZGxlciwgbm90aWZpY2F0aW9uSGFuZGxlcik7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxzIHRoZSBgZGVzdHJveSgpYCBmdW5jdGlvbiBvZiBhbnkgbWlkZGxld2FyZSB3aXRoIHRoYXQgcHJvcGVydHksIGNsZWFyc1xuICAgKiB0aGUgbWlkZGxld2FyZSBhcnJheSwgYW5kIG1hcmtzIHRoaXMgZW5naW5lIGFzIGRlc3Ryb3llZC4gQSBkZXN0cm95ZWRcbiAgICogZW5naW5lIGNhbm5vdCBiZSB1c2VkLlxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICBfX3ByaXZhdGVHZXQodGhpcywgX21pZGRsZXdhcmUpLmZvckVhY2goXG4gICAgICAobWlkZGxld2FyZSkgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgLy8gYGluYCB3YWxrcyB0aGUgcHJvdG90eXBlIGNoYWluLCB3aGljaCBpcyBwcm9iYWJseSB0aGUgZGVzaXJlZFxuICAgICAgICAgIC8vIGJlaGF2aW9yIGhlcmUuXG4gICAgICAgICAgXCJkZXN0cm95XCIgaW4gbWlkZGxld2FyZSAmJiB0eXBlb2YgbWlkZGxld2FyZS5kZXN0cm95ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgbWlkZGxld2FyZS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfbWlkZGxld2FyZSwgW10pO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfaXNEZXN0cm95ZWQsIHRydWUpO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRvIHRoZSBlbmdpbmUncyBtaWRkbGV3YXJlIHN0YWNrLlxuICAgKlxuICAgKiBAcGFyYW0gbWlkZGxld2FyZSAtIFRoZSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRvIGFkZC5cbiAgICovXG4gIHB1c2gobWlkZGxld2FyZSkge1xuICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfYXNzZXJ0SXNOb3REZXN0cm95ZWQsIGFzc2VydElzTm90RGVzdHJveWVkX2ZuKS5jYWxsKHRoaXMpO1xuICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfbWlkZGxld2FyZSkucHVzaChtaWRkbGV3YXJlKTtcbiAgfVxuICBoYW5kbGUocmVxLCBjYWxsYmFjaykge1xuICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfYXNzZXJ0SXNOb3REZXN0cm95ZWQsIGFzc2VydElzTm90RGVzdHJveWVkX2ZuKS5jYWxsKHRoaXMpO1xuICAgIGlmIChjYWxsYmFjayAmJiB0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImNhbGxiYWNrXCIgbXVzdCBiZSBhIGZ1bmN0aW9uIGlmIHByb3ZpZGVkLicpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXEpKSB7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfaGFuZGxlQmF0Y2gsIGhhbmRsZUJhdGNoX2ZuKS5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgcmVxLFxuICAgICAgICAgIC8vIFRoaXMgYXNzZXJ0aW9uIGlzIHNhZmUgYmVjYXVzZSBvZiB0aGUgcnVudGltZSBjaGVja3MgdmFsaWRhdGluZyB0aGF0IGByZXFgIGlzIGFuIGFycmF5IGFuZCBgY2FsbGJhY2tgIGlzIGRlZmluZWQuXG4gICAgICAgICAgLy8gVGhlcmUgaXMgb25seSBvbmUgb3ZlcmxvYWQgc2lnbmF0dXJlIHRoYXQgc2F0aXNmaWVzIGJvdGggY29uZGl0aW9ucywgYW5kIGl0cyBgY2FsbGJhY2tgIHR5cGUgaXMgdGhlIG9uZSB0aGF0J3MgYmVpbmcgYXNzZXJ0ZWQuXG4gICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfX3ByaXZhdGVNZXRob2QodGhpcywgX2hhbmRsZUJhdGNoLCBoYW5kbGVCYXRjaF9mbikuY2FsbCh0aGlzLCByZXEpO1xuICAgIH1cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBfX3ByaXZhdGVNZXRob2QodGhpcywgX2hhbmRsZSwgaGFuZGxlX2ZuKS5jYWxsKHRoaXMsIHJlcSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZUhhbmRsZShyZXEpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgZW5naW5lIGFzIGEgbWlkZGxld2FyZSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBwdXNoZWQgdG8gb3RoZXJcbiAgICogZW5naW5lcy5cbiAgICpcbiAgICogQHJldHVybnMgVGhpcyBlbmdpbmUgYXMgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uLlxuICAgKi9cbiAgYXNNaWRkbGV3YXJlKCkge1xuICAgIF9fcHJpdmF0ZU1ldGhvZCh0aGlzLCBfYXNzZXJ0SXNOb3REZXN0cm95ZWQsIGFzc2VydElzTm90RGVzdHJveWVkX2ZuKS5jYWxsKHRoaXMpO1xuICAgIHJldHVybiBhc3luYyAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFttaWRkbGV3YXJlRXJyb3IsIGlzQ29tcGxldGUsIHJldHVybkhhbmRsZXJzXSA9IGF3YWl0IF9fcHJpdmF0ZU1ldGhvZChfYSA9IF9Kc29uUnBjRW5naW5lLCBfcnVuQWxsTWlkZGxld2FyZSwgcnVuQWxsTWlkZGxld2FyZV9mbikuY2FsbChfYSwgcmVxLCByZXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfbWlkZGxld2FyZSkpO1xuICAgICAgICBpZiAoaXNDb21wbGV0ZSkge1xuICAgICAgICAgIGF3YWl0IF9fcHJpdmF0ZU1ldGhvZChfYiA9IF9Kc29uUnBjRW5naW5lLCBfcnVuUmV0dXJuSGFuZGxlcnMsIHJ1blJldHVybkhhbmRsZXJzX2ZuKS5jYWxsKF9iLCByZXR1cm5IYW5kbGVycyk7XG4gICAgICAgICAgcmV0dXJuIGVuZChtaWRkbGV3YXJlRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXh0KGFzeW5jIChoYW5kbGVyQ2FsbGJhY2spID0+IHtcbiAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBfX3ByaXZhdGVNZXRob2QoX2EyID0gX0pzb25ScGNFbmdpbmUsIF9ydW5SZXR1cm5IYW5kbGVycywgcnVuUmV0dXJuSGFuZGxlcnNfZm4pLmNhbGwoX2EyLCByZXR1cm5IYW5kbGVycyk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVyQ2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaGFuZGxlckNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVuZChlcnJvcik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogQSBwcm9taXNlLXdyYXBwZWQgX2hhbmRsZS5cbiAgICpcbiAgICogQHBhcmFtIHJlcXVlc3QgLSBUaGUgSlNPTi1SUEMgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIEpTT04tUlBDIHJlc3BvbnNlLlxuICAgKi9cbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGluIHRlc3RzLCBzbyB3ZSBjYW5ub3QgZWFzaWx5IGNoYW5nZSBpdCB0byB1c2UgdGhlXG4gIC8vIGhhc2ggc3ludGF4LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgYXN5bmMgX3Byb21pc2VIYW5kbGUocmVxdWVzdCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBfX3ByaXZhdGVNZXRob2QodGhpcywgX2hhbmRsZSwgaGFuZGxlX2ZuKS5jYWxsKHRoaXMsIHJlcXVlc3QsIChlcnJvciwgcmVzKSA9PiB7XG4gICAgICAgIGlmIChlcnJvciAmJiByZXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgICB9XG4gICAgICB9KS5jYXRjaChyZWplY3QpO1xuICAgIH0pO1xuICB9XG59O1xuX2lzRGVzdHJveWVkID0gbmV3IFdlYWtNYXAoKTtcbl9taWRkbGV3YXJlID0gbmV3IFdlYWtNYXAoKTtcbl9ub3RpZmljYXRpb25IYW5kbGVyID0gbmV3IFdlYWtNYXAoKTtcbl9hc3NlcnRJc05vdERlc3Ryb3llZCA9IG5ldyBXZWFrU2V0KCk7XG5hc3NlcnRJc05vdERlc3Ryb3llZF9mbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAoX19wcml2YXRlR2V0KHRoaXMsIF9pc0Rlc3Ryb3llZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoREVTVFJPWUVEX0VSUk9SX01FU1NBR0UpO1xuICB9XG59O1xuX2hhbmRsZUJhdGNoID0gbmV3IFdlYWtTZXQoKTtcbmhhbmRsZUJhdGNoX2ZuID0gYXN5bmMgZnVuY3Rpb24ocmVxdWVzdHMsIGNhbGxiYWNrKSB7XG4gIHRyeSB7XG4gICAgaWYgKHJlcXVlc3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICBpZDogbnVsbCxcbiAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgIGVycm9yOiBuZXcgSnNvblJwY0Vycm9yKFxuICAgICAgICAgICAgZXJyb3JDb2Rlcy5ycGMuaW52YWxpZFJlcXVlc3QsXG4gICAgICAgICAgICBcIlJlcXVlc3QgYmF0Y2ggbXVzdCBjb250YWluIHBsYWluIG9iamVjdHMuIFJlY2VpdmVkIGFuIGVtcHR5IGFycmF5XCJcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uc2VzID0gKGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgLy8gMS4gQmVnaW4gZXhlY3V0aW5nIGVhY2ggcmVxdWVzdCBpbiB0aGUgb3JkZXIgcmVjZWl2ZWRcbiAgICAgIHJlcXVlc3RzLm1hcCh0aGlzLl9wcm9taXNlSGFuZGxlLmJpbmQodGhpcykpXG4gICAgKSkuZmlsdGVyKFxuICAgICAgLy8gRmlsdGVyIG91dCBhbnkgbm90aWZpY2F0aW9uIHJlc3BvbnNlcy5cbiAgICAgIChyZXNwb25zZSkgPT4gcmVzcG9uc2UgIT09IHZvaWQgMFxuICAgICk7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzcG9uc2VzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcik7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuX2hhbmRsZSA9IG5ldyBXZWFrU2V0KCk7XG5oYW5kbGVfZm4gPSBhc3luYyBmdW5jdGlvbihjYWxsZXJSZXEsIGNhbGxiYWNrKSB7XG4gIHZhciBfYTtcbiAgaWYgKCFjYWxsZXJSZXEgfHwgQXJyYXkuaXNBcnJheShjYWxsZXJSZXEpIHx8IHR5cGVvZiBjYWxsZXJSZXEgIT09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCBlcnJvcjIgPSBuZXcgSnNvblJwY0Vycm9yKFxuICAgICAgZXJyb3JDb2Rlcy5ycGMuaW52YWxpZFJlcXVlc3QsXG4gICAgICBgUmVxdWVzdHMgbXVzdCBiZSBwbGFpbiBvYmplY3RzLiBSZWNlaXZlZDogJHt0eXBlb2YgY2FsbGVyUmVxfWAsXG4gICAgICB7IHJlcXVlc3Q6IGNhbGxlclJlcSB9XG4gICAgKTtcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IyLCB7IGlkOiBudWxsLCBqc29ucnBjOiBcIjIuMFwiLCBlcnJvcjogZXJyb3IyIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgY2FsbGVyUmVxLm1ldGhvZCAhPT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IGVycm9yMiA9IG5ldyBKc29uUnBjRXJyb3IoXG4gICAgICBlcnJvckNvZGVzLnJwYy5pbnZhbGlkUmVxdWVzdCxcbiAgICAgIGBNdXN0IHNwZWNpZnkgYSBzdHJpbmcgbWV0aG9kLiBSZWNlaXZlZDogJHt0eXBlb2YgY2FsbGVyUmVxLm1ldGhvZH1gLFxuICAgICAgeyByZXF1ZXN0OiBjYWxsZXJSZXEgfVxuICAgICk7XG4gICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfbm90aWZpY2F0aW9uSGFuZGxlcikgJiYgIWlzSnNvblJwY1JlcXVlc3QoY2FsbGVyUmVxKSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2soZXJyb3IyLCB7XG4gICAgICAvLyBUeXBlY2FzdDogVGhpcyBjb3VsZCBiZSBhIG5vdGlmaWNhdGlvbiwgYnV0IHdlIHdhbnQgdG8gYWNjZXNzIHRoZVxuICAgICAgLy8gYGlkYCBldmVuIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICBpZDogY2FsbGVyUmVxLmlkID8/IG51bGwsXG4gICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgZXJyb3I6IGVycm9yMlxuICAgIH0pO1xuICB9IGVsc2UgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfbm90aWZpY2F0aW9uSGFuZGxlcikgJiYgaXNKc29uUnBjTm90aWZpY2F0aW9uKGNhbGxlclJlcSkgJiYgIWlzSnNvblJwY1JlcXVlc3QoY2FsbGVyUmVxKSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBfX3ByaXZhdGVHZXQodGhpcywgX25vdGlmaWNhdGlvbkhhbmRsZXIpLmNhbGwodGhpcywgY2FsbGVyUmVxKTtcbiAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcjIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gIH1cbiAgbGV0IGVycm9yID0gbnVsbDtcbiAgY29uc3QgcmVxID0geyAuLi5jYWxsZXJSZXEgfTtcbiAgY29uc3QgcmVzID0ge1xuICAgIGlkOiByZXEuaWQsXG4gICAganNvbnJwYzogcmVxLmpzb25ycGNcbiAgfTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBfX3ByaXZhdGVNZXRob2QoX2EgPSBfSnNvblJwY0VuZ2luZSwgX3Byb2Nlc3NSZXF1ZXN0LCBwcm9jZXNzUmVxdWVzdF9mbikuY2FsbChfYSwgcmVxLCByZXMsIF9fcHJpdmF0ZUdldCh0aGlzLCBfbWlkZGxld2FyZSkpO1xuICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICBlcnJvciA9IF9lcnJvcjtcbiAgfVxuICBpZiAoZXJyb3IpIHtcbiAgICBkZWxldGUgcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlcy5lcnJvcikge1xuICAgICAgcmVzLmVycm9yID0gc2VyaWFsaXplRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FsbGJhY2soZXJyb3IsIHJlcyk7XG59O1xuX3Byb2Nlc3NSZXF1ZXN0ID0gbmV3IFdlYWtTZXQoKTtcbnByb2Nlc3NSZXF1ZXN0X2ZuID0gYXN5bmMgZnVuY3Rpb24ocmVxLCByZXMsIG1pZGRsZXdhcmVzKSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICBjb25zdCBbZXJyb3IsIGlzQ29tcGxldGUsIHJldHVybkhhbmRsZXJzXSA9IGF3YWl0IF9fcHJpdmF0ZU1ldGhvZChfYSA9IF9Kc29uUnBjRW5naW5lLCBfcnVuQWxsTWlkZGxld2FyZSwgcnVuQWxsTWlkZGxld2FyZV9mbikuY2FsbChfYSwgcmVxLCByZXMsIG1pZGRsZXdhcmVzKTtcbiAgX19wcml2YXRlTWV0aG9kKF9iID0gX0pzb25ScGNFbmdpbmUsIF9jaGVja0ZvckNvbXBsZXRpb24sIGNoZWNrRm9yQ29tcGxldGlvbl9mbikuY2FsbChfYiwgcmVxLCByZXMsIGlzQ29tcGxldGUpO1xuICBhd2FpdCBfX3ByaXZhdGVNZXRob2QoX2MgPSBfSnNvblJwY0VuZ2luZSwgX3J1blJldHVybkhhbmRsZXJzLCBydW5SZXR1cm5IYW5kbGVyc19mbikuY2FsbChfYywgcmV0dXJuSGFuZGxlcnMpO1xuICBpZiAoZXJyb3IpIHtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcbl9ydW5BbGxNaWRkbGV3YXJlID0gbmV3IFdlYWtTZXQoKTtcbnJ1bkFsbE1pZGRsZXdhcmVfZm4gPSBhc3luYyBmdW5jdGlvbihyZXEsIHJlcywgbWlkZGxld2FyZXMpIHtcbiAgdmFyIF9hO1xuICBjb25zdCByZXR1cm5IYW5kbGVycyA9IFtdO1xuICBsZXQgZXJyb3IgPSBudWxsO1xuICBsZXQgaXNDb21wbGV0ZSA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IG1pZGRsZXdhcmUgb2YgbWlkZGxld2FyZXMpIHtcbiAgICBbZXJyb3IsIGlzQ29tcGxldGVdID0gYXdhaXQgX19wcml2YXRlTWV0aG9kKF9hID0gX0pzb25ScGNFbmdpbmUsIF9ydW5NaWRkbGV3YXJlLCBydW5NaWRkbGV3YXJlX2ZuKS5jYWxsKF9hLCByZXEsIHJlcywgbWlkZGxld2FyZSwgcmV0dXJuSGFuZGxlcnMpO1xuICAgIGlmIChpc0NvbXBsZXRlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtlcnJvciwgaXNDb21wbGV0ZSwgcmV0dXJuSGFuZGxlcnMucmV2ZXJzZSgpXTtcbn07XG5fcnVuTWlkZGxld2FyZSA9IG5ldyBXZWFrU2V0KCk7XG5ydW5NaWRkbGV3YXJlX2ZuID0gYXN5bmMgZnVuY3Rpb24ocmVxdWVzdCwgcmVzcG9uc2UsIG1pZGRsZXdhcmUsIHJldHVybkhhbmRsZXJzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGVuZCA9IChlcnJvcikgPT4ge1xuICAgICAgY29uc3QgcGFyc2VkRXJyb3IgPSBlcnJvciB8fCByZXNwb25zZS5lcnJvcjtcbiAgICAgIGlmIChwYXJzZWRFcnJvcikge1xuICAgICAgICByZXNwb25zZS5lcnJvciA9IHNlcmlhbGl6ZUVycm9yKHBhcnNlZEVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW3BhcnNlZEVycm9yLCB0cnVlXSk7XG4gICAgfTtcbiAgICBjb25zdCBuZXh0ID0gKHJldHVybkhhbmRsZXIpID0+IHtcbiAgICAgIGlmIChyZXNwb25zZS5lcnJvcikge1xuICAgICAgICBlbmQocmVzcG9uc2UuZXJyb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJldHVybkhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHJldHVybkhhbmRsZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZW5kKFxuICAgICAgICAgICAgICBuZXcgSnNvblJwY0Vycm9yKFxuICAgICAgICAgICAgICAgIGVycm9yQ29kZXMucnBjLmludGVybmFsLFxuICAgICAgICAgICAgICAgIGBKc29uUnBjRW5naW5lOiBcIm5leHRcIiByZXR1cm4gaGFuZGxlcnMgbXVzdCBiZSBmdW5jdGlvbnMuIFJlY2VpdmVkIFwiJHt0eXBlb2YgcmV0dXJuSGFuZGxlcn1cIiBmb3IgcmVxdWVzdDpcbiR7anNvbmlmeShcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3RcbiAgICAgICAgICAgICAgICApfWAsXG4gICAgICAgICAgICAgICAgeyByZXF1ZXN0IH1cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuSGFuZGxlcnMucHVzaChyZXR1cm5IYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKFtudWxsLCBmYWxzZV0pO1xuICAgICAgfVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIG1pZGRsZXdhcmUocmVxdWVzdCwgcmVzcG9uc2UsIG5leHQsIGVuZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGVuZChlcnJvcik7XG4gICAgfVxuICB9KTtcbn07XG5fcnVuUmV0dXJuSGFuZGxlcnMgPSBuZXcgV2Vha1NldCgpO1xucnVuUmV0dXJuSGFuZGxlcnNfZm4gPSBhc3luYyBmdW5jdGlvbihoYW5kbGVycykge1xuICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgaGFuZGxlcnMpIHtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBoYW5kbGVyKChlcnJvcikgPT4gZXJyb3IgPyByZWplY3QoZXJyb3IpIDogcmVzb2x2ZSgpKTtcbiAgICB9KTtcbiAgfVxufTtcbl9jaGVja0ZvckNvbXBsZXRpb24gPSBuZXcgV2Vha1NldCgpO1xuY2hlY2tGb3JDb21wbGV0aW9uX2ZuID0gZnVuY3Rpb24ocmVxdWVzdCwgcmVzcG9uc2UsIGlzQ29tcGxldGUpIHtcbiAgaWYgKCFoYXNQcm9wZXJ0eShyZXNwb25zZSwgXCJyZXN1bHRcIikgJiYgIWhhc1Byb3BlcnR5KHJlc3BvbnNlLCBcImVycm9yXCIpKSB7XG4gICAgdGhyb3cgbmV3IEpzb25ScGNFcnJvcihcbiAgICAgIGVycm9yQ29kZXMucnBjLmludGVybmFsLFxuICAgICAgYEpzb25ScGNFbmdpbmU6IFJlc3BvbnNlIGhhcyBubyBlcnJvciBvciByZXN1bHQgZm9yIHJlcXVlc3Q6XG4ke2pzb25pZnkoXG4gICAgICAgIHJlcXVlc3RcbiAgICAgICl9YCxcbiAgICAgIHsgcmVxdWVzdCB9XG4gICAgKTtcbiAgfVxuICBpZiAoIWlzQ29tcGxldGUpIHtcbiAgICB0aHJvdyBuZXcgSnNvblJwY0Vycm9yKFxuICAgICAgZXJyb3JDb2Rlcy5ycGMuaW50ZXJuYWwsXG4gICAgICBgSnNvblJwY0VuZ2luZTogTm90aGluZyBlbmRlZCByZXF1ZXN0OlxuJHtqc29uaWZ5KHJlcXVlc3QpfWAsXG4gICAgICB7IHJlcXVlc3QgfVxuICAgICk7XG4gIH1cbn07XG4vKipcbiAqIEZvciB0aGUgZ2l2ZW4gcmVxdWVzdCBhbmQgcmVzcG9uc2UsIHJ1bnMgYWxsIG1pZGRsZXdhcmUgYW5kIHRoZWlyIHJldHVyblxuICogaGFuZGxlcnMsIGlmIGFueSwgYW5kIGVuc3VyZXMgdGhhdCBpbnRlcm5hbCByZXF1ZXN0IHByb2Nlc3Npbmcgc2VtYW50aWNzXG4gKiBhcmUgc2F0aXNmaWVkLlxuICpcbiAqIEBwYXJhbSByZXEgLSBUaGUgcmVxdWVzdCBvYmplY3QuXG4gKiBAcGFyYW0gcmVzIC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAqIEBwYXJhbSBtaWRkbGV3YXJlcyAtIFRoZSBzdGFjayBvZiBtaWRkbGV3YXJlIGZ1bmN0aW9ucy5cbiAqL1xuX19wcml2YXRlQWRkKF9Kc29uUnBjRW5naW5lLCBfcHJvY2Vzc1JlcXVlc3QpO1xuLyoqXG4gKiBTZXJpYWxseSBleGVjdXRlcyB0aGUgZ2l2ZW4gc3RhY2sgb2YgbWlkZGxld2FyZS5cbiAqXG4gKiBAcGFyYW0gcmVxIC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICogQHBhcmFtIHJlcyAtIFRoZSByZXNwb25zZSBvYmplY3QuXG4gKiBAcGFyYW0gbWlkZGxld2FyZXMgLSBUaGUgc3RhY2sgb2YgbWlkZGxld2FyZSBmdW5jdGlvbnMgdG8gZXhlY3V0ZS5cbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFueSBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgbWlkZGxld2FyZSBleGVjdXRpb24sXG4gKiBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSByZXF1ZXN0IHdhcyBjb21wbGV0ZWQsIGFuZCBhbiBhcnJheSBvZlxuICogbWlkZGxld2FyZS1kZWZpbmVkIHJldHVybiBoYW5kbGVycy5cbiAqL1xuX19wcml2YXRlQWRkKF9Kc29uUnBjRW5naW5lLCBfcnVuQWxsTWlkZGxld2FyZSk7XG4vKipcbiAqIFJ1bnMgYW4gaW5kaXZpZHVhbCBtaWRkbGV3YXJlIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAqIEBwYXJhbSBtaWRkbGV3YXJlIC0gVGhlIG1pZGRsZXdhcmUgZnVuY3Rpb24gdG8gZXhlY3V0ZS5cbiAqIEBwYXJhbSByZXR1cm5IYW5kbGVycyAtIFRoZSByZXR1cm4gaGFuZGxlcnMgYXJyYXkgZm9yIHRoZSBjdXJyZW50IHJlcXVlc3QuXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhbnkgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIG1pZGRsZXdhcmUgZXhlY3Rpb24sXG4gKiBhbmQgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgcmVxdWVzdCBzaG91bGQgZW5kLlxuICovXG5fX3ByaXZhdGVBZGQoX0pzb25ScGNFbmdpbmUsIF9ydW5NaWRkbGV3YXJlKTtcbi8qKlxuICogU2VyaWFsbHkgZXhlY3V0ZXMgYXJyYXkgb2YgcmV0dXJuIGhhbmRsZXJzLiBUaGUgcmVxdWVzdCBhbmQgcmVzcG9uc2UgYXJlXG4gKiBhc3N1bWVkIHRvIGJlIGluIHRoZWlyIHNjb3BlLlxuICpcbiAqIEBwYXJhbSBoYW5kbGVycyAtIFRoZSByZXR1cm4gaGFuZGxlcnMgdG8gZXhlY3V0ZS5cbiAqL1xuX19wcml2YXRlQWRkKF9Kc29uUnBjRW5naW5lLCBfcnVuUmV0dXJuSGFuZGxlcnMpO1xuLyoqXG4gKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHJlc3BvbnNlIGhhcyBuZWl0aGVyIGEgcmVzdWx0IG5vciBhbiBlcnJvciwgb3IgaWZcbiAqIHRoZSBcImlzQ29tcGxldGVcIiBmbGFnIGlzIGZhbHN5LlxuICpcbiAqIEBwYXJhbSByZXF1ZXN0IC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICogQHBhcmFtIHJlc3BvbnNlIC0gVGhlIHJlc3BvbnNlIG9iamVjdC5cbiAqIEBwYXJhbSBpc0NvbXBsZXRlIC0gQm9vbGVhbiBmcm9tIHtAbGluayBKc29uUnBjRW5naW5lLiNydW5BbGxNaWRkbGV3YXJlfVxuICogaW5kaWNhdGluZyB3aGV0aGVyIGEgbWlkZGxld2FyZSBlbmRlZCB0aGUgcmVxdWVzdC5cbiAqL1xuX19wcml2YXRlQWRkKF9Kc29uUnBjRW5naW5lLCBfY2hlY2tGb3JDb21wbGV0aW9uKTtcbnZhciBKc29uUnBjRW5naW5lID0gX0pzb25ScGNFbmdpbmU7XG5mdW5jdGlvbiBqc29uaWZ5KHJlcXVlc3QpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlcXVlc3QsIG51bGwsIDIpO1xufVxuXG5leHBvcnQge1xuICBKc29uUnBjRW5naW5lXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstNUhDWVY0RlYubWpzLm1hcCIsImltcG9ydCB7XG4gIGNyZWF0ZVJwY1dhcm5pbmdNaWRkbGV3YXJlXG59IGZyb20gXCIuL2NodW5rLTVGTDZWUkpKLm1qc1wiO1xuXG4vLyBzcmMvdXRpbHMudHNcbmltcG9ydCB7IGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlIH0gZnJvbSBcIkBtZXRhbWFzay9qc29uLXJwYy1lbmdpbmVcIjtcbmltcG9ydCB7IHJwY0Vycm9ycyB9IGZyb20gXCJAbWV0YW1hc2svcnBjLWVycm9yc1wiO1xudmFyIEVNSVRURURfTk9USUZJQ0FUSU9OUyA9IE9iamVjdC5mcmVlemUoW1xuICBcImV0aF9zdWJzY3JpcHRpb25cIlxuICAvLyBwZXIgZXRoLWpzb24tcnBjLWZpbHRlcnMvc3Vic2NyaXB0aW9uTWFuYWdlclxuXSk7XG52YXIgZ2V0RGVmYXVsdEV4dGVybmFsTWlkZGxld2FyZSA9IChsb2dnZXIgPSBjb25zb2xlKSA9PiBbXG4gIGNyZWF0ZUlkUmVtYXBNaWRkbGV3YXJlKCksXG4gIGNyZWF0ZUVycm9yTWlkZGxld2FyZShsb2dnZXIpLFxuICBjcmVhdGVScGNXYXJuaW5nTWlkZGxld2FyZShsb2dnZXIpXG5dO1xuZnVuY3Rpb24gY3JlYXRlRXJyb3JNaWRkbGV3YXJlKGxvZykge1xuICByZXR1cm4gKHJlcXVlc3QsIHJlc3BvbnNlLCBuZXh0KSA9PiB7XG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0Lm1ldGhvZCAhPT0gXCJzdHJpbmdcIiB8fCAhcmVxdWVzdC5tZXRob2QpIHtcbiAgICAgIHJlc3BvbnNlLmVycm9yID0gcnBjRXJyb3JzLmludmFsaWRSZXF1ZXN0KHtcbiAgICAgICAgbWVzc2FnZTogYFRoZSByZXF1ZXN0ICdtZXRob2QnIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLmAsXG4gICAgICAgIGRhdGE6IHJlcXVlc3RcbiAgICAgIH0pO1xuICAgIH1cbiAgICBuZXh0KChkb25lKSA9PiB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSByZXNwb25zZTtcbiAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcbiAgICAgIH1cbiAgICAgIGxvZy5lcnJvcihgTWV0YU1hc2sgLSBSUEMgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gLCBlcnJvcik7XG4gICAgICByZXR1cm4gZG9uZSgpO1xuICAgIH0pO1xuICB9O1xufVxudmFyIGdldFJwY1Byb21pc2VDYWxsYmFjayA9IChyZXNvbHZlLCByZWplY3QsIHVud3JhcFJlc3VsdCA9IHRydWUpID0+IChlcnJvciwgcmVzcG9uc2UpID0+IHtcbiAgaWYgKGVycm9yIHx8IHJlc3BvbnNlLmVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yIHx8IHJlc3BvbnNlLmVycm9yKTtcbiAgfSBlbHNlIHtcbiAgICAhdW53cmFwUmVzdWx0IHx8IEFycmF5LmlzQXJyYXkocmVzcG9uc2UpID8gcmVzb2x2ZShyZXNwb25zZSkgOiByZXNvbHZlKHJlc3BvbnNlLnJlc3VsdCk7XG4gIH1cbn07XG52YXIgaXNWYWxpZENoYWluSWQgPSAoY2hhaW5JZCkgPT4gQm9vbGVhbihjaGFpbklkKSAmJiB0eXBlb2YgY2hhaW5JZCA9PT0gXCJzdHJpbmdcIiAmJiBjaGFpbklkLnN0YXJ0c1dpdGgoXCIweFwiKTtcbnZhciBpc1ZhbGlkTmV0d29ya1ZlcnNpb24gPSAobmV0d29ya1ZlcnNpb24pID0+IEJvb2xlYW4obmV0d29ya1ZlcnNpb24pICYmIHR5cGVvZiBuZXR3b3JrVmVyc2lvbiA9PT0gXCJzdHJpbmdcIjtcbnZhciBOT09QID0gKCkgPT4gdm9pZCAwO1xuXG5leHBvcnQge1xuICBFTUlUVEVEX05PVElGSUNBVElPTlMsXG4gIGdldERlZmF1bHRFeHRlcm5hbE1pZGRsZXdhcmUsXG4gIGdldFJwY1Byb21pc2VDYWxsYmFjayxcbiAgaXNWYWxpZENoYWluSWQsXG4gIGlzVmFsaWROZXR3b3JrVmVyc2lvbixcbiAgTk9PUFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLVpON1dWNTVKLm1qcy5tYXAiLCJpbXBvcnQge1xuICBOT09QXG59IGZyb20gXCIuL2NodW5rLVpON1dWNTVKLm1qc1wiO1xuaW1wb3J0IHtcbiAgbWVzc2FnZXNfZGVmYXVsdFxufSBmcm9tIFwiLi9jaHVuay1aR0RRM0lZRC5tanNcIjtcblxuLy8gc3JjL3NpdGVNZXRhZGF0YS50c1xuYXN5bmMgZnVuY3Rpb24gc2VuZFNpdGVNZXRhZGF0YShlbmdpbmUsIGxvZykge1xuICB0cnkge1xuICAgIGNvbnN0IGRvbWFpbk1ldGFkYXRhID0gYXdhaXQgZ2V0U2l0ZU1ldGFkYXRhKCk7XG4gICAgZW5naW5lLmhhbmRsZShcbiAgICAgIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgaWQ6IDEsXG4gICAgICAgIG1ldGhvZDogXCJtZXRhbWFza19zZW5kRG9tYWluTWV0YWRhdGFcIixcbiAgICAgICAgcGFyYW1zOiBkb21haW5NZXRhZGF0YVxuICAgICAgfSxcbiAgICAgIE5PT1BcbiAgICApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZy5lcnJvcih7XG4gICAgICBtZXNzYWdlOiBtZXNzYWdlc19kZWZhdWx0LmVycm9ycy5zZW5kU2l0ZU1ldGFkYXRhKCksXG4gICAgICBvcmlnaW5hbEVycm9yOiBlcnJvclxuICAgIH0pO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTaXRlTWV0YWRhdGEoKSB7XG4gIHJldHVybiB7XG4gICAgbmFtZTogZ2V0U2l0ZU5hbWUod2luZG93KSxcbiAgICBpY29uOiBhd2FpdCBnZXRTaXRlSWNvbih3aW5kb3cpXG4gIH07XG59XG5mdW5jdGlvbiBnZXRTaXRlTmFtZSh3aW5kb3dPYmplY3QpIHtcbiAgY29uc3QgeyBkb2N1bWVudDogZG9jdW1lbnQyIH0gPSB3aW5kb3dPYmplY3Q7XG4gIGNvbnN0IHNpdGVOYW1lID0gZG9jdW1lbnQyLnF1ZXJ5U2VsZWN0b3IoXG4gICAgJ2hlYWQgPiBtZXRhW3Byb3BlcnR5PVwib2c6c2l0ZV9uYW1lXCJdJ1xuICApO1xuICBpZiAoc2l0ZU5hbWUpIHtcbiAgICByZXR1cm4gc2l0ZU5hbWUuY29udGVudDtcbiAgfVxuICBjb25zdCBtZXRhVGl0bGUgPSBkb2N1bWVudDIucXVlcnlTZWxlY3RvcihcbiAgICAnaGVhZCA+IG1ldGFbbmFtZT1cInRpdGxlXCJdJ1xuICApO1xuICBpZiAobWV0YVRpdGxlKSB7XG4gICAgcmV0dXJuIG1ldGFUaXRsZS5jb250ZW50O1xuICB9XG4gIGlmIChkb2N1bWVudDIudGl0bGUgJiYgZG9jdW1lbnQyLnRpdGxlLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gZG9jdW1lbnQyLnRpdGxlO1xuICB9XG4gIHJldHVybiB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRTaXRlSWNvbih3aW5kb3dPYmplY3QpIHtcbiAgY29uc3QgeyBkb2N1bWVudDogZG9jdW1lbnQyIH0gPSB3aW5kb3dPYmplY3Q7XG4gIGNvbnN0IGljb25zID0gZG9jdW1lbnQyLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgJ2hlYWQgPiBsaW5rW3JlbH49XCJpY29uXCJdJ1xuICApO1xuICBmb3IgKGNvbnN0IGljb24gb2YgQXJyYXkuZnJvbShpY29ucykpIHtcbiAgICBpZiAoaWNvbiAmJiBhd2FpdCBpbWdFeGlzdHMoaWNvbi5ocmVmKSkge1xuICAgICAgcmV0dXJuIGljb24uaHJlZjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBpbWdFeGlzdHModXJsKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICBpbWcub25sb2FkID0gKCkgPT4gcmVzb2x2ZSh0cnVlKTtcbiAgICAgIGltZy5vbmVycm9yID0gKCkgPT4gcmVzb2x2ZShmYWxzZSk7XG4gICAgICBpbWcuc3JjID0gdXJsO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCB7XG4gIHNlbmRTaXRlTWV0YWRhdGFcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay01NVpRNTVQTy5tanMubWFwIiwidmFyIF9fYWNjZXNzQ2hlY2sgPSAob2JqLCBtZW1iZXIsIG1zZykgPT4ge1xuICBpZiAoIW1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgXCIgKyBtc2cpO1xufTtcbnZhciBfX3ByaXZhdGVHZXQgPSAob2JqLCBtZW1iZXIsIGdldHRlcikgPT4ge1xuICBfX2FjY2Vzc0NoZWNrKG9iaiwgbWVtYmVyLCBcInJlYWQgZnJvbSBwcml2YXRlIGZpZWxkXCIpO1xuICByZXR1cm4gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IG1lbWJlci5nZXQob2JqKTtcbn07XG52YXIgX19wcml2YXRlQWRkID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSkgPT4ge1xuICBpZiAobWVtYmVyLmhhcyhvYmopKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgdGhlIHNhbWUgcHJpdmF0ZSBtZW1iZXIgbW9yZSB0aGFuIG9uY2VcIik7XG4gIG1lbWJlciBpbnN0YW5jZW9mIFdlYWtTZXQgPyBtZW1iZXIuYWRkKG9iaikgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xufTtcbnZhciBfX3ByaXZhdGVTZXQgPSAob2JqLCBtZW1iZXIsIHZhbHVlLCBzZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJ3cml0ZSB0byBwcml2YXRlIGZpZWxkXCIpO1xuICBzZXR0ZXIgPyBzZXR0ZXIuY2FsbChvYmosIHZhbHVlKSA6IG1lbWJlci5zZXQob2JqLCB2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbmV4cG9ydCB7XG4gIF9fcHJpdmF0ZUdldCxcbiAgX19wcml2YXRlQWRkLFxuICBfX3ByaXZhdGVTZXRcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaHVuay1YNjZTVUlFRi5tanMubWFwIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmZ1bmN0aW9uIHNhZmVBcHBseShoYW5kbGVyLCBjb250ZXh0LCBhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgUmVmbGVjdC5hcHBseShoYW5kbGVyLCBjb250ZXh0LCBhcmdzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBUaHJvdyBlcnJvciBhZnRlciB0aW1lb3V0IHNvIGFzIG5vdCB0byBpbnRlcnJ1cHQgdGhlIHN0YWNrXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcnJheUNsb25lKGFycikge1xuICAgIGNvbnN0IG4gPSBhcnIubGVuZ3RoO1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpICs9IDEpIHtcbiAgICAgICAgY29weVtpXSA9IGFycltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTYWZlRXZlbnRFbWl0dGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBlbWl0KHR5cGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IGRvRXJyb3IgPSB0eXBlID09PSAnZXJyb3InO1xuICAgICAgICBjb25zdCBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICAgIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZG9FcnJvciA9IGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWRvRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gICAgICAgIGlmIChkb0Vycm9yKSB7XG4gICAgICAgICAgICBsZXQgZXI7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgW2VyXSA9IGFyZ3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgICAgICAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICAgICAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYFVuaGFuZGxlZCBlcnJvci4ke2VyID8gYCAoJHtlci5tZXNzYWdlfSlgIDogJyd9YCk7XG4gICAgICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICAgICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG4gICAgICAgIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNhZmVBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBzYWZlQXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cblxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICBpZiAoYS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdHJ1ZSBpZiBib3RoIE5hTiwgZmFsc2Ugb3RoZXJ3aXNlXG4gIHJldHVybiBhIT09YSAmJiBiIT09Yjtcbn07XG4iLCJpbXBvcnQge1xuICBnZXRScGNQcm9taXNlQ2FsbGJhY2ssXG4gIGlzVmFsaWRDaGFpbklkXG59IGZyb20gXCIuL2NodW5rLVpON1dWNTVKLm1qc1wiO1xuaW1wb3J0IHtcbiAgbWVzc2FnZXNfZGVmYXVsdFxufSBmcm9tIFwiLi9jaHVuay1aR0RRM0lZRC5tanNcIjtcbmltcG9ydCB7XG4gIF9fcHJpdmF0ZUFkZCxcbiAgX19wcml2YXRlR2V0LFxuICBfX3ByaXZhdGVTZXRcbn0gZnJvbSBcIi4vY2h1bmstWDY2U1VJRUYubWpzXCI7XG5cbi8vIHNyYy9CYXNlUHJvdmlkZXIudHNcbmltcG9ydCB7IEpzb25ScGNFbmdpbmUgfSBmcm9tIFwiQG1ldGFtYXNrL2pzb24tcnBjLWVuZ2luZVwiO1xuaW1wb3J0IHsgcnBjRXJyb3JzLCBKc29uUnBjRXJyb3IgfSBmcm9tIFwiQG1ldGFtYXNrL3JwYy1lcnJvcnNcIjtcbmltcG9ydCBTYWZlRXZlbnRFbWl0dGVyIGZyb20gXCJAbWV0YW1hc2svc2FmZS1ldmVudC1lbWl0dGVyXCI7XG5pbXBvcnQgZGVxdWFsIGZyb20gXCJmYXN0LWRlZXAtZXF1YWxcIjtcbnZhciBfY2hhaW5JZCwgX3NlbGVjdGVkQWRkcmVzcztcbnZhciBfQmFzZVByb3ZpZGVyID0gY2xhc3MgX0Jhc2VQcm92aWRlciBleHRlbmRzIFNhZmVFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBwcm92aWRlci5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIGJhZy5cbiAgICogQHBhcmFtIG9wdGlvbnMubG9nZ2VyIC0gVGhlIGxvZ2dpbmcgQVBJIHRvIHVzZS4gRGVmYXVsdDogYGNvbnNvbGVgLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5tYXhFdmVudExpc3RlbmVycyAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBldmVudFxuICAgKiBsaXN0ZW5lcnMuIERlZmF1bHQ6IDEwMC5cbiAgICogQHBhcmFtIG9wdGlvbnMucnBjTWlkZGxld2FyZSAtIFRoZSBSUEMgbWlkZGxld2FyZSBzdGFjay4gRGVmYXVsdDogW10uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbG9nZ2VyID0gY29uc29sZSxcbiAgICBtYXhFdmVudExpc3RlbmVycyA9IDEwMCxcbiAgICBycGNNaWRkbGV3YXJlID0gW11cbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY2hhaW4gSUQgb2YgdGhlIGN1cnJlbnRseSBjb25uZWN0ZWQgRXRoZXJldW0gY2hhaW4uXG4gICAgICogU2VlIFtjaGFpbklkLm5ldHdvcmtde0BsaW5rIGh0dHBzOi8vY2hhaW5pZC5uZXR3b3JrfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKi9cbiAgICBfX3ByaXZhdGVBZGQodGhpcywgX2NoYWluSWQsIHZvaWQgMCk7XG4gICAgLyoqXG4gICAgICogVGhlIHVzZXIncyBjdXJyZW50bHkgc2VsZWN0ZWQgRXRoZXJldW0gYWRkcmVzcy5cbiAgICAgKiBJZiBudWxsLCBNZXRhTWFzayBpcyBlaXRoZXIgbG9ja2VkIG9yIHRoZSB1c2VyIGhhcyBub3QgcGVybWl0dGVkIGFueVxuICAgICAqIGFkZHJlc3NlcyB0byBiZSB2aWV3ZWQuXG4gICAgICovXG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zZWxlY3RlZEFkZHJlc3MsIHZvaWQgMCk7XG4gICAgdGhpcy5fbG9nID0gbG9nZ2VyO1xuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKG1heEV2ZW50TGlzdGVuZXJzKTtcbiAgICB0aGlzLl9zdGF0ZSA9IHtcbiAgICAgIC4uLl9CYXNlUHJvdmlkZXIuX2RlZmF1bHRTdGF0ZVxuICAgIH07XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9zZWxlY3RlZEFkZHJlc3MsIG51bGwpO1xuICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfY2hhaW5JZCwgbnVsbCk7XG4gICAgdGhpcy5faGFuZGxlQWNjb3VudHNDaGFuZ2VkID0gdGhpcy5faGFuZGxlQWNjb3VudHNDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgdGhpcy5faGFuZGxlQ29ubmVjdCA9IHRoaXMuX2hhbmRsZUNvbm5lY3QuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9oYW5kbGVDaGFpbkNoYW5nZWQgPSB0aGlzLl9oYW5kbGVDaGFpbkNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9oYW5kbGVEaXNjb25uZWN0ID0gdGhpcy5faGFuZGxlRGlzY29ubmVjdC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX2hhbmRsZVVubG9ja1N0YXRlQ2hhbmdlZCA9IHRoaXMuX2hhbmRsZVVubG9ja1N0YXRlQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JwY1JlcXVlc3QgPSB0aGlzLl9ycGNSZXF1ZXN0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0LmJpbmQodGhpcyk7XG4gICAgY29uc3QgcnBjRW5naW5lID0gbmV3IEpzb25ScGNFbmdpbmUoKTtcbiAgICBycGNNaWRkbGV3YXJlLmZvckVhY2goKG1pZGRsZXdhcmUpID0+IHJwY0VuZ2luZS5wdXNoKG1pZGRsZXdhcmUpKTtcbiAgICB0aGlzLl9ycGNFbmdpbmUgPSBycGNFbmdpbmU7XG4gIH1cbiAgLy89PT09PT09PT09PT09PT09PT09PVxuICAvLyBQdWJsaWMgUHJvcGVydGllc1xuICAvLz09PT09PT09PT09PT09PT09PT09XG4gIGdldCBjaGFpbklkKCkge1xuICAgIHJldHVybiBfX3ByaXZhdGVHZXQodGhpcywgX2NoYWluSWQpO1xuICB9XG4gIGdldCBzZWxlY3RlZEFkZHJlc3MoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2VsZWN0ZWRBZGRyZXNzKTtcbiAgfVxuICAvLz09PT09PT09PT09PT09PT09PT09XG4gIC8vIFB1YmxpYyBNZXRob2RzXG4gIC8vPT09PT09PT09PT09PT09PT09PT1cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZXIgY2FuIHByb2Nlc3MgUlBDIHJlcXVlc3RzLlxuICAgKlxuICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBwcm92aWRlciBjYW4gcHJvY2VzcyBSUEMgcmVxdWVzdHMuXG4gICAqL1xuICBpc0Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFN1Ym1pdHMgYW4gUlBDIHJlcXVlc3QgZm9yIHRoZSBnaXZlbiBtZXRob2QsIHdpdGggdGhlIGdpdmVuIHBhcmFtcy5cbiAgICogUmVzb2x2ZXMgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBtZXRob2QgY2FsbCwgb3IgcmVqZWN0cyBvbiBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIGFyZ3MgLSBUaGUgUlBDIHJlcXVlc3QgYXJndW1lbnRzLlxuICAgKiBAcGFyYW0gYXJncy5tZXRob2QgLSBUaGUgUlBDIG1ldGhvZCBuYW1lLlxuICAgKiBAcGFyYW0gYXJncy5wYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIFJQQyBtZXRob2QuXG4gICAqIEByZXR1cm5zIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgUlBDIG1ldGhvZCxcbiAgICogb3IgcmVqZWN0cyBpZiBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAgICovXG4gIGFzeW5jIHJlcXVlc3QoYXJncykge1xuICAgIGlmICghYXJncyB8fCB0eXBlb2YgYXJncyAhPT0gXCJvYmplY3RcIiB8fCBBcnJheS5pc0FycmF5KGFyZ3MpKSB7XG4gICAgICB0aHJvdyBycGNFcnJvcnMuaW52YWxpZFJlcXVlc3Qoe1xuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlc19kZWZhdWx0LmVycm9ycy5pbnZhbGlkUmVxdWVzdEFyZ3MoKSxcbiAgICAgICAgZGF0YTogYXJnc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHsgbWV0aG9kLCBwYXJhbXMgfSA9IGFyZ3M7XG4gICAgaWYgKHR5cGVvZiBtZXRob2QgIT09IFwic3RyaW5nXCIgfHwgbWV0aG9kLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgcnBjRXJyb3JzLmludmFsaWRSZXF1ZXN0KHtcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZXNfZGVmYXVsdC5lcnJvcnMuaW52YWxpZFJlcXVlc3RNZXRob2QoKSxcbiAgICAgICAgZGF0YTogYXJnc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMgIT09IHZvaWQgMCAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXMpICYmICh0eXBlb2YgcGFyYW1zICE9PSBcIm9iamVjdFwiIHx8IHBhcmFtcyA9PT0gbnVsbCkpIHtcbiAgICAgIHRocm93IHJwY0Vycm9ycy5pbnZhbGlkUmVxdWVzdCh7XG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VzX2RlZmF1bHQuZXJyb3JzLmludmFsaWRSZXF1ZXN0UGFyYW1zKCksXG4gICAgICAgIGRhdGE6IGFyZ3NcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwYXlsb2FkID0gcGFyYW1zID09PSB2b2lkIDAgfHwgcGFyYW1zID09PSBudWxsID8ge1xuICAgICAgbWV0aG9kXG4gICAgfSA6IHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHBhcmFtc1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3JwY1JlcXVlc3QocGF5bG9hZCwgZ2V0UnBjUHJvbWlzZUNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCkpO1xuICAgIH0pO1xuICB9XG4gIC8vPT09PT09PT09PT09PT09PT09PT1cbiAgLy8gUHJpdmF0ZSBNZXRob2RzXG4gIC8vPT09PT09PT09PT09PT09PT09PT1cbiAgLyoqXG4gICAqIE1VU1QgYmUgY2FsbGVkIGJ5IGNoaWxkIGNsYXNzZXMuXG4gICAqXG4gICAqIFNldHMgaW5pdGlhbCBzdGF0ZSBpZiBwcm92aWRlZCBhbmQgbWFya3MgdGhpcyBwcm92aWRlciBhcyBpbml0aWFsaXplZC5cbiAgICogVGhyb3dzIGlmIGNhbGxlZCBtb3JlIHRoYW4gb25jZS5cbiAgICpcbiAgICogUGVybWl0cyB0aGUgYG5ldHdvcmtWZXJzaW9uYCBmaWVsZCBpbiB0aGUgcGFyYW1ldGVyIG9iamVjdCBmb3JcbiAgICogY29tcGF0aWJpbGl0eSB3aXRoIGNoaWxkIGNsYXNzZXMgdGhhdCB1c2UgdGhpcyB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIGluaXRpYWxTdGF0ZSAtIFRoZSBwcm92aWRlcidzIGluaXRpYWwgc3RhdGUuXG4gICAqIEBwYXJhbSBpbml0aWFsU3RhdGUuYWNjb3VudHMgLSBUaGUgdXNlcidzIGFjY291bnRzLlxuICAgKiBAcGFyYW0gaW5pdGlhbFN0YXRlLmNoYWluSWQgLSBUaGUgY2hhaW4gSUQuXG4gICAqIEBwYXJhbSBpbml0aWFsU3RhdGUuaXNVbmxvY2tlZCAtIFdoZXRoZXIgdGhlIHVzZXIgaGFzIHVubG9ja2VkIE1ldGFNYXNrLlxuICAgKiBAcGFyYW0gaW5pdGlhbFN0YXRlLm5ldHdvcmtWZXJzaW9uIC0gVGhlIG5ldHdvcmsgdmVyc2lvbi5cbiAgICogQGZpcmVzIEJhc2VQcm92aWRlciNfaW5pdGlhbGl6ZWQgLSBJZiBgaW5pdGlhbFN0YXRlYCBpcyBkZWZpbmVkLlxuICAgKiBAZmlyZXMgQmFzZVByb3ZpZGVyI2Nvbm5lY3QgLSBJZiBgaW5pdGlhbFN0YXRlYCBpcyBkZWZpbmVkLlxuICAgKi9cbiAgX2luaXRpYWxpemVTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgICBpZiAodGhpcy5fc3RhdGUuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb3ZpZGVyIGFscmVhZHkgaW5pdGlhbGl6ZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjb25zdCB7IGFjY291bnRzLCBjaGFpbklkLCBpc1VubG9ja2VkLCBuZXR3b3JrVmVyc2lvbiB9ID0gaW5pdGlhbFN0YXRlO1xuICAgICAgdGhpcy5faGFuZGxlQ29ubmVjdChjaGFpbklkKTtcbiAgICAgIHRoaXMuX2hhbmRsZUNoYWluQ2hhbmdlZCh7IGNoYWluSWQsIG5ldHdvcmtWZXJzaW9uIH0pO1xuICAgICAgdGhpcy5faGFuZGxlVW5sb2NrU3RhdGVDaGFuZ2VkKHsgYWNjb3VudHMsIGlzVW5sb2NrZWQgfSk7XG4gICAgICB0aGlzLl9oYW5kbGVBY2NvdW50c0NoYW5nZWQoYWNjb3VudHMpO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0ZS5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KFwiX2luaXRpYWxpemVkXCIpO1xuICB9XG4gIC8qKlxuICAgKiBJbnRlcm5hbCBSUEMgbWV0aG9kLiBGb3J3YXJkcyByZXF1ZXN0cyB0byBiYWNrZ3JvdW5kIHZpYSB0aGUgUlBDIGVuZ2luZS5cbiAgICogQWxzbyByZW1hcCBpZHMgaW5ib3VuZCBhbmQgb3V0Ym91bmQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIFJQQyByZXF1ZXN0IG9iamVjdC5cbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNvbnN1bWVyJ3MgY2FsbGJhY2suXG4gICAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgdGhlIFJQQyByZXF1ZXN0LlxuICAgKi9cbiAgX3JwY1JlcXVlc3QocGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICBsZXQgY2FsbGJhY2tXcmFwcGVyID0gY2FsbGJhY2s7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgICBpZiAoIXBheWxvYWQuanNvbnJwYykge1xuICAgICAgICBwYXlsb2FkLmpzb25ycGMgPSBcIjIuMFwiO1xuICAgICAgfVxuICAgICAgaWYgKHBheWxvYWQubWV0aG9kID09PSBcImV0aF9hY2NvdW50c1wiIHx8IHBheWxvYWQubWV0aG9kID09PSBcImV0aF9yZXF1ZXN0QWNjb3VudHNcIikge1xuICAgICAgICBjYWxsYmFja1dyYXBwZXIgPSAoZXJyb3IsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlQWNjb3VudHNDaGFuZ2VkKFxuICAgICAgICAgICAgcmVzcG9uc2UucmVzdWx0ID8/IFtdLFxuICAgICAgICAgICAgcGF5bG9hZC5tZXRob2QgPT09IFwiZXRoX2FjY291bnRzXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9yLCByZXNwb25zZSk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcnBjRW5naW5lLmhhbmRsZShwYXlsb2FkLCBjYWxsYmFja1dyYXBwZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcnBjRW5naW5lLmhhbmRsZShwYXlsb2FkLCBjYWxsYmFja1dyYXBwZXIpO1xuICB9XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBwcm92aWRlciBiZWNvbWVzIGNvbm5lY3RlZCwgdXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgZW1pdHNcbiAgICogcmVxdWlyZWQgZXZlbnRzLiBJZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gY2hhaW5JZCAtIFRoZSBJRCBvZiB0aGUgbmV3bHkgY29ubmVjdGVkIGNoYWluLlxuICAgKiBAZmlyZXMgTWV0YU1hc2tJbnBhZ2VQcm92aWRlciNjb25uZWN0XG4gICAqL1xuICBfaGFuZGxlQ29ubmVjdChjaGFpbklkKSB7XG4gICAgaWYgKCF0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy5fc3RhdGUuaXNDb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdFwiLCB7IGNoYWluSWQgfSk7XG4gICAgICB0aGlzLl9sb2cuZGVidWcobWVzc2FnZXNfZGVmYXVsdC5pbmZvLmNvbm5lY3RlZChjaGFpbklkKSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBwcm92aWRlciBiZWNvbWVzIGRpc2Nvbm5lY3RlZCwgdXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgZW1pdHNcbiAgICogcmVxdWlyZWQgZXZlbnRzLiBJZGVtcG90ZW50IHdpdGggcmVzcGVjdCB0byB0aGUgaXNSZWNvdmVyYWJsZSBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEVycm9yIGNvZGVzIHBlciB0aGUgQ2xvc2VFdmVudCBzdGF0dXMgY29kZXMgYXMgcmVxdWlyZWQgYnkgRUlQLTExOTM6XG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50I1N0YXR1c19jb2Rlcy5cbiAgICpcbiAgICogQHBhcmFtIGlzUmVjb3ZlcmFibGUgLSBXaGV0aGVyIHRoZSBkaXNjb25uZWN0aW9uIGlzIHJlY292ZXJhYmxlLlxuICAgKiBAcGFyYW0gZXJyb3JNZXNzYWdlIC0gQSBjdXN0b20gZXJyb3IgbWVzc2FnZS5cbiAgICogQGZpcmVzIEJhc2VQcm92aWRlciNkaXNjb25uZWN0IC0gSWYgdGhlIGRpc2Nvbm5lY3Rpb24gaXMgbm90IHJlY292ZXJhYmxlLlxuICAgKi9cbiAgX2hhbmRsZURpc2Nvbm5lY3QoaXNSZWNvdmVyYWJsZSwgZXJyb3JNZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkIHx8ICF0aGlzLl9zdGF0ZS5pc1Blcm1hbmVudGx5RGlzY29ubmVjdGVkICYmICFpc1JlY292ZXJhYmxlKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgbGV0IGVycm9yO1xuICAgICAgaWYgKGlzUmVjb3ZlcmFibGUpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgSnNvblJwY0Vycm9yKFxuICAgICAgICAgIDEwMTMsXG4gICAgICAgICAgLy8gVHJ5IGFnYWluIGxhdGVyXG4gICAgICAgICAgZXJyb3JNZXNzYWdlID8/IG1lc3NhZ2VzX2RlZmF1bHQuZXJyb3JzLmRpc2Nvbm5lY3RlZCgpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX2xvZy5kZWJ1ZyhlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvciA9IG5ldyBKc29uUnBjRXJyb3IoXG4gICAgICAgICAgMTAxMSxcbiAgICAgICAgICAvLyBJbnRlcm5hbCBlcnJvclxuICAgICAgICAgIGVycm9yTWVzc2FnZSA/PyBtZXNzYWdlc19kZWZhdWx0LmVycm9ycy5wZXJtYW5lbnRseURpc2Nvbm5lY3RlZCgpXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX2xvZy5lcnJvcihlcnJvcik7XG4gICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfY2hhaW5JZCwgbnVsbCk7XG4gICAgICAgIHRoaXMuX3N0YXRlLmFjY291bnRzID0gbnVsbDtcbiAgICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9zZWxlY3RlZEFkZHJlc3MsIG51bGwpO1xuICAgICAgICB0aGlzLl9zdGF0ZS5pc1VubG9ja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3N0YXRlLmlzUGVybWFuZW50bHlEaXNjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFwiZGlzY29ubmVjdFwiLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcG9uIHJlY2VpcHQgb2YgYSBuZXcgYGNoYWluSWRgLCBlbWl0cyB0aGUgY29ycmVzcG9uZGluZyBldmVudCBhbmQgc2V0c1xuICAgKiBhbmQgc2V0cyByZWxldmFudCBwdWJsaWMgc3RhdGUuIERvZXMgbm90aGluZyBpZiB0aGUgZ2l2ZW4gYGNoYWluSWRgIGlzXG4gICAqIGVxdWl2YWxlbnQgdG8gdGhlIGV4aXN0aW5nIHZhbHVlLlxuICAgKlxuICAgKiBQZXJtaXRzIHRoZSBgbmV0d29ya1ZlcnNpb25gIGZpZWxkIGluIHRoZSBwYXJhbWV0ZXIgb2JqZWN0IGZvclxuICAgKiBjb21wYXRpYmlsaXR5IHdpdGggY2hpbGQgY2xhc3NlcyB0aGF0IHVzZSB0aGlzIHZhbHVlLlxuICAgKlxuICAgKiBAZmlyZXMgQmFzZVByb3ZpZGVyI2NoYWluQ2hhbmdlZFxuICAgKiBAcGFyYW0gbmV0d29ya0luZm8gLSBBbiBvYmplY3Qgd2l0aCBuZXR3b3JrIGluZm8uXG4gICAqIEBwYXJhbSBuZXR3b3JrSW5mby5jaGFpbklkIC0gVGhlIGxhdGVzdCBjaGFpbiBJRC5cbiAgICovXG4gIF9oYW5kbGVDaGFpbkNoYW5nZWQoe1xuICAgIGNoYWluSWRcbiAgfSA9IHt9KSB7XG4gICAgaWYgKCFpc1ZhbGlkQ2hhaW5JZChjaGFpbklkKSkge1xuICAgICAgdGhpcy5fbG9nLmVycm9yKG1lc3NhZ2VzX2RlZmF1bHQuZXJyb3JzLmludmFsaWROZXR3b3JrUGFyYW1zKCksIHsgY2hhaW5JZCB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faGFuZGxlQ29ubmVjdChjaGFpbklkKTtcbiAgICBpZiAoY2hhaW5JZCAhPT0gX19wcml2YXRlR2V0KHRoaXMsIF9jaGFpbklkKSkge1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9jaGFpbklkLCBjaGFpbklkKTtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZS5pbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJjaGFpbkNoYW5nZWRcIiwgX19wcml2YXRlR2V0KHRoaXMsIF9jaGFpbklkKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhY2NvdW50cyBtYXkgaGF2ZSBjaGFuZ2VkLiBEaWZmcyB0aGUgbmV3IGFjY291bnRzIHZhbHVlIHdpdGhcbiAgICogdGhlIGN1cnJlbnQgb25lLCB1cGRhdGVzIGFsbCBzdGF0ZSBhcyBuZWNlc3NhcnksIGFuZCBlbWl0cyB0aGVcbiAgICogYWNjb3VudHNDaGFuZ2VkIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0gYWNjb3VudHMgLSBUaGUgbmV3IGFjY291bnRzIHZhbHVlLlxuICAgKiBAcGFyYW0gaXNFdGhBY2NvdW50cyAtIFdoZXRoZXIgdGhlIGFjY291bnRzIHZhbHVlIHdhcyByZXR1cm5lZCBieVxuICAgKiBhIGNhbGwgdG8gZXRoX2FjY291bnRzLlxuICAgKi9cbiAgX2hhbmRsZUFjY291bnRzQ2hhbmdlZChhY2NvdW50cywgaXNFdGhBY2NvdW50cyA9IGZhbHNlKSB7XG4gICAgbGV0IF9hY2NvdW50cyA9IGFjY291bnRzO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhY2NvdW50cykpIHtcbiAgICAgIHRoaXMuX2xvZy5lcnJvcihcbiAgICAgICAgXCJNZXRhTWFzazogUmVjZWl2ZWQgaW52YWxpZCBhY2NvdW50cyBwYXJhbWV0ZXIuIFBsZWFzZSByZXBvcnQgdGhpcyBidWcuXCIsXG4gICAgICAgIGFjY291bnRzXG4gICAgICApO1xuICAgICAgX2FjY291bnRzID0gW107XG4gICAgfVxuICAgIGZvciAoY29uc3QgYWNjb3VudCBvZiBhY2NvdW50cykge1xuICAgICAgaWYgKHR5cGVvZiBhY2NvdW50ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRoaXMuX2xvZy5lcnJvcihcbiAgICAgICAgICBcIk1ldGFNYXNrOiBSZWNlaXZlZCBub24tc3RyaW5nIGFjY291bnQuIFBsZWFzZSByZXBvcnQgdGhpcyBidWcuXCIsXG4gICAgICAgICAgYWNjb3VudHNcbiAgICAgICAgKTtcbiAgICAgICAgX2FjY291bnRzID0gW107XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWRlcXVhbCh0aGlzLl9zdGF0ZS5hY2NvdW50cywgX2FjY291bnRzKSkge1xuICAgICAgaWYgKGlzRXRoQWNjb3VudHMgJiYgdGhpcy5fc3RhdGUuYWNjb3VudHMgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fbG9nLmVycm9yKFxuICAgICAgICAgIGBNZXRhTWFzazogJ2V0aF9hY2NvdW50cycgdW5leHBlY3RlZGx5IHVwZGF0ZWQgYWNjb3VudHMuIFBsZWFzZSByZXBvcnQgdGhpcyBidWcuYCxcbiAgICAgICAgICBfYWNjb3VudHNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXRlLmFjY291bnRzID0gX2FjY291bnRzO1xuICAgICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfc2VsZWN0ZWRBZGRyZXNzKSAhPT0gX2FjY291bnRzWzBdKSB7XG4gICAgICAgIF9fcHJpdmF0ZVNldCh0aGlzLCBfc2VsZWN0ZWRBZGRyZXNzLCBfYWNjb3VudHNbMF0gfHwgbnVsbCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc3RhdGUuaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgY29uc3QgX25leHRBY2NvdW50cyA9IFsuLi5fYWNjb3VudHNdO1xuICAgICAgICB0aGlzLmVtaXQoXCJhY2NvdW50c0NoYW5nZWRcIiwgX25leHRBY2NvdW50cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcG9uIHJlY2VpcHQgb2YgYSBuZXcgaXNVbmxvY2tlZCBzdGF0ZSwgc2V0cyByZWxldmFudCBwdWJsaWMgc3RhdGUuXG4gICAqIENhbGxzIHRoZSBhY2NvdW50cyBjaGFuZ2VkIGhhbmRsZXIgd2l0aCB0aGUgcmVjZWl2ZWQgYWNjb3VudHMsIG9yIGFuIGVtcHR5XG4gICAqIGFycmF5LlxuICAgKlxuICAgKiBEb2VzIG5vdGhpbmcgaWYgdGhlIHJlY2VpdmVkIHZhbHVlIGlzIGVxdWFsIHRvIHRoZSBleGlzdGluZyB2YWx1ZS5cbiAgICogVGhlcmUgYXJlIG5vIGxvY2svdW5sb2NrIGV2ZW50cy5cbiAgICpcbiAgICogQHBhcmFtIG9wdHMgLSBPcHRpb25zIGJhZy5cbiAgICogQHBhcmFtIG9wdHMuYWNjb3VudHMgLSBUaGUgZXhwb3NlZCBhY2NvdW50cywgaWYgYW55LlxuICAgKiBAcGFyYW0gb3B0cy5pc1VubG9ja2VkIC0gVGhlIGxhdGVzdCBpc1VubG9ja2VkIHZhbHVlLlxuICAgKi9cbiAgX2hhbmRsZVVubG9ja1N0YXRlQ2hhbmdlZCh7XG4gICAgYWNjb3VudHMsXG4gICAgaXNVbmxvY2tlZFxuICB9ID0ge30pIHtcbiAgICBpZiAodHlwZW9mIGlzVW5sb2NrZWQgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICB0aGlzLl9sb2cuZXJyb3IoXG4gICAgICAgIFwiTWV0YU1hc2s6IFJlY2VpdmVkIGludmFsaWQgaXNVbmxvY2tlZCBwYXJhbWV0ZXIuIFBsZWFzZSByZXBvcnQgdGhpcyBidWcuXCJcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1VubG9ja2VkICE9PSB0aGlzLl9zdGF0ZS5pc1VubG9ja2VkKSB7XG4gICAgICB0aGlzLl9zdGF0ZS5pc1VubG9ja2VkID0gaXNVbmxvY2tlZDtcbiAgICAgIHRoaXMuX2hhbmRsZUFjY291bnRzQ2hhbmdlZChhY2NvdW50cyA/PyBbXSk7XG4gICAgfVxuICB9XG59O1xuX2NoYWluSWQgPSBuZXcgV2Vha01hcCgpO1xuX3NlbGVjdGVkQWRkcmVzcyA9IG5ldyBXZWFrTWFwKCk7XG5fQmFzZVByb3ZpZGVyLl9kZWZhdWx0U3RhdGUgPSB7XG4gIGFjY291bnRzOiBudWxsLFxuICBpc0Nvbm5lY3RlZDogZmFsc2UsXG4gIGlzVW5sb2NrZWQ6IGZhbHNlLFxuICBpbml0aWFsaXplZDogZmFsc2UsXG4gIGlzUGVybWFuZW50bHlEaXNjb25uZWN0ZWQ6IGZhbHNlXG59O1xudmFyIEJhc2VQcm92aWRlciA9IF9CYXNlUHJvdmlkZXI7XG5cbmV4cG9ydCB7XG4gIEJhc2VQcm92aWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLU9HUEE1UTc2Lm1qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgX3RvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTsgfSB9XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwgeyB3cml0YWJsZTogZmFsc2UgfSk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdidWZmZXInKSxcbiAgQnVmZmVyID0gX3JlcXVpcmUuQnVmZmVyO1xudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJ3V0aWwnKSxcbiAgaW5zcGVjdCA9IF9yZXF1aXJlMi5pbnNwZWN0O1xudmFyIGN1c3RvbSA9IGluc3BlY3QgJiYgaW5zcGVjdC5jdXN0b20gfHwgJ2luc3BlY3QnO1xuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuY29weS5jYWxsKHNyYywgdGFyZ2V0LCBvZmZzZXQpO1xufVxubW9kdWxlLmV4cG9ydHMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhCdWZmZXJMaXN0LCBbe1xuICAgIGtleTogXCJwdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2godikge1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICBkYXRhOiB2LFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICArK3RoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICBkYXRhOiB2LFxuICAgICAgICBuZXh0OiB0aGlzLmhlYWRcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgICArK3RoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgICAtLXRoaXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJqb2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSByZXQgKz0gcyArIHAuZGF0YTtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbmNhdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25jYXQobikge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIG9yIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cbiAgfSwge1xuICAgIGtleTogXCJjb25zdW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnN1bWUobiwgaGFzU3RyaW5ncykge1xuICAgICAgdmFyIHJldDtcbiAgICAgIGlmIChuIDwgdGhpcy5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vIGBzbGljZWAgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICAgIHJldCA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgICAgICB0aGlzLmhlYWQuZGF0YSA9IHRoaXMuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICAgICAgfSBlbHNlIGlmIChuID09PSB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gRmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoLlxuICAgICAgICByZXQgPSB0aGlzLnNoaWZ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXIuXG4gICAgICAgIHJldCA9IGhhc1N0cmluZ3MgPyB0aGlzLl9nZXRTdHJpbmcobikgOiB0aGlzLl9nZXRCdWZmZXIobik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaXJzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB9XG5cbiAgICAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRTdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFN0cmluZyhuKSB7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBjID0gMTtcbiAgICAgIHZhciByZXQgPSBwLmRhdGE7XG4gICAgICBuIC09IHJldC5sZW5ndGg7XG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgICAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgICAgICBuIC09IG5iO1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gcDtcbiAgICAgICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgICsrYztcbiAgICAgIH1cbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEJ1ZmZlcihuKSB7XG4gICAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgYyA9IDE7XG4gICAgICBwLmRhdGEuY29weShyZXQpO1xuICAgICAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICAgICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICAgICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgICAgICBuIC09IG5iO1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gcDtcbiAgICAgICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgICsrYztcbiAgICAgIH1cbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGlua2VkIGxpc3Qgb25seSBzaG93cyB0aGUgbWluaW1hbCBuZWNlc3NhcnkgaW5mb3JtYXRpb24uXG4gIH0sIHtcbiAgICBrZXk6IGN1c3RvbSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoXywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGluc3BlY3QodGhpcywgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgLy8gT25seSBpbnNwZWN0IG9uZSBsZXZlbC5cbiAgICAgICAgZGVwdGg6IDAsXG4gICAgICAgIC8vIEl0IHNob3VsZCBub3QgcmVjdXJzZS5cbiAgICAgICAgY3VzdG9tSW5zcGVjdDogZmFsc2VcbiAgICAgIH0pKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufVxuZnVuY3Rpb24gZW1pdEVycm9yQW5kQ2xvc2VOVChzZWxmLCBlcnIpIHtcbiAgZW1pdEVycm9yTlQoc2VsZiwgZXJyKTtcbiAgZW1pdENsb3NlTlQoc2VsZik7XG59XG5mdW5jdGlvbiBlbWl0Q2xvc2VOVChzZWxmKSB7XG4gIGlmIChzZWxmLl93cml0YWJsZVN0YXRlICYmICFzZWxmLl93cml0YWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBpZiAoc2VsZi5fcmVhZGFibGVTdGF0ZSAmJiAhc2VsZi5fcmVhZGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgc2VsZi5lbWl0KCdjbG9zZScpO1xufVxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5mdW5jdGlvbiBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycikge1xuICAvLyBXZSBoYXZlIHRlc3RzIHRoYXQgcmVseSBvbiBlcnJvcnMgYmVpbmcgZW1pdHRlZFxuICAvLyBpbiB0aGUgc2FtZSB0aWNrLCBzbyBjaGFuZ2luZyB0aGlzIGlzIHNlbXZlciBtYWpvci5cbiAgLy8gRm9yIG5vdyB3aGVuIHlvdSBvcHQtaW4gdG8gYXV0b0Rlc3Ryb3kgd2UgYWxsb3dcbiAgLy8gdGhlIGVycm9yIHRvIGJlIGVtaXR0ZWQgbmV4dFRpY2suIEluIGEgZnV0dXJlXG4gIC8vIHNlbXZlciBtYWpvciB1cGRhdGUgd2Ugc2hvdWxkIGNoYW5nZSB0aGUgZGVmYXVsdCB0byB0aGlzLlxuXG4gIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIGlmIChyU3RhdGUgJiYgclN0YXRlLmF1dG9EZXN0cm95IHx8IHdTdGF0ZSAmJiB3U3RhdGUuYXV0b0Rlc3Ryb3kpIHN0cmVhbS5kZXN0cm95KGVycik7ZWxzZSBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95LFxuICBlcnJvck9yRGVzdHJveTogZXJyb3JPckRlc3Ryb3lcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGNvZGVzID0ge307XG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShjb2RlLCBtZXNzYWdlLCBCYXNlKSB7XG4gIGlmICghQmFzZSkge1xuICAgIEJhc2UgPSBFcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9XG4gIH1cblxuICB2YXIgTm9kZUVycm9yID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0Jhc2UpIHtcbiAgICBfaW5oZXJpdHNMb29zZShOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICByZXR1cm4gX0Jhc2UuY2FsbCh0aGlzLCBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpKSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBOb2RlRXJyb3I7XG4gIH0oQmFzZSk7XG5cbiAgTm9kZUVycm9yLnByb3RvdHlwZS5uYW1lID0gQmFzZS5uYW1lO1xuICBOb2RlRXJyb3IucHJvdG90eXBlLmNvZGUgPSBjb2RlO1xuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfT1BUX1ZBTFVFJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiAnVGhlIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiJztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJywgZnVuY3Rpb24gKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcbiAgdmFyIGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuXG4gIHZhciBtc2c7XG5cbiAgaWYgKGVuZHNXaXRoKG5hbWUsICcgYXJndW1lbnQnKSkge1xuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICBtc2cgPSBcIlRoZSBcIi5jb25jYXQobmFtZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBcIikuY29uY2F0KHR5cGUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH1cblxuICBtc2cgKz0gXCIuIFJlY2VpdmVkIHR5cGUgXCIuY29uY2F0KHR5cGVvZiBhY3R1YWwpO1xuICByZXR1cm4gbXNnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRicsICdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCcsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAnVGhlICcgKyBuYW1lICsgJyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScsICdQcmVtYXR1cmUgY2xvc2UnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9ERVNUUk9ZRUQnLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gJ0Nhbm5vdCBjYWxsICcgKyBuYW1lICsgJyBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTVVMVElQTEVfQ0FMTEJBQ0snLCAnQ2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fQ0FOTk9UX1BJUEUnLCAnQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCcsICd3cml0ZSBhZnRlciBlbmQnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUycsICdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScsIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9VTktOT1dOX0VOQ09ESU5HJywgZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBhcmc7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UJywgJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG5tb2R1bGUuZXhwb3J0cy5jb2RlcyA9IGNvZGVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX0lOVkFMSURfT1BUX1ZBTFVFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX0lOVkFMSURfT1BUX1ZBTFVFO1xuZnVuY3Rpb24gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSkge1xuICByZXR1cm4gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrICE9IG51bGwgPyBvcHRpb25zLmhpZ2hXYXRlck1hcmsgOiBpc0R1cGxleCA/IG9wdGlvbnNbZHVwbGV4S2V5XSA6IG51bGw7XG59XG5mdW5jdGlvbiBnZXRIaWdoV2F0ZXJNYXJrKHN0YXRlLCBvcHRpb25zLCBkdXBsZXhLZXksIGlzRHVwbGV4KSB7XG4gIHZhciBod20gPSBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KTtcbiAgaWYgKGh3bSAhPSBudWxsKSB7XG4gICAgaWYgKCEoaXNGaW5pdGUoaHdtKSAmJiBNYXRoLmZsb29yKGh3bSkgPT09IGh3bSkgfHwgaHdtIDwgMCkge1xuICAgICAgdmFyIG5hbWUgPSBpc0R1cGxleCA/IGR1cGxleEtleSA6ICdoaWdoV2F0ZXJNYXJrJztcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9PUFRfVkFMVUUobmFtZSwgaHdtKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoaHdtKTtcbiAgfVxuXG4gIC8vIERlZmF1bHQgdmFsdWVcbiAgcmV0dXJuIHN0YXRlLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRIaWdoV2F0ZXJNYXJrOiBnZXRIaWdoV2F0ZXJNYXJrXG59OyIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyogPHJlcGxhY2VtZW50PiAqL1xuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xuICB0aGlzLm5leHQgPSBudWxsO1xufVxuXG4vLyBJdCBzZWVtcyBhIGxpbmtlZCBsaXN0IGJ1dCBpdCBpcyBub3Rcbi8vIHRoZXJlIHdpbGwgYmUgb25seSAyIG9mIHRoZXNlIGZvciBlYWNoIHN0cmVhbVxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9ICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9KS5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gIEVSUl9NVUxUSVBMRV9DQUxMQkFDSyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxcbiAgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUsXG4gIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQsXG4gIEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX05VTExfVkFMVUVTLFxuICBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5ELFxuICBFUlJfVU5LTk9XTl9FTkNPRElORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9VTktOT1dOX0VOQ09ESU5HO1xudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG5yZXF1aXJlKCdpbmhlcml0cycpKFdyaXRhYmxlLCBTdHJlYW0pO1xuZnVuY3Rpb24gbm9wKCkge31cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbSxcbiAgLy8gZS5nLiBvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZSB2cy4gb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGUsIGV0Yy5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpO1xuXG4gIC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xuXG4gIC8vIGRyYWluIGV2ZW50IGZsYWcuXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XG4gIC8vIGF0IHRoZSBzdGFydCBvZiBjYWxsaW5nIGVuZCgpXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7XG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cbiAgdmFyIG5vRGVjb2RlID0gb3B0aW9ucy5kZWNvZGVTdHJpbmdzID09PSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG4gIHRoaXMubGVuZ3RoID0gMDtcblxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuICB0aGlzLndyaXRpbmcgPSBmYWxzZTtcblxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG4gIHRoaXMuY29ya2VkID0gMDtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuICB0aGlzLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG4gIHRoaXMub253cml0ZSA9IGZ1bmN0aW9uIChlcikge1xuICAgIG9ud3JpdGUoc3RyZWFtLCBlcik7XG4gIH07XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG5cbiAgLy8gdGhlIGFtb3VudCB0aGF0IGlzIGJlaW5nIHdyaXR0ZW4gd2hlbiBfd3JpdGUgaXMgY2FsbGVkLlxuICB0aGlzLndyaXRlbGVuID0gMDtcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBTaG91bGQgY2xvc2UgYmUgZW1pdHRlZCBvbiBkZXN0cm95LiBEZWZhdWx0cyB0byB0cnVlLlxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTtcblxuICAvLyBTaG91bGQgLmRlc3Ryb3koKSBiZSBjYWxsZWQgYWZ0ZXIgJ2ZpbmlzaCcgKGFuZCBwb3RlbnRpYWxseSAnZW5kJylcbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiB3cml0YWJsZVN0YXRlQnVmZmVyR2V0dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gcmVhbEhhc0luc3RhbmNlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuXG4gIC8vIENoZWNraW5nIGZvciBhIFN0cmVhbS5EdXBsZXggaW5zdGFuY2UgaXMgZmFzdGVyIGhlcmUgaW5zdGVhZCBvZiBpbnNpZGVcbiAgLy8gdGhlIFdyaXRhYmxlU3RhdGUgY29uc3RydWN0b3IsIGF0IGxlYXN0IHdpdGggVjggNi41XG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIGlmICghaXNEdXBsZXggJiYgIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUoKSk7XG59O1xuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCgpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgZXI7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJ10sIGNodW5rKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuICBpZiAoc3RhdGUuZW5kaW5nKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuY29ya2VkKys7XG59O1xuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IEVSUl9VTktOT1dOX0VOQ09ESU5HKGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAoc3RhdGUuZGVzdHJveWVkKSBzdGF0ZS5vbndyaXRlKG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnd3JpdGUnKSk7ZWxzZSBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB0aGUgY2FsbGVyIGV4cGVjdCB0aGlzIHRvIGhhcHBlbiBiZWZvcmUgaWZcbiAgICAvLyBpdCBpcyBhc3luY1xuICAgIGNiKGVyKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKTtcbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpIHx8IHN0cmVhbS5kZXN0cm95ZWQ7XG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3dyaXRlKCknKSk7XG59O1xuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZykgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlTGVuZ3RoJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5sZW5ndGg7XG4gIH1cbn0pO1xuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgaWYgKGVycikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nICYmICFzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcbiAgICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAgIC8vIGlmIHRoZSByZWFkYWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICAgIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gICAgICAgIGlmICghclN0YXRlIHx8IHJTdGF0ZS5hdXRvRGVzdHJveSAmJiByU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZWQ7XG59XG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcbiAgdmFyIGVudHJ5ID0gY29ya1JlcS5lbnRyeTtcbiAgY29ya1JlcS5lbnRyeSA9IG51bGw7XG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9XG5cbiAgLy8gcmV1c2UgdGhlIGZyZWUgY29ya1JlcS5cbiAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcbnJlcXVpcmUoJ2luaGVyaXRzJykoRHVwbGV4LCBSZWFkYWJsZSk7XG57XG4gIC8vIEFsbG93IHRoZSBrZXlzIGFycmF5IHRvIGJlIEdDJ2VkLlxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG4gICAgfVxuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBJZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCwgdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pOyIsIi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvZW5kLW9mLXN0cmVhbSB3aXRoXG4vLyBwZXJtaXNzaW9uIGZyb20gdGhlIGF1dGhvciwgTWF0aGlhcyBCdXVzIChAbWFmaW50b3NoKS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRTtcbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG59XG5mdW5jdGlvbiBub29wKCkge31cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGVvcyhzdHJlYW0sIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVvcyhzdHJlYW0sIG51bGwsIG9wdHMpO1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICB2YXIgcmVhZGFibGUgPSBvcHRzLnJlYWRhYmxlIHx8IG9wdHMucmVhZGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS5yZWFkYWJsZTtcbiAgdmFyIHdyaXRhYmxlID0gb3B0cy53cml0YWJsZSB8fCBvcHRzLndyaXRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ud3JpdGFibGU7XG4gIHZhciBvbmxlZ2FjeWZpbmlzaCA9IGZ1bmN0aW9uIG9ubGVnYWN5ZmluaXNoKCkge1xuICAgIGlmICghc3RyZWFtLndyaXRhYmxlKSBvbmZpbmlzaCgpO1xuICB9O1xuICB2YXIgd3JpdGFibGVFbmRlZCA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZSAmJiBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQ7XG4gIHZhciBvbmZpbmlzaCA9IGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIHdyaXRhYmxlID0gZmFsc2U7XG4gICAgd3JpdGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCFyZWFkYWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuICB2YXIgcmVhZGFibGVFbmRlZCA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZSAmJiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZDtcbiAgdmFyIG9uZW5kID0gZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICByZWFkYWJsZUVuZGVkID0gdHJ1ZTtcbiAgICBpZiAoIXdyaXRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gIH07XG4gIHZhciBvbmVycm9yID0gZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgfTtcbiAgdmFyIG9uY2xvc2UgPSBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIHZhciBlcnI7XG4gICAgaWYgKHJlYWRhYmxlICYmICFyZWFkYWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fcmVhZGFibGVTdGF0ZSB8fCAhc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG4gICAgaWYgKHdyaXRhYmxlICYmICF3cml0YWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fd3JpdGFibGVTdGF0ZSB8fCAhc3RyZWFtLl93cml0YWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG4gIH07XG4gIHZhciBvbnJlcXVlc3QgPSBmdW5jdGlvbiBvbnJlcXVlc3QoKSB7XG4gICAgc3RyZWFtLnJlcS5vbignZmluaXNoJywgb25maW5pc2gpO1xuICB9O1xuICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHtcbiAgICBzdHJlYW0ub24oJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5vbignYWJvcnQnLCBvbmNsb3NlKTtcbiAgICBpZiAoc3RyZWFtLnJlcSkgb25yZXF1ZXN0KCk7ZWxzZSBzdHJlYW0ub24oJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuICB9IGVsc2UgaWYgKHdyaXRhYmxlICYmICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAvLyBsZWdhY3kgc3RyZWFtc1xuICAgIHN0cmVhbS5vbignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5vbignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gIH1cbiAgc3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7XG4gIHN0cmVhbS5vbignZmluaXNoJywgb25maW5pc2gpO1xuICBpZiAob3B0cy5lcnJvciAhPT0gZmFsc2UpIHN0cmVhbS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgc3RyZWFtLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY29tcGxldGUnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIG9uY2xvc2UpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIHN0cmVhbS5yZXEucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGVvczsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfT2JqZWN0JHNldFByb3RvdHlwZU87XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG52YXIgZmluaXNoZWQgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKTtcbnZhciBrTGFzdFJlc29sdmUgPSBTeW1ib2woJ2xhc3RSZXNvbHZlJyk7XG52YXIga0xhc3RSZWplY3QgPSBTeW1ib2woJ2xhc3RSZWplY3QnKTtcbnZhciBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG52YXIga0VuZGVkID0gU3ltYm9sKCdlbmRlZCcpO1xudmFyIGtMYXN0UHJvbWlzZSA9IFN5bWJvbCgnbGFzdFByb21pc2UnKTtcbnZhciBrSGFuZGxlUHJvbWlzZSA9IFN5bWJvbCgnaGFuZGxlUHJvbWlzZScpO1xudmFyIGtTdHJlYW0gPSBTeW1ib2woJ3N0cmVhbScpO1xuZnVuY3Rpb24gY3JlYXRlSXRlclJlc3VsdCh2YWx1ZSwgZG9uZSkge1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBkb25lOiBkb25lXG4gIH07XG59XG5mdW5jdGlvbiByZWFkQW5kUmVzb2x2ZShpdGVyKSB7XG4gIHZhciByZXNvbHZlID0gaXRlcltrTGFzdFJlc29sdmVdO1xuICBpZiAocmVzb2x2ZSAhPT0gbnVsbCkge1xuICAgIHZhciBkYXRhID0gaXRlcltrU3RyZWFtXS5yZWFkKCk7XG4gICAgLy8gd2UgZGVmZXIgaWYgZGF0YSBpcyBudWxsXG4gICAgLy8gd2UgY2FuIGJlIGV4cGVjdGluZyBlaXRoZXIgJ2VuZCcgb3JcbiAgICAvLyAnZXJyb3InXG4gICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBvblJlYWRhYmxlKGl0ZXIpIHtcbiAgLy8gd2Ugd2FpdCBmb3IgdGhlIG5leHQgdGljaywgYmVjYXVzZSBpdCBtaWdodFxuICAvLyBlbWl0IGFuIGVycm9yIHdpdGggcHJvY2Vzcy5uZXh0VGlja1xuICBwcm9jZXNzLm5leHRUaWNrKHJlYWRBbmRSZXNvbHZlLCBpdGVyKTtcbn1cbmZ1bmN0aW9uIHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCBpdGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbGFzdFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXRlcltrRW5kZWRdKSB7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaXRlcltrSGFuZGxlUHJvbWlzZV0ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9LCByZWplY3QpO1xuICB9O1xufVxudmFyIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnVuY3Rpb24gKCkge30pO1xudmFyIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZigoX09iamVjdCRzZXRQcm90b3R5cGVPID0ge1xuICBnZXQgc3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzW2tTdHJlYW1dO1xuICB9LFxuICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgLy8gaWYgd2UgaGF2ZSBkZXRlY3RlZCBhbiBlcnJvciBpbiB0aGUgbWVhbndoaWxlXG4gICAgLy8gcmVqZWN0IHN0cmFpZ2h0IGF3YXlcbiAgICB2YXIgZXJyb3IgPSB0aGlzW2tFcnJvcl07XG4gICAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgICBpZiAodGhpc1trRW5kZWRdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuICAgIGlmICh0aGlzW2tTdHJlYW1dLmRlc3Ryb3llZCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBkZWZlciB2aWEgbmV4dFRpY2sgYmVjYXVzZSBpZiAuZGVzdHJveShlcnIpIGlzXG4gICAgICAvLyBjYWxsZWQsIHRoZSBlcnJvciB3aWxsIGJlIGVtaXR0ZWQgdmlhIG5leHRUaWNrLCBhbmRcbiAgICAgIC8vIHdlIGNhbm5vdCBndWFyYW50ZWUgdGhhdCB0aGVyZSBpcyBubyBlcnJvciBsaW5nZXJpbmcgYXJvdW5kXG4gICAgICAvLyB3YWl0aW5nIHRvIGJlIGVtaXR0ZWQuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXNba0Vycm9yXSkge1xuICAgICAgICAgICAgcmVqZWN0KF90aGlzW2tFcnJvcl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIGlmIHdlIGhhdmUgbXVsdGlwbGUgbmV4dCgpIGNhbGxzXG4gICAgLy8gd2Ugd2lsbCB3YWl0IGZvciB0aGUgcHJldmlvdXMgUHJvbWlzZSB0byBmaW5pc2hcbiAgICAvLyB0aGlzIGxvZ2ljIGlzIG9wdGltaXplZCB0byBzdXBwb3J0IGZvciBhd2FpdCBsb29wcyxcbiAgICAvLyB3aGVyZSBuZXh0KCkgaXMgb25seSBjYWxsZWQgb25jZSBhdCBhIHRpbWVcbiAgICB2YXIgbGFzdFByb21pc2UgPSB0aGlzW2tMYXN0UHJvbWlzZV07XG4gICAgdmFyIHByb21pc2U7XG4gICAgaWYgKGxhc3RQcm9taXNlKSB7XG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2Uod3JhcEZvck5leHQobGFzdFByb21pc2UsIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmFzdCBwYXRoIG5lZWRlZCB0byBzdXBwb3J0IG11bHRpcGxlIHRoaXMucHVzaCgpXG4gICAgICAvLyB3aXRob3V0IHRyaWdnZXJpbmcgdGhlIG5leHQoKSBxdWV1ZVxuICAgICAgdmFyIGRhdGEgPSB0aGlzW2tTdHJlYW1dLnJlYWQoKTtcbiAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfVxuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHRoaXNba0hhbmRsZVByb21pc2VdKTtcbiAgICB9XG4gICAgdGhpc1trTGFzdFByb21pc2VdID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgU3ltYm9sLmFzeW5jSXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgXCJyZXR1cm5cIiwgZnVuY3Rpb24gX3JldHVybigpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG4gIC8vIGRlc3Ryb3koZXJyLCBjYikgaXMgYSBwcml2YXRlIEFQSVxuICAvLyB3ZSBjYW4gZ3VhcmFudGVlIHdlIGhhdmUgdGhhdCBoZXJlLCBiZWNhdXNlIHdlIGNvbnRyb2wgdGhlXG4gIC8vIFJlYWRhYmxlIGNsYXNzIHRoaXMgaXMgYXR0YWNoZWQgdG9cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBfdGhpczJba1N0cmVhbV0uZGVzdHJveShudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfSk7XG4gIH0pO1xufSksIF9PYmplY3Qkc2V0UHJvdG90eXBlTyksIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcihzdHJlYW0pIHtcbiAgdmFyIF9PYmplY3QkY3JlYXRlO1xuICB2YXIgaXRlcmF0b3IgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSwgKF9PYmplY3QkY3JlYXRlID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga1N0cmVhbSwge1xuICAgIHZhbHVlOiBzdHJlYW0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZXNvbHZlLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZWplY3QsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRXJyb3IsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRW5kZWQsIHtcbiAgICB2YWx1ZTogc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0hhbmRsZVByb21pc2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZGF0YSA9IGl0ZXJhdG9yW2tTdHJlYW1dLnJlYWQoKTtcbiAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gcmVzb2x2ZTtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gcmVqZWN0O1xuICAgICAgfVxuICAgIH0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9PYmplY3QkY3JlYXRlKSk7XG4gIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICBmaW5pc2hlZChzdHJlYW0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyICYmIGVyci5jb2RlICE9PSAnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnKSB7XG4gICAgICB2YXIgcmVqZWN0ID0gaXRlcmF0b3Jba0xhc3RSZWplY3RdO1xuICAgICAgLy8gcmVqZWN0IGlmIHdlIGFyZSB3YWl0aW5nIGZvciBkYXRhIGluIHRoZSBQcm9taXNlXG4gICAgICAvLyByZXR1cm5lZCBieSBuZXh0KCkgYW5kIHN0b3JlIHRoZSBlcnJvclxuICAgICAgaWYgKHJlamVjdCAhPT0gbnVsbCkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgaXRlcmF0b3Jba0Vycm9yXSA9IGVycjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJlc29sdmUgPSBpdGVyYXRvcltrTGFzdFJlc29sdmVdO1xuICAgIGlmIChyZXNvbHZlICE9PSBudWxsKSB7XG4gICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG4gICAgaXRlcmF0b3Jba0VuZGVkXSA9IHRydWU7XG4gIH0pO1xuICBzdHJlYW0ub24oJ3JlYWRhYmxlJywgb25SZWFkYWJsZS5iaW5kKG51bGwsIGl0ZXJhdG9yKSk7XG4gIHJldHVybiBpdGVyYXRvcjtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBFRWxpc3RlbmVyQ291bnQoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fSkuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZztcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gZGVidWcoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRixcbiAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQ7XG5cbi8vIExhenkgbG9hZGVkIHRvIGltcHJvdmUgdGhlIHN0YXJ0dXAgcGVyZm9ybWFuY2UuXG52YXIgU3RyaW5nRGVjb2RlcjtcbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7XG52YXIgZnJvbTtcbnJlcXVpcmUoJ2luaGVyaXRzJykoUmVhZGFibGUsIFN0cmVhbSk7XG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcblxuICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZ2V0SGlnaFdhdGVyTWFyayh0aGlzLCBvcHRpb25zLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywgaXNEdXBsZXgpO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdGhpcy5wYXVzZWQgPSB0cnVlO1xuXG4gIC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG4gIHRoaXMuZW1pdENsb3NlID0gb3B0aW9ucy5lbWl0Q2xvc2UgIT09IGZhbHNlO1xuXG4gIC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZW5kJyAoYW5kIHBvdGVudGlhbGx5ICdmaW5pc2gnKVxuICB0aGlzLmF1dG9EZXN0cm95ID0gISFvcHRpb25zLmF1dG9EZXN0cm95O1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBSZWFkYWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIGRlYnVnKCdyZWFkYWJsZUFkZENodW5rJywgY2h1bmspO1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UKCkpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GKCkpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9XG5cbiAgLy8gV2UgY2FuIHB1c2ggbW9yZSBkYXRhIGlmIHdlIGFyZSBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyay5cbiAgLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWUgbW9yZSBieXRlcy5cbiAgLy8gVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCwgc3VjaCBhcyB0aGUgcmVwbC5cbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJywgJ1VpbnQ4QXJyYXknXSwgY2h1bmspO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdmFyIGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBkZWNvZGVyO1xuICAvLyBJZiBzZXRFbmNvZGluZyhudWxsKSwgZGVjb2Rlci5lbmNvZGluZyBlcXVhbHMgdXRmOFxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyLmVuY29kaW5nO1xuXG4gIC8vIEl0ZXJhdGUgb3ZlciBjdXJyZW50IGJ1ZmZlciB0byBjb252ZXJ0IGFscmVhZHkgc3RvcmVkIEJ1ZmZlcnM6XG4gIHZhciBwID0gdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuaGVhZDtcbiAgdmFyIGNvbnRlbnQgPSAnJztcbiAgd2hpbGUgKHAgIT09IG51bGwpIHtcbiAgICBjb250ZW50ICs9IGRlY29kZXIud3JpdGUocC5kYXRhKTtcbiAgICBwID0gcC5uZXh0O1xuICB9XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIGlmIChjb250ZW50ICE9PSAnJykgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIucHVzaChjb250ZW50KTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggPSBjb250ZW50Lmxlbmd0aDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gMUdCXG52YXIgTUFYX0hXTSA9IDB4NDAwMDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICAvLyBUT0RPKHJvbmFnKTogVGhyb3cgRVJSX1ZBTFVFX09VVF9PRl9SQU5HRS5cbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmICgoc3RhdGUuaGlnaFdhdGVyTWFyayAhPT0gMCA/IHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIDogc3RhdGUubGVuZ3RoID4gMCkgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICB9XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG4gIHJldHVybiByZXQ7XG59O1xuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdvbkVvZkNodW5rJyk7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIGlmIChzdGF0ZS5zeW5jKSB7XG4gICAgLy8gaWYgd2UgYXJlIHN5bmMsIHdhaXQgdW50aWwgbmV4dCB0aWNrIHRvIGVtaXQgdGhlIGRhdGEuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIHJpc2sgZW1pdHRpbmcgZGF0YSBpbiB0aGUgZmxvdygpXG4gICAgLy8gdGhlIHJlYWRhYmxlIGNvZGUgdHJpZ2dlcnMgZHVyaW5nIGEgcmVhZCgpIGNhbGxcbiAgICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUubmVlZFJlYWRhYmxlLCBzdGF0ZS5lbWl0dGVkUmVhZGFibGUpO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZV8nLCBzdGF0ZS5kZXN0cm95ZWQsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICBpZiAoIXN0YXRlLmRlc3Ryb3llZCAmJiAoc3RhdGUubGVuZ3RoIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB9XG5cbiAgLy8gVGhlIHN0cmVhbSBuZWVkcyBhbm90aGVyIHJlYWRhYmxlIGV2ZW50IGlmXG4gIC8vIDEuIEl0IGlzIG5vdCBmbG93aW5nLCBhcyB0aGUgZmxvdyBtZWNoYW5pc20gd2lsbCB0YWtlXG4gIC8vICAgIGNhcmUgb2YgaXQuXG4gIC8vIDIuIEl0IGlzIG5vdCBlbmRlZC5cbiAgLy8gMy4gSXQgaXMgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmssIHNvIHdlIGNhbiBzY2hlZHVsZVxuICAvLyAgICBhbm90aGVyIHJlYWRhYmxlIGxhdGVyLlxuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBBdHRlbXB0IHRvIHJlYWQgbW9yZSBkYXRhIGlmIHdlIHNob3VsZC5cbiAgLy9cbiAgLy8gVGhlIGNvbmRpdGlvbnMgZm9yIHJlYWRpbmcgbW9yZSBkYXRhIGFyZSAob25lIG9mKTpcbiAgLy8gLSBOb3QgZW5vdWdoIGRhdGEgYnVmZmVyZWQgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspLiBUaGUgbG9vcFxuICAvLyAgIGlzIHJlc3BvbnNpYmxlIGZvciBmaWxsaW5nIHRoZSBidWZmZXIgd2l0aCBlbm91Z2ggZGF0YSBpZiBzdWNoIGRhdGFcbiAgLy8gICBpcyBhdmFpbGFibGUuIElmIGhpZ2hXYXRlck1hcmsgaXMgMCBhbmQgd2UgYXJlIG5vdCBpbiB0aGUgZmxvd2luZyBtb2RlXG4gIC8vICAgd2Ugc2hvdWxkIF9ub3RfIGF0dGVtcHQgdG8gYnVmZmVyIGFueSBleHRyYSBkYXRhLiBXZSdsbCBnZXQgbW9yZSBkYXRhXG4gIC8vICAgd2hlbiB0aGUgc3RyZWFtIGNvbnN1bWVyIGNhbGxzIHJlYWQoKSBpbnN0ZWFkLlxuICAvLyAtIE5vIGRhdGEgaW4gdGhlIGJ1ZmZlciwgYW5kIHRoZSBzdHJlYW0gaXMgaW4gZmxvd2luZyBtb2RlLiBJbiB0aGlzIG1vZGVcbiAgLy8gICB0aGUgbG9vcCBiZWxvdyBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgcmVhZCgpIGlzIGNhbGxlZC4gRmFpbGluZyB0b1xuICAvLyAgIGNhbGwgcmVhZCBoZXJlIHdvdWxkIGFib3J0IHRoZSBmbG93IGFuZCB0aGVyZSdzIG5vIG90aGVyIG1lY2hhbmlzbSBmb3JcbiAgLy8gICBjb250aW51aW5nIHRoZSBmbG93IGlmIHRoZSBzdHJlYW0gY29uc3VtZXIgaGFzIGp1c3Qgc3Vic2NyaWJlZCB0byB0aGVcbiAgLy8gICAnZGF0YScgZXZlbnQuXG4gIC8vXG4gIC8vIEluIGFkZGl0aW9uIHRvIHRoZSBhYm92ZSBjb25kaXRpb25zIHRvIGtlZXAgcmVhZGluZyBkYXRhLCB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgcHJldmVudCB0aGUgZGF0YSBmcm9tIGJlaW5nIHJlYWQ6XG4gIC8vIC0gVGhlIHN0cmVhbSBoYXMgZW5kZWQgKHN0YXRlLmVuZGVkKS5cbiAgLy8gLSBUaGVyZSBpcyBhbHJlYWR5IGEgcGVuZGluZyAncmVhZCcgb3BlcmF0aW9uIChzdGF0ZS5yZWFkaW5nKS4gVGhpcyBpcyBhXG4gIC8vICAgY2FzZSB3aGVyZSB0aGUgdGhlIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIF9yZWFkKClcbiAgLy8gICBtZXRob2QsIGJ1dCB0aGV5IGFyZSBwcm9jZXNzaW5nIHRoZSBjYWxsIGFzeW5jaHJvbm91c2x5IGFuZCBoYXZlIF9ub3RfXG4gIC8vICAgY2FsbGVkIHB1c2goKSB3aXRoIG5ldyBkYXRhLiBJbiB0aGlzIGNhc2Ugd2Ugc2tpcCBwZXJmb3JtaW5nIG1vcmVcbiAgLy8gICByZWFkKClzLiBUaGUgZXhlY3V0aW9uIGVuZHMgaW4gdGhpcyBtZXRob2QgYWdhaW4gYWZ0ZXIgdGhlIF9yZWFkKCkgZW5kc1xuICAvLyAgIHVwIGNhbGxpbmcgcHVzaCgpIHdpdGggbW9yZSBkYXRhLlxuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwKSkge1xuICAgIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfcmVhZCgpJykpO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGRlYnVnKCdkZXN0LndyaXRlJywgcmV0KTtcbiAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGVycm9yT3JEZXN0cm95KGRlc3QsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn07XG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVPbkRyYWluRnVuY3Rpb25SZXN1bHQoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0ge1xuICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB7XG4gICAgICBoYXNVbnBpcGVkOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyB1cGRhdGUgcmVhZGFibGVMaXN0ZW5pbmcgc28gdGhhdCByZXN1bWUoKSBtYXkgYmUgYSBuby1vcFxuICAgIC8vIGEgZmV3IGxpbmVzIGRvd24uIFRoaXMgaXMgbmVlZGVkIHRvIHN1cHBvcnQgb25jZSgncmVhZGFibGUnKS5cbiAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRoaXMubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7XG5cbiAgICAvLyBUcnkgc3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBkZWJ1Zygnb24gcmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLnJlYWRpbmcpO1xuICAgICAgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsIGV2LCBmbik7XG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyB8fCBldiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoc2VsZikge1xuICB2YXIgc3RhdGUgPSBzZWxmLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHNlbGYubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7XG4gIGlmIChzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgJiYgIXN0YXRlLnBhdXNlZCkge1xuICAgIC8vIGZsb3dpbmcgbmVlZHMgdG8gYmUgc2V0IHRvIHRydWUgbm93LCBvdGhlcndpc2VcbiAgICAvLyB0aGUgdXBjb21pbmcgcmVzdW1lIHdpbGwgbm90IGZsb3cuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG5cbiAgICAvLyBjcnVkZSB3YXkgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHJlc3VtZVxuICB9IGVsc2UgaWYgKHNlbGYubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCkge1xuICAgIHNlbGYucmVzdW1lKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIC8vIHdlIGZsb3cgb25seSBpZiB0aGVyZSBpcyBubyBvbmUgbGlzdGVuaW5nXG4gICAgLy8gZm9yIHJlYWRhYmxlLCBidXQgd2Ugc3RpbGwgaGF2ZSB0byBjYWxsXG4gICAgLy8gcmVzdW1lKClcbiAgICBzdGF0ZS5mbG93aW5nID0gIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgc3RhdGUucGF1c2VkID0gZmFsc2U7XG4gIHJldHVybiB0aGlzO1xufTtcbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ3Jlc3VtZScsIHN0YXRlLnJlYWRpbmcpO1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUucGF1c2VkID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKTtcbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIG1ldGhvZFdyYXAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXRob2RXcmFwUmV0dXJuRnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0aGlzO1xufTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3InKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKTtcbiAgfTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVGbG93aW5nJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldChzdGF0ZSkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBzdGF0ZTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuZmlyc3QoKTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25zdW1lKG4sIHN0YXRlLmRlY29kZXIpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW5kUmVhZGFibGUnLCBzdGF0ZS5lbmRFbWl0dGVkKTtcbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICBkZWJ1ZygnZW5kUmVhZGFibGVOVCcsIHN0YXRlLmVuZEVtaXR0ZWQsIHN0YXRlLmxlbmd0aCk7XG5cbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAvLyBJbiBjYXNlIG9mIGR1cGxleCBzdHJlYW1zIHdlIG5lZWQgYSB3YXkgdG8gZGV0ZWN0XG4gICAgICAvLyBpZiB0aGUgd3JpdGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgdmFyIHdTdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgICAgIGlmICghd1N0YXRlIHx8IHdTdGF0ZS5hdXRvRGVzdHJveSAmJiB3U3RhdGUuZmluaXNoZWQpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLmZyb20gPSBmdW5jdGlvbiAoaXRlcmFibGUsIG9wdHMpIHtcbiAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcm9tID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20nKTtcbiAgICB9XG4gICAgcmV0dXJuIGZyb20oUmVhZGFibGUsIGl0ZXJhYmxlLCBvcHRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdSZWFkYWJsZS5mcm9tIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGJyb3dzZXInKVxufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICBFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyxcbiAgRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wID0gX3JlcXVpcmUkY29kZXMuRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wO1xudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbnJlcXVpcmUoJ2luaGVyaXRzJykoVHJhbnNmb3JtLCBEdXBsZXgpO1xuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKSk7XG4gIH1cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuICBpZiAoZGF0YSAhPSBudWxsKVxuICAgIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcbiAgY2IoZXIpO1xuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTtcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG4gIHRoaXMub24oJ3ByZWZpbmlzaCcsIHByZWZpbmlzaCk7XG59XG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3RyYW5zZm9ybSgpJykpO1xufTtcblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICB9KTtcbn07XG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBpZiAoZGF0YSAhPSBudWxsKVxuICAgIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIFRPRE8oQnJpZGdlQVIpOiBXcml0ZSBhIHRlc3QgZm9yIHRoZXNlIHR3byBlcnJvciBjYXNlc1xuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCgpO1xuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HKCk7XG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL3B1bXAgd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVvcztcbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLFxuICBFUlJfTUlTU0lOR19BUkdTID0gX3JlcXVpcmUkY29kZXMuRVJSX01JU1NJTkdfQVJHUyxcbiAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRDtcbmZ1bmN0aW9uIG5vb3AoZXJyKSB7XG4gIC8vIFJldGhyb3cgdGhlIGVycm9yIGlmIGl0IGV4aXN0cyB0byBhdm9pZCBzd2FsbG93aW5nIGl0XG4gIGlmIChlcnIpIHRocm93IGVycjtcbn1cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayk7XG4gIHZhciBjbG9zZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjbG9zZWQgPSB0cnVlO1xuICB9KTtcbiAgaWYgKGVvcyA9PT0gdW5kZWZpbmVkKSBlb3MgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKTtcbiAgZW9zKHN0cmVhbSwge1xuICAgIHJlYWRhYmxlOiByZWFkaW5nLFxuICAgIHdyaXRhYmxlOiB3cml0aW5nXG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICBjbG9zZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrKCk7XG4gIH0pO1xuICB2YXIgZGVzdHJveWVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGNsb3NlZCkgcmV0dXJuO1xuICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICBkZXN0cm95ZWQgPSB0cnVlO1xuXG4gICAgLy8gcmVxdWVzdC5kZXN0cm95IGp1c3QgZG8gLmVuZCAtIC5hYm9ydCBpcyB3aGF0IHdlIHdhbnRcbiAgICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHJldHVybiBzdHJlYW0uYWJvcnQoKTtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSByZXR1cm4gc3RyZWFtLmRlc3Ryb3koKTtcbiAgICBjYWxsYmFjayhlcnIgfHwgbmV3IEVSUl9TVFJFQU1fREVTVFJPWUVEKCdwaXBlJykpO1xuICB9O1xufVxuZnVuY3Rpb24gY2FsbChmbikge1xuICBmbigpO1xufVxuZnVuY3Rpb24gcGlwZShmcm9tLCB0bykge1xuICByZXR1cm4gZnJvbS5waXBlKHRvKTtcbn1cbmZ1bmN0aW9uIHBvcENhbGxiYWNrKHN0cmVhbXMpIHtcbiAgaWYgKCFzdHJlYW1zLmxlbmd0aCkgcmV0dXJuIG5vb3A7XG4gIGlmICh0eXBlb2Ygc3RyZWFtc1tzdHJlYW1zLmxlbmd0aCAtIDFdICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gbm9vcDtcbiAgcmV0dXJuIHN0cmVhbXMucG9wKCk7XG59XG5mdW5jdGlvbiBwaXBlbGluZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0cmVhbXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc3RyZWFtc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICB2YXIgY2FsbGJhY2sgPSBwb3BDYWxsYmFjayhzdHJlYW1zKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RyZWFtc1swXSkpIHN0cmVhbXMgPSBzdHJlYW1zWzBdO1xuICBpZiAoc3RyZWFtcy5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVSUl9NSVNTSU5HX0FSR1MoJ3N0cmVhbXMnKTtcbiAgfVxuICB2YXIgZXJyb3I7XG4gIHZhciBkZXN0cm95cyA9IHN0cmVhbXMubWFwKGZ1bmN0aW9uIChzdHJlYW0sIGkpIHtcbiAgICB2YXIgcmVhZGluZyA9IGkgPCBzdHJlYW1zLmxlbmd0aCAtIDE7XG4gICAgdmFyIHdyaXRpbmcgPSBpID4gMDtcbiAgICByZXR1cm4gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gICAgICBpZiAoZXJyKSBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xuICAgICAgaWYgKHJlYWRpbmcpIHJldHVybjtcbiAgICAgIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gc3RyZWFtcy5yZWR1Y2UocGlwZSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IHBpcGVsaW5lOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcbnJlcXVpcmUoJ2luaGVyaXRzJykoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5leHBvcnRzLmZpbmlzaGVkID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzJyk7XG5leHBvcnRzLnBpcGVsaW5lID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcycpO1xuIiwiLy8gc3JjL2NyZWF0ZVN0cmVhbU1pZGRsZXdhcmUudHNcbmltcG9ydCBTYWZlRXZlbnRFbWl0dGVyIGZyb20gXCJAbWV0YW1hc2svc2FmZS1ldmVudC1lbWl0dGVyXCI7XG5pbXBvcnQgeyBEdXBsZXggfSBmcm9tIFwicmVhZGFibGUtc3RyZWFtXCI7XG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1NaWRkbGV3YXJlKG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBpZE1hcCA9IHt9O1xuICBjb25zdCBzdHJlYW0gPSBuZXcgRHVwbGV4KHtcbiAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgIHJlYWQ6ICgpID0+IHZvaWQgMCxcbiAgICB3cml0ZTogcHJvY2Vzc01lc3NhZ2VcbiAgfSk7XG4gIGNvbnN0IGV2ZW50cyA9IG5ldyBTYWZlRXZlbnRFbWl0dGVyKCk7XG4gIGNvbnN0IG1pZGRsZXdhcmUgPSAocmVxLCByZXMsIG5leHQsIGVuZCkgPT4ge1xuICAgIGlkTWFwW3JlcS5pZF0gPSB7IHJlcSwgcmVzLCBuZXh0LCBlbmQgfTtcbiAgICBzZW5kVG9TdHJlYW0ocmVxKTtcbiAgfTtcbiAgcmV0dXJuIHsgZXZlbnRzLCBtaWRkbGV3YXJlLCBzdHJlYW0gfTtcbiAgZnVuY3Rpb24gc2VuZFRvU3RyZWFtKHJlcSkge1xuICAgIHN0cmVhbS5wdXNoKHJlcSk7XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc01lc3NhZ2UocmVzLCBfZW5jb2RpbmcsIHN0cmVhbVdyaXRlQ2FsbGJhY2spIHtcbiAgICBsZXQgZXJyb3JPYmogPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBpc05vdGlmaWNhdGlvbiA9ICFyZXMuaWQ7XG4gICAgICBpZiAoaXNOb3RpZmljYXRpb24pIHtcbiAgICAgICAgcHJvY2Vzc05vdGlmaWNhdGlvbihyZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc1Jlc3BvbnNlKHJlcyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgZXJyb3JPYmogPSBfZXJyO1xuICAgIH1cbiAgICBzdHJlYW1Xcml0ZUNhbGxiYWNrKGVycm9yT2JqKTtcbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzUmVzcG9uc2UocmVzKSB7XG4gICAgY29uc3QgeyBpZDogcmVzcG9uc2VJZCB9ID0gcmVzO1xuICAgIGlmIChyZXNwb25zZUlkID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSBpZE1hcFtyZXNwb25zZUlkXTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIGNvbnNvbGUud2FybihgU3RyZWFtTWlkZGxld2FyZSAtIFVua25vd24gcmVzcG9uc2UgaWQgXCIke3Jlc3BvbnNlSWR9XCJgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIGlkTWFwW3Jlc3BvbnNlSWRdO1xuICAgIE9iamVjdC5hc3NpZ24oY29udGV4dC5yZXMsIHJlcyk7XG4gICAgc2V0VGltZW91dChjb250ZXh0LmVuZCk7XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc05vdGlmaWNhdGlvbihub3RpZikge1xuICAgIGlmIChvcHRpb25zPy5yZXRyeU9uTWVzc2FnZSAmJiBub3RpZi5tZXRob2QgPT09IG9wdGlvbnMucmV0cnlPbk1lc3NhZ2UpIHtcbiAgICAgIHJldHJ5U3R1Y2tSZXF1ZXN0cygpO1xuICAgIH1cbiAgICBldmVudHMuZW1pdChcIm5vdGlmaWNhdGlvblwiLCBub3RpZik7XG4gIH1cbiAgZnVuY3Rpb24gcmV0cnlTdHVja1JlcXVlc3RzKCkge1xuICAgIE9iamVjdC52YWx1ZXMoaWRNYXApLmZvckVhY2goKHsgcmVxLCByZXRyeUNvdW50ID0gMCB9KSA9PiB7XG4gICAgICBpZiAoIXJlcS5pZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmV0cnlDb3VudCA+PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgU3RyZWFtTWlkZGxld2FyZSAtIFJldHJ5IGxpbWl0IGV4Y2VlZGVkIGZvciByZXF1ZXN0IGlkIFwiJHtyZXEuaWR9XCJgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBpZE1hcE9iamVjdCA9IGlkTWFwW3JlcS5pZF07XG4gICAgICBpZiAoaWRNYXBPYmplY3QpIHtcbiAgICAgICAgaWRNYXBPYmplY3QucmV0cnlDb3VudCA9IHJldHJ5Q291bnQgKyAxO1xuICAgICAgfVxuICAgICAgc2VuZFRvU3RyZWFtKHJlcSk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IHtcbiAgY3JlYXRlU3RyZWFtTWlkZGxld2FyZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLTQ0NlFZT0JQLm1qcy5tYXAiLCIvLyBSZXR1cm5zIGEgd3JhcHBlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSB3cmFwcGVkIGNhbGxiYWNrXG4vLyBUaGUgd3JhcHBlciBmdW5jdGlvbiBzaG91bGQgZG8gc29tZSBzdHVmZiwgYW5kIHJldHVybiBhXG4vLyBwcmVzdW1hYmx5IGRpZmZlcmVudCBjYWxsYmFjayBmdW5jdGlvbi5cbi8vIFRoaXMgbWFrZXMgc3VyZSB0aGF0IG93biBwcm9wZXJ0aWVzIGFyZSByZXRhaW5lZCwgc28gdGhhdFxuLy8gZGVjb3JhdGlvbnMgYW5kIHN1Y2ggYXJlIG5vdCBsb3N0IGFsb25nIHRoZSB3YXkuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweVxuZnVuY3Rpb24gd3JhcHB5IChmbiwgY2IpIHtcbiAgaWYgKGZuICYmIGNiKSByZXR1cm4gd3JhcHB5KGZuKShjYilcblxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25lZWQgd3JhcHBlciBmdW5jdGlvbicpXG5cbiAgT2JqZWN0LmtleXMoZm4pLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICB3cmFwcGVyW2tdID0gZm5ba11cbiAgfSlcblxuICByZXR1cm4gd3JhcHBlclxuXG4gIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgICB9XG4gICAgdmFyIHJldCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3MpXG4gICAgdmFyIGNiID0gYXJnc1thcmdzLmxlbmd0aC0xXVxuICAgIGlmICh0eXBlb2YgcmV0ID09PSAnZnVuY3Rpb24nICYmIHJldCAhPT0gY2IpIHtcbiAgICAgIE9iamVjdC5rZXlzKGNiKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldFtrXSA9IGNiW2tdXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cbn1cbiIsInZhciB3cmFwcHkgPSByZXF1aXJlKCd3cmFwcHknKVxubW9kdWxlLmV4cG9ydHMgPSB3cmFwcHkob25jZSlcbm1vZHVsZS5leHBvcnRzLnN0cmljdCA9IHdyYXBweShvbmNlU3RyaWN0KVxuXG5vbmNlLnByb3RvID0gb25jZShmdW5jdGlvbiAoKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGdW5jdGlvbi5wcm90b3R5cGUsICdvbmNlJywge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb25jZSh0aGlzKVxuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2VTdHJpY3QnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlU3RyaWN0KHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChmLmNhbGxlZCkgcmV0dXJuIGYudmFsdWVcbiAgICBmLmNhbGxlZCA9IHRydWVcbiAgICByZXR1cm4gZi52YWx1ZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuICBmLmNhbGxlZCA9IGZhbHNlXG4gIHJldHVybiBmXG59XG5cbmZ1bmN0aW9uIG9uY2VTdHJpY3QgKGZuKSB7XG4gIHZhciBmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChmLmNhbGxlZClcbiAgICAgIHRocm93IG5ldyBFcnJvcihmLm9uY2VFcnJvcilcbiAgICBmLmNhbGxlZCA9IHRydWVcbiAgICByZXR1cm4gZi52YWx1ZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuICB2YXIgbmFtZSA9IGZuLm5hbWUgfHwgJ0Z1bmN0aW9uIHdyYXBwZWQgd2l0aCBgb25jZWAnXG4gIGYub25jZUVycm9yID0gbmFtZSArIFwiIHNob3VsZG4ndCBiZSBjYWxsZWQgbW9yZSB0aGFuIG9uY2VcIlxuICBmLmNhbGxlZCA9IGZhbHNlXG4gIHJldHVybiBmXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3Vic3RyZWFtID0gdm9pZCAwO1xuY29uc3QgcmVhZGFibGVfc3RyZWFtXzEgPSByZXF1aXJlKFwicmVhZGFibGUtc3RyZWFtXCIpO1xuY2xhc3MgU3Vic3RyZWFtIGV4dGVuZHMgcmVhZGFibGVfc3RyZWFtXzEuRHVwbGV4IHtcbiAgICBjb25zdHJ1Y3Rvcih7IHBhcmVudCwgbmFtZSB9KSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwbGljaXRseSBzZXRzIHJlYWQgb3BlcmF0aW9ucyB0byBhIG5vLW9wLlxuICAgICAqL1xuICAgIF9yZWFkKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBkYXRhIHNob3VsZCBiZSB3cml0dGVuIHRvIHRoaXMgd3JpdGFibGUgc3RyZWFtLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNodW5rIC0gQXJiaXRyYXJ5IG9iamVjdCB0byB3cml0ZVxuICAgICAqIEBwYXJhbSBlbmNvZGluZyAtIEVuY29kaW5nIHRvIHVzZSB3aGVuIHdyaXRpbmcgcGF5bG9hZFxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxlZCB3aGVuIHdyaXRpbmcgaXMgY29tcGxldGUgb3IgYW4gZXJyb3Igb2NjdXJzXG4gICAgICovXG4gICAgX3dyaXRlKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3BhcmVudC5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuX25hbWUsXG4gICAgICAgICAgICBkYXRhOiBjaHVuayxcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TdWJzdHJlYW0gPSBTdWJzdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdWJzdHJlYW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9iamVjdE11bHRpcGxleCA9IHZvaWQgMDtcbmNvbnN0IHJlYWRhYmxlX3N0cmVhbV8xID0gcmVxdWlyZShcInJlYWRhYmxlLXN0cmVhbVwiKTtcbmNvbnN0IG9uY2VfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwib25jZVwiKSk7XG5jb25zdCBTdWJzdHJlYW1fMSA9IHJlcXVpcmUoXCIuL1N1YnN0cmVhbVwiKTtcbmNvbnN0IElHTk9SRV9TVUJTVFJFQU0gPSBTeW1ib2woJ0lHTk9SRV9TVUJTVFJFQU0nKTtcbmNsYXNzIE9iamVjdE11bHRpcGxleCBleHRlbmRzIHJlYWRhYmxlX3N0cmVhbV8xLkR1cGxleCB7XG4gICAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0cyksIHsgb2JqZWN0TW9kZTogdHJ1ZSB9KSk7XG4gICAgICAgIHRoaXMuX3N1YnN0cmVhbXMgPSB7fTtcbiAgICB9XG4gICAgY3JlYXRlU3RyZWFtKG5hbWUpIHtcbiAgICAgICAgLy8gZ3VhcmQgc3RyZWFtIGFnYWluc3QgZGVzdHJveWVkIGFscmVhZHlcbiAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdE11bHRpcGxleCAtIHBhcmVudCBzdHJlYW0gZm9yIG5hbWUgXCIke25hbWV9XCIgYWxyZWFkeSBkZXN0cm95ZWRgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBndWFyZCBzdHJlYW0gYWdhaW5zdCBlbmRlZCBhbHJlYWR5XG4gICAgICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT2JqZWN0TXVsdGlwbGV4IC0gcGFyZW50IHN0cmVhbSBmb3IgbmFtZSBcIiR7bmFtZX1cIiBhbHJlYWR5IGVuZGVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdmFsaWRhdGUgbmFtZVxuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0TXVsdGlwbGV4IC0gbmFtZSBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdWJzdHJlYW1zW25hbWVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdE11bHRpcGxleCAtIFN1YnN0cmVhbSBmb3IgbmFtZSBcIiR7bmFtZX1cIiBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBzdWJzdHJlYW1cbiAgICAgICAgY29uc3Qgc3Vic3RyZWFtID0gbmV3IFN1YnN0cmVhbV8xLlN1YnN0cmVhbSh7IHBhcmVudDogdGhpcywgbmFtZSB9KTtcbiAgICAgICAgdGhpcy5fc3Vic3RyZWFtc1tuYW1lXSA9IHN1YnN0cmVhbTtcbiAgICAgICAgLy8gbGlzdGVuIGZvciBwYXJlbnQgc3RyZWFtIHRvIGVuZFxuICAgICAgICBhbnlTdHJlYW1FbmQodGhpcywgKF9lcnJvcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN1YnN0cmVhbS5kZXN0cm95KF9lcnJvciB8fCB1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN1YnN0cmVhbTtcbiAgICB9XG4gICAgLy8gaWdub3JlIHN0cmVhbXMgKGRvbnQgZGlzcGxheSBvcnBoYW5lZCBkYXRhIHdhcm5pbmcpXG4gICAgaWdub3JlU3RyZWFtKG5hbWUpIHtcbiAgICAgICAgLy8gdmFsaWRhdGUgbmFtZVxuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0TXVsdGlwbGV4IC0gbmFtZSBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9zdWJzdHJlYW1zW25hbWVdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9iamVjdE11bHRpcGxleCAtIFN1YnN0cmVhbSBmb3IgbmFtZSBcIiR7bmFtZX1cIiBhbHJlYWR5IGV4aXN0c2ApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldFxuICAgICAgICB0aGlzLl9zdWJzdHJlYW1zW25hbWVdID0gSUdOT1JFX1NVQlNUUkVBTTtcbiAgICB9XG4gICAgX3JlYWQoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIF93cml0ZShjaHVuaywgX2VuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCB7IG5hbWUsIGRhdGEgfSA9IGNodW5rO1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgT2JqZWN0TXVsdGlwbGV4IC0gbWFsZm9ybWVkIGNodW5rIHdpdGhvdXQgbmFtZSBcIiR7Y2h1bmt9XCJgKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBjb3JyZXNwb25kaW5nIHN1YnN0cmVhbVxuICAgICAgICBjb25zdCBzdWJzdHJlYW0gPSB0aGlzLl9zdWJzdHJlYW1zW25hbWVdO1xuICAgICAgICBpZiAoIXN1YnN0cmVhbSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBPYmplY3RNdWx0aXBsZXggLSBvcnBoYW5lZCBkYXRhIGZvciBzdHJlYW0gXCIke25hbWV9XCJgKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHB1c2ggZGF0YSBpbnRvIHN1YnN0cmVhbVxuICAgICAgICBpZiAoc3Vic3RyZWFtICE9PSBJR05PUkVfU1VCU1RSRUFNKSB7XG4gICAgICAgICAgICBzdWJzdHJlYW0ucHVzaChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG59XG5leHBvcnRzLk9iamVjdE11bHRpcGxleCA9IE9iamVjdE11bHRpcGxleDtcbi8vIHV0aWxcbmZ1bmN0aW9uIGFueVN0cmVhbUVuZChzdHJlYW0sIF9jYikge1xuICAgIGNvbnN0IGNiID0gKDAsIG9uY2VfMS5kZWZhdWx0KShfY2IpO1xuICAgICgwLCByZWFkYWJsZV9zdHJlYW1fMS5maW5pc2hlZCkoc3RyZWFtLCB7IHJlYWRhYmxlOiBmYWxzZSB9LCBjYik7XG4gICAgKDAsIHJlYWRhYmxlX3N0cmVhbV8xLmZpbmlzaGVkKShzdHJlYW0sIHsgd3JpdGFibGU6IGZhbHNlIH0sIGNiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdE11bHRpcGxleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmNvbnN0IE9iamVjdE11bHRpcGxleF8xID0gcmVxdWlyZShcIi4vT2JqZWN0TXVsdGlwbGV4XCIpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RNdWx0aXBsZXhfMS5PYmplY3RNdWx0aXBsZXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzU3RyZWFtID0gc3RyZWFtID0+XG5cdHN0cmVhbSAhPT0gbnVsbCAmJlxuXHR0eXBlb2Ygc3RyZWFtID09PSAnb2JqZWN0JyAmJlxuXHR0eXBlb2Ygc3RyZWFtLnBpcGUgPT09ICdmdW5jdGlvbic7XG5cbmlzU3RyZWFtLndyaXRhYmxlID0gc3RyZWFtID0+XG5cdGlzU3RyZWFtKHN0cmVhbSkgJiZcblx0c3RyZWFtLndyaXRhYmxlICE9PSBmYWxzZSAmJlxuXHR0eXBlb2Ygc3RyZWFtLl93cml0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHR0eXBlb2Ygc3RyZWFtLl93cml0YWJsZVN0YXRlID09PSAnb2JqZWN0JztcblxuaXNTdHJlYW0ucmVhZGFibGUgPSBzdHJlYW0gPT5cblx0aXNTdHJlYW0oc3RyZWFtKSAmJlxuXHRzdHJlYW0ucmVhZGFibGUgIT09IGZhbHNlICYmXG5cdHR5cGVvZiBzdHJlYW0uX3JlYWQgPT09ICdmdW5jdGlvbicgJiZcblx0dHlwZW9mIHN0cmVhbS5fcmVhZGFibGVTdGF0ZSA9PT0gJ29iamVjdCc7XG5cbmlzU3RyZWFtLmR1cGxleCA9IHN0cmVhbSA9PlxuXHRpc1N0cmVhbS53cml0YWJsZShzdHJlYW0pICYmXG5cdGlzU3RyZWFtLnJlYWRhYmxlKHN0cmVhbSk7XG5cbmlzU3RyZWFtLnRyYW5zZm9ybSA9IHN0cmVhbSA9PlxuXHRpc1N0cmVhbS5kdXBsZXgoc3RyZWFtKSAmJlxuXHR0eXBlb2Ygc3RyZWFtLl90cmFuc2Zvcm0gPT09ICdmdW5jdGlvbic7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJlYW07XG4iLCJpbXBvcnQge1xuICBzZW5kU2l0ZU1ldGFkYXRhXG59IGZyb20gXCIuL2NodW5rLTU1WlE1NVBPLm1qc1wiO1xuaW1wb3J0IHtcbiAgQWJzdHJhY3RTdHJlYW1Qcm92aWRlclxufSBmcm9tIFwiLi9jaHVuay1VVFJPSFhQVC5tanNcIjtcbmltcG9ydCB7XG4gIEVNSVRURURfTk9USUZJQ0FUSU9OUyxcbiAgTk9PUCxcbiAgZ2V0RGVmYXVsdEV4dGVybmFsTWlkZGxld2FyZSxcbiAgZ2V0UnBjUHJvbWlzZUNhbGxiYWNrXG59IGZyb20gXCIuL2NodW5rLVpON1dWNTVKLm1qc1wiO1xuaW1wb3J0IHtcbiAgbWVzc2FnZXNfZGVmYXVsdFxufSBmcm9tIFwiLi9jaHVuay1aR0RRM0lZRC5tanNcIjtcbmltcG9ydCB7XG4gIF9fcHJpdmF0ZUFkZCxcbiAgX19wcml2YXRlR2V0LFxuICBfX3ByaXZhdGVTZXRcbn0gZnJvbSBcIi4vY2h1bmstWDY2U1VJRUYubWpzXCI7XG5cbi8vIHNyYy9NZXRhTWFza0lucGFnZVByb3ZpZGVyLnRzXG5pbXBvcnQgeyBycGNFcnJvcnMgfSBmcm9tIFwiQG1ldGFtYXNrL3JwYy1lcnJvcnNcIjtcbnZhciBNZXRhTWFza0lucGFnZVByb3ZpZGVyU3RyZWFtTmFtZSA9IFwibWV0YW1hc2stcHJvdmlkZXJcIjtcbnZhciBfbmV0d29ya1ZlcnNpb247XG52YXIgTWV0YU1hc2tJbnBhZ2VQcm92aWRlciA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RTdHJlYW1Qcm92aWRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBNZXRhTWFza0lucGFnZVByb3ZpZGVyYC5cbiAgICpcbiAgICogQHBhcmFtIGNvbm5lY3Rpb25TdHJlYW0gLSBBIE5vZGUuanMgZHVwbGV4IHN0cmVhbS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIGJhZy5cbiAgICogQHBhcmFtIG9wdGlvbnMuanNvblJwY1N0cmVhbU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgaW50ZXJuYWwgSlNPTi1SUEMgc3RyZWFtLlxuICAgKiBEZWZhdWx0OiBgbWV0YW1hc2stcHJvdmlkZXJgLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5sb2dnZXIgLSBUaGUgbG9nZ2luZyBBUEkgdG8gdXNlLiBEZWZhdWx0OiBgY29uc29sZWAuXG4gICAqIEBwYXJhbSBvcHRpb25zLm1heEV2ZW50TGlzdGVuZXJzIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGV2ZW50XG4gICAqIGxpc3RlbmVycy4gRGVmYXVsdDogMTAwLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5zaG91bGRTZW5kTWV0YWRhdGEgLSBXaGV0aGVyIHRoZSBwcm92aWRlciBzaG91bGRcbiAgICogc2VuZCBwYWdlIG1ldGFkYXRhLiBEZWZhdWx0OiBgdHJ1ZWAuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uU3RyZWFtLCB7XG4gICAganNvblJwY1N0cmVhbU5hbWUgPSBNZXRhTWFza0lucGFnZVByb3ZpZGVyU3RyZWFtTmFtZSxcbiAgICBsb2dnZXIgPSBjb25zb2xlLFxuICAgIG1heEV2ZW50TGlzdGVuZXJzID0gMTAwLFxuICAgIHNob3VsZFNlbmRNZXRhZGF0YVxuICB9ID0ge30pIHtcbiAgICBzdXBlcihjb25uZWN0aW9uU3RyZWFtLCB7XG4gICAgICBqc29uUnBjU3RyZWFtTmFtZSxcbiAgICAgIGxvZ2dlcixcbiAgICAgIG1heEV2ZW50TGlzdGVuZXJzLFxuICAgICAgcnBjTWlkZGxld2FyZTogZ2V0RGVmYXVsdEV4dGVybmFsTWlkZGxld2FyZShsb2dnZXIpXG4gICAgfSk7XG4gICAgdGhpcy5fc2VudFdhcm5pbmdzID0ge1xuICAgICAgLy8gcHJvcGVydGllc1xuICAgICAgY2hhaW5JZDogZmFsc2UsXG4gICAgICBuZXR3b3JrVmVyc2lvbjogZmFsc2UsXG4gICAgICBzZWxlY3RlZEFkZHJlc3M6IGZhbHNlLFxuICAgICAgLy8gbWV0aG9kc1xuICAgICAgZW5hYmxlOiBmYWxzZSxcbiAgICAgIGV4cGVyaW1lbnRhbE1ldGhvZHM6IGZhbHNlLFxuICAgICAgc2VuZDogZmFsc2UsXG4gICAgICAvLyBldmVudHNcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBjbG9zZTogZmFsc2UsXG4gICAgICAgIGRhdGE6IGZhbHNlLFxuICAgICAgICBuZXR3b3JrQ2hhbmdlZDogZmFsc2UsXG4gICAgICAgIG5vdGlmaWNhdGlvbjogZmFsc2VcbiAgICAgIH1cbiAgICB9O1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfbmV0d29ya1ZlcnNpb24sIHZvaWQgMCk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZVN0YXRlQXN5bmMoKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX25ldHdvcmtWZXJzaW9uLCBudWxsKTtcbiAgICB0aGlzLmlzTWV0YU1hc2sgPSB0cnVlO1xuICAgIHRoaXMuX3NlbmRTeW5jID0gdGhpcy5fc2VuZFN5bmMuYmluZCh0aGlzKTtcbiAgICB0aGlzLmVuYWJsZSA9IHRoaXMuZW5hYmxlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zZW5kID0gdGhpcy5zZW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zZW5kQXN5bmMgPSB0aGlzLnNlbmRBc3luYy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3dhcm5PZkRlcHJlY2F0aW9uID0gdGhpcy5fd2Fybk9mRGVwcmVjYXRpb24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9tZXRhbWFzayA9IHRoaXMuX2dldEV4cGVyaW1lbnRhbEFwaSgpO1xuICAgIHRoaXMuX2pzb25ScGNDb25uZWN0aW9uLmV2ZW50cy5vbihcIm5vdGlmaWNhdGlvblwiLCAocGF5bG9hZCkgPT4ge1xuICAgICAgY29uc3QgeyBtZXRob2QgfSA9IHBheWxvYWQ7XG4gICAgICBpZiAoRU1JVFRFRF9OT1RJRklDQVRJT05TLmluY2x1ZGVzKG1ldGhvZCkpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGF0YVwiLCBwYXlsb2FkKTtcbiAgICAgICAgdGhpcy5lbWl0KFwibm90aWZpY2F0aW9uXCIsIHBheWxvYWQucGFyYW1zLnJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHNob3VsZFNlbmRNZXRhZGF0YSkge1xuICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICBzZW5kU2l0ZU1ldGFkYXRhKHRoaXMuX3JwY0VuZ2luZSwgdGhpcy5fbG9nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRvbUNvbnRlbnRMb2FkZWRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgIHNlbmRTaXRlTWV0YWRhdGEodGhpcy5fcnBjRW5naW5lLCB0aGlzLl9sb2cpO1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgXCJET01Db250ZW50TG9hZGVkXCIsXG4gICAgICAgICAgICBkb21Db250ZW50TG9hZGVkSGFuZGxlclxuICAgICAgICAgICk7XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBkb21Db250ZW50TG9hZGVkSGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vPT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRGVwcmVjYXRlZCBQcm9wZXJ0aWVzXG4gIC8vPT09PT09PT09PT09PT09PT09PT1cbiAgZ2V0IGNoYWluSWQoKSB7XG4gICAgaWYgKCF0aGlzLl9zZW50V2FybmluZ3MuY2hhaW5JZCkge1xuICAgICAgdGhpcy5fbG9nLndhcm4obWVzc2FnZXNfZGVmYXVsdC53YXJuaW5ncy5jaGFpbklkRGVwcmVjYXRpb24pO1xuICAgICAgdGhpcy5fc2VudFdhcm5pbmdzLmNoYWluSWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuY2hhaW5JZDtcbiAgfVxuICBnZXQgbmV0d29ya1ZlcnNpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9zZW50V2FybmluZ3MubmV0d29ya1ZlcnNpb24pIHtcbiAgICAgIHRoaXMuX2xvZy53YXJuKG1lc3NhZ2VzX2RlZmF1bHQud2FybmluZ3MubmV0d29ya1ZlcnNpb25EZXByZWNhdGlvbik7XG4gICAgICB0aGlzLl9zZW50V2FybmluZ3MubmV0d29ya1ZlcnNpb24gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9uZXR3b3JrVmVyc2lvbik7XG4gIH1cbiAgZ2V0IHNlbGVjdGVkQWRkcmVzcygpIHtcbiAgICBpZiAoIXRoaXMuX3NlbnRXYXJuaW5ncy5zZWxlY3RlZEFkZHJlc3MpIHtcbiAgICAgIHRoaXMuX2xvZy53YXJuKG1lc3NhZ2VzX2RlZmF1bHQud2FybmluZ3Muc2VsZWN0ZWRBZGRyZXNzRGVwcmVjYXRpb24pO1xuICAgICAgdGhpcy5fc2VudFdhcm5pbmdzLnNlbGVjdGVkQWRkcmVzcyA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5zZWxlY3RlZEFkZHJlc3M7XG4gIH1cbiAgLy89PT09PT09PT09PT09PT09PT09PVxuICAvLyBQdWJsaWMgTWV0aG9kc1xuICAvLz09PT09PT09PT09PT09PT09PT09XG4gIC8qKlxuICAgKiBTdWJtaXRzIGFuIFJQQyByZXF1ZXN0IHBlciB0aGUgZ2l2ZW4gSlNPTi1SUEMgcmVxdWVzdCBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSBwYXlsb2FkIC0gVGhlIFJQQyByZXF1ZXN0IG9iamVjdC5cbiAgICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKi9cbiAgc2VuZEFzeW5jKHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fcnBjUmVxdWVzdChwYXlsb2FkLCBjYWxsYmFjayk7XG4gIH1cbiAgLyoqXG4gICAqIFdlIG92ZXJyaWRlIHRoZSBmb2xsb3dpbmcgZXZlbnQgbWV0aG9kcyBzbyB0aGF0IHdlIGNhbiB3YXJuIGNvbnN1bWVyc1xuICAgKiBhYm91dCBkZXByZWNhdGVkIGV2ZW50czpcbiAgICogYGFkZExpc3RlbmVyYCwgYG9uYCwgYG9uY2VgLCBgcHJlcGVuZExpc3RlbmVyYCwgYHByZXBlbmRPbmNlTGlzdGVuZXJgLlxuICAgKi9cbiAgYWRkTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHRoaXMuX3dhcm5PZkRlcHJlY2F0aW9uKGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHN1cGVyLmFkZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG4gIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLl93YXJuT2ZEZXByZWNhdGlvbihldmVudE5hbWUpO1xuICAgIHJldHVybiBzdXBlci5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuICBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLl93YXJuT2ZEZXByZWNhdGlvbihldmVudE5hbWUpO1xuICAgIHJldHVybiBzdXBlci5vbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG4gIHByZXBlbmRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fd2Fybk9mRGVwcmVjYXRpb24oZXZlbnROYW1lKTtcbiAgICByZXR1cm4gc3VwZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICB9XG4gIHByZXBlbmRPbmNlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgIHRoaXMuX3dhcm5PZkRlcHJlY2F0aW9uKGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHN1cGVyLnByZXBlbmRPbmNlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gIH1cbiAgLy89PT09PT09PT09PT09PT09PT09PVxuICAvLyBQcml2YXRlIE1ldGhvZHNcbiAgLy89PT09PT09PT09PT09PT09PT09PVxuICAvKipcbiAgICogV2hlbiB0aGUgcHJvdmlkZXIgYmVjb21lcyBkaXNjb25uZWN0ZWQsIHVwZGF0ZXMgaW50ZXJuYWwgc3RhdGUgYW5kIGVtaXRzXG4gICAqIHJlcXVpcmVkIGV2ZW50cy4gSWRlbXBvdGVudCB3aXRoIHJlc3BlY3QgdG8gdGhlIGlzUmVjb3ZlcmFibGUgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBFcnJvciBjb2RlcyBwZXIgdGhlIENsb3NlRXZlbnQgc3RhdHVzIGNvZGVzIGFzIHJlcXVpcmVkIGJ5IEVJUC0xMTkzOlxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2xvc2VFdmVudCNTdGF0dXNfY29kZXMuXG4gICAqXG4gICAqIEBwYXJhbSBpc1JlY292ZXJhYmxlIC0gV2hldGhlciB0aGUgZGlzY29ubmVjdGlvbiBpcyByZWNvdmVyYWJsZS5cbiAgICogQHBhcmFtIGVycm9yTWVzc2FnZSAtIEEgY3VzdG9tIGVycm9yIG1lc3NhZ2UuXG4gICAqIEBmaXJlcyBCYXNlUHJvdmlkZXIjZGlzY29ubmVjdCAtIElmIHRoZSBkaXNjb25uZWN0aW9uIGlzIG5vdCByZWNvdmVyYWJsZS5cbiAgICovXG4gIF9oYW5kbGVEaXNjb25uZWN0KGlzUmVjb3ZlcmFibGUsIGVycm9yTWVzc2FnZSkge1xuICAgIHN1cGVyLl9oYW5kbGVEaXNjb25uZWN0KGlzUmVjb3ZlcmFibGUsIGVycm9yTWVzc2FnZSk7XG4gICAgaWYgKF9fcHJpdmF0ZUdldCh0aGlzLCBfbmV0d29ya1ZlcnNpb24pICYmICFpc1JlY292ZXJhYmxlKSB7XG4gICAgICBfX3ByaXZhdGVTZXQodGhpcywgX25ldHdvcmtWZXJzaW9uLCBudWxsKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFdhcm5zIG9mIGRlcHJlY2F0aW9uIGZvciB0aGUgZ2l2ZW4gZXZlbnQsIGlmIGFwcGxpY2FibGUuXG4gICAqXG4gICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuXG4gICAqL1xuICBfd2Fybk9mRGVwcmVjYXRpb24oZXZlbnROYW1lKSB7XG4gICAgaWYgKHRoaXMuX3NlbnRXYXJuaW5ncz8uZXZlbnRzW2V2ZW50TmFtZV0gPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl9sb2cud2FybihtZXNzYWdlc19kZWZhdWx0Lndhcm5pbmdzLmV2ZW50c1tldmVudE5hbWVdKTtcbiAgICAgIHRoaXMuX3NlbnRXYXJuaW5ncy5ldmVudHNbZXZlbnROYW1lXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8vPT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRGVwcmVjYXRlZCBNZXRob2RzXG4gIC8vPT09PT09PT09PT09PT09PT09PT1cbiAgLyoqXG4gICAqIEVxdWl2YWxlbnQgdG86IGBldGhlcmV1bS5yZXF1ZXN0KCdldGhfcmVxdWVzdEFjY291bnRzJylgLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVxdWVzdCh7IG1ldGhvZDogJ2V0aF9yZXF1ZXN0QWNjb3VudHMnIH0pIGluc3RlYWQuXG4gICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIGFycmF5IG9mIGFkZHJlc3Nlcy5cbiAgICovXG4gIGFzeW5jIGVuYWJsZSgpIHtcbiAgICBpZiAoIXRoaXMuX3NlbnRXYXJuaW5ncy5lbmFibGUpIHtcbiAgICAgIHRoaXMuX2xvZy53YXJuKG1lc3NhZ2VzX2RlZmF1bHQud2FybmluZ3MuZW5hYmxlRGVwcmVjYXRpb24pO1xuICAgICAgdGhpcy5fc2VudFdhcm5pbmdzLmVuYWJsZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9ycGNSZXF1ZXN0KFxuICAgICAgICAgIHsgbWV0aG9kOiBcImV0aF9yZXF1ZXN0QWNjb3VudHNcIiwgcGFyYW1zOiBbXSB9LFxuICAgICAgICAgIGdldFJwY1Byb21pc2VDYWxsYmFjayhyZXNvbHZlLCByZWplY3QpXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJvbWlzZS1mdW5jdGlvbi1hc3luY1xuICBzZW5kKG1ldGhvZE9yUGF5bG9hZCwgY2FsbGJhY2tPckFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuX3NlbnRXYXJuaW5ncy5zZW5kKSB7XG4gICAgICB0aGlzLl9sb2cud2FybihtZXNzYWdlc19kZWZhdWx0Lndhcm5pbmdzLnNlbmREZXByZWNhdGlvbik7XG4gICAgICB0aGlzLl9zZW50V2FybmluZ3Muc2VuZCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWV0aG9kT3JQYXlsb2FkID09PSBcInN0cmluZ1wiICYmICghY2FsbGJhY2tPckFyZ3MgfHwgQXJyYXkuaXNBcnJheShjYWxsYmFja09yQXJncykpKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuX3JwY1JlcXVlc3QoXG4gICAgICAgICAgICB7IG1ldGhvZDogbWV0aG9kT3JQYXlsb2FkLCBwYXJhbXM6IGNhbGxiYWNrT3JBcmdzIH0sXG4gICAgICAgICAgICBnZXRScGNQcm9taXNlQ2FsbGJhY2socmVzb2x2ZSwgcmVqZWN0LCBmYWxzZSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobWV0aG9kT3JQYXlsb2FkICYmIHR5cGVvZiBtZXRob2RPclBheWxvYWQgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGNhbGxiYWNrT3JBcmdzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KFxuICAgICAgICBtZXRob2RPclBheWxvYWQsXG4gICAgICAgIGNhbGxiYWNrT3JBcmdzXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VuZFN5bmMobWV0aG9kT3JQYXlsb2FkKTtcbiAgfVxuICAvKipcbiAgICogSW50ZXJuYWwgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgbWV0aG9kLCB1c2VkIGluIHNlbmQuXG4gICAqXG4gICAqIEBwYXJhbSBwYXlsb2FkIC0gQSBKU09OLVJQQyByZXF1ZXN0IG9iamVjdC5cbiAgICogQHJldHVybnMgQSBKU09OLVJQQyByZXNwb25zZSBvYmplY3QuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBfc2VuZFN5bmMocGF5bG9hZCkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgc3dpdGNoIChwYXlsb2FkLm1ldGhvZCkge1xuICAgICAgY2FzZSBcImV0aF9hY2NvdW50c1wiOlxuICAgICAgICByZXN1bHQgPSB0aGlzLnNlbGVjdGVkQWRkcmVzcyA/IFt0aGlzLnNlbGVjdGVkQWRkcmVzc10gOiBbXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZXRoX2NvaW5iYXNlXCI6XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuc2VsZWN0ZWRBZGRyZXNzID8/IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImV0aF91bmluc3RhbGxGaWx0ZXJcIjpcbiAgICAgICAgdGhpcy5fcnBjUmVxdWVzdChwYXlsb2FkLCBOT09QKTtcbiAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibmV0X3ZlcnNpb25cIjpcbiAgICAgICAgcmVzdWx0ID0gX19wcml2YXRlR2V0KHRoaXMsIF9uZXR3b3JrVmVyc2lvbikgPz8gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXNfZGVmYXVsdC5lcnJvcnMudW5zdXBwb3J0ZWRTeW5jKHBheWxvYWQubWV0aG9kKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpZDogcGF5bG9hZC5pZCxcbiAgICAgIGpzb25ycGM6IHBheWxvYWQuanNvbnJwYyxcbiAgICAgIHJlc3VsdFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIGhlbHBlci5cbiAgICpcbiAgICogR2V0cyB0aGUgZXhwZXJpbWVudGFsIF9tZXRhbWFzayBBUEkgYXMgUHJveHksIHNvIHRoYXQgd2UgY2FuIHdhcm4gY29uc3VtZXJzXG4gICAqIGFib3V0IGl0cyBleHBlcmltZW50YWwgbmF0dXJlLlxuICAgKlxuICAgKiBAcmV0dXJucyBUaGUgZXhwZXJpbWVudGFsIF9tZXRhbWFzayBBUEkuXG4gICAqL1xuICBfZ2V0RXhwZXJpbWVudGFsQXBpKCkge1xuICAgIHJldHVybiBuZXcgUHJveHkoXG4gICAgICB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIE1ldGFNYXNrIGlzIHVubG9ja2VkIGJ5IHRoZSB1c2VyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0cnVlIGlmIE1ldGFNYXNrIGlzIGN1cnJlbnRseSB1bmxvY2tlZC5cbiAgICAgICAgICovXG4gICAgICAgIGlzVW5sb2NrZWQ6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuX3N0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLm9uKFwiX2luaXRpYWxpemVkXCIsICgpID0+IHJlc29sdmUoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmlzVW5sb2NrZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlIGEgYmF0Y2ggUlBDIHJlcXVlc3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSByZXF1ZXN0cyAtIFRoZSBSUEMgcmVxdWVzdHMgdG8gbWFrZS5cbiAgICAgICAgICovXG4gICAgICAgIHJlcXVlc3RCYXRjaDogYXN5bmMgKHJlcXVlc3RzKSA9PiB7XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlcXVlc3RzKSkge1xuICAgICAgICAgICAgdGhyb3cgcnBjRXJyb3JzLmludmFsaWRSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogXCJCYXRjaCByZXF1ZXN0cyBtdXN0IGJlIG1hZGUgd2l0aCBhbiBhcnJheSBvZiByZXF1ZXN0IG9iamVjdHMuXCIsXG4gICAgICAgICAgICAgIGRhdGE6IHJlcXVlc3RzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3JwY1JlcXVlc3QocmVxdWVzdHMsIGdldFJwY1Byb21pc2VDYWxsYmFjayhyZXNvbHZlLCByZWplY3QpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZ2V0OiAob2JqLCBwcm9wLCAuLi5hcmdzKSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9zZW50V2FybmluZ3MuZXhwZXJpbWVudGFsTWV0aG9kcykge1xuICAgICAgICAgICAgdGhpcy5fbG9nLndhcm4obWVzc2FnZXNfZGVmYXVsdC53YXJuaW5ncy5leHBlcmltZW50YWxNZXRob2RzKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbnRXYXJuaW5ncy5leHBlcmltZW50YWxNZXRob2RzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KG9iaiwgcHJvcCwgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBVcG9uIHJlY2VpcHQgb2YgYSBuZXcgY2hhaW5JZCBhbmQgbmV0d29ya1ZlcnNpb24sIGVtaXRzIGNvcnJlc3BvbmRpbmdcbiAgICogZXZlbnRzIGFuZCBzZXRzIHJlbGV2YW50IHB1YmxpYyBzdGF0ZS4gRG9lcyBub3RoaW5nIGlmIG5laXRoZXIgdGhlIGNoYWluSWRcbiAgICogbm9yIHRoZSBuZXR3b3JrVmVyc2lvbiBhcmUgZGlmZmVyZW50IGZyb20gZXhpc3RpbmcgdmFsdWVzLlxuICAgKlxuICAgKiBAZmlyZXMgTWV0YW1hc2tJbnBhZ2VQcm92aWRlciNuZXR3b3JrQ2hhbmdlZFxuICAgKiBAcGFyYW0gbmV0d29ya0luZm8gLSBBbiBvYmplY3Qgd2l0aCBuZXR3b3JrIGluZm8uXG4gICAqIEBwYXJhbSBuZXR3b3JrSW5mby5jaGFpbklkIC0gVGhlIGxhdGVzdCBjaGFpbiBJRC5cbiAgICogQHBhcmFtIG5ldHdvcmtJbmZvLm5ldHdvcmtWZXJzaW9uIC0gVGhlIGxhdGVzdCBuZXR3b3JrIElELlxuICAgKi9cbiAgX2hhbmRsZUNoYWluQ2hhbmdlZCh7XG4gICAgY2hhaW5JZCxcbiAgICBuZXR3b3JrVmVyc2lvblxuICB9ID0ge30pIHtcbiAgICBzdXBlci5faGFuZGxlQ2hhaW5DaGFuZ2VkKHsgY2hhaW5JZCwgbmV0d29ya1ZlcnNpb24gfSk7XG4gICAgaWYgKHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkICYmIG5ldHdvcmtWZXJzaW9uICE9PSBfX3ByaXZhdGVHZXQodGhpcywgX25ldHdvcmtWZXJzaW9uKSkge1xuICAgICAgX19wcml2YXRlU2V0KHRoaXMsIF9uZXR3b3JrVmVyc2lvbiwgbmV0d29ya1ZlcnNpb24pO1xuICAgICAgaWYgKHRoaXMuX3N0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtDaGFuZ2VkXCIsIF9fcHJpdmF0ZUdldCh0aGlzLCBfbmV0d29ya1ZlcnNpb24pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5fbmV0d29ya1ZlcnNpb24gPSBuZXcgV2Vha01hcCgpO1xuXG5leHBvcnQge1xuICBNZXRhTWFza0lucGFnZVByb3ZpZGVyU3RyZWFtTmFtZSxcbiAgTWV0YU1hc2tJbnBhZ2VQcm92aWRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNodW5rLVVSTVNaTzdaLm1qcy5tYXAiLCJpbXBvcnQge1xuICBCYXNlUHJvdmlkZXJcbn0gZnJvbSBcIi4vY2h1bmstT0dQQTVRNzYubWpzXCI7XG5pbXBvcnQge1xuICBFTUlUVEVEX05PVElGSUNBVElPTlMsXG4gIGlzVmFsaWRDaGFpbklkLFxuICBpc1ZhbGlkTmV0d29ya1ZlcnNpb25cbn0gZnJvbSBcIi4vY2h1bmstWk43V1Y1NUoubWpzXCI7XG5pbXBvcnQge1xuICBtZXNzYWdlc19kZWZhdWx0XG59IGZyb20gXCIuL2NodW5rLVpHRFEzSVlELm1qc1wiO1xuXG4vLyBzcmMvU3RyZWFtUHJvdmlkZXIudHNcbmltcG9ydCB7IGNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUgfSBmcm9tIFwiQG1ldGFtYXNrL2pzb24tcnBjLW1pZGRsZXdhcmUtc3RyZWFtXCI7XG5pbXBvcnQgT2JqZWN0TXVsdGlwbGV4IGZyb20gXCJAbWV0YW1hc2svb2JqZWN0LW11bHRpcGxleFwiO1xuaW1wb3J0IHsgZHVwbGV4IGFzIGlzRHVwbGV4IH0gZnJvbSBcImlzLXN0cmVhbVwiO1xuaW1wb3J0IHsgcGlwZWxpbmUgfSBmcm9tIFwicmVhZGFibGUtc3RyZWFtXCI7XG52YXIgQWJzdHJhY3RTdHJlYW1Qcm92aWRlciA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3ZpZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgQWJzdHJhY3RTdHJlYW1Qcm92aWRlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIGNvbm5lY3Rpb25TdHJlYW0gLSBBIE5vZGUuanMgZHVwbGV4IHN0cmVhbS5cbiAgICogQHBhcmFtIG9wdGlvbnMgLSBBbiBvcHRpb25zIGJhZy5cbiAgICogQHBhcmFtIG9wdGlvbnMuanNvblJwY1N0cmVhbU5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgaW50ZXJuYWwgSlNPTi1SUEMgc3RyZWFtLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5sb2dnZXIgLSBUaGUgbG9nZ2luZyBBUEkgdG8gdXNlLiBEZWZhdWx0OiBgY29uc29sZWAuXG4gICAqIEBwYXJhbSBvcHRpb25zLm1heEV2ZW50TGlzdGVuZXJzIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGV2ZW50XG4gICAqIGxpc3RlbmVycy4gRGVmYXVsdDogMTAwLlxuICAgKiBAcGFyYW0gb3B0aW9ucy5ycGNNaWRkbGV3YXJlIC0gVGhlIFJQQyBtaWRkbGV3YXJlIHN0YWNrIHRvIHVzZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25TdHJlYW0sIHtcbiAgICBqc29uUnBjU3RyZWFtTmFtZSxcbiAgICBsb2dnZXIgPSBjb25zb2xlLFxuICAgIG1heEV2ZW50TGlzdGVuZXJzID0gMTAwLFxuICAgIHJwY01pZGRsZXdhcmUgPSBbXVxuICB9KSB7XG4gICAgc3VwZXIoeyBsb2dnZXIsIG1heEV2ZW50TGlzdGVuZXJzLCBycGNNaWRkbGV3YXJlIH0pO1xuICAgIGlmICghaXNEdXBsZXgoY29ubmVjdGlvblN0cmVhbSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlc19kZWZhdWx0LmVycm9ycy5pbnZhbGlkRHVwbGV4U3RyZWFtKCkpO1xuICAgIH1cbiAgICB0aGlzLl9oYW5kbGVTdHJlYW1EaXNjb25uZWN0ID0gdGhpcy5faGFuZGxlU3RyZWFtRGlzY29ubmVjdC5iaW5kKHRoaXMpO1xuICAgIGNvbnN0IG11eCA9IG5ldyBPYmplY3RNdWx0aXBsZXgoKTtcbiAgICBwaXBlbGluZShcbiAgICAgIGNvbm5lY3Rpb25TdHJlYW0sXG4gICAgICBtdXgsXG4gICAgICBjb25uZWN0aW9uU3RyZWFtLFxuICAgICAgdGhpcy5faGFuZGxlU3RyZWFtRGlzY29ubmVjdC5iaW5kKHRoaXMsIFwiTWV0YU1hc2tcIilcbiAgICApO1xuICAgIHRoaXMuX2pzb25ScGNDb25uZWN0aW9uID0gY3JlYXRlU3RyZWFtTWlkZGxld2FyZSh7XG4gICAgICByZXRyeU9uTWVzc2FnZTogXCJNRVRBTUFTS19FWFRFTlNJT05fQ09OTkVDVF9DQU5fUkVUUllcIlxuICAgIH0pO1xuICAgIHBpcGVsaW5lKFxuICAgICAgdGhpcy5fanNvblJwY0Nvbm5lY3Rpb24uc3RyZWFtLFxuICAgICAgbXV4LmNyZWF0ZVN0cmVhbShqc29uUnBjU3RyZWFtTmFtZSksXG4gICAgICB0aGlzLl9qc29uUnBjQ29ubmVjdGlvbi5zdHJlYW0sXG4gICAgICB0aGlzLl9oYW5kbGVTdHJlYW1EaXNjb25uZWN0LmJpbmQodGhpcywgXCJNZXRhTWFzayBScGNQcm92aWRlclwiKVxuICAgICk7XG4gICAgdGhpcy5fcnBjRW5naW5lLnB1c2godGhpcy5fanNvblJwY0Nvbm5lY3Rpb24ubWlkZGxld2FyZSk7XG4gICAgdGhpcy5fanNvblJwY0Nvbm5lY3Rpb24uZXZlbnRzLm9uKFwibm90aWZpY2F0aW9uXCIsIChwYXlsb2FkKSA9PiB7XG4gICAgICBjb25zdCB7IG1ldGhvZCwgcGFyYW1zIH0gPSBwYXlsb2FkO1xuICAgICAgaWYgKG1ldGhvZCA9PT0gXCJtZXRhbWFza19hY2NvdW50c0NoYW5nZWRcIikge1xuICAgICAgICB0aGlzLl9oYW5kbGVBY2NvdW50c0NoYW5nZWQocGFyYW1zKTtcbiAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBcIm1ldGFtYXNrX3VubG9ja1N0YXRlQ2hhbmdlZFwiKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZVVubG9ja1N0YXRlQ2hhbmdlZChwYXJhbXMpO1xuICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwibWV0YW1hc2tfY2hhaW5DaGFuZ2VkXCIpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlQ2hhaW5DaGFuZ2VkKHBhcmFtcyk7XG4gICAgICB9IGVsc2UgaWYgKEVNSVRURURfTk9USUZJQ0FUSU9OUy5pbmNsdWRlcyhtZXRob2QpKSB7XG4gICAgICAgIHRoaXMuZW1pdChcIm1lc3NhZ2VcIiwge1xuICAgICAgICAgIHR5cGU6IG1ldGhvZCxcbiAgICAgICAgICBkYXRhOiBwYXJhbXNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKG1ldGhvZCA9PT0gXCJNRVRBTUFTS19TVFJFQU1fRkFJTFVSRVwiKSB7XG4gICAgICAgIGNvbm5lY3Rpb25TdHJlYW0uZGVzdHJveShcbiAgICAgICAgICBuZXcgRXJyb3IobWVzc2FnZXNfZGVmYXVsdC5lcnJvcnMucGVybWFuZW50bHlEaXNjb25uZWN0ZWQoKSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvLz09PT09PT09PT09PT09PT09PT09XG4gIC8vIFByaXZhdGUgTWV0aG9kc1xuICAvLz09PT09PT09PT09PT09PT09PT09XG4gIC8qKlxuICAgKiBNVVNUIGJlIGNhbGxlZCBieSBjaGlsZCBjbGFzc2VzLlxuICAgKlxuICAgKiBDYWxscyBgbWV0YW1hc2tfZ2V0UHJvdmlkZXJTdGF0ZWAgYW5kIHBhc3NlcyB0aGUgcmVzdWx0IHRvXG4gICAqIHtAbGluayBCYXNlUHJvdmlkZXIuX2luaXRpYWxpemVTdGF0ZX0uIExvZ3MgYW4gZXJyb3IgaWYgZ2V0dGluZyBpbml0aWFsIHN0YXRlXG4gICAqIGZhaWxzLiBUaHJvd3MgaWYgY2FsbGVkIGFmdGVyIGluaXRpYWxpemF0aW9uIGhhcyBjb21wbGV0ZWQuXG4gICAqL1xuICBhc3luYyBfaW5pdGlhbGl6ZVN0YXRlQXN5bmMoKSB7XG4gICAgbGV0IGluaXRpYWxTdGF0ZTtcbiAgICB0cnkge1xuICAgICAgaW5pdGlhbFN0YXRlID0gYXdhaXQgdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgbWV0aG9kOiBcIm1ldGFtYXNrX2dldFByb3ZpZGVyU3RhdGVcIlxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuX2xvZy5lcnJvcihcbiAgICAgICAgXCJNZXRhTWFzazogRmFpbGVkIHRvIGdldCBpbml0aWFsIHN0YXRlLiBQbGVhc2UgcmVwb3J0IHRoaXMgYnVnLlwiLFxuICAgICAgICBlcnJvclxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbGl6ZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gIH1cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgbG9zdCB0byBjcml0aWNhbCBzdHJlYW1zLiBFbWl0cyBhbiAnZXJyb3InIGV2ZW50XG4gICAqIGZyb20gdGhlIHByb3ZpZGVyIHdpdGggdGhlIGVycm9yIG1lc3NhZ2UgYW5kIHN0YWNrIGlmIHByZXNlbnQuXG4gICAqXG4gICAqIEBwYXJhbSBzdHJlYW1OYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHN0cmVhbSB0aGF0IGRpc2Nvbm5lY3RlZC5cbiAgICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIHRoYXQgY2F1c2VkIHRoZSBkaXNjb25uZWN0aW9uLlxuICAgKiBAZmlyZXMgQmFzZVByb3ZpZGVyI2Rpc2Nvbm5lY3QgLSBJZiB0aGUgcHJvdmlkZXIgaXMgbm90IGFscmVhZHlcbiAgICogZGlzY29ubmVjdGVkLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gIF9oYW5kbGVTdHJlYW1EaXNjb25uZWN0KHN0cmVhbU5hbWUsIGVycm9yKSB7XG4gICAgbGV0IHdhcm5pbmdNc2cgPSBgTWV0YU1hc2s6IExvc3QgY29ubmVjdGlvbiB0byBcIiR7c3RyZWFtTmFtZX1cIi5gO1xuICAgIGlmIChlcnJvcj8uc3RhY2spIHtcbiAgICAgIHdhcm5pbmdNc2cgKz0gYFxuJHtlcnJvci5zdGFja31gO1xuICAgIH1cbiAgICB0aGlzLl9sb2cud2Fybih3YXJuaW5nTXNnKTtcbiAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KFwiZXJyb3JcIikgPiAwKSB7XG4gICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCB3YXJuaW5nTXNnKTtcbiAgICB9XG4gICAgdGhpcy5faGFuZGxlRGlzY29ubmVjdChmYWxzZSwgZXJyb3IgPyBlcnJvci5tZXNzYWdlIDogdm9pZCAwKTtcbiAgfVxuICAvKipcbiAgICogVXBvbiByZWNlaXB0IG9mIGEgbmV3IGNoYWluSWQgYW5kIG5ldHdvcmtWZXJzaW9uLCBlbWl0cyBjb3JyZXNwb25kaW5nXG4gICAqIGV2ZW50cyBhbmQgc2V0cyByZWxldmFudCBwdWJsaWMgc3RhdGUuIFRoaXMgY2xhc3MgZG9lcyBub3QgaGF2ZSBhXG4gICAqIGBuZXR3b3JrVmVyc2lvbmAgcHJvcGVydHksIGJ1dCB3ZSByZWx5IG9uIHJlY2VpdmluZyBhIGBuZXR3b3JrVmVyc2lvbmBcbiAgICogd2l0aCB0aGUgdmFsdWUgb2YgYGxvYWRpbmdgIHRvIGRldGVjdCB3aGVuIHRoZSBuZXR3b3JrIGlzIGNoYW5naW5nIGFuZFxuICAgKiBhIHJlY292ZXJhYmxlIGBkaXNjb25uZWN0YCBldmVuIGhhcyBvY2N1cnJlZC4gQ2hpbGQgY2xhc3NlcyB0aGF0IHVzZSB0aGVcbiAgICogYG5ldHdvcmtWZXJzaW9uYCBmb3Igb3RoZXIgcHVycG9zZXMgbXVzdCBpbXBsZW1lbnQgYWRkaXRpb25hbCBoYW5kbGluZ1xuICAgKiB0aGVyZWZvcmUuXG4gICAqXG4gICAqIEBmaXJlcyBCYXNlUHJvdmlkZXIjY2hhaW5DaGFuZ2VkXG4gICAqIEBwYXJhbSBuZXR3b3JrSW5mbyAtIEFuIG9iamVjdCB3aXRoIG5ldHdvcmsgaW5mby5cbiAgICogQHBhcmFtIG5ldHdvcmtJbmZvLmNoYWluSWQgLSBUaGUgbGF0ZXN0IGNoYWluIElELlxuICAgKiBAcGFyYW0gbmV0d29ya0luZm8ubmV0d29ya1ZlcnNpb24gLSBUaGUgbGF0ZXN0IG5ldHdvcmsgSUQuXG4gICAqL1xuICBfaGFuZGxlQ2hhaW5DaGFuZ2VkKHtcbiAgICBjaGFpbklkLFxuICAgIG5ldHdvcmtWZXJzaW9uXG4gIH0gPSB7fSkge1xuICAgIGlmICghaXNWYWxpZENoYWluSWQoY2hhaW5JZCkgfHwgIWlzVmFsaWROZXR3b3JrVmVyc2lvbihuZXR3b3JrVmVyc2lvbikpIHtcbiAgICAgIHRoaXMuX2xvZy5lcnJvcihtZXNzYWdlc19kZWZhdWx0LmVycm9ycy5pbnZhbGlkTmV0d29ya1BhcmFtcygpLCB7XG4gICAgICAgIGNoYWluSWQsXG4gICAgICAgIG5ldHdvcmtWZXJzaW9uXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5ldHdvcmtWZXJzaW9uID09PSBcImxvYWRpbmdcIikge1xuICAgICAgdGhpcy5faGFuZGxlRGlzY29ubmVjdCh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuX2hhbmRsZUNoYWluQ2hhbmdlZCh7IGNoYWluSWQgfSk7XG4gICAgfVxuICB9XG59O1xudmFyIFN0cmVhbVByb3ZpZGVyID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdFN0cmVhbVByb3ZpZGVyIHtcbiAgLyoqXG4gICAqIE1VU1QgYmUgY2FsbGVkIGFmdGVyIGluc3RhbnRpYXRpb24gdG8gY29tcGxldGUgaW5pdGlhbGl6YXRpb24uXG4gICAqXG4gICAqIENhbGxzIGBtZXRhbWFza19nZXRQcm92aWRlclN0YXRlYCBhbmQgcGFzc2VzIHRoZSByZXN1bHQgdG9cbiAgICoge0BsaW5rIEJhc2VQcm92aWRlci5faW5pdGlhbGl6ZVN0YXRlfS4gTG9ncyBhbiBlcnJvciBpZiBnZXR0aW5nIGluaXRpYWwgc3RhdGVcbiAgICogZmFpbHMuIFRocm93cyBpZiBjYWxsZWQgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gaGFzIGNvbXBsZXRlZC5cbiAgICovXG4gIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luaXRpYWxpemVTdGF0ZUFzeW5jKCk7XG4gIH1cbn07XG5cbmV4cG9ydCB7XG4gIEFic3RyYWN0U3RyZWFtUHJvdmlkZXIsXG4gIFN0cmVhbVByb3ZpZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstVVRST0hYUFQubWpzLm1hcCIsImltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5cbi8qKlxuICogTG9nZ2VyIGZvciB0aGUgU0RLLlxuICogVGhpcyBsb2dnZXIgdXNlcyB0aGUgJ2RlYnVnJyBsaWJyYXJ5IGZvciBvdXRwdXR0aW5nIGRlYnVnIGluZm9ybWF0aW9uLlxuICogTG9nZ2luZyBpcyBlbmFibGVkIGluIHRoZSBjb2RlIHZpYSBgZGVidWcuZW5hYmxlKCdfX05BTUVTUEFDRV9fJylgLlxuICovXG5leHBvcnQgY29uc3QgbG9nZ2VyID0gZGVidWcoJ01NX1NESycpO1xuXG5sb2dnZXIuY29sb3IgPSAnI0ZGQUMxQyc7XG4iLCJpbXBvcnQgeyBhbmFseXRpY3MgfSBmcm9tICdAbWV0YW1hc2svc2RrLWFuYWx5dGljcyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgU0RLUHJvdmlkZXIgfSBmcm9tICcuLi8uLi8uLi9wcm92aWRlci9TREtQcm92aWRlcic7XG5cbmxldCBfcHJldmlvdXNDaGFpbklkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbi8qKlxuICogSGFuZGxlcyBhIGNoYW5nZSBpbiB0aGUgYmxvY2tjaGFpbiBuZXR3b3JrIGZvciBhbiBTREtQcm92aWRlciBpbnN0YW5jZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciB1cGRhdGluZyB0aGUgc3RhdGUgYW5kIGVtaXR0aW5nIGV2ZW50cyB3aGVuIHRoZSBjaGFpbiBvciBuZXR3b3JrIHZlcnNpb24gY2hhbmdlcy5cbiAqIEl0IHVwZGF0ZXMgdGhlIGBfc3RhdGUuaXNDb25uZWN0ZWRgIHByb3BlcnR5IHRvIHRydWUgYW5kIGVtaXRzIGEgJ2Nvbm5lY3QnIGV2ZW50IHdpdGggdGhlIG5ldyBgY2hhaW5JZGAuXG4gKiBUaGUgZnVuY3Rpb24gdGhlbiBjYWxscyBgc3VwZXJIYW5kbGVDaGFpbkNoYW5nZWRgIHRvIHBlcmZvcm0gYWRkaXRpb25hbCB1cGRhdGVzLlxuICpcbiAqIElmIHRoZSBgbmV0d29ya1ZlcnNpb25gIHBhcmFtZXRlciBpcyBtaXNzaW5nIChvYnNlcnZlZCBlc3BlY2lhbGx5IG9uIFJOIElPUyksIHRoZSBmdW5jdGlvbiBzZXRzIGl0IHRvICcxJyBhcyBhIGZhbGxiYWNrIHRvIHByZXZlbnQgcHJvdmlkZXIgZXJyb3JzLlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIEFuIG9iamVjdCBjb250YWluaW5nOlxuICogIC0gYGNoYWluSWRgOiBBbiBvcHRpb25hbCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBuZXcgYmxvY2tjaGFpbiBjaGFpbiBJRC5cbiAqICAtIGBuZXR3b3JrVmVyc2lvbmA6IEFuIG9wdGlvbmFsIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIG5ldyBuZXR3b3JrIHZlcnNpb24uXG4gKiAgLSBgaW5zdGFuY2VgOiBUaGUgU0RLUHJvdmlkZXIgaW5zdGFuY2UgdGhhdCBpcyBleHBlcmllbmNpbmcgdGhlIGNoYWluIGNoYW5nZS5cbiAqICAtIGBzdXBlckhhbmRsZUNoYWluQ2hhbmdlZGA6IEEgZnVuY3Rpb24gdG8gcGVyZm9ybSBhZGRpdGlvbmFsIHVwZGF0ZXMgYW5kIHBhc3NlZCB0aGUgbmV3IGBjaGFpbklkYCBhbmQgYG5ldHdvcmtWZXJzaW9uYC5cbiAqIEByZXR1cm5zIHZvaWRcbiAqIEBlbWl0cyAnY29ubmVjdCcgZXZlbnQgd2l0aCB0aGUgbmV3IGBjaGFpbklkYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZUNoYWluQ2hhbmdlZCh7XG4gIGluc3RhbmNlLFxuICBjaGFpbklkLFxuICBuZXR3b3JrVmVyc2lvbixcbiAgc3VwZXJIYW5kbGVDaGFpbkNoYW5nZWQsXG59OiB7XG4gIGNoYWluSWQ/OiBzdHJpbmc7XG4gIG5ldHdvcmtWZXJzaW9uPzogc3RyaW5nO1xuICBpbnN0YW5jZTogU0RLUHJvdmlkZXI7XG4gIHN1cGVySGFuZGxlQ2hhaW5DaGFuZ2VkOiAoYXJnczoge1xuICAgIGNoYWluSWQ/OiBzdHJpbmc7XG4gICAgbmV0d29ya1ZlcnNpb24/OiBzdHJpbmc7XG4gIH0pID0+IHZvaWQ7XG59KSB7XG4gIGxvZ2dlcihcbiAgICBgW1NES1Byb3ZpZGVyOiBoYW5kbGVDaGFpbkNoYW5nZWQoKV0gY2hhaW5JZD0ke2NoYWluSWR9IG5ldHdvcmtWZXJzaW9uPSR7bmV0d29ya1ZlcnNpb259YCxcbiAgKTtcblxuICAvLyBGSVhNRSBvbiBSTiBJT1MgbmV0d29ya1ZlcnNpb24gaXMgc29tZXRpbWUgbWlzc2luZz8gd2h5P1xuICBsZXQgZm9yY2VkTmV0d29ya1ZlcnNpb24gPSBuZXR3b3JrVmVyc2lvbjtcbiAgaWYgKCFuZXR3b3JrVmVyc2lvbikge1xuICAgIGxvZ2dlcihcbiAgICAgIGBbU0RLUHJvdmlkZXI6IGhhbmRsZUNoYWluQ2hhbmdlZCgpXSBmb3JjZWQgbmV0d29yayB2ZXJzaW9uIHRvIHByZXZlbnQgcHJvdmlkZXIgZXJyb3JgLFxuICAgICk7XG4gICAgZm9yY2VkTmV0d29ya1ZlcnNpb24gPSAnMSc7XG4gIH1cblxuICBpZiAoY2hhaW5JZCAhPT0gX3ByZXZpb3VzQ2hhaW5JZCkge1xuICAgIGFuYWx5dGljcy50cmFjaygnc2RrX3VzZWRfY2hhaW4nLCB7XG4gICAgICBjYWlwX2NoYWluX2lkOiBgZWlwMTU1OiR7cGFyc2VJbnQoY2hhaW5JZCA/PyAnMHgxJywgMTYpfWAsXG4gICAgfSk7XG4gICAgX3ByZXZpb3VzQ2hhaW5JZCA9IGNoYWluSWQ7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gIC8vIEB0cy1pZ25vcmVcbiAgaW5zdGFuY2UuX3N0YXRlLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgaW5zdGFuY2UuZW1pdCgnY29ubmVjdCcsIHsgY2hhaW5JZCB9KTtcbiAgc3VwZXJIYW5kbGVDaGFpbkNoYW5nZWQoe1xuICAgIGNoYWluSWQsXG4gICAgbmV0d29ya1ZlcnNpb246IGZvcmNlZE5ldHdvcmtWZXJzaW9uLFxuICB9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FdGhlcmV1bVByb3ZpZGVyRXJyb3IgPSBleHBvcnRzLkV0aGVyZXVtUnBjRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBmYXN0X3NhZmVfc3RyaW5naWZ5XzEgPSByZXF1aXJlKFwiZmFzdC1zYWZlLXN0cmluZ2lmeVwiKTtcbi8qKlxuICogRXJyb3Igc3ViY2xhc3MgaW1wbGVtZW50aW5nIEpTT04gUlBDIDIuMCBlcnJvcnMgYW5kIEV0aGVyZXVtIFJQQyBlcnJvcnNcbiAqIHBlciBFSVAtMTQ3NC5cbiAqIFBlcm1pdHMgYW55IGludGVnZXIgZXJyb3IgY29kZS5cbiAqL1xuY2xhc3MgRXRoZXJldW1ScGNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihjb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImNvZGVcIiBtdXN0IGJlIGFuIGludGVnZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VcIiBtdXN0IGJlIGEgbm9uZW1wdHkgc3RyaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBwbGFpbiBvYmplY3Qgd2l0aCBhbGwgcHVibGljIGNsYXNzIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgc2VyaWFsaXplKCkge1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkID0ge1xuICAgICAgICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5kYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQuZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGFjaykge1xuICAgICAgICAgICAgc2VyaWFsaXplZC5zdGFjayA9IHRoaXMuc3RhY2s7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2VyaWFsaXplZCBlcnJvciwgb21pdHRpbmdcbiAgICAgKiBhbnkgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGZhc3Rfc2FmZV9zdHJpbmdpZnlfMS5kZWZhdWx0KHRoaXMuc2VyaWFsaXplKCksIHN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgICB9XG59XG5leHBvcnRzLkV0aGVyZXVtUnBjRXJyb3IgPSBFdGhlcmV1bVJwY0Vycm9yO1xuLyoqXG4gKiBFcnJvciBzdWJjbGFzcyBpbXBsZW1lbnRpbmcgRXRoZXJldW0gUHJvdmlkZXIgZXJyb3JzIHBlciBFSVAtMTE5My5cbiAqIFBlcm1pdHMgaW50ZWdlciBlcnJvciBjb2RlcyBpbiB0aGUgWyAxMDAwIDw9IDQ5OTkgXSByYW5nZS5cbiAqL1xuY2xhc3MgRXRoZXJldW1Qcm92aWRlckVycm9yIGV4dGVuZHMgRXRoZXJldW1ScGNFcnJvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIEV0aGVyZXVtIFByb3ZpZGVyIEpTT04tUlBDIGVycm9yLlxuICAgICAqIGBjb2RlYCBtdXN0IGJlIGFuIGludGVnZXIgaW4gdGhlIDEwMDAgPD0gNDk5OSByYW5nZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgICAgIGlmICghaXNWYWxpZEV0aFByb3ZpZGVyQ29kZShjb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImNvZGVcIiBtdXN0IGJlIGFuIGludGVnZXIgc3VjaCB0aGF0OiAxMDAwIDw9IGNvZGUgPD0gNDk5OScpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGNvZGUsIG1lc3NhZ2UsIGRhdGEpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXRoZXJldW1Qcm92aWRlckVycm9yID0gRXRoZXJldW1Qcm92aWRlckVycm9yO1xuLy8gSW50ZXJuYWxcbmZ1bmN0aW9uIGlzVmFsaWRFdGhQcm92aWRlckNvZGUoY29kZSkge1xuICAgIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpICYmIGNvZGUgPj0gMTAwMCAmJiBjb2RlIDw9IDQ5OTk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlSZXBsYWNlcihfLCB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gJ1tDaXJjdWxhcl0nKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVkyeGhjM05sY3k1cWN5SXNJbk52ZFhKalpWSnZiM1FpT2lJaUxDSnpiM1Z5WTJWeklqcGJJaTR1TDNOeVl5OWpiR0Z6YzJWekxuUnpJbDBzSW01aGJXVnpJanBiWFN3aWJXRndjR2x1WjNNaU9pSTdPenRCUVVGQkxEWkVRVUZuUkR0QlFWTm9SRHM3T3p0SFFVbEhPMEZCUTBnc1RVRkJZU3huUWtGQmIwSXNVMEZCVVN4TFFVRkxPMGxCVFRWRExGbEJRVmtzU1VGQldTeEZRVUZGTEU5QlFXVXNSVUZCUlN4SlFVRlJPMUZCUldwRUxFbEJRVWtzUTBGQlF5eE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRk8xbEJRek5DTEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUTJJc05FSkJRVFJDTEVOQlF6ZENMRU5CUVVNN1UwRkRTRHRSUVVORUxFbEJRVWtzUTBGQlF5eFBRVUZQTEVsQlFVa3NUMEZCVHl4UFFVRlBMRXRCUVVzc1VVRkJVU3hGUVVGRk8xbEJRek5ETEUxQlFVMHNTVUZCU1N4TFFVRkxMRU5CUTJJc2MwTkJRWE5ETEVOQlEzWkRMRU5CUVVNN1UwRkRTRHRSUVVWRUxFdEJRVXNzUTBGQlF5eFBRVUZQTEVOQlFVTXNRMEZCUXp0UlFVTm1MRWxCUVVrc1EwRkJReXhKUVVGSkxFZEJRVWNzU1VGQlNTeERRVUZETzFGQlEycENMRWxCUVVrc1NVRkJTU3hMUVVGTExGTkJRVk1zUlVGQlJUdFpRVU4wUWl4SlFVRkpMRU5CUVVNc1NVRkJTU3hIUVVGSExFbEJRVWtzUTBGQlF6dFRRVU5zUWp0SlFVTklMRU5CUVVNN1NVRkZSRHM3VDBGRlJ6dEpRVU5JTEZOQlFWTTdVVUZEVUN4TlFVRk5MRlZCUVZVc1IwRkJLMEk3V1VGRE4wTXNTVUZCU1N4RlFVRkZMRWxCUVVrc1EwRkJReXhKUVVGSk8xbEJRMllzVDBGQlR5eEZRVUZGTEVsQlFVa3NRMEZCUXl4UFFVRlBPMU5CUTNSQ0xFTkJRVU03VVVGRFJpeEpRVUZKTEVsQlFVa3NRMEZCUXl4SlFVRkpMRXRCUVVzc1UwRkJVeXhGUVVGRk8xbEJRek5DTEZWQlFWVXNRMEZCUXl4SlFVRkpMRWRCUVVjc1NVRkJTU3hEUVVGRExFbEJRVWtzUTBGQlF6dFRRVU0zUWp0UlFVTkVMRWxCUVVrc1NVRkJTU3hEUVVGRExFdEJRVXNzUlVGQlJUdFpRVU5rTEZWQlFWVXNRMEZCUXl4TFFVRkxMRWRCUVVjc1NVRkJTU3hEUVVGRExFdEJRVXNzUTBGQlF6dFRRVU12UWp0UlFVTkVMRTlCUVU4c1ZVRkJWU3hEUVVGRE8wbEJRM0JDTEVOQlFVTTdTVUZGUkRzN08wOUJSMGM3U1VGRFNDeFJRVUZSTzFGQlEwNHNUMEZCVHl3MlFrRkJZU3hEUVVOc1FpeEpRVUZKTEVOQlFVTXNVMEZCVXl4RlFVRkZMRVZCUTJoQ0xHbENRVUZwUWl4RlFVTnFRaXhEUVVGRExFTkJRMFlzUTBGQlF6dEpRVU5LTEVOQlFVTTdRMEZEUmp0QlFYUkVSQ3cwUTBGelJFTTdRVUZGUkRzN08wZEJSMGM3UVVGRFNDeE5RVUZoTEhGQ1FVRjVRaXhUUVVGUkxHZENRVUZ0UWp0SlFVVXZSRHM3TzA5QlIwYzdTVUZEU0N4WlFVRlpMRWxCUVZrc1JVRkJSU3hQUVVGbExFVkJRVVVzU1VGQlVUdFJRVVZxUkN4SlFVRkpMRU5CUVVNc2MwSkJRWE5DTEVOQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVN1dVRkRha01zVFVGQlRTeEpRVUZKTEV0QlFVc3NRMEZEWWl3eVJFRkJNa1FzUTBGRE5VUXNRMEZCUXp0VFFVTklPMUZCUlVRc1MwRkJTeXhEUVVGRExFbEJRVWtzUlVGQlJTeFBRVUZQTEVWQlFVVXNTVUZCU1N4RFFVRkRMRU5CUVVNN1NVRkROMElzUTBGQlF6dERRVU5HTzBGQmFFSkVMSE5FUVdkQ1F6dEJRVVZFTEZkQlFWYzdRVUZGV0N4VFFVRlRMSE5DUVVGelFpeERRVUZETEVsQlFWazdTVUZETVVNc1QwRkJUeXhOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETEVsQlFVa3NRMEZCUXl4SlFVRkpMRWxCUVVrc1NVRkJTU3hKUVVGSkxFbEJRVWtzU1VGQlNTeEpRVUZKTEVsQlFVa3NRMEZCUXp0QlFVTm9SU3hEUVVGRE8wRkJSVVFzVTBGQlV5eHBRa0ZCYVVJc1EwRkJReXhEUVVGVkxFVkJRVVVzUzBGQll6dEpRVU51UkN4SlFVRkpMRXRCUVVzc1MwRkJTeXhaUVVGWkxFVkJRVVU3VVVGRE1VSXNUMEZCVHl4VFFVRlRMRU5CUVVNN1MwRkRiRUk3U1VGRFJDeFBRVUZQTEV0QlFVc3NRMEZCUXp0QlFVTm1MRU5CUVVNaWZRPT0iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXJyb3JWYWx1ZXMgPSBleHBvcnRzLmVycm9yQ29kZXMgPSB2b2lkIDA7XG5leHBvcnRzLmVycm9yQ29kZXMgPSB7XG4gICAgcnBjOiB7XG4gICAgICAgIGludmFsaWRJbnB1dDogLTMyMDAwLFxuICAgICAgICByZXNvdXJjZU5vdEZvdW5kOiAtMzIwMDEsXG4gICAgICAgIHJlc291cmNlVW5hdmFpbGFibGU6IC0zMjAwMixcbiAgICAgICAgdHJhbnNhY3Rpb25SZWplY3RlZDogLTMyMDAzLFxuICAgICAgICBtZXRob2ROb3RTdXBwb3J0ZWQ6IC0zMjAwNCxcbiAgICAgICAgbGltaXRFeGNlZWRlZDogLTMyMDA1LFxuICAgICAgICBwYXJzZTogLTMyNzAwLFxuICAgICAgICBpbnZhbGlkUmVxdWVzdDogLTMyNjAwLFxuICAgICAgICBtZXRob2ROb3RGb3VuZDogLTMyNjAxLFxuICAgICAgICBpbnZhbGlkUGFyYW1zOiAtMzI2MDIsXG4gICAgICAgIGludGVybmFsOiAtMzI2MDMsXG4gICAgfSxcbiAgICBwcm92aWRlcjoge1xuICAgICAgICB1c2VyUmVqZWN0ZWRSZXF1ZXN0OiA0MDAxLFxuICAgICAgICB1bmF1dGhvcml6ZWQ6IDQxMDAsXG4gICAgICAgIHVuc3VwcG9ydGVkTWV0aG9kOiA0MjAwLFxuICAgICAgICBkaXNjb25uZWN0ZWQ6IDQ5MDAsXG4gICAgICAgIGNoYWluRGlzY29ubmVjdGVkOiA0OTAxLFxuICAgIH0sXG59O1xuZXhwb3J0cy5lcnJvclZhbHVlcyA9IHtcbiAgICAnLTMyNzAwJzoge1xuICAgICAgICBzdGFuZGFyZDogJ0pTT04gUlBDIDIuMCcsXG4gICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIEpTT04gd2FzIHJlY2VpdmVkIGJ5IHRoZSBzZXJ2ZXIuIEFuIGVycm9yIG9jY3VycmVkIG9uIHRoZSBzZXJ2ZXIgd2hpbGUgcGFyc2luZyB0aGUgSlNPTiB0ZXh0LicsXG4gICAgfSxcbiAgICAnLTMyNjAwJzoge1xuICAgICAgICBzdGFuZGFyZDogJ0pTT04gUlBDIDIuMCcsXG4gICAgICAgIG1lc3NhZ2U6ICdUaGUgSlNPTiBzZW50IGlzIG5vdCBhIHZhbGlkIFJlcXVlc3Qgb2JqZWN0LicsXG4gICAgfSxcbiAgICAnLTMyNjAxJzoge1xuICAgICAgICBzdGFuZGFyZDogJ0pTT04gUlBDIDIuMCcsXG4gICAgICAgIG1lc3NhZ2U6ICdUaGUgbWV0aG9kIGRvZXMgbm90IGV4aXN0IC8gaXMgbm90IGF2YWlsYWJsZS4nLFxuICAgIH0sXG4gICAgJy0zMjYwMic6IHtcbiAgICAgICAgc3RhbmRhcmQ6ICdKU09OIFJQQyAyLjAnLFxuICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCBtZXRob2QgcGFyYW1ldGVyKHMpLicsXG4gICAgfSxcbiAgICAnLTMyNjAzJzoge1xuICAgICAgICBzdGFuZGFyZDogJ0pTT04gUlBDIDIuMCcsXG4gICAgICAgIG1lc3NhZ2U6ICdJbnRlcm5hbCBKU09OLVJQQyBlcnJvci4nLFxuICAgIH0sXG4gICAgJy0zMjAwMCc6IHtcbiAgICAgICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGlucHV0LicsXG4gICAgfSxcbiAgICAnLTMyMDAxJzoge1xuICAgICAgICBzdGFuZGFyZDogJ0VJUC0xNDc0JyxcbiAgICAgICAgbWVzc2FnZTogJ1Jlc291cmNlIG5vdCBmb3VuZC4nLFxuICAgIH0sXG4gICAgJy0zMjAwMic6IHtcbiAgICAgICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgICAgIG1lc3NhZ2U6ICdSZXNvdXJjZSB1bmF2YWlsYWJsZS4nLFxuICAgIH0sXG4gICAgJy0zMjAwMyc6IHtcbiAgICAgICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgICAgIG1lc3NhZ2U6ICdUcmFuc2FjdGlvbiByZWplY3RlZC4nLFxuICAgIH0sXG4gICAgJy0zMjAwNCc6IHtcbiAgICAgICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgICAgIG1lc3NhZ2U6ICdNZXRob2Qgbm90IHN1cHBvcnRlZC4nLFxuICAgIH0sXG4gICAgJy0zMjAwNSc6IHtcbiAgICAgICAgc3RhbmRhcmQ6ICdFSVAtMTQ3NCcsXG4gICAgICAgIG1lc3NhZ2U6ICdSZXF1ZXN0IGxpbWl0IGV4Y2VlZGVkLicsXG4gICAgfSxcbiAgICAnNDAwMSc6IHtcbiAgICAgICAgc3RhbmRhcmQ6ICdFSVAtMTE5MycsXG4gICAgICAgIG1lc3NhZ2U6ICdVc2VyIHJlamVjdGVkIHRoZSByZXF1ZXN0LicsXG4gICAgfSxcbiAgICAnNDEwMCc6IHtcbiAgICAgICAgc3RhbmRhcmQ6ICdFSVAtMTE5MycsXG4gICAgICAgIG1lc3NhZ2U6ICdUaGUgcmVxdWVzdGVkIGFjY291bnQgYW5kL29yIG1ldGhvZCBoYXMgbm90IGJlZW4gYXV0aG9yaXplZCBieSB0aGUgdXNlci4nLFxuICAgIH0sXG4gICAgJzQyMDAnOiB7XG4gICAgICAgIHN0YW5kYXJkOiAnRUlQLTExOTMnLFxuICAgICAgICBtZXNzYWdlOiAnVGhlIHJlcXVlc3RlZCBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIEV0aGVyZXVtIHByb3ZpZGVyLicsXG4gICAgfSxcbiAgICAnNDkwMCc6IHtcbiAgICAgICAgc3RhbmRhcmQ6ICdFSVAtMTE5MycsXG4gICAgICAgIG1lc3NhZ2U6ICdUaGUgcHJvdmlkZXIgaXMgZGlzY29ubmVjdGVkIGZyb20gYWxsIGNoYWlucy4nLFxuICAgIH0sXG4gICAgJzQ5MDEnOiB7XG4gICAgICAgIHN0YW5kYXJkOiAnRUlQLTExOTMnLFxuICAgICAgICBtZXNzYWdlOiAnVGhlIHByb3ZpZGVyIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIHRoZSBzcGVjaWZpZWQgY2hhaW4uJyxcbiAgICB9LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVpYSnliM0l0WTI5dWMzUmhiblJ6TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2YzNKakwyVnljbTl5TFdOdmJuTjBZVzUwY3k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdRVUYxUW1Fc1VVRkJRU3hWUVVGVkxFZEJRV1U3U1VGRGNFTXNSMEZCUnl4RlFVRkZPMUZCUTBnc1dVRkJXU3hGUVVGRkxFTkJRVU1zUzBGQlN6dFJRVU53UWl4blFrRkJaMElzUlVGQlJTeERRVUZETEV0QlFVczdVVUZEZUVJc2JVSkJRVzFDTEVWQlFVVXNRMEZCUXl4TFFVRkxPMUZCUXpOQ0xHMUNRVUZ0UWl4RlFVRkZMRU5CUVVNc1MwRkJTenRSUVVNelFpeHJRa0ZCYTBJc1JVRkJSU3hEUVVGRExFdEJRVXM3VVVGRE1VSXNZVUZCWVN4RlFVRkZMRU5CUVVNc1MwRkJTenRSUVVOeVFpeExRVUZMTEVWQlFVVXNRMEZCUXl4TFFVRkxPMUZCUTJJc1kwRkJZeXhGUVVGRkxFTkJRVU1zUzBGQlN6dFJRVU4wUWl4alFVRmpMRVZCUVVVc1EwRkJReXhMUVVGTE8xRkJRM1JDTEdGQlFXRXNSVUZCUlN4RFFVRkRMRXRCUVVzN1VVRkRja0lzVVVGQlVTeEZRVUZGTEVOQlFVTXNTMEZCU3p0TFFVTnFRanRKUVVORUxGRkJRVkVzUlVGQlJUdFJRVU5TTEcxQ1FVRnRRaXhGUVVGRkxFbEJRVWs3VVVGRGVrSXNXVUZCV1N4RlFVRkZMRWxCUVVrN1VVRkRiRUlzYVVKQlFXbENMRVZCUVVVc1NVRkJTVHRSUVVOMlFpeFpRVUZaTEVWQlFVVXNTVUZCU1R0UlFVTnNRaXhwUWtGQmFVSXNSVUZCUlN4SlFVRkpPMHRCUTNoQ08wTkJRMFlzUTBGQlF6dEJRVVZYTEZGQlFVRXNWMEZCVnl4SFFVRkhPMGxCUTNwQ0xGRkJRVkVzUlVGQlJUdFJRVU5TTEZGQlFWRXNSVUZCUlN4alFVRmpPMUZCUTNoQ0xFOUJRVThzUlVGQlJTeDFSMEZCZFVjN1MwRkRha2c3U1VGRFJDeFJRVUZSTEVWQlFVVTdVVUZEVWl4UlFVRlJMRVZCUVVVc1kwRkJZenRSUVVONFFpeFBRVUZQTEVWQlFVVXNPRU5CUVRoRE8wdEJRM2hFTzBsQlEwUXNVVUZCVVN4RlFVRkZPMUZCUTFJc1VVRkJVU3hGUVVGRkxHTkJRV003VVVGRGVFSXNUMEZCVHl4RlFVRkZMQ3REUVVFclF6dExRVU42UkR0SlFVTkVMRkZCUVZFc1JVRkJSVHRSUVVOU0xGRkJRVkVzUlVGQlJTeGpRVUZqTzFGQlEzaENMRTlCUVU4c1JVRkJSU3c0UWtGQk9FSTdTMEZEZUVNN1NVRkRSQ3hSUVVGUkxFVkJRVVU3VVVGRFVpeFJRVUZSTEVWQlFVVXNZMEZCWXp0UlFVTjRRaXhQUVVGUExFVkJRVVVzTUVKQlFUQkNPMHRCUTNCRE8wbEJRMFFzVVVGQlVTeEZRVUZGTzFGQlExSXNVVUZCVVN4RlFVRkZMRlZCUVZVN1VVRkRjRUlzVDBGQlR5eEZRVUZGTEdkQ1FVRm5RanRMUVVNeFFqdEpRVU5FTEZGQlFWRXNSVUZCUlR0UlFVTlNMRkZCUVZFc1JVRkJSU3hWUVVGVk8xRkJRM0JDTEU5QlFVOHNSVUZCUlN4eFFrRkJjVUk3UzBGREwwSTdTVUZEUkN4UlFVRlJMRVZCUVVVN1VVRkRVaXhSUVVGUkxFVkJRVVVzVlVGQlZUdFJRVU53UWl4UFFVRlBMRVZCUVVVc2RVSkJRWFZDTzB0QlEycERPMGxCUTBRc1VVRkJVU3hGUVVGRk8xRkJRMUlzVVVGQlVTeEZRVUZGTEZWQlFWVTdVVUZEY0VJc1QwRkJUeXhGUVVGRkxIVkNRVUYxUWp0TFFVTnFRenRKUVVORUxGRkJRVkVzUlVGQlJUdFJRVU5TTEZGQlFWRXNSVUZCUlN4VlFVRlZPMUZCUTNCQ0xFOUJRVThzUlVGQlJTeDFRa0ZCZFVJN1MwRkRha003U1VGRFJDeFJRVUZSTEVWQlFVVTdVVUZEVWl4UlFVRlJMRVZCUVVVc1ZVRkJWVHRSUVVOd1FpeFBRVUZQTEVWQlFVVXNlVUpCUVhsQ08wdEJRMjVETzBsQlEwUXNUVUZCVFN4RlFVRkZPMUZCUTA0c1VVRkJVU3hGUVVGRkxGVkJRVlU3VVVGRGNFSXNUMEZCVHl4RlFVRkZMRFJDUVVFMFFqdExRVU4wUXp0SlFVTkVMRTFCUVUwc1JVRkJSVHRSUVVOT0xGRkJRVkVzUlVGQlJTeFZRVUZWTzFGQlEzQkNMRTlCUVU4c1JVRkJSU3d3UlVGQk1FVTdTMEZEY0VZN1NVRkRSQ3hOUVVGTkxFVkJRVVU3VVVGRFRpeFJRVUZSTEVWQlFVVXNWVUZCVlR0UlFVTndRaXhQUVVGUExFVkJRVVVzYTBWQlFXdEZPMHRCUXpWRk8wbEJRMFFzVFVGQlRTeEZRVUZGTzFGQlEwNHNVVUZCVVN4RlFVRkZMRlZCUVZVN1VVRkRjRUlzVDBGQlR5eEZRVUZGTEN0RFFVRXJRenRMUVVONlJEdEpRVU5FTEUxQlFVMHNSVUZCUlR0UlFVTk9MRkZCUVZFc1JVRkJSU3hWUVVGVk8xRkJRM0JDTEU5QlFVOHNSVUZCUlN4M1JFRkJkMFE3UzBGRGJFVTdRMEZEUml4RFFVRkRJbjA9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNlcmlhbGl6ZUVycm9yID0gZXhwb3J0cy5pc1ZhbGlkQ29kZSA9IGV4cG9ydHMuZ2V0TWVzc2FnZUZyb21Db2RlID0gZXhwb3J0cy5KU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRSA9IHZvaWQgMDtcbmNvbnN0IGVycm9yX2NvbnN0YW50c18xID0gcmVxdWlyZShcIi4vZXJyb3ItY29uc3RhbnRzXCIpO1xuY29uc3QgY2xhc3Nlc18xID0gcmVxdWlyZShcIi4vY2xhc3Nlc1wiKTtcbmNvbnN0IEZBTExCQUNLX0VSUk9SX0NPREUgPSBlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5pbnRlcm5hbDtcbmNvbnN0IEZBTExCQUNLX01FU1NBR0UgPSAnVW5zcGVjaWZpZWQgZXJyb3IgbWVzc2FnZS4gVGhpcyBpcyBhIGJ1ZywgcGxlYXNlIHJlcG9ydCBpdC4nO1xuY29uc3QgRkFMTEJBQ0tfRVJST1IgPSB7XG4gICAgY29kZTogRkFMTEJBQ0tfRVJST1JfQ09ERSxcbiAgICBtZXNzYWdlOiBnZXRNZXNzYWdlRnJvbUNvZGUoRkFMTEJBQ0tfRVJST1JfQ09ERSksXG59O1xuZXhwb3J0cy5KU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRSA9ICdVbnNwZWNpZmllZCBzZXJ2ZXIgZXJyb3IuJztcbi8qKlxuICogR2V0cyB0aGUgbWVzc2FnZSBmb3IgYSBnaXZlbiBjb2RlLCBvciBhIGZhbGxiYWNrIG1lc3NhZ2UgaWYgdGhlIGNvZGUgaGFzXG4gKiBubyBjb3JyZXNwb25kaW5nIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIGdldE1lc3NhZ2VGcm9tQ29kZShjb2RlLCBmYWxsYmFja01lc3NhZ2UgPSBGQUxMQkFDS19NRVNTQUdFKSB7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoY29kZSkpIHtcbiAgICAgICAgY29uc3QgY29kZVN0cmluZyA9IGNvZGUudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKGhhc0tleShlcnJvcl9jb25zdGFudHNfMS5lcnJvclZhbHVlcywgY29kZVN0cmluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcl9jb25zdGFudHNfMS5lcnJvclZhbHVlc1tjb2RlU3RyaW5nXS5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0pzb25ScGNTZXJ2ZXJFcnJvcihjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbGxiYWNrTWVzc2FnZTtcbn1cbmV4cG9ydHMuZ2V0TWVzc2FnZUZyb21Db2RlID0gZ2V0TWVzc2FnZUZyb21Db2RlO1xuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIGNvZGUgaXMgdmFsaWQuXG4gKiBBIGNvZGUgaXMgb25seSB2YWxpZCBpZiBpdCBoYXMgYSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQ29kZShjb2RlKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY29kZVN0cmluZyA9IGNvZGUudG9TdHJpbmcoKTtcbiAgICBpZiAoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JWYWx1ZXNbY29kZVN0cmluZ10pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc0pzb25ScGNTZXJ2ZXJFcnJvcihjb2RlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc1ZhbGlkQ29kZSA9IGlzVmFsaWRDb2RlO1xuLyoqXG4gKiBTZXJpYWxpemVzIHRoZSBnaXZlbiBlcnJvciB0byBhbiBFdGhlcmV1bSBKU09OIFJQQy1jb21wYXRpYmxlIGVycm9yIG9iamVjdC5cbiAqIE1lcmVseSBjb3BpZXMgdGhlIGdpdmVuIGVycm9yJ3MgdmFsdWVzIGlmIGl0IGlzIGFscmVhZHkgY29tcGF0aWJsZS5cbiAqIElmIHRoZSBnaXZlbiBlcnJvciBpcyBub3QgZnVsbHkgY29tcGF0aWJsZSwgaXQgd2lsbCBiZSBwcmVzZXJ2ZWQgb24gdGhlXG4gKiByZXR1cm5lZCBvYmplY3QncyBkYXRhLm9yaWdpbmFsRXJyb3IgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUVycm9yKGVycm9yLCB7IGZhbGxiYWNrRXJyb3IgPSBGQUxMQkFDS19FUlJPUiwgc2hvdWxkSW5jbHVkZVN0YWNrID0gZmFsc2UsIH0gPSB7fSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKCFmYWxsYmFja0Vycm9yIHx8XG4gICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKGZhbGxiYWNrRXJyb3IuY29kZSkgfHxcbiAgICAgICAgdHlwZW9mIGZhbGxiYWNrRXJyb3IubWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgZmFsbGJhY2sgZXJyb3Igd2l0aCBpbnRlZ2VyIG51bWJlciBjb2RlIGFuZCBzdHJpbmcgbWVzc2FnZS4nKTtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgY2xhc3Nlc18xLkV0aGVyZXVtUnBjRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLnNlcmlhbGl6ZSgpO1xuICAgIH1cbiAgICBjb25zdCBzZXJpYWxpemVkID0ge307XG4gICAgaWYgKGVycm9yICYmXG4gICAgICAgIHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgIUFycmF5LmlzQXJyYXkoZXJyb3IpICYmXG4gICAgICAgIGhhc0tleShlcnJvciwgJ2NvZGUnKSAmJlxuICAgICAgICBpc1ZhbGlkQ29kZShlcnJvci5jb2RlKSkge1xuICAgICAgICBjb25zdCBfZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgc2VyaWFsaXplZC5jb2RlID0gX2Vycm9yLmNvZGU7XG4gICAgICAgIGlmIChfZXJyb3IubWVzc2FnZSAmJiB0eXBlb2YgX2Vycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLm1lc3NhZ2UgPSBfZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgIGlmIChoYXNLZXkoX2Vycm9yLCAnZGF0YScpKSB7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZC5kYXRhID0gX2Vycm9yLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkLm1lc3NhZ2UgPSBnZXRNZXNzYWdlRnJvbUNvZGUoc2VyaWFsaXplZC5jb2RlKTtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQuZGF0YSA9IHsgb3JpZ2luYWxFcnJvcjogYXNzaWduT3JpZ2luYWxFcnJvcihlcnJvcikgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2VyaWFsaXplZC5jb2RlID0gZmFsbGJhY2tFcnJvci5jb2RlO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gKF9hID0gZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlO1xuICAgICAgICBzZXJpYWxpemVkLm1lc3NhZ2UgPSAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gbWVzc2FnZVxuICAgICAgICAgICAgOiBmYWxsYmFja0Vycm9yLm1lc3NhZ2UpO1xuICAgICAgICBzZXJpYWxpemVkLmRhdGEgPSB7IG9yaWdpbmFsRXJyb3I6IGFzc2lnbk9yaWdpbmFsRXJyb3IoZXJyb3IpIH07XG4gICAgfVxuICAgIGNvbnN0IHN0YWNrID0gKF9iID0gZXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGFjaztcbiAgICBpZiAoc2hvdWxkSW5jbHVkZVN0YWNrICYmIGVycm9yICYmIHN0YWNrICYmIHR5cGVvZiBzdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgc2VyaWFsaXplZC5zdGFjayA9IHN0YWNrO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZDtcbn1cbmV4cG9ydHMuc2VyaWFsaXplRXJyb3IgPSBzZXJpYWxpemVFcnJvcjtcbi8vIEludGVybmFsXG5mdW5jdGlvbiBpc0pzb25ScGNTZXJ2ZXJFcnJvcihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gLTMyMDk5ICYmIGNvZGUgPD0gLTMyMDAwO1xufVxuZnVuY3Rpb24gYXNzaWduT3JpZ2luYWxFcnJvcihlcnJvcikge1xuICAgIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGVycm9yKSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3I7XG59XG5mdW5jdGlvbiBoYXNLZXkob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaWRYUnBiSE11YW5NaUxDSnpiM1Z5WTJWU2IyOTBJam9pSWl3aWMyOTFjbU5sY3lJNld5SXVMaTl6Y21NdmRYUnBiSE11ZEhNaVhTd2libUZ0WlhNaU9sdGRMQ0p0WVhCd2FXNW5jeUk2SWpzN08wRkJRVUVzZFVSQlFUUkVPMEZCUXpWRUxIVkRRVUY1UlR0QlFVVjZSU3hOUVVGTkxHMUNRVUZ0UWl4SFFVRkhMRFJDUVVGVkxFTkJRVU1zUjBGQlJ5eERRVUZETEZGQlFWRXNRMEZCUXp0QlFVTndSQ3hOUVVGTkxHZENRVUZuUWl4SFFVRkhMRFpFUVVFMlJDeERRVUZETzBGQlEzWkdMRTFCUVUwc1kwRkJZeXhIUVVFclFqdEpRVU5xUkN4SlFVRkpMRVZCUVVVc2JVSkJRVzFDTzBsQlEzcENMRTlCUVU4c1JVRkJSU3hyUWtGQmEwSXNRMEZCUXl4dFFrRkJiVUlzUTBGQlF6dERRVU5xUkN4RFFVRkRPMEZCUlZjc1VVRkJRU3cyUWtGQk5rSXNSMEZCUnl3eVFrRkJNa0lzUTBGQlF6dEJRVWw2UlRzN08wZEJSMGM3UVVGRFNDeFRRVUZuUWl4clFrRkJhMElzUTBGRGFFTXNTVUZCV1N4RlFVTmFMR3RDUVVFd1FpeG5Ra0ZCWjBJN1NVRkZNVU1zU1VGQlNTeE5RVUZOTEVOQlFVTXNVMEZCVXl4RFFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRk8xRkJRekZDTEUxQlFVMHNWVUZCVlN4SFFVRkhMRWxCUVVrc1EwRkJReXhSUVVGUkxFVkJRVVVzUTBGQlF6dFJRVVZ1UXl4SlFVRkpMRTFCUVUwc1EwRkJReXcyUWtGQlZ5eEZRVUZGTEZWQlFWVXNRMEZCUXl4RlFVRkZPMWxCUTI1RExFOUJRVThzTmtKQlFWY3NRMEZCUXl4VlFVRXlRaXhEUVVGRExFTkJRVU1zVDBGQlR5eERRVUZETzFOQlEzcEVPMUZCUTBRc1NVRkJTU3h2UWtGQmIwSXNRMEZCUXl4SlFVRkpMRU5CUVVNc1JVRkJSVHRaUVVNNVFpeFBRVUZQTEhGRFFVRTJRaXhEUVVGRE8xTkJRM1JETzB0QlEwWTdTVUZEUkN4UFFVRlBMR1ZCUVdVc1EwRkJRenRCUVVONlFpeERRVUZETzBGQlprUXNaMFJCWlVNN1FVRkZSRHM3TzBkQlIwYzdRVUZEU0N4VFFVRm5RaXhYUVVGWExFTkJRVU1zU1VGQldUdEpRVU4wUXl4SlFVRkpMRU5CUVVNc1RVRkJUU3hEUVVGRExGTkJRVk1zUTBGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlR0UlFVTXpRaXhQUVVGUExFdEJRVXNzUTBGQlF6dExRVU5rTzBsQlJVUXNUVUZCVFN4VlFVRlZMRWRCUVVjc1NVRkJTU3hEUVVGRExGRkJRVkVzUlVGQlJTeERRVUZETzBsQlEyNURMRWxCUVVrc05rSkJRVmNzUTBGQlF5eFZRVUV5UWl4RFFVRkRMRVZCUVVVN1VVRkROVU1zVDBGQlR5eEpRVUZKTEVOQlFVTTdTMEZEWWp0SlFVVkVMRWxCUVVrc2IwSkJRVzlDTEVOQlFVTXNTVUZCU1N4RFFVRkRMRVZCUVVVN1VVRkRPVUlzVDBGQlR5eEpRVUZKTEVOQlFVTTdTMEZEWWp0SlFVTkVMRTlCUVU4c1MwRkJTeXhEUVVGRE8wRkJRMllzUTBGQlF6dEJRV1JFTEd0RFFXTkRPMEZCUlVRN096czdPMGRCUzBjN1FVRkRTQ3hUUVVGblFpeGpRVUZqTEVOQlF6VkNMRXRCUVdNc1JVRkRaQ3hGUVVORkxHRkJRV0VzUjBGQlJ5eGpRVUZqTEVWQlF6bENMR3RDUVVGclFpeEhRVUZITEV0QlFVc3NSMEZETTBJc1IwRkJSeXhGUVVGRk96dEpRVWRPTEVsQlEwVXNRMEZCUXl4aFFVRmhPMUZCUTJRc1EwRkJReXhOUVVGTkxFTkJRVU1zVTBGQlV5eERRVUZETEdGQlFXRXNRMEZCUXl4SlFVRkpMRU5CUVVNN1VVRkRja01zVDBGQlR5eGhRVUZoTEVOQlFVTXNUMEZCVHl4TFFVRkxMRkZCUVZFc1JVRkRla003VVVGRFFTeE5RVUZOTEVsQlFVa3NTMEZCU3l4RFFVTmlMREJGUVVFd1JTeERRVU16UlN4RFFVRkRPMHRCUTBnN1NVRkZSQ3hKUVVGSkxFdEJRVXNzV1VGQldTd3dRa0ZCWjBJc1JVRkJSVHRSUVVOeVF5eFBRVUZQTEV0QlFVc3NRMEZCUXl4VFFVRlRMRVZCUVVVc1EwRkJRenRMUVVNeFFqdEpRVVZFTEUxQlFVMHNWVUZCVlN4SFFVRjNReXhGUVVGRkxFTkJRVU03U1VGRk0wUXNTVUZEUlN4TFFVRkxPMUZCUTB3c1QwRkJUeXhMUVVGTExFdEJRVXNzVVVGQlVUdFJRVU42UWl4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETzFGQlEzSkNMRTFCUVUwc1EwRkJReXhMUVVGblF5eEZRVUZGTEUxQlFVMHNRMEZCUXp0UlFVTm9SQ3hYUVVGWExFTkJRVVVzUzBGQmIwTXNRMEZCUXl4SlFVRkpMRU5CUVVNc1JVRkRka1E3VVVGRFFTeE5RVUZOTEUxQlFVMHNSMEZCUnl4TFFVRTBReXhEUVVGRE8xRkJRelZFTEZWQlFWVXNRMEZCUXl4SlFVRkpMRWRCUVVjc1RVRkJUU3hEUVVGRExFbEJRVWtzUTBGQlF6dFJRVVU1UWl4SlFVRkpMRTFCUVUwc1EwRkJReXhQUVVGUExFbEJRVWtzVDBGQlR5eE5RVUZOTEVOQlFVTXNUMEZCVHl4TFFVRkxMRkZCUVZFc1JVRkJSVHRaUVVONFJDeFZRVUZWTEVOQlFVTXNUMEZCVHl4SFFVRkhMRTFCUVUwc1EwRkJReXhQUVVGUExFTkJRVU03V1VGRmNFTXNTVUZCU1N4TlFVRk5MRU5CUVVNc1RVRkJUU3hGUVVGRkxFMUJRVTBzUTBGQlF5eEZRVUZGTzJkQ1FVTXhRaXhWUVVGVkxFTkJRVU1zU1VGQlNTeEhRVUZITEUxQlFVMHNRMEZCUXl4SlFVRkpMRU5CUVVNN1lVRkRMMEk3VTBGRFJqdGhRVUZOTzFsQlEwd3NWVUZCVlN4RFFVRkRMRTlCUVU4c1IwRkJSeXhyUWtGQmEwSXNRMEZEY0VNc1ZVRkJlVU1zUTBGQlF5eEpRVUZKTEVOQlEyaEVMRU5CUVVNN1dVRkZSaXhWUVVGVkxFTkJRVU1zU1VGQlNTeEhRVUZITEVWQlFVVXNZVUZCWVN4RlFVRkZMRzFDUVVGdFFpeERRVUZETEV0QlFVc3NRMEZCUXl4RlFVRkZMRU5CUVVNN1UwRkRha1U3UzBGRFJqdFRRVUZOTzFGQlEwd3NWVUZCVlN4RFFVRkRMRWxCUVVrc1IwRkJSeXhoUVVGaExFTkJRVU1zU1VGQlNTeERRVUZETzFGQlJYSkRMRTFCUVUwc1QwRkJUeXhUUVVGSkxFdEJRV0VzTUVOQlFVVXNUMEZCVHl4RFFVRkRPMUZCUlhoRExGVkJRVlVzUTBGQlF5eFBRVUZQTEVkQlFVY3NRMEZEYmtJc1QwRkJUeXhKUVVGSkxFOUJRVThzVDBGQlR5eExRVUZMTEZGQlFWRTdXVUZEY0VNc1EwRkJReXhEUVVGRExFOUJRVTg3V1VGRFZDeERRVUZETEVOQlFVTXNZVUZCWVN4RFFVRkRMRTlCUVU4c1EwRkRNVUlzUTBGQlF6dFJRVU5HTEZWQlFWVXNRMEZCUXl4SlFVRkpMRWRCUVVjc1JVRkJSU3hoUVVGaExFVkJRVVVzYlVKQlFXMUNMRU5CUVVNc1MwRkJTeXhEUVVGRExFVkJRVVVzUTBGQlF6dExRVU5xUlR0SlFVVkVMRTFCUVUwc1MwRkJTeXhUUVVGSkxFdEJRV0VzTUVOQlFVVXNTMEZCU3l4RFFVRkRPMGxCUlhCRExFbEJRVWtzYTBKQlFXdENMRWxCUVVrc1MwRkJTeXhKUVVGSkxFdEJRVXNzU1VGQlNTeFBRVUZQTEV0QlFVc3NTMEZCU3l4UlFVRlJMRVZCUVVVN1VVRkRja1VzVlVGQlZTeERRVUZETEV0QlFVc3NSMEZCUnl4TFFVRkxMRU5CUVVNN1MwRkRNVUk3U1VGRFJDeFBRVUZQTEZWQlFYZERMRU5CUVVNN1FVRkRiRVFzUTBGQlF6dEJRV3hGUkN4M1EwRnJSVU03UVVGRlJDeFhRVUZYTzBGQlJWZ3NVMEZCVXl4dlFrRkJiMElzUTBGQlF5eEpRVUZaTzBsQlEzaERMRTlCUVU4c1NVRkJTU3hKUVVGSkxFTkJRVU1zUzBGQlN5eEpRVUZKTEVsQlFVa3NTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJRenRCUVVNeFF5eERRVUZETzBGQlJVUXNVMEZCVXl4dFFrRkJiVUlzUTBGQlF5eExRVUZqTzBsQlEzcERMRWxCUVVrc1MwRkJTeXhKUVVGSkxFOUJRVThzUzBGQlN5eExRVUZMTEZGQlFWRXNTVUZCU1N4RFFVRkRMRXRCUVVzc1EwRkJReXhQUVVGUExFTkJRVU1zUzBGQlN5eERRVUZETEVWQlFVVTdVVUZETDBRc1QwRkJUeXhOUVVGTkxFTkJRVU1zVFVGQlRTeERRVUZETEVWQlFVVXNSVUZCUlN4TFFVRkxMRU5CUVVNc1EwRkJRenRMUVVOcVF6dEpRVU5FTEU5QlFVOHNTMEZCU3l4RFFVRkRPMEZCUTJZc1EwRkJRenRCUVVWRUxGTkJRVk1zVFVGQlRTeERRVUZETEVkQlFUUkNMRVZCUVVVc1IwRkJWenRKUVVOMlJDeFBRVUZQTEUxQlFVMHNRMEZCUXl4VFFVRlRMRU5CUVVNc1kwRkJZeXhEUVVGRExFbEJRVWtzUTBGQlF5eEhRVUZITEVWQlFVVXNSMEZCUnl4RFFVRkRMRU5CUVVNN1FVRkRlRVFzUTBGQlF5SjkiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXRoRXJyb3JzID0gdm9pZCAwO1xuY29uc3QgY2xhc3Nlc18xID0gcmVxdWlyZShcIi4vY2xhc3Nlc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IGVycm9yX2NvbnN0YW50c18xID0gcmVxdWlyZShcIi4vZXJyb3ItY29uc3RhbnRzXCIpO1xuZXhwb3J0cy5ldGhFcnJvcnMgPSB7XG4gICAgcnBjOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgUGFyc2UgKC0zMjcwMCkgZXJyb3IuXG4gICAgICAgICAqL1xuICAgICAgICBwYXJzZTogKGFyZykgPT4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLnBhcnNlLCBhcmcpLFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludmFsaWQgUmVxdWVzdCAoLTMyNjAwKSBlcnJvci5cbiAgICAgICAgICovXG4gICAgICAgIGludmFsaWRSZXF1ZXN0OiAoYXJnKSA9PiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMuaW52YWxpZFJlcXVlc3QsIGFyZyksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgSW52YWxpZCBQYXJhbXMgKC0zMjYwMikgZXJyb3IuXG4gICAgICAgICAqL1xuICAgICAgICBpbnZhbGlkUGFyYW1zOiAoYXJnKSA9PiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMuaW52YWxpZFBhcmFtcywgYXJnKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBNZXRob2QgTm90IEZvdW5kICgtMzI2MDEpIGVycm9yLlxuICAgICAgICAgKi9cbiAgICAgICAgbWV0aG9kTm90Rm91bmQ6IChhcmcpID0+IGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5tZXRob2ROb3RGb3VuZCwgYXJnKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBJbnRlcm5hbCAoLTMyNjAzKSBlcnJvci5cbiAgICAgICAgICovXG4gICAgICAgIGludGVybmFsOiAoYXJnKSA9PiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMuaW50ZXJuYWwsIGFyZyksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgU2VydmVyIGVycm9yLlxuICAgICAgICAgKiBQZXJtaXRzIGludGVnZXIgZXJyb3IgY29kZXMgaW4gdGhlIFsgLTMyMDk5IDw9IC0zMjAwNSBdIHJhbmdlLlxuICAgICAgICAgKiBDb2RlcyAtMzIwMDAgdGhyb3VnaCAtMzIwMDQgYXJlIHJlc2VydmVkIGJ5IEVJUC0xNDc0LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VydmVyOiAob3B0cykgPT4ge1xuICAgICAgICAgICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdGhlcmV1bSBSUEMgU2VydmVyIGVycm9ycyBtdXN0IHByb3ZpZGUgc2luZ2xlIG9iamVjdCBhcmd1bWVudC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgY29kZSB9ID0gb3B0cztcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihjb2RlKSB8fCBjb2RlID4gLTMyMDA1IHx8IGNvZGUgPCAtMzIwOTkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlciBzdWNoIHRoYXQ6IC0zMjA5OSA8PSBjb2RlIDw9IC0zMjAwNScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdldEV0aEpzb25ScGNFcnJvcihjb2RlLCBvcHRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBJbnZhbGlkIElucHV0ICgtMzIwMDApIGVycm9yLlxuICAgICAgICAgKi9cbiAgICAgICAgaW52YWxpZElucHV0OiAoYXJnKSA9PiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMuaW52YWxpZElucHV0LCBhcmcpLFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIFJlc291cmNlIE5vdCBGb3VuZCAoLTMyMDAxKSBlcnJvci5cbiAgICAgICAgICovXG4gICAgICAgIHJlc291cmNlTm90Rm91bmQ6IChhcmcpID0+IGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5yZXNvdXJjZU5vdEZvdW5kLCBhcmcpLFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIFJlc291cmNlIFVuYXZhaWxhYmxlICgtMzIwMDIpIGVycm9yLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVzb3VyY2VVbmF2YWlsYWJsZTogKGFyZykgPT4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLnJlc291cmNlVW5hdmFpbGFibGUsIGFyZyksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgVHJhbnNhY3Rpb24gUmVqZWN0ZWQgKC0zMjAwMykgZXJyb3IuXG4gICAgICAgICAqL1xuICAgICAgICB0cmFuc2FjdGlvblJlamVjdGVkOiAoYXJnKSA9PiBnZXRFdGhKc29uUnBjRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5ycGMudHJhbnNhY3Rpb25SZWplY3RlZCwgYXJnKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBNZXRob2QgTm90IFN1cHBvcnRlZCAoLTMyMDA0KSBlcnJvci5cbiAgICAgICAgICovXG4gICAgICAgIG1ldGhvZE5vdFN1cHBvcnRlZDogKGFyZykgPT4gZ2V0RXRoSnNvblJwY0Vycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCwgYXJnKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBMaW1pdCBFeGNlZWRlZCAoLTMyMDA1KSBlcnJvci5cbiAgICAgICAgICovXG4gICAgICAgIGxpbWl0RXhjZWVkZWQ6IChhcmcpID0+IGdldEV0aEpzb25ScGNFcnJvcihlcnJvcl9jb25zdGFudHNfMS5lcnJvckNvZGVzLnJwYy5saW1pdEV4Y2VlZGVkLCBhcmcpLFxuICAgIH0sXG4gICAgcHJvdmlkZXI6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBVc2VyIFJlamVjdGVkIFJlcXVlc3QgKDQwMDEpIGVycm9yLlxuICAgICAgICAgKi9cbiAgICAgICAgdXNlclJlamVjdGVkUmVxdWVzdDogKGFyZykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0LCBhcmcpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVuYXV0aG9yaXplZCAoNDEwMCkgZXJyb3IuXG4gICAgICAgICAqL1xuICAgICAgICB1bmF1dGhvcml6ZWQ6IChhcmcpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFdGhQcm92aWRlckVycm9yKGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXMucHJvdmlkZXIudW5hdXRob3JpemVkLCBhcmcpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVuc3VwcG9ydGVkIE1ldGhvZCAoNDIwMCkgZXJyb3IuXG4gICAgICAgICAqL1xuICAgICAgICB1bnN1cHBvcnRlZE1ldGhvZDogKGFyZykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5wcm92aWRlci51bnN1cHBvcnRlZE1ldGhvZCwgYXJnKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBOb3QgQ29ubmVjdGVkICg0OTAwKSBlcnJvci5cbiAgICAgICAgICovXG4gICAgICAgIGRpc2Nvbm5lY3RlZDogKGFyZykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5wcm92aWRlci5kaXNjb25uZWN0ZWQsIGFyZyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgQ2hhaW4gTm90IENvbm5lY3RlZCAoNDkwMSkgZXJyb3IuXG4gICAgICAgICAqL1xuICAgICAgICBjaGFpbkRpc2Nvbm5lY3RlZDogKGFyZykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoZXJyb3JfY29uc3RhbnRzXzEuZXJyb3JDb2Rlcy5wcm92aWRlci5jaGFpbkRpc2Nvbm5lY3RlZCwgYXJnKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCBhIGN1c3RvbSBFdGhlcmV1bSBQcm92aWRlciBlcnJvci5cbiAgICAgICAgICovXG4gICAgICAgIGN1c3RvbTogKG9wdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXRoZXJldW0gUHJvdmlkZXIgY3VzdG9tIGVycm9ycyBtdXN0IHByb3ZpZGUgc2luZ2xlIG9iamVjdCBhcmd1bWVudC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgY29kZSwgbWVzc2FnZSwgZGF0YSB9ID0gb3B0cztcbiAgICAgICAgICAgIGlmICghbWVzc2FnZSB8fCB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWVzc2FnZVwiIG11c3QgYmUgYSBub25lbXB0eSBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgY2xhc3Nlc18xLkV0aGVyZXVtUHJvdmlkZXJFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhKTtcbiAgICAgICAgfSxcbiAgICB9LFxufTtcbi8vIEludGVybmFsXG5mdW5jdGlvbiBnZXRFdGhKc29uUnBjRXJyb3IoY29kZSwgYXJnKSB7XG4gICAgY29uc3QgW21lc3NhZ2UsIGRhdGFdID0gcGFyc2VPcHRzKGFyZyk7XG4gICAgcmV0dXJuIG5ldyBjbGFzc2VzXzEuRXRoZXJldW1ScGNFcnJvcihjb2RlLCBtZXNzYWdlIHx8IHV0aWxzXzEuZ2V0TWVzc2FnZUZyb21Db2RlKGNvZGUpLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIGdldEV0aFByb3ZpZGVyRXJyb3IoY29kZSwgYXJnKSB7XG4gICAgY29uc3QgW21lc3NhZ2UsIGRhdGFdID0gcGFyc2VPcHRzKGFyZyk7XG4gICAgcmV0dXJuIG5ldyBjbGFzc2VzXzEuRXRoZXJldW1Qcm92aWRlckVycm9yKGNvZGUsIG1lc3NhZ2UgfHwgdXRpbHNfMS5nZXRNZXNzYWdlRnJvbUNvZGUoY29kZSksIGRhdGEpO1xufVxuZnVuY3Rpb24gcGFyc2VPcHRzKGFyZykge1xuICAgIGlmIChhcmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gW2FyZ107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICAgICAgY29uc3QgeyBtZXNzYWdlLCBkYXRhIH0gPSBhcmc7XG4gICAgICAgICAgICBpZiAobWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSBzdHJpbmcgbWVzc2FnZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbbWVzc2FnZSB8fCB1bmRlZmluZWQsIGRhdGFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSm1hV3hsSWpvaVpYSnliM0p6TG1weklpd2ljMjkxY21ObFVtOXZkQ0k2SWlJc0luTnZkWEpqWlhNaU9sc2lMaTR2YzNKakwyVnljbTl5Y3k1MGN5SmRMQ0p1WVcxbGN5STZXMTBzSW0xaGNIQnBibWR6SWpvaU96czdRVUZCUVN4MVEwRkJiMFU3UVVGRGNFVXNiVU5CUVRaRE8wRkJRemRETEhWRVFVRXJRenRCUVdWc1F5eFJRVUZCTEZOQlFWTXNSMEZCUnp0SlFVTjJRaXhIUVVGSExFVkJRVVU3VVVGRlNEczdWMEZGUnp0UlFVTklMRXRCUVVzc1JVRkJSU3hEUVVGSkxFZEJRWEZDTEVWQlFVVXNSVUZCUlN4RFFVRkRMR3RDUVVGclFpeERRVU55UkN3MFFrRkJWU3hEUVVGRExFZEJRVWNzUTBGQlF5eExRVUZMTEVWQlFVVXNSMEZCUnl4RFFVTXhRanRSUVVWRU96dFhRVVZITzFGQlEwZ3NZMEZCWXl4RlFVRkZMRU5CUVVrc1IwRkJjVUlzUlVGQlJTeEZRVUZGTEVOQlFVTXNhMEpCUVd0Q0xFTkJRemxFTERSQ1FVRlZMRU5CUVVNc1IwRkJSeXhEUVVGRExHTkJRV01zUlVGQlJTeEhRVUZITEVOQlEyNURPMUZCUlVRN08xZEJSVWM3VVVGRFNDeGhRVUZoTEVWQlFVVXNRMEZCU1N4SFFVRnhRaXhGUVVGRkxFVkJRVVVzUTBGQlF5eHJRa0ZCYTBJc1EwRkROMFFzTkVKQlFWVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1lVRkJZU3hGUVVGRkxFZEJRVWNzUTBGRGJFTTdVVUZGUkRzN1YwRkZSenRSUVVOSUxHTkJRV01zUlVGQlJTeERRVUZKTEVkQlFYRkNMRVZCUVVVc1JVRkJSU3hEUVVGRExHdENRVUZyUWl4RFFVTTVSQ3cwUWtGQlZTeERRVUZETEVkQlFVY3NRMEZCUXl4alFVRmpMRVZCUVVVc1IwRkJSeXhEUVVOdVF6dFJRVVZFT3p0WFFVVkhPMUZCUTBnc1VVRkJVU3hGUVVGRkxFTkJRVWtzUjBGQmNVSXNSVUZCUlN4RlFVRkZMRU5CUVVNc2EwSkJRV3RDTEVOQlEzaEVMRFJDUVVGVkxFTkJRVU1zUjBGQlJ5eERRVUZETEZGQlFWRXNSVUZCUlN4SFFVRkhMRU5CUXpkQ08xRkJSVVE3T3pzN1YwRkpSenRSUVVOSUxFMUJRVTBzUlVGQlJTeERRVUZKTEVsQlFUSkNMRVZCUVVVc1JVRkJSVHRaUVVONlF5eEpRVUZKTEVOQlFVTXNTVUZCU1N4SlFVRkpMRTlCUVU4c1NVRkJTU3hMUVVGTExGRkJRVkVzU1VGQlNTeExRVUZMTEVOQlFVTXNUMEZCVHl4RFFVRkRMRWxCUVVrc1EwRkJReXhGUVVGRk8yZENRVU0xUkN4TlFVRk5MRWxCUVVrc1MwRkJTeXhEUVVGRExHbEZRVUZwUlN4RFFVRkRMRU5CUVVNN1lVRkRjRVk3V1VGRFJDeE5RVUZOTEVWQlFVVXNTVUZCU1N4RlFVRkZMRWRCUVVjc1NVRkJTU3hEUVVGRE8xbEJRM1JDTEVsQlFVa3NRMEZCUXl4TlFVRk5MRU5CUVVNc1UwRkJVeXhEUVVGRExFbEJRVWtzUTBGQlF5eEpRVUZKTEVsQlFVa3NSMEZCUnl4RFFVRkRMRXRCUVVzc1NVRkJTU3hKUVVGSkxFZEJRVWNzUTBGQlF5eExRVUZMTEVWQlFVVTdaMEpCUXpkRUxFMUJRVTBzU1VGQlNTeExRVUZMTEVOQlEySXNLMFJCUVN0RUxFTkJRMmhGTEVOQlFVTTdZVUZEU0R0WlFVTkVMRTlCUVU4c2EwSkJRV3RDTEVOQlFVTXNTVUZCU1N4RlFVRkZMRWxCUVVrc1EwRkJReXhEUVVGRE8xRkJRM2hETEVOQlFVTTdVVUZGUkRzN1YwRkZSenRSUVVOSUxGbEJRVmtzUlVGQlJTeERRVUZKTEVkQlFYRkNMRVZCUVVVc1JVRkJSU3hEUVVGRExHdENRVUZyUWl4RFFVTTFSQ3cwUWtGQlZTeERRVUZETEVkQlFVY3NRMEZCUXl4WlFVRlpMRVZCUVVVc1IwRkJSeXhEUVVOcVF6dFJRVVZFT3p0WFFVVkhPMUZCUTBnc1owSkJRV2RDTEVWQlFVVXNRMEZCU1N4SFFVRnhRaXhGUVVGRkxFVkJRVVVzUTBGQlF5eHJRa0ZCYTBJc1EwRkRhRVVzTkVKQlFWVXNRMEZCUXl4SFFVRkhMRU5CUVVNc1owSkJRV2RDTEVWQlFVVXNSMEZCUnl4RFFVTnlRenRSUVVWRU96dFhRVVZITzFGQlEwZ3NiVUpCUVcxQ0xFVkJRVVVzUTBGQlNTeEhRVUZ4UWl4RlFVRkZMRVZCUVVVc1EwRkJReXhyUWtGQmEwSXNRMEZEYmtVc05FSkJRVlVzUTBGQlF5eEhRVUZITEVOQlFVTXNiVUpCUVcxQ0xFVkJRVVVzUjBGQlJ5eERRVU40UXp0UlFVVkVPenRYUVVWSE8xRkJRMGdzYlVKQlFXMUNMRVZCUVVVc1EwRkJTU3hIUVVGeFFpeEZRVUZGTEVWQlFVVXNRMEZCUXl4clFrRkJhMElzUTBGRGJrVXNORUpCUVZVc1EwRkJReXhIUVVGSExFTkJRVU1zYlVKQlFXMUNMRVZCUVVVc1IwRkJSeXhEUVVONFF6dFJRVVZFT3p0WFFVVkhPMUZCUTBnc2EwSkJRV3RDTEVWQlFVVXNRMEZCU1N4SFFVRnhRaXhGUVVGRkxFVkJRVVVzUTBGQlF5eHJRa0ZCYTBJc1EwRkRiRVVzTkVKQlFWVXNRMEZCUXl4SFFVRkhMRU5CUVVNc2EwSkJRV3RDTEVWQlFVVXNSMEZCUnl4RFFVTjJRenRSUVVWRU96dFhRVVZITzFGQlEwZ3NZVUZCWVN4RlFVRkZMRU5CUVVrc1IwRkJjVUlzUlVGQlJTeEZRVUZGTEVOQlFVTXNhMEpCUVd0Q0xFTkJRemRFTERSQ1FVRlZMRU5CUVVNc1IwRkJSeXhEUVVGRExHRkJRV0VzUlVGQlJTeEhRVUZITEVOQlEyeERPMHRCUTBZN1NVRkZSQ3hSUVVGUkxFVkJRVVU3VVVGRlVqczdWMEZGUnp0UlFVTklMRzFDUVVGdFFpeEZRVUZGTEVOQlFVa3NSMEZCY1VJc1JVRkJSU3hGUVVGRk8xbEJRMmhFTEU5QlFVOHNiVUpCUVcxQ0xFTkJRM2hDTERSQ1FVRlZMRU5CUVVNc1VVRkJVU3hEUVVGRExHMUNRVUZ0UWl4RlFVRkZMRWRCUVVjc1EwRkROME1zUTBGQlF6dFJRVU5LTEVOQlFVTTdVVUZGUkRzN1YwRkZSenRSUVVOSUxGbEJRVmtzUlVGQlJTeERRVUZKTEVkQlFYRkNMRVZCUVVVc1JVRkJSVHRaUVVONlF5eFBRVUZQTEcxQ1FVRnRRaXhEUVVONFFpdzBRa0ZCVlN4RFFVRkRMRkZCUVZFc1EwRkJReXhaUVVGWkxFVkJRVVVzUjBGQlJ5eERRVU4wUXl4RFFVRkRPMUZCUTBvc1EwRkJRenRSUVVWRU96dFhRVVZITzFGQlEwZ3NhVUpCUVdsQ0xFVkJRVVVzUTBGQlNTeEhRVUZ4UWl4RlFVRkZMRVZCUVVVN1dVRkRPVU1zVDBGQlR5eHRRa0ZCYlVJc1EwRkRlRUlzTkVKQlFWVXNRMEZCUXl4UlFVRlJMRU5CUVVNc2FVSkJRV2xDTEVWQlFVVXNSMEZCUnl4RFFVTXpReXhEUVVGRE8xRkJRMG9zUTBGQlF6dFJRVVZFT3p0WFFVVkhPMUZCUTBnc1dVRkJXU3hGUVVGRkxFTkJRVWtzUjBGQmNVSXNSVUZCUlN4RlFVRkZPMWxCUTNwRExFOUJRVThzYlVKQlFXMUNMRU5CUTNoQ0xEUkNRVUZWTEVOQlFVTXNVVUZCVVN4RFFVRkRMRmxCUVZrc1JVRkJSU3hIUVVGSExFTkJRM1JETEVOQlFVTTdVVUZEU2l4RFFVRkRPMUZCUlVRN08xZEJSVWM3VVVGRFNDeHBRa0ZCYVVJc1JVRkJSU3hEUVVGSkxFZEJRWEZDTEVWQlFVVXNSVUZCUlR0WlFVTTVReXhQUVVGUExHMUNRVUZ0UWl4RFFVTjRRaXcwUWtGQlZTeERRVUZETEZGQlFWRXNRMEZCUXl4cFFrRkJhVUlzUlVGQlJTeEhRVUZITEVOQlF6TkRMRU5CUVVNN1VVRkRTaXhEUVVGRE8xRkJSVVE3TzFkQlJVYzdVVUZEU0N4TlFVRk5MRVZCUVVVc1EwRkJTU3hKUVVGMVFpeEZRVUZGTEVWQlFVVTdXVUZEY2tNc1NVRkJTU3hEUVVGRExFbEJRVWtzU1VGQlNTeFBRVUZQTEVsQlFVa3NTMEZCU3l4UlFVRlJMRWxCUVVrc1MwRkJTeXhEUVVGRExFOUJRVThzUTBGQlF5eEpRVUZKTEVOQlFVTXNSVUZCUlR0blFrRkROVVFzVFVGQlRTeEpRVUZKTEV0QlFVc3NRMEZCUXl4elJVRkJjMFVzUTBGQlF5eERRVUZETzJGQlEzcEdPMWxCUlVRc1RVRkJUU3hGUVVGRkxFbEJRVWtzUlVGQlJTeFBRVUZQTEVWQlFVVXNTVUZCU1N4RlFVRkZMRWRCUVVjc1NVRkJTU3hEUVVGRE8xbEJSWEpETEVsQlFVa3NRMEZCUXl4UFFVRlBMRWxCUVVrc1QwRkJUeXhQUVVGUExFdEJRVXNzVVVGQlVTeEZRVUZGTzJkQ1FVTXpReXhOUVVGTkxFbEJRVWtzUzBGQlN5eERRVU5pTEhGRFFVRnhReXhEUVVOMFF5eERRVUZETzJGQlEwZzdXVUZEUkN4UFFVRlBMRWxCUVVrc0swSkJRWEZDTEVOQlFVTXNTVUZCU1N4RlFVRkZMRTlCUVU4c1JVRkJSU3hKUVVGSkxFTkJRVU1zUTBGQlF6dFJRVU40UkN4RFFVRkRPMHRCUTBZN1EwRkRSaXhEUVVGRE8wRkJSVVlzVjBGQlZ6dEJRVVZZTEZOQlFWTXNhMEpCUVd0Q0xFTkJRVWtzU1VGQldTeEZRVUZGTEVkQlFYRkNPMGxCUTJoRkxFMUJRVTBzUTBGQlF5eFBRVUZQTEVWQlFVVXNTVUZCU1N4RFFVRkRMRWRCUVVjc1UwRkJVeXhEUVVGRExFZEJRVWNzUTBGQlF5eERRVUZETzBsQlEzWkRMRTlCUVU4c1NVRkJTU3d3UWtGQlowSXNRMEZEZWtJc1NVRkJTU3hGUVVOS0xFOUJRVThzU1VGQlNTd3dRa0ZCYTBJc1EwRkJReXhKUVVGSkxFTkJRVU1zUlVGRGJrTXNTVUZCU1N4RFFVTk1MRU5CUVVNN1FVRkRTaXhEUVVGRE8wRkJSVVFzVTBGQlV5eHRRa0ZCYlVJc1EwRkJTU3hKUVVGWkxFVkJRVVVzUjBGQmNVSTdTVUZEYWtVc1RVRkJUU3hEUVVGRExFOUJRVThzUlVGQlJTeEpRVUZKTEVOQlFVTXNSMEZCUnl4VFFVRlRMRU5CUVVNc1IwRkJSeXhEUVVGRExFTkJRVU03U1VGRGRrTXNUMEZCVHl4SlFVRkpMQ3RDUVVGeFFpeERRVU01UWl4SlFVRkpMRVZCUTBvc1QwRkJUeXhKUVVGSkxEQkNRVUZyUWl4RFFVRkRMRWxCUVVrc1EwRkJReXhGUVVOdVF5eEpRVUZKTEVOQlEwd3NRMEZCUXp0QlFVTktMRU5CUVVNN1FVRkZSQ3hUUVVGVExGTkJRVk1zUTBGQlNTeEhRVUZ4UWp0SlFVTjZReXhKUVVGSkxFZEJRVWNzUlVGQlJUdFJRVU5RTEVsQlFVa3NUMEZCVHl4SFFVRkhMRXRCUVVzc1VVRkJVU3hGUVVGRk8xbEJRek5DTEU5QlFVOHNRMEZCUXl4SFFVRkhMRU5CUVVNc1EwRkJRenRUUVVOa08yRkJRVTBzU1VGQlNTeFBRVUZQTEVkQlFVY3NTMEZCU3l4UlFVRlJMRWxCUVVrc1EwRkJReXhMUVVGTExFTkJRVU1zVDBGQlR5eERRVUZETEVkQlFVY3NRMEZCUXl4RlFVRkZPMWxCUTNwRUxFMUJRVTBzUlVGQlJTeFBRVUZQTEVWQlFVVXNTVUZCU1N4RlFVRkZMRWRCUVVjc1IwRkJSeXhEUVVGRE8xbEJSVGxDTEVsQlFVa3NUMEZCVHl4SlFVRkpMRTlCUVU4c1QwRkJUeXhMUVVGTExGRkJRVkVzUlVGQlJUdG5Ra0ZETVVNc1RVRkJUU3hKUVVGSkxFdEJRVXNzUTBGQlF5dzRRa0ZCT0VJc1EwRkJReXhEUVVGRE8yRkJRMnBFTzFsQlEwUXNUMEZCVHl4RFFVRkRMRTlCUVU4c1NVRkJTU3hUUVVGVExFVkJRVVVzU1VGQlNTeERRVUZETEVOQlFVTTdVMEZEY2tNN1MwRkRSanRKUVVORUxFOUJRVThzUlVGQlJTeERRVUZETzBGQlExb3NRMEZCUXlKOSIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRNZXNzYWdlRnJvbUNvZGUgPSBleHBvcnRzLnNlcmlhbGl6ZUVycm9yID0gZXhwb3J0cy5FdGhlcmV1bVByb3ZpZGVyRXJyb3IgPSBleHBvcnRzLkV0aGVyZXVtUnBjRXJyb3IgPSBleHBvcnRzLmV0aEVycm9ycyA9IGV4cG9ydHMuZXJyb3JDb2RlcyA9IHZvaWQgMDtcbmNvbnN0IGNsYXNzZXNfMSA9IHJlcXVpcmUoXCIuL2NsYXNzZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJFdGhlcmV1bVJwY0Vycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGFzc2VzXzEuRXRoZXJldW1ScGNFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkV0aGVyZXVtUHJvdmlkZXJFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY2xhc3Nlc18xLkV0aGVyZXVtUHJvdmlkZXJFcnJvcjsgfSB9KTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNlcmlhbGl6ZUVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLnNlcmlhbGl6ZUVycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0TWVzc2FnZUZyb21Db2RlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1dGlsc18xLmdldE1lc3NhZ2VGcm9tQ29kZTsgfSB9KTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZXRoRXJyb3JzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfMS5ldGhFcnJvcnM7IH0gfSk7XG5jb25zdCBlcnJvcl9jb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yLWNvbnN0YW50c1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImVycm9yQ29kZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yX2NvbnN0YW50c18xLmVycm9yQ29kZXM7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0ptYVd4bElqb2lhVzVrWlhndWFuTWlMQ0p6YjNWeVkyVlNiMjkwSWpvaUlpd2ljMjkxY21ObGN5STZXeUl1TGk5emNtTXZhVzVrWlhndWRITWlYU3dpYm1GdFpYTWlPbHRkTENKdFlYQndhVzVuY3lJNklqczdPMEZCUVVFc2RVTkJRVzlGTzBGQlZXeEZMR2xIUVZaUExEQkNRVUZuUWl4UFFWVlFPMEZCUTJoQ0xITkhRVmg1UWl3clFrRkJjVUlzVDBGWGVrSTdRVUZXZGtJc2JVTkJSV2xDTzBGQlUyWXNLMFpCVmtFc2MwSkJRV01zVDBGVlFUdEJRVU5rTEcxSFFWaG5RaXd3UWtGQmEwSXNUMEZYYUVJN1FVRlVjRUlzY1VOQlFYRkRPMEZCUzI1RExEQkdRVXhQTEd0Q1FVRlRMRTlCUzFBN1FVRktXQ3gxUkVGQkswTTdRVUZITjBNc01rWkJTRThzTkVKQlFWVXNUMEZIVUNKOSIsIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQoKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuYm93c2VyPXQoKTplLmJvd3Nlcj10KCl9KHRoaXMsKGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PXt9O2Z1bmN0aW9uIHIobil7aWYodFtuXSlyZXR1cm4gdFtuXS5leHBvcnRzO3ZhciBpPXRbbl09e2k6bixsOiExLGV4cG9ydHM6e319O3JldHVybiBlW25dLmNhbGwoaS5leHBvcnRzLGksaS5leHBvcnRzLHIpLGkubD0hMCxpLmV4cG9ydHN9cmV0dXJuIHIubT1lLHIuYz10LHIuZD1mdW5jdGlvbihlLHQsbil7ci5vKGUsdCl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse2VudW1lcmFibGU6ITAsZ2V0Om59KX0sci5yPWZ1bmN0aW9uKGUpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LHIudD1mdW5jdGlvbihlLHQpe2lmKDEmdCYmKGU9cihlKSksOCZ0KXJldHVybiBlO2lmKDQmdCYmXCJvYmplY3RcIj09dHlwZW9mIGUmJmUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgbj1PYmplY3QuY3JlYXRlKG51bGwpO2lmKHIucihuKSxPYmplY3QuZGVmaW5lUHJvcGVydHkobixcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTplfSksMiZ0JiZcInN0cmluZ1wiIT10eXBlb2YgZSlmb3IodmFyIGkgaW4gZSlyLmQobixpLGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdfS5iaW5kKG51bGwsaSkpO3JldHVybiBufSxyLm49ZnVuY3Rpb24oZSl7dmFyIHQ9ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIHIuZCh0LFwiYVwiLHQpLHR9LHIubz1mdW5jdGlvbihlLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KX0sci5wPVwiXCIscihyLnM9OTApfSh7MTc6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuPXIoMTgpLGk9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7fXJldHVybiBlLmdldEZpcnN0TWF0Y2g9ZnVuY3Rpb24oZSx0KXt2YXIgcj10Lm1hdGNoKGUpO3JldHVybiByJiZyLmxlbmd0aD4wJiZyWzFdfHxcIlwifSxlLmdldFNlY29uZE1hdGNoPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dC5tYXRjaChlKTtyZXR1cm4gciYmci5sZW5ndGg+MSYmclsyXXx8XCJcIn0sZS5tYXRjaEFuZFJldHVybkNvbnN0PWZ1bmN0aW9uKGUsdCxyKXtpZihlLnRlc3QodCkpcmV0dXJuIHJ9LGUuZ2V0V2luZG93c1ZlcnNpb25OYW1lPWZ1bmN0aW9uKGUpe3N3aXRjaChlKXtjYXNlXCJOVFwiOnJldHVyblwiTlRcIjtjYXNlXCJYUFwiOnJldHVyblwiWFBcIjtjYXNlXCJOVCA1LjBcIjpyZXR1cm5cIjIwMDBcIjtjYXNlXCJOVCA1LjFcIjpyZXR1cm5cIlhQXCI7Y2FzZVwiTlQgNS4yXCI6cmV0dXJuXCIyMDAzXCI7Y2FzZVwiTlQgNi4wXCI6cmV0dXJuXCJWaXN0YVwiO2Nhc2VcIk5UIDYuMVwiOnJldHVyblwiN1wiO2Nhc2VcIk5UIDYuMlwiOnJldHVyblwiOFwiO2Nhc2VcIk5UIDYuM1wiOnJldHVyblwiOC4xXCI7Y2FzZVwiTlQgMTAuMFwiOnJldHVyblwiMTBcIjtkZWZhdWx0OnJldHVybn19LGUuZ2V0TWFjT1NWZXJzaW9uTmFtZT1mdW5jdGlvbihlKXt2YXIgdD1lLnNwbGl0KFwiLlwiKS5zcGxpY2UoMCwyKS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBwYXJzZUludChlLDEwKXx8MH0pKTtpZih0LnB1c2goMCksMTA9PT10WzBdKXN3aXRjaCh0WzFdKXtjYXNlIDU6cmV0dXJuXCJMZW9wYXJkXCI7Y2FzZSA2OnJldHVyblwiU25vdyBMZW9wYXJkXCI7Y2FzZSA3OnJldHVyblwiTGlvblwiO2Nhc2UgODpyZXR1cm5cIk1vdW50YWluIExpb25cIjtjYXNlIDk6cmV0dXJuXCJNYXZlcmlja3NcIjtjYXNlIDEwOnJldHVyblwiWW9zZW1pdGVcIjtjYXNlIDExOnJldHVyblwiRWwgQ2FwaXRhblwiO2Nhc2UgMTI6cmV0dXJuXCJTaWVycmFcIjtjYXNlIDEzOnJldHVyblwiSGlnaCBTaWVycmFcIjtjYXNlIDE0OnJldHVyblwiTW9qYXZlXCI7Y2FzZSAxNTpyZXR1cm5cIkNhdGFsaW5hXCI7ZGVmYXVsdDpyZXR1cm59fSxlLmdldEFuZHJvaWRWZXJzaW9uTmFtZT1mdW5jdGlvbihlKXt2YXIgdD1lLnNwbGl0KFwiLlwiKS5zcGxpY2UoMCwyKS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBwYXJzZUludChlLDEwKXx8MH0pKTtpZih0LnB1c2goMCksISgxPT09dFswXSYmdFsxXTw1KSlyZXR1cm4gMT09PXRbMF0mJnRbMV08Nj9cIkN1cGNha2VcIjoxPT09dFswXSYmdFsxXT49Nj9cIkRvbnV0XCI6Mj09PXRbMF0mJnRbMV08Mj9cIkVjbGFpclwiOjI9PT10WzBdJiYyPT09dFsxXT9cIkZyb3lvXCI6Mj09PXRbMF0mJnRbMV0+Mj9cIkdpbmdlcmJyZWFkXCI6Mz09PXRbMF0/XCJIb25leWNvbWJcIjo0PT09dFswXSYmdFsxXTwxP1wiSWNlIENyZWFtIFNhbmR3aWNoXCI6ND09PXRbMF0mJnRbMV08ND9cIkplbGx5IEJlYW5cIjo0PT09dFswXSYmdFsxXT49ND9cIktpdEthdFwiOjU9PT10WzBdP1wiTG9sbGlwb3BcIjo2PT09dFswXT9cIk1hcnNobWFsbG93XCI6Nz09PXRbMF0/XCJOb3VnYXRcIjo4PT09dFswXT9cIk9yZW9cIjo5PT09dFswXT9cIlBpZVwiOnZvaWQgMH0sZS5nZXRWZXJzaW9uUHJlY2lzaW9uPWZ1bmN0aW9uKGUpe3JldHVybiBlLnNwbGl0KFwiLlwiKS5sZW5ndGh9LGUuY29tcGFyZVZlcnNpb25zPWZ1bmN0aW9uKHQscixuKXt2b2lkIDA9PT1uJiYobj0hMSk7dmFyIGk9ZS5nZXRWZXJzaW9uUHJlY2lzaW9uKHQpLHM9ZS5nZXRWZXJzaW9uUHJlY2lzaW9uKHIpLGE9TWF0aC5tYXgoaSxzKSxvPTAsdT1lLm1hcChbdCxyXSwoZnVuY3Rpb24odCl7dmFyIHI9YS1lLmdldFZlcnNpb25QcmVjaXNpb24odCksbj10K25ldyBBcnJheShyKzEpLmpvaW4oXCIuMFwiKTtyZXR1cm4gZS5tYXAobi5zcGxpdChcIi5cIiksKGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgQXJyYXkoMjAtZS5sZW5ndGgpLmpvaW4oXCIwXCIpK2V9KSkucmV2ZXJzZSgpfSkpO2ZvcihuJiYobz1hLU1hdGgubWluKGkscykpLGEtPTE7YT49bzspe2lmKHVbMF1bYV0+dVsxXVthXSlyZXR1cm4gMTtpZih1WzBdW2FdPT09dVsxXVthXSl7aWYoYT09PW8pcmV0dXJuIDA7YS09MX1lbHNlIGlmKHVbMF1bYV08dVsxXVthXSlyZXR1cm4tMX19LGUubWFwPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbj1bXTtpZihBcnJheS5wcm90b3R5cGUubWFwKXJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoZSx0KTtmb3Iocj0wO3I8ZS5sZW5ndGg7cis9MSluLnB1c2godChlW3JdKSk7cmV0dXJuIG59LGUuZmluZD1mdW5jdGlvbihlLHQpe3ZhciByLG47aWYoQXJyYXkucHJvdG90eXBlLmZpbmQpcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maW5kLmNhbGwoZSx0KTtmb3Iocj0wLG49ZS5sZW5ndGg7cjxuO3IrPTEpe3ZhciBpPWVbcl07aWYodChpLHIpKXJldHVybiBpfX0sZS5hc3NpZ249ZnVuY3Rpb24oZSl7Zm9yKHZhciB0LHIsbj1lLGk9YXJndW1lbnRzLmxlbmd0aCxzPW5ldyBBcnJheShpPjE/aS0xOjApLGE9MTthPGk7YSsrKXNbYS0xXT1hcmd1bWVudHNbYV07aWYoT2JqZWN0LmFzc2lnbilyZXR1cm4gT2JqZWN0LmFzc2lnbi5hcHBseShPYmplY3QsW2VdLmNvbmNhdChzKSk7dmFyIG89ZnVuY3Rpb24oKXt2YXIgZT1zW3RdO1wib2JqZWN0XCI9PXR5cGVvZiBlJiZudWxsIT09ZSYmT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7blt0XT1lW3RdfSkpfTtmb3IodD0wLHI9cy5sZW5ndGg7dDxyO3QrPTEpbygpO3JldHVybiBlfSxlLmdldEJyb3dzZXJBbGlhcz1mdW5jdGlvbihlKXtyZXR1cm4gbi5CUk9XU0VSX0FMSUFTRVNfTUFQW2VdfSxlLmdldEJyb3dzZXJUeXBlQnlBbGlhcz1mdW5jdGlvbihlKXtyZXR1cm4gbi5CUk9XU0VSX01BUFtlXXx8XCJcIn0sZX0oKTt0LmRlZmF1bHQ9aSxlLmV4cG9ydHM9dC5kZWZhdWx0fSwxODpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwLHQuRU5HSU5FX01BUD10Lk9TX01BUD10LlBMQVRGT1JNU19NQVA9dC5CUk9XU0VSX01BUD10LkJST1dTRVJfQUxJQVNFU19NQVA9dm9pZCAwO3QuQlJPV1NFUl9BTElBU0VTX01BUD17XCJBbWF6b24gU2lsa1wiOlwiYW1hem9uX3NpbGtcIixcIkFuZHJvaWQgQnJvd3NlclwiOlwiYW5kcm9pZFwiLEJhZGE6XCJiYWRhXCIsQmxhY2tCZXJyeTpcImJsYWNrYmVycnlcIixDaHJvbWU6XCJjaHJvbWVcIixDaHJvbWl1bTpcImNocm9taXVtXCIsRWxlY3Ryb246XCJlbGVjdHJvblwiLEVwaXBoYW55OlwiZXBpcGhhbnlcIixGaXJlZm94OlwiZmlyZWZveFwiLEZvY3VzOlwiZm9jdXNcIixHZW5lcmljOlwiZ2VuZXJpY1wiLFwiR29vZ2xlIFNlYXJjaFwiOlwiZ29vZ2xlX3NlYXJjaFwiLEdvb2dsZWJvdDpcImdvb2dsZWJvdFwiLFwiSW50ZXJuZXQgRXhwbG9yZXJcIjpcImllXCIsXCJLLU1lbGVvblwiOlwia19tZWxlb25cIixNYXh0aG9uOlwibWF4dGhvblwiLFwiTWljcm9zb2Z0IEVkZ2VcIjpcImVkZ2VcIixcIk1aIEJyb3dzZXJcIjpcIm16XCIsXCJOQVZFUiBXaGFsZSBCcm93c2VyXCI6XCJuYXZlclwiLE9wZXJhOlwib3BlcmFcIixcIk9wZXJhIENvYXN0XCI6XCJvcGVyYV9jb2FzdFwiLFBoYW50b21KUzpcInBoYW50b21qc1wiLFB1ZmZpbjpcInB1ZmZpblwiLFF1cFppbGxhOlwicXVwemlsbGFcIixRUTpcInFxXCIsUVFMaXRlOlwicXFsaXRlXCIsU2FmYXJpOlwic2FmYXJpXCIsU2FpbGZpc2g6XCJzYWlsZmlzaFwiLFwiU2Ftc3VuZyBJbnRlcm5ldCBmb3IgQW5kcm9pZFwiOlwic2Ftc3VuZ19pbnRlcm5ldFwiLFNlYU1vbmtleTpcInNlYW1vbmtleVwiLFNsZWlwbmlyOlwic2xlaXBuaXJcIixTd2luZzpcInN3aW5nXCIsVGl6ZW46XCJ0aXplblwiLFwiVUMgQnJvd3NlclwiOlwidWNcIixWaXZhbGRpOlwidml2YWxkaVwiLFwiV2ViT1MgQnJvd3NlclwiOlwid2Vib3NcIixXZUNoYXQ6XCJ3ZWNoYXRcIixcIllhbmRleCBCcm93c2VyXCI6XCJ5YW5kZXhcIixSb2t1Olwicm9rdVwifTt0LkJST1dTRVJfTUFQPXthbWF6b25fc2lsazpcIkFtYXpvbiBTaWxrXCIsYW5kcm9pZDpcIkFuZHJvaWQgQnJvd3NlclwiLGJhZGE6XCJCYWRhXCIsYmxhY2tiZXJyeTpcIkJsYWNrQmVycnlcIixjaHJvbWU6XCJDaHJvbWVcIixjaHJvbWl1bTpcIkNocm9taXVtXCIsZWxlY3Ryb246XCJFbGVjdHJvblwiLGVwaXBoYW55OlwiRXBpcGhhbnlcIixmaXJlZm94OlwiRmlyZWZveFwiLGZvY3VzOlwiRm9jdXNcIixnZW5lcmljOlwiR2VuZXJpY1wiLGdvb2dsZWJvdDpcIkdvb2dsZWJvdFwiLGdvb2dsZV9zZWFyY2g6XCJHb29nbGUgU2VhcmNoXCIsaWU6XCJJbnRlcm5ldCBFeHBsb3JlclwiLGtfbWVsZW9uOlwiSy1NZWxlb25cIixtYXh0aG9uOlwiTWF4dGhvblwiLGVkZ2U6XCJNaWNyb3NvZnQgRWRnZVwiLG16OlwiTVogQnJvd3NlclwiLG5hdmVyOlwiTkFWRVIgV2hhbGUgQnJvd3NlclwiLG9wZXJhOlwiT3BlcmFcIixvcGVyYV9jb2FzdDpcIk9wZXJhIENvYXN0XCIscGhhbnRvbWpzOlwiUGhhbnRvbUpTXCIscHVmZmluOlwiUHVmZmluXCIscXVwemlsbGE6XCJRdXBaaWxsYVwiLHFxOlwiUVEgQnJvd3NlclwiLHFxbGl0ZTpcIlFRIEJyb3dzZXIgTGl0ZVwiLHNhZmFyaTpcIlNhZmFyaVwiLHNhaWxmaXNoOlwiU2FpbGZpc2hcIixzYW1zdW5nX2ludGVybmV0OlwiU2Ftc3VuZyBJbnRlcm5ldCBmb3IgQW5kcm9pZFwiLHNlYW1vbmtleTpcIlNlYU1vbmtleVwiLHNsZWlwbmlyOlwiU2xlaXBuaXJcIixzd2luZzpcIlN3aW5nXCIsdGl6ZW46XCJUaXplblwiLHVjOlwiVUMgQnJvd3NlclwiLHZpdmFsZGk6XCJWaXZhbGRpXCIsd2Vib3M6XCJXZWJPUyBCcm93c2VyXCIsd2VjaGF0OlwiV2VDaGF0XCIseWFuZGV4OlwiWWFuZGV4IEJyb3dzZXJcIn07dC5QTEFURk9STVNfTUFQPXt0YWJsZXQ6XCJ0YWJsZXRcIixtb2JpbGU6XCJtb2JpbGVcIixkZXNrdG9wOlwiZGVza3RvcFwiLHR2OlwidHZcIn07dC5PU19NQVA9e1dpbmRvd3NQaG9uZTpcIldpbmRvd3MgUGhvbmVcIixXaW5kb3dzOlwiV2luZG93c1wiLE1hY09TOlwibWFjT1NcIixpT1M6XCJpT1NcIixBbmRyb2lkOlwiQW5kcm9pZFwiLFdlYk9TOlwiV2ViT1NcIixCbGFja0JlcnJ5OlwiQmxhY2tCZXJyeVwiLEJhZGE6XCJCYWRhXCIsVGl6ZW46XCJUaXplblwiLExpbnV4OlwiTGludXhcIixDaHJvbWVPUzpcIkNocm9tZSBPU1wiLFBsYXlTdGF0aW9uNDpcIlBsYXlTdGF0aW9uIDRcIixSb2t1OlwiUm9rdVwifTt0LkVOR0lORV9NQVA9e0VkZ2VIVE1MOlwiRWRnZUhUTUxcIixCbGluazpcIkJsaW5rXCIsVHJpZGVudDpcIlRyaWRlbnRcIixQcmVzdG86XCJQcmVzdG9cIixHZWNrbzpcIkdlY2tvXCIsV2ViS2l0OlwiV2ViS2l0XCJ9fSw5MDpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwLHQuZGVmYXVsdD12b2lkIDA7dmFyIG4saT0obj1yKDkxKSkmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59LHM9cigxOCk7ZnVuY3Rpb24gYShlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX19dmFyIG89ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKCl7fXZhciB0LHIsbjtyZXR1cm4gZS5nZXRQYXJzZXI9ZnVuY3Rpb24oZSx0KXtpZih2b2lkIDA9PT10JiYodD0hMSksXCJzdHJpbmdcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwiVXNlckFnZW50IHNob3VsZCBiZSBhIHN0cmluZ1wiKTtyZXR1cm4gbmV3IGkuZGVmYXVsdChlLHQpfSxlLnBhcnNlPWZ1bmN0aW9uKGUpe3JldHVybiBuZXcgaS5kZWZhdWx0KGUpLmdldFJlc3VsdCgpfSx0PWUsbj1be2tleTpcIkJST1dTRVJfTUFQXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuQlJPV1NFUl9NQVB9fSx7a2V5OlwiRU5HSU5FX01BUFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBzLkVOR0lORV9NQVB9fSx7a2V5OlwiT1NfTUFQXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuT1NfTUFQfX0se2tleTpcIlBMQVRGT1JNU19NQVBcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5QTEFURk9STVNfTUFQfX1dLChyPW51bGwpJiZhKHQucHJvdG90eXBlLHIpLG4mJmEodCxuKSxlfSgpO3QuZGVmYXVsdD1vLGUuZXhwb3J0cz10LmRlZmF1bHR9LDkxOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgbj11KHIoOTIpKSxpPXUocig5MykpLHM9dShyKDk0KSksYT11KHIoOTUpKSxvPXUocigxNykpO2Z1bmN0aW9uIHUoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fXZhciBkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlLHQpe2lmKHZvaWQgMD09PXQmJih0PSExKSxudWxsPT1lfHxcIlwiPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJVc2VyQWdlbnQgcGFyYW1ldGVyIGNhbid0IGJlIGVtcHR5XCIpO3RoaXMuX3VhPWUsdGhpcy5wYXJzZWRSZXN1bHQ9e30sITAhPT10JiZ0aGlzLnBhcnNlKCl9dmFyIHQ9ZS5wcm90b3R5cGU7cmV0dXJuIHQuZ2V0VUE9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdWF9LHQudGVzdD1mdW5jdGlvbihlKXtyZXR1cm4gZS50ZXN0KHRoaXMuX3VhKX0sdC5wYXJzZUJyb3dzZXI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMucGFyc2VkUmVzdWx0LmJyb3dzZXI9e307dmFyIHQ9by5kZWZhdWx0LmZpbmQobi5kZWZhdWx0LChmdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnRlc3QpcmV0dXJuIHQudGVzdChlKTtpZih0LnRlc3QgaW5zdGFuY2VvZiBBcnJheSlyZXR1cm4gdC50ZXN0LnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiBlLnRlc3QodCl9KSk7dGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlcidzIHRlc3QgZnVuY3Rpb24gaXMgbm90IHZhbGlkXCIpfSkpO3JldHVybiB0JiYodGhpcy5wYXJzZWRSZXN1bHQuYnJvd3Nlcj10LmRlc2NyaWJlKHRoaXMuZ2V0VUEoKSkpLHRoaXMucGFyc2VkUmVzdWx0LmJyb3dzZXJ9LHQuZ2V0QnJvd3Nlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcnNlZFJlc3VsdC5icm93c2VyP3RoaXMucGFyc2VkUmVzdWx0LmJyb3dzZXI6dGhpcy5wYXJzZUJyb3dzZXIoKX0sdC5nZXRCcm93c2VyTmFtZT1mdW5jdGlvbihlKXtyZXR1cm4gZT9TdHJpbmcodGhpcy5nZXRCcm93c2VyKCkubmFtZSkudG9Mb3dlckNhc2UoKXx8XCJcIjp0aGlzLmdldEJyb3dzZXIoKS5uYW1lfHxcIlwifSx0LmdldEJyb3dzZXJWZXJzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0QnJvd3NlcigpLnZlcnNpb259LHQuZ2V0T1M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJzZWRSZXN1bHQub3M/dGhpcy5wYXJzZWRSZXN1bHQub3M6dGhpcy5wYXJzZU9TKCl9LHQucGFyc2VPUz1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5wYXJzZWRSZXN1bHQub3M9e307dmFyIHQ9by5kZWZhdWx0LmZpbmQoaS5kZWZhdWx0LChmdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnRlc3QpcmV0dXJuIHQudGVzdChlKTtpZih0LnRlc3QgaW5zdGFuY2VvZiBBcnJheSlyZXR1cm4gdC50ZXN0LnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiBlLnRlc3QodCl9KSk7dGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlcidzIHRlc3QgZnVuY3Rpb24gaXMgbm90IHZhbGlkXCIpfSkpO3JldHVybiB0JiYodGhpcy5wYXJzZWRSZXN1bHQub3M9dC5kZXNjcmliZSh0aGlzLmdldFVBKCkpKSx0aGlzLnBhcnNlZFJlc3VsdC5vc30sdC5nZXRPU05hbWU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5nZXRPUygpLm5hbWU7cmV0dXJuIGU/U3RyaW5nKHQpLnRvTG93ZXJDYXNlKCl8fFwiXCI6dHx8XCJcIn0sdC5nZXRPU1ZlcnNpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRPUygpLnZlcnNpb259LHQuZ2V0UGxhdGZvcm09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJzZWRSZXN1bHQucGxhdGZvcm0/dGhpcy5wYXJzZWRSZXN1bHQucGxhdGZvcm06dGhpcy5wYXJzZVBsYXRmb3JtKCl9LHQuZ2V0UGxhdGZvcm1UeXBlPWZ1bmN0aW9uKGUpe3ZvaWQgMD09PWUmJihlPSExKTt2YXIgdD10aGlzLmdldFBsYXRmb3JtKCkudHlwZTtyZXR1cm4gZT9TdHJpbmcodCkudG9Mb3dlckNhc2UoKXx8XCJcIjp0fHxcIlwifSx0LnBhcnNlUGxhdGZvcm09ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMucGFyc2VkUmVzdWx0LnBsYXRmb3JtPXt9O3ZhciB0PW8uZGVmYXVsdC5maW5kKHMuZGVmYXVsdCwoZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdC50ZXN0KXJldHVybiB0LnRlc3QoZSk7aWYodC50ZXN0IGluc3RhbmNlb2YgQXJyYXkpcmV0dXJuIHQudGVzdC5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gZS50ZXN0KHQpfSkpO3Rocm93IG5ldyBFcnJvcihcIkJyb3dzZXIncyB0ZXN0IGZ1bmN0aW9uIGlzIG5vdCB2YWxpZFwiKX0pKTtyZXR1cm4gdCYmKHRoaXMucGFyc2VkUmVzdWx0LnBsYXRmb3JtPXQuZGVzY3JpYmUodGhpcy5nZXRVQSgpKSksdGhpcy5wYXJzZWRSZXN1bHQucGxhdGZvcm19LHQuZ2V0RW5naW5lPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyc2VkUmVzdWx0LmVuZ2luZT90aGlzLnBhcnNlZFJlc3VsdC5lbmdpbmU6dGhpcy5wYXJzZUVuZ2luZSgpfSx0LmdldEVuZ2luZU5hbWU9ZnVuY3Rpb24oZSl7cmV0dXJuIGU/U3RyaW5nKHRoaXMuZ2V0RW5naW5lKCkubmFtZSkudG9Mb3dlckNhc2UoKXx8XCJcIjp0aGlzLmdldEVuZ2luZSgpLm5hbWV8fFwiXCJ9LHQucGFyc2VFbmdpbmU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMucGFyc2VkUmVzdWx0LmVuZ2luZT17fTt2YXIgdD1vLmRlZmF1bHQuZmluZChhLmRlZmF1bHQsKGZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQudGVzdClyZXR1cm4gdC50ZXN0KGUpO2lmKHQudGVzdCBpbnN0YW5jZW9mIEFycmF5KXJldHVybiB0LnRlc3Quc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIGUudGVzdCh0KX0pKTt0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyJ3MgdGVzdCBmdW5jdGlvbiBpcyBub3QgdmFsaWRcIil9KSk7cmV0dXJuIHQmJih0aGlzLnBhcnNlZFJlc3VsdC5lbmdpbmU9dC5kZXNjcmliZSh0aGlzLmdldFVBKCkpKSx0aGlzLnBhcnNlZFJlc3VsdC5lbmdpbmV9LHQucGFyc2U9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJzZUJyb3dzZXIoKSx0aGlzLnBhcnNlT1MoKSx0aGlzLnBhcnNlUGxhdGZvcm0oKSx0aGlzLnBhcnNlRW5naW5lKCksdGhpc30sdC5nZXRSZXN1bHQ9ZnVuY3Rpb24oKXtyZXR1cm4gby5kZWZhdWx0LmFzc2lnbih7fSx0aGlzLnBhcnNlZFJlc3VsdCl9LHQuc2F0aXNmaWVzPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMscj17fSxuPTAsaT17fSxzPTA7aWYoT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIGE9ZVt0XTtcInN0cmluZ1wiPT10eXBlb2YgYT8oaVt0XT1hLHMrPTEpOlwib2JqZWN0XCI9PXR5cGVvZiBhJiYoclt0XT1hLG4rPTEpfSkpLG4+MCl7dmFyIGE9T2JqZWN0LmtleXMociksdT1vLmRlZmF1bHQuZmluZChhLChmdW5jdGlvbihlKXtyZXR1cm4gdC5pc09TKGUpfSkpO2lmKHUpe3ZhciBkPXRoaXMuc2F0aXNmaWVzKHJbdV0pO2lmKHZvaWQgMCE9PWQpcmV0dXJuIGR9dmFyIGM9by5kZWZhdWx0LmZpbmQoYSwoZnVuY3Rpb24oZSl7cmV0dXJuIHQuaXNQbGF0Zm9ybShlKX0pKTtpZihjKXt2YXIgZj10aGlzLnNhdGlzZmllcyhyW2NdKTtpZih2b2lkIDAhPT1mKXJldHVybiBmfX1pZihzPjApe3ZhciBsPU9iamVjdC5rZXlzKGkpLGg9by5kZWZhdWx0LmZpbmQobCwoZnVuY3Rpb24oZSl7cmV0dXJuIHQuaXNCcm93c2VyKGUsITApfSkpO2lmKHZvaWQgMCE9PWgpcmV0dXJuIHRoaXMuY29tcGFyZVZlcnNpb24oaVtoXSl9fSx0LmlzQnJvd3Nlcj1mdW5jdGlvbihlLHQpe3ZvaWQgMD09PXQmJih0PSExKTt2YXIgcj10aGlzLmdldEJyb3dzZXJOYW1lKCkudG9Mb3dlckNhc2UoKSxuPWUudG9Mb3dlckNhc2UoKSxpPW8uZGVmYXVsdC5nZXRCcm93c2VyVHlwZUJ5QWxpYXMobik7cmV0dXJuIHQmJmkmJihuPWkudG9Mb3dlckNhc2UoKSksbj09PXJ9LHQuY29tcGFyZVZlcnNpb249ZnVuY3Rpb24oZSl7dmFyIHQ9WzBdLHI9ZSxuPSExLGk9dGhpcy5nZXRCcm93c2VyVmVyc2lvbigpO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBpKXJldHVyblwiPlwiPT09ZVswXXx8XCI8XCI9PT1lWzBdPyhyPWUuc3Vic3RyKDEpLFwiPVwiPT09ZVsxXT8obj0hMCxyPWUuc3Vic3RyKDIpKTp0PVtdLFwiPlwiPT09ZVswXT90LnB1c2goMSk6dC5wdXNoKC0xKSk6XCI9XCI9PT1lWzBdP3I9ZS5zdWJzdHIoMSk6XCJ+XCI9PT1lWzBdJiYobj0hMCxyPWUuc3Vic3RyKDEpKSx0LmluZGV4T2Yoby5kZWZhdWx0LmNvbXBhcmVWZXJzaW9ucyhpLHIsbikpPi0xfSx0LmlzT1M9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZ2V0T1NOYW1lKCEwKT09PVN0cmluZyhlKS50b0xvd2VyQ2FzZSgpfSx0LmlzUGxhdGZvcm09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZ2V0UGxhdGZvcm1UeXBlKCEwKT09PVN0cmluZyhlKS50b0xvd2VyQ2FzZSgpfSx0LmlzRW5naW5lPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmdldEVuZ2luZU5hbWUoITApPT09U3RyaW5nKGUpLnRvTG93ZXJDYXNlKCl9LHQuaXM9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdm9pZCAwPT09dCYmKHQ9ITEpLHRoaXMuaXNCcm93c2VyKGUsdCl8fHRoaXMuaXNPUyhlKXx8dGhpcy5pc1BsYXRmb3JtKGUpfSx0LnNvbWU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztyZXR1cm4gdm9pZCAwPT09ZSYmKGU9W10pLGUuc29tZSgoZnVuY3Rpb24oZSl7cmV0dXJuIHQuaXMoZSl9KSl9LGV9KCk7dC5kZWZhdWx0PWQsZS5leHBvcnRzPXQuZGVmYXVsdH0sOTI6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuLGk9KG49cigxNykpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufTt2YXIgcz0vdmVyc2lvblxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxhPVt7dGVzdDpbL2dvb2dsZWJvdC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkdvb2dsZWJvdFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9nb29nbGVib3RcXC8oXFxkKyhcXC5cXGQrKSkvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9vcGVyYS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk9wZXJhXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Om9wZXJhKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9vcHJcXC98b3Bpb3MvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJPcGVyYVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpvcHJ8b3Bpb3MpW1xccy9dKFxcUyspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvU2Ftc3VuZ0Jyb3dzZXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJTYW1zdW5nIEludGVybmV0IGZvciBBbmRyb2lkXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OlNhbXN1bmdCcm93c2VyKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9XaGFsZS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk5BVkVSIFdoYWxlIEJyb3dzZXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86d2hhbGUpW1xccy9dKFxcZCsoPzpcXC5cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvTVpCcm93c2VyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiTVogQnJvd3NlclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpNWkJyb3dzZXIpW1xccy9dKFxcZCsoPzpcXC5cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvZm9jdXMvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJGb2N1c1wifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpmb2N1cylbXFxzL10oXFxkKyg/OlxcLlxcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zd2luZy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlN3aW5nXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnN3aW5nKVtcXHMvXShcXGQrKD86XFwuXFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2NvYXN0L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiT3BlcmEgQ29hc3RcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86Y29hc3QpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL29wdFxcL1xcZCsoPzouP18/XFxkKykrL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiT3BlcmEgVG91Y2hcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86b3B0KVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy95YWJyb3dzZXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJZYW5kZXggQnJvd3NlclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzp5YWJyb3dzZXIpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3VjYnJvd3Nlci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlVDIEJyb3dzZXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86dWNicm93c2VyKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9NYXh0aG9ufG14aW9zL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiTWF4dGhvblwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpNYXh0aG9ufG14aW9zKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9lcGlwaGFueS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkVwaXBoYW55XCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmVwaXBoYW55KVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9wdWZmaW4vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJQdWZmaW5cIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86cHVmZmluKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zbGVpcG5pci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlNsZWlwbmlyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnNsZWlwbmlyKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9rLW1lbGVvbi9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkstTWVsZW9uXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmstbWVsZW9uKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9taWNyb21lc3Nlbmdlci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIldlQ2hhdFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzptaWNyb21lc3NlbmdlcilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvcXFicm93c2VyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOi9xcWJyb3dzZXJsaXRlL2kudGVzdChlKT9cIlFRIEJyb3dzZXIgTGl0ZVwiOlwiUVEgQnJvd3NlclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpxcWJyb3dzZXJsaXRlfHFxYnJvd3NlcilbL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvbXNpZXx0cmlkZW50L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiSW50ZXJuZXQgRXhwbG9yZXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86bXNpZSB8cnY6KShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9cXHNlZGdcXC8vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJNaWNyb3NvZnQgRWRnZVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9cXHNlZGdcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvZWRnKFtlYV18aW9zKS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk1pY3Jvc29mdCBFZGdlXCJ9LHI9aS5kZWZhdWx0LmdldFNlY29uZE1hdGNoKC9lZGcoW2VhXXxpb3MpXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3ZpdmFsZGkvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJWaXZhbGRpXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3ZpdmFsZGlcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvc2VhbW9ua2V5L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU2VhTW9ua2V5XCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3NlYW1vbmtleVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zYWlsZmlzaC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlNhaWxmaXNoXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3NhaWxmaXNoXFxzP2Jyb3dzZXJcXC8oXFxkKyhcXC5cXGQrKT8pL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvc2lsay9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkFtYXpvbiBTaWxrXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3NpbGtcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvcGhhbnRvbS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlBoYW50b21KU1wifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9waGFudG9tanNcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvc2xpbWVyanMvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJTbGltZXJKU1wifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9zbGltZXJqc1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9ibGFja2JlcnJ5fFxcYmJiXFxkKy9pLC9yaW1cXHN0YWJsZXQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJCbGFja0JlcnJ5XCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2JsYWNrYmVycnlbXFxkXStcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvKHdlYnxocHcpW28wXXMvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJXZWJPUyBCcm93c2VyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3coPzplYik/W28wXXNicm93c2VyXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2JhZGEvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJCYWRhXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2RvbGZpblxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy90aXplbi9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlRpemVuXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnRpemVuXFxzPyk/YnJvd3NlclxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9xdXB6aWxsYS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlF1cFppbGxhXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnF1cHppbGxhKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9maXJlZm94fGljZXdlYXNlbHxmeGlvcy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkZpcmVmb3hcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86ZmlyZWZveHxpY2V3ZWFzZWx8Znhpb3MpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2VsZWN0cm9uL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiRWxlY3Ryb25cIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86ZWxlY3Ryb24pXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL01pdWlCcm93c2VyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiTWl1aVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpNaXVpQnJvd3NlcilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvY2hyb21pdW0vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJDaHJvbWl1bVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpjaHJvbWl1bSlbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvY2hyb21lfGNyaW9zfGNybW8vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJDaHJvbWVcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86Y2hyb21lfGNyaW9zfGNybW8pXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL0dTQS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkdvb2dsZSBTZWFyY2hcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86R1NBKVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7dmFyIHQ9IWUudGVzdCgvbGlrZSBhbmRyb2lkL2kpLHI9ZS50ZXN0KC9hbmRyb2lkL2kpO3JldHVybiB0JiZyfSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkFuZHJvaWQgQnJvd3NlclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvcGxheXN0YXRpb24gNC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlBsYXlTdGF0aW9uIDRcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3NhZmFyaXxhcHBsZXdlYmtpdC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlNhZmFyaVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvLiovaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9LTEhPT1lLnNlYXJjaChcIlxcXFwoXCIpPy9eKC4qKVxcLyguKilbIFxcdF1cXCgoLiopLzovXiguKilcXC8oLiopIC87cmV0dXJue25hbWU6aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2godCxlKSx2ZXJzaW9uOmkuZGVmYXVsdC5nZXRTZWNvbmRNYXRjaCh0LGUpfX19XTt0LmRlZmF1bHQ9YSxlLmV4cG9ydHM9dC5kZWZhdWx0fSw5MzpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwLHQuZGVmYXVsdD12b2lkIDA7dmFyIG4saT0obj1yKDE3KSkmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59LHM9cigxOCk7dmFyIGE9W3t0ZXN0OlsvUm9rdVxcL0RWUC9dLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9Sb2t1XFwvRFZQLShcXGQrXFwuXFxkKykvaSxlKTtyZXR1cm57bmFtZTpzLk9TX01BUC5Sb2t1LHZlcnNpb246dH19fSx7dGVzdDpbL3dpbmRvd3MgcGhvbmUvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3dpbmRvd3MgcGhvbmUgKD86b3MpP1xccz8oXFxkKyhcXC5cXGQrKSopL2ksZSk7cmV0dXJue25hbWU6cy5PU19NQVAuV2luZG93c1Bob25lLHZlcnNpb246dH19fSx7dGVzdDpbL3dpbmRvd3MgL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9XaW5kb3dzICgoTlR8WFApKCBcXGRcXGQ/LlxcZCk/KS9pLGUpLHI9aS5kZWZhdWx0LmdldFdpbmRvd3NWZXJzaW9uTmFtZSh0KTtyZXR1cm57bmFtZTpzLk9TX01BUC5XaW5kb3dzLHZlcnNpb246dCx2ZXJzaW9uTmFtZTpyfX19LHt0ZXN0OlsvTWFjaW50b3NoKC4qPykgRnhpT1MoLio/KVxcLy9dLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOnMuT1NfTUFQLmlPU30scj1pLmRlZmF1bHQuZ2V0U2Vjb25kTWF0Y2goLyhWZXJzaW9uXFwvKShcXGRbXFxkLl0rKS8sZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvbWFjaW50b3NoL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9tYWMgb3MgeCAoXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSkucmVwbGFjZSgvW19cXHNdL2csXCIuXCIpLHI9aS5kZWZhdWx0LmdldE1hY09TVmVyc2lvbk5hbWUodCksbj17bmFtZTpzLk9TX01BUC5NYWNPUyx2ZXJzaW9uOnR9O3JldHVybiByJiYobi52ZXJzaW9uTmFtZT1yKSxufX0se3Rlc3Q6Wy8oaXBvZHxpcGhvbmV8aXBhZCkvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL29zIChcXGQrKFtfXFxzXVxcZCspKikgbGlrZSBtYWMgb3MgeC9pLGUpLnJlcGxhY2UoL1tfXFxzXS9nLFwiLlwiKTtyZXR1cm57bmFtZTpzLk9TX01BUC5pT1MsdmVyc2lvbjp0fX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3ZhciB0PSFlLnRlc3QoL2xpa2UgYW5kcm9pZC9pKSxyPWUudGVzdCgvYW5kcm9pZC9pKTtyZXR1cm4gdCYmcn0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2FuZHJvaWRbXFxzLy1dKFxcZCsoXFwuXFxkKykqKS9pLGUpLHI9aS5kZWZhdWx0LmdldEFuZHJvaWRWZXJzaW9uTmFtZSh0KSxuPXtuYW1lOnMuT1NfTUFQLkFuZHJvaWQsdmVyc2lvbjp0fTtyZXR1cm4gciYmKG4udmVyc2lvbk5hbWU9ciksbn19LHt0ZXN0OlsvKHdlYnxocHcpW28wXXMvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OndlYnxocHcpW28wXXNcXC8oXFxkKyhcXC5cXGQrKSopL2ksZSkscj17bmFtZTpzLk9TX01BUC5XZWJPU307cmV0dXJuIHQmJnQubGVuZ3RoJiYoci52ZXJzaW9uPXQpLHJ9fSx7dGVzdDpbL2JsYWNrYmVycnl8XFxiYmJcXGQrL2ksL3JpbVxcc3RhYmxldC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvcmltXFxzdGFibGV0XFxzb3NcXHMoXFxkKyhcXC5cXGQrKSopL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9ibGFja2JlcnJ5XFxkK1xcLyhcXGQrKFtfXFxzXVxcZCspKikvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL1xcYmJiKFxcZCspL2ksZSk7cmV0dXJue25hbWU6cy5PU19NQVAuQmxhY2tCZXJyeSx2ZXJzaW9uOnR9fX0se3Rlc3Q6Wy9iYWRhL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9iYWRhXFwvKFxcZCsoXFwuXFxkKykqKS9pLGUpO3JldHVybntuYW1lOnMuT1NfTUFQLkJhZGEsdmVyc2lvbjp0fX19LHt0ZXN0OlsvdGl6ZW4vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3RpemVuWy9cXHNdKFxcZCsoXFwuXFxkKykqKS9pLGUpO3JldHVybntuYW1lOnMuT1NfTUFQLlRpemVuLHZlcnNpb246dH19fSx7dGVzdDpbL2xpbnV4L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue25hbWU6cy5PU19NQVAuTGludXh9fX0se3Rlc3Q6Wy9Dck9TL10sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57bmFtZTpzLk9TX01BUC5DaHJvbWVPU319fSx7dGVzdDpbL1BsYXlTdGF0aW9uIDQvXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvUGxheVN0YXRpb24gNFsvXFxzXShcXGQrKFxcLlxcZCspKikvaSxlKTtyZXR1cm57bmFtZTpzLk9TX01BUC5QbGF5U3RhdGlvbjQsdmVyc2lvbjp0fX19XTt0LmRlZmF1bHQ9YSxlLmV4cG9ydHM9dC5kZWZhdWx0fSw5NDpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwLHQuZGVmYXVsdD12b2lkIDA7dmFyIG4saT0obj1yKDE3KSkmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59LHM9cigxOCk7dmFyIGE9W3t0ZXN0OlsvZ29vZ2xlYm90L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6XCJib3RcIix2ZW5kb3I6XCJHb29nbGVcIn19fSx7dGVzdDpbL2h1YXdlaS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKGNhbi1sMDEpL2ksZSkmJlwiTm92YVwiLHI9e3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZSx2ZW5kb3I6XCJIdWF3ZWlcIn07cmV0dXJuIHQmJihyLm1vZGVsPXQpLHJ9fSx7dGVzdDpbL25leHVzXFxzKig/Ojd8OHw5fDEwKS4qL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnRhYmxldCx2ZW5kb3I6XCJOZXh1c1wifX19LHt0ZXN0OlsvaXBhZC9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50YWJsZXQsdmVuZG9yOlwiQXBwbGVcIixtb2RlbDpcImlQYWRcIn19fSx7dGVzdDpbL01hY2ludG9zaCguKj8pIEZ4aU9TKC4qPylcXC8vXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50YWJsZXQsdmVuZG9yOlwiQXBwbGVcIixtb2RlbDpcImlQYWRcIn19fSx7dGVzdDpbL2tmdHQgYnVpbGQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0LHZlbmRvcjpcIkFtYXpvblwiLG1vZGVsOlwiS2luZGxlIEZpcmUgSEQgN1wifX19LHt0ZXN0Olsvc2lsay9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50YWJsZXQsdmVuZG9yOlwiQW1hem9uXCJ9fX0se3Rlc3Q6Wy90YWJsZXQoPyEgcGMpL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnRhYmxldH19fSx7dGVzdDpmdW5jdGlvbihlKXt2YXIgdD1lLnRlc3QoL2lwb2R8aXBob25lL2kpLHI9ZS50ZXN0KC9saWtlIChpcG9kfGlwaG9uZSkvaSk7cmV0dXJuIHQmJiFyfSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKGlwb2R8aXBob25lKS9pLGUpO3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGUsdmVuZG9yOlwiQXBwbGVcIixtb2RlbDp0fX19LHt0ZXN0OlsvbmV4dXNcXHMqWzAtNl0uKi9pLC9nYWxheHkgbmV4dXMvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlLHZlbmRvcjpcIk5leHVzXCJ9fX0se3Rlc3Q6Wy9bXi1dbW9iaS9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGV9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJibGFja2JlcnJ5XCI9PT1lLmdldEJyb3dzZXJOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlLHZlbmRvcjpcIkJsYWNrQmVycnlcIn19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cImJhZGFcIj09PWUuZ2V0QnJvd3Nlck5hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGV9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJ3aW5kb3dzIHBob25lXCI9PT1lLmdldEJyb3dzZXJOYW1lKCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZSx2ZW5kb3I6XCJNaWNyb3NvZnRcIn19fSx7dGVzdDpmdW5jdGlvbihlKXt2YXIgdD1OdW1iZXIoU3RyaW5nKGUuZ2V0T1NWZXJzaW9uKCkpLnNwbGl0KFwiLlwiKVswXSk7cmV0dXJuXCJhbmRyb2lkXCI9PT1lLmdldE9TTmFtZSghMCkmJnQ+PTN9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnRhYmxldH19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cImFuZHJvaWRcIj09PWUuZ2V0T1NOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlfX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwibWFjb3NcIj09PWUuZ2V0T1NOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAuZGVza3RvcCx2ZW5kb3I6XCJBcHBsZVwifX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwid2luZG93c1wiPT09ZS5nZXRPU05hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5kZXNrdG9wfX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwibGludXhcIj09PWUuZ2V0T1NOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAuZGVza3RvcH19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cInBsYXlzdGF0aW9uIDRcIj09PWUuZ2V0T1NOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudHZ9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJyb2t1XCI9PT1lLmdldE9TTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnR2fX19XTt0LmRlZmF1bHQ9YSxlLmV4cG9ydHM9dC5kZWZhdWx0fSw5NTpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwLHQuZGVmYXVsdD12b2lkIDA7dmFyIG4saT0obj1yKDE3KSkmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59LHM9cigxOCk7dmFyIGE9W3t0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwibWljcm9zb2Z0IGVkZ2VcIj09PWUuZ2V0QnJvd3Nlck5hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbihlKXtpZigvXFxzZWRnXFwvL2kudGVzdChlKSlyZXR1cm57bmFtZTpzLkVOR0lORV9NQVAuQmxpbmt9O3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9lZGdlXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybntuYW1lOnMuRU5HSU5FX01BUC5FZGdlSFRNTCx2ZXJzaW9uOnR9fX0se3Rlc3Q6Wy90cmlkZW50L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOnMuRU5HSU5FX01BUC5UcmlkZW50fSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC90cmlkZW50XFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm4gZS50ZXN0KC9wcmVzdG8vaSl9LGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOnMuRU5HSU5FX01BUC5QcmVzdG99LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3ByZXN0b1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS50ZXN0KC9nZWNrby9pKSxyPWUudGVzdCgvbGlrZSBnZWNrby9pKTtyZXR1cm4gdCYmIXJ9LGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOnMuRU5HSU5FX01BUC5HZWNrb30scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvZ2Vja29cXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvKGFwcGxlKT93ZWJraXRcXC81MzdcXC4zNi9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybntuYW1lOnMuRU5HSU5FX01BUC5CbGlua319fSx7dGVzdDpbLyhhcHBsZSk/d2Via2l0L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOnMuRU5HSU5FX01BUC5XZWJLaXR9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3dlYmtpdFxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX1dO3QuZGVmYXVsdD1hLGUuZXhwb3J0cz10LmRlZmF1bHR9fSl9KSk7IiwiaW1wb3J0IHtcbiAgQ29ubmVjdGlvblN0YXR1cyxcbiAgU2VydmljZVN0YXR1cyxcbn0gZnJvbSAnQG1ldGFtYXNrL3Nkay1jb21tdW5pY2F0aW9uLWxheWVyJztcbmltcG9ydCB7IFBST1ZJREVSX1VQREFURV9UWVBFIH0gZnJvbSAnLi9Qcm92aWRlclVwZGF0ZVR5cGUnO1xuXG5leHBvcnQgY29uc3QgTWV0YU1hc2tTREtFdmVudCA9IHtcbiAgSW5pdGlhbGl6ZWQ6ICdpbml0aWFsaXplZCcsXG4gIERpc3BsYXlVUkk6ICdkaXNwbGF5X3VyaScsXG4gIFByb3ZpZGVyVXBkYXRlOiAncHJvdmlkZXJfdXBkYXRlJyxcbiAgQ29ubmVjdFdpdGhSZXNwb25zZTogJ2Nvbm5lY3RXaXRoUmVzcG9uc2UnLFxuICBDb25uZWN0aW9uU3RhdHVzOiAnY29ubmVjdGlvbl9zdGF0dXMnLFxuICBTZXJ2aWNlU3RhdHVzOiAnc2VydmljZV9zdGF0dXMnLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IHR5cGUgTWV0YU1hc2tTREtFdmVudFR5cGUgPVxuICAodHlwZW9mIE1ldGFNYXNrU0RLRXZlbnQpW2tleW9mIHR5cGVvZiBNZXRhTWFza1NES0V2ZW50XTtcblxuZXhwb3J0IGludGVyZmFjZSBNZXRhTWFza1NES0V2ZW50cyB7XG4gIFtNZXRhTWFza1NES0V2ZW50LkluaXRpYWxpemVkXToge1xuICAgIGNoYWluSWQ6IHN0cmluZztcbiAgICBpc0Nvbm5lY3RlZDogYm9vbGVhbjtcbiAgICBpc01ldGFNYXNrOiBib29sZWFuO1xuICAgIHNlbGVjdGVkQWRkcmVzczogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgICBuZXR3b3JrVmVyc2lvbjogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgfTtcbiAgW01ldGFNYXNrU0RLRXZlbnQuRGlzcGxheVVSSV06IHN0cmluZztcbiAgW01ldGFNYXNrU0RLRXZlbnQuUHJvdmlkZXJVcGRhdGVdOiBQUk9WSURFUl9VUERBVEVfVFlQRTtcbiAgW01ldGFNYXNrU0RLRXZlbnQuQ29ubmVjdFdpdGhSZXNwb25zZV06IHVua25vd247XG4gIFtNZXRhTWFza1NES0V2ZW50LkNvbm5lY3Rpb25TdGF0dXNdOiBDb25uZWN0aW9uU3RhdHVzO1xuICBbTWV0YU1hc2tTREtFdmVudC5TZXJ2aWNlU3RhdHVzXTogU2VydmljZVN0YXR1cztcbn1cblxuZXhwb3J0IHR5cGUgTWV0YU1hc2tTREtFdmVudFBheWxvYWQ8VCBleHRlbmRzIE1ldGFNYXNrU0RLRXZlbnRUeXBlPiA9XG4gIFQgZXh0ZW5kcyBrZXlvZiBNZXRhTWFza1NES0V2ZW50cyA/IE1ldGFNYXNrU0RLRXZlbnRzW1RdIDogdW5rbm93bjtcbiIsImltcG9ydCB7IHNldEdsb2JhbFByb3ZpZGVyLCBzaGltV2ViMyB9IGZyb20gJ0BtZXRhbWFzay9wcm92aWRlcnMnO1xuaW1wb3J0IHsgRHVwbGV4IH0gZnJvbSAncmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7IFNES1Byb3ZpZGVyIH0gZnJvbSAnLi4vcHJvdmlkZXIvU0RLUHJvdmlkZXInO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IE1ldGFNYXNrU0RLIH0gZnJvbSAnLi4vc2RrJztcbmltcG9ydCB7IE1ldGFNYXNrU0RLRXZlbnQgfSBmcm9tICcuLi90eXBlcy9NZXRhTWFza1NES0V2ZW50cyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXRoZXJldW1Qcm9wcyB7XG4gIHNob3VsZFNldE9uV2luZG93OiBib29sZWFuO1xuICBjb25uZWN0aW9uU3RyZWFtOiBEdXBsZXg7XG4gIHNob3VsZFNlbmRNZXRhZGF0YT86IGJvb2xlYW47XG4gIHNob3VsZFNoaW1XZWIzOiBib29sZWFuO1xuICBzZGtJbnN0YW5jZTogTWV0YU1hc2tTREs7XG59XG5cbmV4cG9ydCBjbGFzcyBFdGhlcmV1bSB7XG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlPzogRXRoZXJldW07XG5cbiAgcHJpdmF0ZSBwcm92aWRlcjogU0RLUHJvdmlkZXI7XG5cbiAgcHJpdmF0ZSBzZGtJbnN0YW5jZTogTWV0YU1hc2tTREs7XG5cbiAgcHJpdmF0ZSBjb25zdHJ1Y3Rvcih7XG4gICAgc2hvdWxkU2V0T25XaW5kb3csXG4gICAgY29ubmVjdGlvblN0cmVhbSxcbiAgICBzaG91bGRTZW5kTWV0YWRhdGEgPSBmYWxzZSxcbiAgICBzaG91bGRTaGltV2ViMyxcbiAgICBzZGtJbnN0YW5jZSxcbiAgfTogRXRoZXJldW1Qcm9wcykge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IFNES1Byb3ZpZGVyKHtcbiAgICAgIGNvbm5lY3Rpb25TdHJlYW0sXG4gICAgICBzaG91bGRTZW5kTWV0YWRhdGEsXG4gICAgICBzaG91bGRTZXRPbldpbmRvdyxcbiAgICAgIHNob3VsZFNoaW1XZWIzLFxuICAgICAgYXV0b1JlcXVlc3RBY2NvdW50czogZmFsc2UsXG4gICAgfSk7XG5cbiAgICBjb25zdCBwcm94aWVkUHJvdmlkZXIgPSBuZXcgUHJveHkocHJvdmlkZXIsIHtcbiAgICAgIC8vIHNvbWUgY29tbW9uIGxpYnJhcmllcywgZS5nLiB3ZWIzQDEueCwgY2FuIGNvbmZsaWN0IHdpdGggb3VyIEFQSS5cbiAgICAgIGRlbGV0ZVByb3BlcnR5OiAoKSA9PiB0cnVlLFxuICAgIH0pO1xuXG4gICAgdGhpcy5wcm92aWRlciA9IHByb3hpZWRQcm92aWRlcjtcbiAgICB0aGlzLnNka0luc3RhbmNlID0gc2RrSW5zdGFuY2U7XG5cbiAgICAvLyBBZGQgdHJ5LWNhdGNoIGJsb2NrIGFyb3VuZCB3aW5kb3cgbW9kaWZpY2F0aW9uc1xuICAgIGlmIChzaG91bGRTZXRPbldpbmRvdyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0R2xvYmFsUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyKFxuICAgICAgICAgICdbRXRoZXJldW1dIFVuYWJsZSB0byBzZXQgZ2xvYmFsIHByb3ZpZGVyIC0gd2luZG93LmV0aGVyZXVtIG1heSBiZSByZWFkLW9ubHknLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICApO1xuICAgICAgICAvLyBDb250aW51ZSBleGVjdXRpb24gd2l0aG91dCB0aHJvd2luZ1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRTaGltV2ViMyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2hpbVdlYjModGhpcy5wcm92aWRlcik7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgJ1tFdGhlcmV1bV0gVW5hYmxlIHRvIHNoaW0gd2ViMyAtIHdpbmRvdy53ZWIzIG1heSBiZSByZWFkLW9ubHknLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICApO1xuICAgICAgICAvLyBDb250aW51ZSBleGVjdXRpb24gd2l0aG91dCB0aHJvd2luZ1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByb3BhZ2F0ZSBkaXNwbGF5X3VyaSBldmVudHMgdG8gdGhlIFNES1xuICAgIHRoaXMucHJvdmlkZXIub24oJ2Rpc3BsYXlfdXJpJywgKHVyaSkgPT4ge1xuICAgICAgdGhpcy5zZGtJbnN0YW5jZS5lbWl0KE1ldGFNYXNrU0RLRXZlbnQuRGlzcGxheVVSSSwgdXJpIGFzIHN0cmluZyk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnByb3ZpZGVyLm9uKCdfaW5pdGlhbGl6ZWQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICBjaGFpbklkOiB0aGlzLnByb3ZpZGVyLmdldENoYWluSWQoKSxcbiAgICAgICAgaXNDb25uZWN0ZWQ6IHRoaXMucHJvdmlkZXIuaXNDb25uZWN0ZWQoKSxcbiAgICAgICAgaXNNZXRhTWFzazogdGhpcy5wcm92aWRlci5pc01ldGFNYXNrLFxuICAgICAgICBzZWxlY3RlZEFkZHJlc3M6IHRoaXMucHJvdmlkZXIuZ2V0U2VsZWN0ZWRBZGRyZXNzKCksXG4gICAgICAgIG5ldHdvcmtWZXJzaW9uOiB0aGlzLnByb3ZpZGVyLmdldE5ldHdvcmtWZXJzaW9uKCksXG4gICAgICB9O1xuXG4gICAgICAvLyBBbHNvIGVtaXQgaW5pdGlhbGl6ZWQgZXZlbnQgb24gc2RrLlxuICAgICAgdGhpcy5zZGtJbnN0YW5jZS5lbWl0KE1ldGFNYXNrU0RLRXZlbnQuSW5pdGlhbGl6ZWQsIGluZm8pO1xuXG4gICAgICBsb2dnZXIoYFtFdGhlcmV1bTogY29uc3RydWN0b3IoKV0gcHJvdmlkZXIgaW5pdGlhbGl6ZWRgLCBpbmZvKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCB0byBpbml0aWFsaXplIGFuIEV0aGVyZXVtIHNlcnZpY2UuXG4gICAqXG4gICAqIEBwYXJhbSBwcm9wc1xuICAgKi9cbiAgc3RhdGljIGluaXQocHJvcHM6IEV0aGVyZXVtUHJvcHMpIHtcbiAgICBsb2dnZXIoYFtFdGhlcmV1bTogaW5pdCgpXSBJbml0aWFsaXppbmcgRXRoZXJldW0gc2VydmljZWApO1xuXG4gICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBFdGhlcmV1bShwcm9wcyk7XG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U/LnByb3ZpZGVyO1xuICB9XG5cbiAgc3RhdGljIGRlc3Ryb3koKSB7XG4gICAgLy8gRG8gbm90IHJlaW5pdGlhbGl6ZSB0byBpbnN0YW5jZSB0byBhdm9pZCB0aHJvd2luZyBvbiB0ZXJtaW5hdGVkLlxuICB9XG5cbiAgc3RhdGljIGdldEluc3RhbmNlKCkge1xuICAgIGlmICghdGhpcy5pbnN0YW5jZT8ucHJvdmlkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0V0aGVyZXVtIGluc3RhbmNlIG5vdCBpbnRpaWFsaXplZCAtIGNhbGwgRXRoZXJldW0uZmFjdG9yeSBmaXJzdC4nLFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gIH1cblxuICBzdGF0aWMgZ2V0UHJvdmlkZXIoKSB7XG4gICAgaWYgKCF0aGlzLmluc3RhbmNlPy5wcm92aWRlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnRXRoZXJldW0gaW5zdGFuY2Ugbm90IGludGlpYWxpemVkIC0gY2FsbCBFdGhlcmV1bS5mYWN0b3J5IGZpcnN0LicsXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlLnByb3ZpZGVyO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBzaGltV2ViM1xufSBmcm9tIFwiLi9jaHVuay1GMlo1Wk1IMy5tanNcIjtcbmltcG9ydCB7XG4gIGFubm91bmNlUHJvdmlkZXJcbn0gZnJvbSBcIi4vY2h1bmstWlVKWVgzN1AubWpzXCI7XG5pbXBvcnQge1xuICBNZXRhTWFza0lucGFnZVByb3ZpZGVyXG59IGZyb20gXCIuL2NodW5rLVVSTVNaTzdaLm1qc1wiO1xuXG4vLyBzcmMvaW5pdGlhbGl6ZUlucGFnZVByb3ZpZGVyLnRzXG5mdW5jdGlvbiBpbml0aWFsaXplUHJvdmlkZXIoe1xuICBjb25uZWN0aW9uU3RyZWFtLFxuICBqc29uUnBjU3RyZWFtTmFtZSxcbiAgbG9nZ2VyID0gY29uc29sZSxcbiAgbWF4RXZlbnRMaXN0ZW5lcnMgPSAxMDAsXG4gIHByb3ZpZGVySW5mbyxcbiAgc2hvdWxkU2VuZE1ldGFkYXRhID0gdHJ1ZSxcbiAgc2hvdWxkU2V0T25XaW5kb3cgPSB0cnVlLFxuICBzaG91bGRTaGltV2ViMyA9IGZhbHNlXG59KSB7XG4gIGNvbnN0IHByb3ZpZGVyID0gbmV3IE1ldGFNYXNrSW5wYWdlUHJvdmlkZXIoY29ubmVjdGlvblN0cmVhbSwge1xuICAgIGpzb25ScGNTdHJlYW1OYW1lLFxuICAgIGxvZ2dlcixcbiAgICBtYXhFdmVudExpc3RlbmVycyxcbiAgICBzaG91bGRTZW5kTWV0YWRhdGFcbiAgfSk7XG4gIGNvbnN0IHByb3hpZWRQcm92aWRlciA9IG5ldyBQcm94eShwcm92aWRlciwge1xuICAgIC8vIHNvbWUgY29tbW9uIGxpYnJhcmllcywgZS5nLiB3ZWIzQDEueCwgbWVzcyB3aXRoIG91ciBBUElcbiAgICBkZWxldGVQcm9wZXJ0eTogKCkgPT4gdHJ1ZSxcbiAgICAvLyBmaXggaXNzdWUgd2l0aCBQcm94eSB1bmFibGUgdG8gYWNjZXNzIHByaXZhdGUgdmFyaWFibGVzIGZyb20gZ2V0dGVyc1xuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MzA1MTQ4MlxuICAgIGdldCh0YXJnZXQsIHByb3BOYW1lKSB7XG4gICAgICByZXR1cm4gdGFyZ2V0W3Byb3BOYW1lXTtcbiAgICB9XG4gIH0pO1xuICBpZiAocHJvdmlkZXJJbmZvKSB7XG4gICAgYW5ub3VuY2VQcm92aWRlcih7XG4gICAgICBpbmZvOiBwcm92aWRlckluZm8sXG4gICAgICBwcm92aWRlcjogcHJveGllZFByb3ZpZGVyXG4gICAgfSk7XG4gIH1cbiAgaWYgKHNob3VsZFNldE9uV2luZG93KSB7XG4gICAgc2V0R2xvYmFsUHJvdmlkZXIocHJveGllZFByb3ZpZGVyKTtcbiAgfVxuICBpZiAoc2hvdWxkU2hpbVdlYjMpIHtcbiAgICBzaGltV2ViMyhwcm94aWVkUHJvdmlkZXIsIGxvZ2dlcik7XG4gIH1cbiAgcmV0dXJuIHByb3hpZWRQcm92aWRlcjtcbn1cbmZ1bmN0aW9uIHNldEdsb2JhbFByb3ZpZGVyKHByb3ZpZGVySW5zdGFuY2UpIHtcbiAgd2luZG93LmV0aGVyZXVtID0gcHJvdmlkZXJJbnN0YW5jZTtcbiAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwiZXRoZXJldW0jaW5pdGlhbGl6ZWRcIikpO1xufVxuXG5leHBvcnQge1xuICBpbml0aWFsaXplUHJvdmlkZXIsXG4gIHNldEdsb2JhbFByb3ZpZGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstTEYyS042WlQubWpzLm1hcCIsIi8vIHNyYy9zaGltV2ViMy50c1xuZnVuY3Rpb24gc2hpbVdlYjMocHJvdmlkZXIsIGxvZyA9IGNvbnNvbGUpIHtcbiAgbGV0IGxvZ2dlZEN1cnJlbnRQcm92aWRlciA9IGZhbHNlO1xuICBsZXQgbG9nZ2VkTWlzc2luZ1Byb3BlcnR5ID0gZmFsc2U7XG4gIGlmICghd2luZG93LndlYjMpIHtcbiAgICBjb25zdCBTSElNX0lERU5USUZJRVIgPSBcIl9faXNNZXRhTWFza1NoaW1fX1wiO1xuICAgIGxldCB3ZWIzU2hpbSA9IHsgY3VycmVudFByb3ZpZGVyOiBwcm92aWRlciB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3ZWIzU2hpbSwgU0hJTV9JREVOVElGSUVSLCB7XG4gICAgICB2YWx1ZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlXG4gICAgfSk7XG4gICAgd2ViM1NoaW0gPSBuZXcgUHJveHkod2ViM1NoaW0sIHtcbiAgICAgIGdldDogKHRhcmdldCwgcHJvcGVydHksIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKHByb3BlcnR5ID09PSBcImN1cnJlbnRQcm92aWRlclwiICYmICFsb2dnZWRDdXJyZW50UHJvdmlkZXIpIHtcbiAgICAgICAgICBsb2dnZWRDdXJyZW50UHJvdmlkZXIgPSB0cnVlO1xuICAgICAgICAgIGxvZy53YXJuKFxuICAgICAgICAgICAgXCJZb3UgYXJlIGFjY2Vzc2luZyB0aGUgTWV0YU1hc2sgd2luZG93LndlYjMuY3VycmVudFByb3ZpZGVyIHNoaW0uIFRoaXMgcHJvcGVydHkgaXMgZGVwcmVjYXRlZDsgdXNlIHdpbmRvdy5ldGhlcmV1bSBpbnN0ZWFkLiBGb3IgZGV0YWlscywgc2VlOiBodHRwczovL2RvY3MubWV0YW1hc2suaW8vZ3VpZGUvcHJvdmlkZXItbWlncmF0aW9uLmh0bWwjcmVwbGFjaW5nLXdpbmRvdy13ZWIzXCJcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnR5ICE9PSBcImN1cnJlbnRQcm92aWRlclwiICYmIHByb3BlcnR5ICE9PSBTSElNX0lERU5USUZJRVIgJiYgIWxvZ2dlZE1pc3NpbmdQcm9wZXJ0eSkge1xuICAgICAgICAgIGxvZ2dlZE1pc3NpbmdQcm9wZXJ0eSA9IHRydWU7XG4gICAgICAgICAgbG9nLmVycm9yKFxuICAgICAgICAgICAgYE1ldGFNYXNrIG5vIGxvbmdlciBpbmplY3RzIHdlYjMuIEZvciBkZXRhaWxzLCBzZWU6IGh0dHBzOi8vZG9jcy5tZXRhbWFzay5pby9ndWlkZS9wcm92aWRlci1taWdyYXRpb24uaHRtbCNyZXBsYWNpbmctd2luZG93LXdlYjNgXG4gICAgICAgICAgKTtcbiAgICAgICAgICBwcm92aWRlci5yZXF1ZXN0KHsgbWV0aG9kOiBcIm1ldGFtYXNrX2xvZ1dlYjNTaGltVXNhZ2VcIiB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIk1ldGFNYXNrOiBGYWlsZWQgdG8gbG9nIHdlYjMgc2hpbSB1c2FnZS5cIiwgZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3BlcnR5LCAuLi5hcmdzKTtcbiAgICAgIH0sXG4gICAgICBzZXQ6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGxvZy53YXJuKFxuICAgICAgICAgIFwiWW91IGFyZSBhY2Nlc3NpbmcgdGhlIE1ldGFNYXNrIHdpbmRvdy53ZWIzIHNoaW0uIFRoaXMgb2JqZWN0IGlzIGRlcHJlY2F0ZWQ7IHVzZSB3aW5kb3cuZXRoZXJldW0gaW5zdGVhZC4gRm9yIGRldGFpbHMsIHNlZTogaHR0cHM6Ly9kb2NzLm1ldGFtYXNrLmlvL2d1aWRlL3Byb3ZpZGVyLW1pZ3JhdGlvbi5odG1sI3JlcGxhY2luZy13aW5kb3ctd2ViM1wiXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBSZWZsZWN0LnNldCguLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LCBcIndlYjNcIiwge1xuICAgICAgdmFsdWU6IHdlYjNTaGltLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCB7XG4gIHNoaW1XZWIzXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstRjJaNVpNSDMubWpzLm1hcCIsImltcG9ydCB7IFBsYXRmb3JtVHlwZSB9IGZyb20gJ0BtZXRhbWFzay9zZGstY29tbXVuaWNhdGlvbi1sYXllcic7XG5pbXBvcnQgQm93c2VyIGZyb20gJ2Jvd3Nlcic7XG5pbXBvcnQgeyBnZXRQbGF0Zm9ybVR5cGUgfSBmcm9tICcuLi9zZXJ2aWNlcy9QbGF0ZmZvcm1NYW5hZ2VyL2dldFBsYXRmb3JtVHlwZSc7XG5pbXBvcnQgeyBpc01ldGFNYXNrSW5zdGFsbGVkIH0gZnJvbSAnLi4vc2VydmljZXMvUGxhdGZmb3JtTWFuYWdlci9pc01ldGFNYXNrSW5zdGFsbGVkJztcbmltcG9ydCB7IG9wZW5EZWVwbGluayB9IGZyb20gJy4uL3NlcnZpY2VzL1BsYXRmZm9ybU1hbmFnZXIvb3BlbkRlZXBsaW5rJztcblxuZXhwb3J0IGNvbnN0IFRFTVBPUkFSWV9XQUtFX0xPQ0tfVElNRSA9IDIwMDA7XG5leHBvcnQgY29uc3QgVU5USUxfUkVTUE9OU0VfV0FLRV9MT0NLX1RJTUUgPSA0MDAwMDtcblxuaW50ZXJmYWNlIFBsYXRmb3JtUHJvcHMge1xuICB1c2VEZWVwTGluazogYm9vbGVhbjtcbiAgcHJlZmVycmVkT3Blbkxpbms/OiAobGluazogc3RyaW5nLCB0YXJnZXQ/OiBzdHJpbmcpID0+IHZvaWQ7XG4gIGRlYnVnPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIFBsYXRmb3JtTWFuYWdlclN0YXRlIHtcbiAgcGxhdGZvcm1UeXBlPzogUGxhdGZvcm1UeXBlO1xuICB1c2VEZWVwbGluazogYm9vbGVhbjtcbiAgcHJlZmVycmVkT3Blbkxpbms/OiAobGluazogc3RyaW5nLCB0YXJnZXQ/OiBzdHJpbmcpID0+IHZvaWQ7XG4gIGRlYnVnOiBib29sZWFuO1xufVxuXG5leHBvcnQgY2xhc3MgUGxhdGZvcm1NYW5hZ2VyIHtcbiAgcHVibGljIHN0YXRlOiBQbGF0Zm9ybU1hbmFnZXJTdGF0ZSA9IHtcbiAgICBwbGF0Zm9ybVR5cGU6IHVuZGVmaW5lZCxcbiAgICB1c2VEZWVwbGluazogZmFsc2UsXG4gICAgcHJlZmVycmVkT3Blbkxpbms6IHVuZGVmaW5lZCxcbiAgICBkZWJ1ZzogZmFsc2UsXG4gIH07XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIHVzZURlZXBMaW5rLFxuICAgIHByZWZlcnJlZE9wZW5MaW5rLFxuICAgIGRlYnVnID0gZmFsc2UsXG4gIH06IFBsYXRmb3JtUHJvcHMpIHtcbiAgICB0aGlzLnN0YXRlLnBsYXRmb3JtVHlwZSA9IHRoaXMuZ2V0UGxhdGZvcm1UeXBlKCk7XG4gICAgdGhpcy5zdGF0ZS51c2VEZWVwbGluayA9IHVzZURlZXBMaW5rO1xuICAgIHRoaXMuc3RhdGUucHJlZmVycmVkT3BlbkxpbmsgPSBwcmVmZXJyZWRPcGVuTGluaztcbiAgICB0aGlzLnN0YXRlLmRlYnVnID0gZGVidWc7XG4gIH1cblxuICBvcGVuRGVlcGxpbmsodW5pdmVyc2FsTGluazogc3RyaW5nLCBkZWVwbGluazogc3RyaW5nLCB0YXJnZXQ/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gb3BlbkRlZXBsaW5rKHRoaXMsIHVuaXZlcnNhbExpbmssIGRlZXBsaW5rLCB0YXJnZXQpO1xuICB9XG5cbiAgaXNSZWFjdE5hdGl2ZSgpIHtcbiAgICAvLyBBdm9pZCBncm91cGluZyBpbiBzaW5nbGUgY29uZGl0aW9uIGZvciByZWFkaWJpbGl0eVxuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmlzTm90QnJvd3NlcigpICYmXG4gICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgd2luZG93Py5uYXZpZ2F0b3IgJiZcbiAgICAgIHdpbmRvdy5uYXZpZ2F0b3I/LnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZSdcbiAgICApO1xuICB9XG5cbiAgaXNNZXRhTWFza0luc3RhbGxlZCgpIHtcbiAgICByZXR1cm4gaXNNZXRhTWFza0luc3RhbGxlZCgpO1xuICB9XG5cbiAgaXNEZXNrdG9wV2ViKCkge1xuICAgIHJldHVybiB0aGlzLmlzQnJvd3NlcigpICYmICF0aGlzLmlzTW9iaWxlV2ViKCk7XG4gIH1cblxuICBpc01vYmlsZSgpIHtcbiAgICBjb25zdCBicm93c2VyID0gQm93c2VyLnBhcnNlKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICAgIHJldHVybiAoXG4gICAgICBicm93c2VyPy5wbGF0Zm9ybT8udHlwZSA9PT0gJ21vYmlsZScgfHxcbiAgICAgIGJyb3dzZXI/LnBsYXRmb3JtPy50eXBlID09PSAndGFibGV0J1xuICAgICk7XG4gIH1cblxuICBpc1NlY3VyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1JlYWN0TmF0aXZlKCkgfHwgdGhpcy5pc01vYmlsZVdlYigpO1xuICB9XG5cbiAgaXNNZXRhTWFza01vYmlsZVdlYlZpZXcoKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIEJvb2xlYW4od2luZG93LlJlYWN0TmF0aXZlV2ViVmlldykgJiZcbiAgICAgIEJvb2xlYW4obmF2aWdhdG9yLnVzZXJBZ2VudC5lbmRzV2l0aCgnTWV0YU1hc2tNb2JpbGUnKSlcbiAgICApO1xuICB9XG5cbiAgaXNNb2JpbGVXZWIoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucGxhdGZvcm1UeXBlID09PSBQbGF0Zm9ybVR5cGUuTW9iaWxlV2ViO1xuICB9XG5cbiAgc3RhdGljIGlzTm90QnJvd3NlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgICF3aW5kb3c/Lm5hdmlnYXRvciB8fFxuICAgICAgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIGdsb2JhbD8ubmF2aWdhdG9yPy5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnKSB8fFxuICAgICAgbmF2aWdhdG9yPy5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnXG4gICAgKTtcbiAgfVxuXG4gIGlzTm90QnJvd3NlcigpIHtcbiAgICByZXR1cm4gUGxhdGZvcm1NYW5hZ2VyLmlzTm90QnJvd3NlcigpO1xuICB9XG5cbiAgc3RhdGljIGlzQnJvd3NlcigpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNOb3RCcm93c2VyKCk7XG4gIH1cblxuICBpc0Jyb3dzZXIoKSB7XG4gICAgcmV0dXJuIFBsYXRmb3JtTWFuYWdlci5pc0Jyb3dzZXIoKTtcbiAgfVxuXG4gIGlzTm9kZUpTKCkge1xuICAgIHJldHVybiB0aGlzLmlzTm90QnJvd3NlcigpICYmICF0aGlzLmlzUmVhY3ROYXRpdmUoKTtcbiAgfVxuXG4gIGlzVXNlRGVlcExpbmsoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUudXNlRGVlcGxpbms7XG4gIH1cblxuICBnZXRQbGF0Zm9ybVR5cGUoKSB7XG4gICAgcmV0dXJuIGdldFBsYXRmb3JtVHlwZSh0aGlzKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IFBsYXRmb3JtTWFuYWdlciB9IGZyb20gJy4uLy4uL1BsYXRmb3JtL1BsYXRmZm9ybU1hbmFnZXInO1xuXG5leHBvcnQgZnVuY3Rpb24gb3BlbkRlZXBsaW5rKFxuICBpbnN0YW5jZTogUGxhdGZvcm1NYW5hZ2VyLFxuICB1bml2ZXJzYWxMaW5rOiBzdHJpbmcsXG4gIGRlZXBsaW5rOiBzdHJpbmcsXG4gIHRhcmdldD86IHN0cmluZyxcbikge1xuICBjb25zdCB7IHN0YXRlIH0gPSBpbnN0YW5jZTtcblxuICBsb2dnZXIoXG4gICAgYFtQbGF0ZmZvcm1NYW5hZ2VyOiBvcGVuRGVlcGxpbmsoKV0gdW5pdmVyc2FsTGluayAtLT4gJHt1bml2ZXJzYWxMaW5rfWAsXG4gICk7XG4gIGxvZ2dlcihgW1BsYXRmZm9ybU1hbmFnZXI6IG9wZW5EZWVwbGluaygpXSBkZWVwTGluayAtLT4gJHtkZWVwbGlua31gKTtcblxuICB0cnkge1xuICAgIGlmIChzdGF0ZS5wcmVmZXJyZWRPcGVuTGluaykge1xuICAgICAgc3RhdGUucHJlZmVycmVkT3BlbkxpbmsoXG4gICAgICAgIHN0YXRlLnVzZURlZXBsaW5rID8gZGVlcGxpbmsgOiB1bml2ZXJzYWxMaW5rLFxuICAgICAgICB0YXJnZXQsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxvZ2dlcihcbiAgICAgIGBbUGxhdGZmb3JtTWFuYWdlcjogb3BlbkRlZXBsaW5rKCldIG9wZW4gbGluayBub3cgdXNlRGVlcExpbms9JHtcbiAgICAgICAgc3RhdGUudXNlRGVlcGxpbmtcbiAgICAgIH0gbGluaz0ke3N0YXRlLnVzZURlZXBsaW5rID8gZGVlcGxpbmsgOiB1bml2ZXJzYWxMaW5rfWAsXG4gICAgKTtcblxuICAgIC8vIEl0IHNob3VsZCBvbmx5IG9wZW4gYWZ0ZXIgd2UgY2FuIGFja25vd2xlZGdlIHRoYXQgdGhlIHJwYyBjYWxsIHRoYXQgdHJpZ2dlcmVkIHRoZSBkZWVwbGluayBoYXMgYmVlbiBzZW50XG4gICAgLy8gVE9ETyBob3cgY2FuIHdlIGtub3cgdGhhdCB0aGUgcnBjIGNhbGwgaGFzIGJlZW4gc2VudD9cbiAgICBpZiAoc3RhdGUudXNlRGVlcGxpbmspIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIG9wZW4gYSBkZWVwbGluayBpbiBhIG5ldyB0YWJcbiAgICAgICAgLy8gSXQgYXZvaWQgdGhlIGJyb3dzZXIgdG8gZGlzcGxheSBhIGJsYW5rIHBhZ2VcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBkZWVwbGluaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWluYm93LW1lL3JhaW5ib3draXQvaXNzdWVzLzUyNC5cbiAgICAgIC8vIFVzaW5nICd3aW5kb3cub3BlbicgY2F1c2VzIGlzc3VlcyBvbiBpT1MgaW4gbm9uLVNhZmFyaSBicm93c2VycyBhbmRcbiAgICAgIC8vIFdlYlZpZXdzIHdoZXJlIGEgYmxhbmsgdGFiIGlzIGxlZnQgYmVoaW5kIGFmdGVyIGNvbm5lY3RpbmcuXG4gICAgICAvLyBUaGlzIGlzIGVzcGVjaWFsbHkgYmFkIGluIHNvbWUgV2ViVmlldyBzY2VuYXJpb3MgKGUuZy4gZm9sbG93aW5nIGFcbiAgICAgIC8vIGxpbmsgZnJvbSBUd2l0dGVyKSB3aGVyZSB0aGUgdXNlciBkb2Vzbid0IGhhdmUgYW55IG1lY2hhbmlzbSBmb3JcbiAgICAgIC8vIGNsb3NpbmcgdGhlIGJsYW5rIHRhYi5cbiAgICAgIC8vIEZvciB3aGF0ZXZlciByZWFzb24sIGxpbmtzIHdpdGggYSB0YXJnZXQgb2YgXCJfYmxhbmtcIiBkb24ndCBzdWZmZXJcbiAgICAgIC8vIGZyb20gdGhpcyBwcm9ibGVtLCBhbmQgcHJvZ3JhbW1hdGljYWxseSBjbGlja2luZyBhIGRldGFjaGVkIGxpbmtcbiAgICAgIC8vIGVsZW1lbnQgd2l0aCB0aGUgc2FtZSBhdHRyaWJ1dGVzIGFsc28gYXZvaWRzIHRoZSBpc3N1ZS5cbiAgICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICBsaW5rLmhyZWYgPSB1bml2ZXJzYWxMaW5rO1xuICAgICAgbGluay50YXJnZXQgPSAnX3NlbGYnO1xuICAgICAgbGluay5yZWwgPSAnbm9yZWZlcnJlciBub29wZW5lcic7XG4gICAgICBsaW5rLmNsaWNrKCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLmxvZyhgW1BsYXRmZm9ybU1hbmFnZXI6IG9wZW5EZWVwbGluaygpXSBjYW4ndCBvcGVuIGxpbmtgLCBlcnIpO1xuICB9XG5cbiAgLy8gY29uc29sZS5sb2coJ1BsZWFzZSBzZXR1cCB0aGUgb3BlbkRlZXBsaW5rIHBhcmFtZXRlcicpO1xufVxuIiwiaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEV0aGVyZXVtIH0gZnJvbSAnLi4vRXRoZXJldW0nO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNNZXRhTWFza0luc3RhbGxlZCgpIHtcbiAgY29uc3QgZXRoID0gRXRoZXJldW0uZ2V0UHJvdmlkZXIoKSB8fCB3aW5kb3c/LmV0aGVyZXVtO1xuICBsb2dnZXIoXG4gICAgYFtQbGF0ZmZvcm1NYW5hZ2VyOiBpc01ldGFNYXNrSW5zdGFsbGVkKCldIGlzTWV0YU1hc2s9JHtcbiAgICAgIGV0aD8uaXNNZXRhTWFza1xuICAgIH0gaXNDb25uZWN0ZWQ9JHtldGg/LmlzQ29ubmVjdGVkKCl9YCxcbiAgKTtcblxuICByZXR1cm4gZXRoPy5pc01ldGFNYXNrICYmIGV0aD8uaXNDb25uZWN0ZWQoKTtcbn1cbiIsImltcG9ydCB7IFBsYXRmb3JtVHlwZSB9IGZyb20gJ0BtZXRhbWFzay9zZGstY29tbXVuaWNhdGlvbi1sYXllcic7XG5pbXBvcnQgeyBQbGF0Zm9ybU1hbmFnZXIgfSBmcm9tICcuLi8uLi9QbGF0Zm9ybS9QbGF0ZmZvcm1NYW5hZ2VyJztcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFBsYXRmb3JtVHlwZShpbnN0YW5jZTogUGxhdGZvcm1NYW5hZ2VyKSB7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IGluc3RhbmNlO1xuXG4gIGlmIChzdGF0ZS5wbGF0Zm9ybVR5cGUpIHtcbiAgICByZXR1cm4gc3RhdGUucGxhdGZvcm1UeXBlO1xuICB9XG5cbiAgaWYgKGluc3RhbmNlLmlzUmVhY3ROYXRpdmUoKSkge1xuICAgIHJldHVybiBQbGF0Zm9ybVR5cGUuUmVhY3ROYXRpdmU7XG4gIH1cblxuICBpZiAoaW5zdGFuY2UuaXNOb3RCcm93c2VyKCkpIHtcbiAgICByZXR1cm4gUGxhdGZvcm1UeXBlLk5vbkJyb3dzZXI7XG4gIH1cblxuICBpZiAoaW5zdGFuY2UuaXNNZXRhTWFza01vYmlsZVdlYlZpZXcoKSkge1xuICAgIHJldHVybiBQbGF0Zm9ybVR5cGUuTWV0YU1hc2tNb2JpbGVXZWJ2aWV3O1xuICB9XG5cbiAgaWYgKGluc3RhbmNlLmlzTW9iaWxlKCkpIHtcbiAgICByZXR1cm4gUGxhdGZvcm1UeXBlLk1vYmlsZVdlYjtcbiAgfVxuXG4gIHJldHVybiBQbGF0Zm9ybVR5cGUuRGVza3RvcFdlYjtcbn1cbiIsImltcG9ydCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gIFN0b3JhZ2VNYW5hZ2VyLFxuICBTdG9yYWdlTWFuYWdlclByb3BzLFxufSBmcm9tICdAbWV0YW1hc2svc2RrLWNvbW11bmljYXRpb24tbGF5ZXInO1xuaW1wb3J0IHsgUGxhdGZvcm1NYW5hZ2VyIH0gZnJvbSAnLi4vUGxhdGZvcm0vUGxhdGZmb3JtTWFuYWdlcic7XG5cbmV4cG9ydCBjb25zdCBnZXRTdG9yYWdlTWFuYWdlciA9IGFzeW5jIChcbiAgb3B0aW9uczogU3RvcmFnZU1hbmFnZXJQcm9wcyxcbik6IFByb21pc2U8U3RvcmFnZU1hbmFnZXI+ID0+IHtcbiAgaWYgKFBsYXRmb3JtTWFuYWdlci5pc0Jyb3dzZXIoKSkge1xuICAgIGNvbnN0IHsgU3RvcmFnZU1hbmFnZXJXZWIgfSA9IGF3YWl0IGltcG9ydCgnLi9TdG9yYWdlTWFuYWdlcldlYicpO1xuICAgIHJldHVybiBuZXcgU3RvcmFnZU1hbmFnZXJXZWIob3B0aW9ucyk7XG4gIH1cblxuICBjb25zdCBub29wU3RvcmFnZU1hbmFnZXI6IFN0b3JhZ2VNYW5hZ2VyID0ge1xuICAgIHBlcnNpc3RDaGFubmVsQ29uZmlnOiBhc3luYyAoKSA9PiB1bmRlZmluZWQsXG4gICAgZ2V0UGVyc2lzdGVkQ2hhbm5lbENvbmZpZzogYXN5bmMgKCkgPT4gdW5kZWZpbmVkLFxuICAgIHBlcnNpc3RBY2NvdW50czogYXN5bmMgKCkgPT4gdW5kZWZpbmVkLFxuICAgIGdldENhY2hlZEFjY291bnRzOiBhc3luYyAoKSA9PiBbXSxcbiAgICBwZXJzaXN0Q2hhaW5JZDogYXN5bmMgKCkgPT4gdW5kZWZpbmVkLFxuICAgIGdldENhY2hlZENoYWluSWQ6IGFzeW5jICgpID0+IHVuZGVmaW5lZCxcbiAgICB0ZXJtaW5hdGU6IGFzeW5jICgpID0+IHVuZGVmaW5lZCxcbiAgfSBhcyBTdG9yYWdlTWFuYWdlcjtcblxuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5vb3BTdG9yYWdlTWFuYWdlcik7XG59O1xuIiwiaW1wb3J0IHsgRHVwbGV4IH0gZnJvbSAncmVhZGFibGUtc3RyZWFtJztcbmltcG9ydCB7IE1ldGFNYXNrSW5wYWdlUHJvdmlkZXIgfSBmcm9tICdAbWV0YW1hc2svcHJvdmlkZXJzJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBoYW5kbGVDaGFpbkNoYW5nZWQgfSBmcm9tICcuLi9zZXJ2aWNlcy9TREtQcm92aWRlci9DaGFpbk1hbmFnZXIvaGFuZGxlQ2hhaW5DaGFuZ2VkJztcbmltcG9ydCB7IGhhbmRsZURpc2Nvbm5lY3QgfSBmcm9tICcuLi9zZXJ2aWNlcy9TREtQcm92aWRlci9Db25uZWN0aW9uTWFuYWdlci9oYW5kbGVEaXNjb25uZWN0JztcbmltcG9ydCB7IGluaXRpYWxpemVTdGF0ZSB9IGZyb20gJy4uL3NlcnZpY2VzL1NES1Byb3ZpZGVyL0luaXRpYWxpemF0aW9uTWFuYWdlci9pbml0aWFsaXplU3RhdGUnO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZVN0YXRlQXN5bmMgfSBmcm9tICcuLi9zZXJ2aWNlcy9TREtQcm92aWRlci9Jbml0aWFsaXphdGlvbk1hbmFnZXIvaW5pdGlhbGl6ZVN0YXRlQXN5bmMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNES1Byb3ZpZGVyUHJvcHMge1xuICAvKipcbiAgICogVGhlIHN0cmVhbSB1c2VkIHRvIGNvbm5lY3QgdG8gdGhlIHdhbGxldC5cbiAgICovXG4gIGNvbm5lY3Rpb25TdHJlYW06IER1cGxleDtcblxuICAvKipcbiAgICogQXV0b21hdGljYWxseSBjYWxsIGV0aF9yZXF1ZXN0QWNjb3VudHMgb24gaW5pdGlhbGl6YXRpb24uXG4gICAqL1xuICBhdXRvUmVxdWVzdEFjY291bnRzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgcHJvdmlkZXIgc2hvdWxkIGJlIHNldCBhcyB3aW5kb3cuZXRoZXJldW0uXG4gICAqL1xuICBzaG91bGRTZXRPbldpbmRvdz86IGJvb2xlYW47XG4gIHNob3VsZFNlbmRNZXRhZGF0YT86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSB3aW5kb3cud2ViMyBzaGltIHNob3VsZCBiZSBzZXQuXG4gICAqL1xuICBzaG91bGRTaGltV2ViMz86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBTREtQcm92aWRlclN0YXRlIHtcbiAgYWNjb3VudHM6IHN0cmluZ1tdIHwgbnVsbDtcbiAgc2VsZWN0ZWRBZGRyZXNzPzogc3RyaW5nO1xuICBhdXRvUmVxdWVzdEFjY291bnRzOiBib29sZWFuO1xuICBwcm92aWRlclN0YXRlUmVxdWVzdGVkOiBib29sZWFuO1xuICBjaGFpbklkOiBzdHJpbmc7XG4gIG5ldHdvcmtWZXJzaW9uPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgU0RLUHJvdmlkZXIgZXh0ZW5kcyBNZXRhTWFza0lucGFnZVByb3ZpZGVyIHtcbiAgcHVibGljIHN0YXRlOiBTREtQcm92aWRlclN0YXRlID0ge1xuICAgIGFjY291bnRzOiBudWxsLFxuICAgIGF1dG9SZXF1ZXN0QWNjb3VudHM6IGZhbHNlLFxuICAgIHByb3ZpZGVyU3RhdGVSZXF1ZXN0ZWQ6IGZhbHNlLFxuICAgIGNoYWluSWQ6ICcnLFxuICAgIG5ldHdvcmtWZXJzaW9uOiAnJyxcbiAgfTtcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29ubmVjdGlvblN0cmVhbSxcbiAgICBzaG91bGRTZW5kTWV0YWRhdGEsXG4gICAgYXV0b1JlcXVlc3RBY2NvdW50cyA9IGZhbHNlLFxuICB9OiBTREtQcm92aWRlclByb3BzKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvblN0cmVhbSwge1xuICAgICAgbG9nZ2VyOiBjb25zb2xlLFxuICAgICAgbWF4RXZlbnRMaXN0ZW5lcnM6IDEwMCxcbiAgICAgIHNob3VsZFNlbmRNZXRhZGF0YSxcbiAgICB9KTtcblxuICAgIGxvZ2dlcihcbiAgICAgIGBbU0RLUHJvdmlkZXI6IGNvbnN0cnVjdG9yKCldIGF1dG9SZXF1ZXN0QWNjb3VudHM9JHthdXRvUmVxdWVzdEFjY291bnRzfWAsXG4gICAgKTtcbiAgICB0aGlzLnN0YXRlLmF1dG9SZXF1ZXN0QWNjb3VudHMgPSBhdXRvUmVxdWVzdEFjY291bnRzO1xuICB9XG5cbiAgYXN5bmMgZm9yY2VJbml0aWFsaXplU3RhdGUoKSB7XG4gICAgbG9nZ2VyKFxuICAgICAgYFtTREtQcm92aWRlcjogZm9yY2VJbml0aWFsaXplU3RhdGUoKV0gYXV0b1JlcXVlc3RBY2NvdW50cz0ke3RoaXMuc3RhdGUuYXV0b1JlcXVlc3RBY2NvdW50c31gLFxuICAgICk7XG5cbiAgICByZXR1cm4gdGhpcy5faW5pdGlhbGl6ZVN0YXRlQXN5bmMoKTtcbiAgfVxuXG4gIF9zZXRDb25uZWN0ZWQoKSB7XG4gICAgbG9nZ2VyKGBbU0RLUHJvdmlkZXI6IF9zZXRDb25uZWN0ZWQoKV0gU2V0dGluZyBjb25uZWN0ZWQgc3RhdGVgKTtcblxuICAgIHRoaXMuX3N0YXRlLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGdldFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgfVxuXG4gIGdldFNES1Byb3ZpZGVyU3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gIH1cblxuICBnZXRTZWxlY3RlZEFkZHJlc3MoKSB7XG4gICAgY29uc3QgeyBhY2NvdW50cyB9ID0gdGhpcy5fc3RhdGU7XG5cbiAgICBpZiAoIWFjY291bnRzIHx8IGFjY291bnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbG9nZ2VyKCdbU0RLUHJvdmlkZXI6IGdldFNlbGVjdGVkQWRkcmVzc10gTm8gYWNjb3VudHMgZm91bmQnKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBhY2NvdW50c1swXT8udG9Mb3dlckNhc2UoKSB8fCAnJztcbiAgfVxuXG4gIGdldENoYWluSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuY2hhaW5JZDtcbiAgfVxuXG4gIGdldE5ldHdvcmtWZXJzaW9uKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLm5ldHdvcmtWZXJzaW9uO1xuICB9XG5cbiAgc2V0U0RLUHJvdmlkZXJTdGF0ZShzdGF0ZTogUGFydGlhbDxTREtQcm92aWRlclN0YXRlPikge1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAuLi50aGlzLnN0YXRlLFxuICAgICAgLi4uc3RhdGUsXG4gICAgfTtcbiAgfVxuXG4gIGhhbmRsZUFjY291bnRzQ2hhbmdlZChhY2NvdW50czogc3RyaW5nW10sIGlzRXRoQWNjb3VudHM/OiBib29sZWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhbmRsZUFjY291bnRzQ2hhbmdlZChhY2NvdW50cywgaXNFdGhBY2NvdW50cyk7XG4gIH1cblxuICBoYW5kbGVEaXNjb25uZWN0KHsgdGVybWluYXRlID0gZmFsc2UgfTogeyB0ZXJtaW5hdGU6IGJvb2xlYW4gfSkge1xuICAgIGhhbmRsZURpc2Nvbm5lY3Qoe1xuICAgICAgdGVybWluYXRlLFxuICAgICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXN5bmMgX2luaXRpYWxpemVTdGF0ZUFzeW5jKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBpbml0aWFsaXplU3RhdGVBc3luYyh0aGlzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfaW5pdGlhbGl6ZVN0YXRlKFxuICAgIGluaXRpYWxTdGF0ZT86XG4gICAgICB8IHtcbiAgICAgICAgICBhY2NvdW50czogc3RyaW5nW107XG4gICAgICAgICAgY2hhaW5JZDogc3RyaW5nO1xuICAgICAgICAgIGlzVW5sb2NrZWQ6IGJvb2xlYW47XG4gICAgICAgICAgbmV0d29ya1ZlcnNpb24/OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIHwgdW5kZWZpbmVkLFxuICApOiB2b2lkIHtcbiAgICBsb2dnZXIoJ1tTREtQcm92aWRlcjogX2luaXRpYWxpemVTdGF0ZSgpXScsIGluaXRpYWxTdGF0ZSk7XG4gICAgcmV0dXJuIGluaXRpYWxpemVTdGF0ZShcbiAgICAgIHRoaXMsXG4gICAgICBzdXBlci5faW5pdGlhbGl6ZVN0YXRlLmJpbmQodGhpcyksXG4gICAgICBpbml0aWFsU3RhdGUsXG4gICAgKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBfaGFuZGxlQ2hhaW5DaGFuZ2VkKHtcbiAgICBjaGFpbklkLFxuICAgIG5ldHdvcmtWZXJzaW9uLFxuICB9OiB7IGNoYWluSWQ/OiBzdHJpbmc7IG5ldHdvcmtWZXJzaW9uPzogc3RyaW5nIH0gPSB7fSkge1xuICAgIHRoaXMuc3RhdGUuY2hhaW5JZCA9IGNoYWluSWQgYXMgc3RyaW5nO1xuICAgIHRoaXMuc3RhdGUubmV0d29ya1ZlcnNpb24gPSBuZXR3b3JrVmVyc2lvbiBhcyBzdHJpbmc7XG5cbiAgICBoYW5kbGVDaGFpbkNoYW5nZWQoe1xuICAgICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgICBjaGFpbklkLFxuICAgICAgbmV0d29ya1ZlcnNpb24sXG4gICAgICBzdXBlckhhbmRsZUNoYWluQ2hhbmdlZDogc3VwZXIuX2hhbmRsZUNoYWluQ2hhbmdlZC5iaW5kKHRoaXMpLFxuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQgeyBldGhFcnJvcnMgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgU0RLUHJvdmlkZXIgfSBmcm9tICcuLi8uLi8uLi9wcm92aWRlci9TREtQcm92aWRlcic7XG5cbi8qKlxuICogSGFuZGxlcyB0aGUgZGlzY29ubmVjdGlvbiBvZiBhbiBTREtQcm92aWRlciBpbnN0YW5jZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBjbGVhbmluZyB1cCB0aGUgc3RhdGUgb2YgYW4gU0RLUHJvdmlkZXIgaW5zdGFuY2UgdXBvbiBkaXNjb25uZWN0aW9uLlxuICogSWYgdGhlIGB0ZXJtaW5hdGVgIGZsYWcgaXMgc2V0IHRvIHRydWUsIGl0IGNsZWFycyB2YXJpb3VzIHN0YXRlIGF0dHJpYnV0ZXMgbGlrZSBgY2hhaW5JZGAsIGBhY2NvdW50c2AsIGFuZCBgc2VsZWN0ZWRBZGRyZXNzYC5cbiAqIEl0IGFsc28gc2V0cyB0aGUgYF9zdGF0ZS5pc1VubG9ja2VkYCBhbmQgYF9zdGF0ZS5pc1Blcm1hbmVudGx5RGlzY29ubmVjdGVkYCBmbGFncyB0byBmYWxzZSwgbWFya2luZyB0aGUgcHJvdmlkZXIgYXMgZGlzY29ubmVjdGVkLlxuICogQW4gJ2V0aC1ycGMtZXJyb3InIGZvciBkaXNjb25uZWN0aW9uIGlzIGVtaXR0ZWQgYXQgdGhlIGVuZC5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyBBbiBvYmplY3QgY29udGFpbmluZzpcbiAqICAtIGB0ZXJtaW5hdGVgOiBBIGJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gdGVybWluYXRlIHRoZSBjb25uZWN0aW9uIGFuZCBjbGVhciBzdGF0ZSB2YXJpYWJsZXMuXG4gKiAgLSBgaW5zdGFuY2VgOiBUaGUgU0RLUHJvdmlkZXIgaW5zdGFuY2UgdGhhdCBpcyBiZWluZyBkaXNjb25uZWN0ZWQuXG4gKiBAcmV0dXJucyB2b2lkXG4gKiBAZW1pdHMgJ2Rpc2Nvbm5lY3QnIGV2ZW50IGFsb25nIHdpdGggYW4gJ2V0aC1ycGMtZXJyb3InIGRlc2NyaWJpbmcgdGhlIGRpc2Nvbm5lY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVEaXNjb25uZWN0KHtcbiAgdGVybWluYXRlID0gZmFsc2UsXG4gIGluc3RhbmNlLFxufToge1xuICB0ZXJtaW5hdGU6IGJvb2xlYW47XG4gIGluc3RhbmNlOiBTREtQcm92aWRlcjtcbn0pIHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gaW5zdGFuY2U7XG5cbiAgbG9nZ2VyKFxuICAgIGBbU0RLUHJvdmlkZXI6IGhhbmRsZURpc2Nvbm5lY3QoKV0gY2xlYW5pbmcgdXAgcHJvdmlkZXIgc3RhdGUgdGVybWluYXRlPSR7dGVybWluYXRlfWAsXG4gICAgaW5zdGFuY2UsXG4gICk7XG5cbiAgaWYgKHRlcm1pbmF0ZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaW5zdGFuY2UuX3N0YXRlLmFjY291bnRzID0gbnVsbDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGluc3RhbmNlLl9zdGF0ZS5pc1VubG9ja2VkID0gZmFsc2U7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpbnN0YW5jZS5fc3RhdGUuaXNQZXJtYW5lbnRseURpc2Nvbm5lY3RlZCA9IHRydWU7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpbnN0YW5jZS5fc3RhdGUuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gIC8vIEB0cy1pZ25vcmVcbiAgaW5zdGFuY2UuX2hhbmRsZUFjY291bnRzQ2hhbmdlZChbXSk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICBpbnN0YW5jZS5fc3RhdGUuaXNDb25uZWN0ZWQgPSBmYWxzZTtcbiAgaW5zdGFuY2UuZW1pdCgnZGlzY29ubmVjdCcsIGV0aEVycm9ycy5wcm92aWRlci5kaXNjb25uZWN0ZWQoKSk7XG5cbiAgc3RhdGUucHJvdmlkZXJTdGF0ZVJlcXVlc3RlZCA9IGZhbHNlO1xufVxuIiwiaW1wb3J0IHsgTWV0YU1hc2tJbnBhZ2VQcm92aWRlciB9IGZyb20gJ0BtZXRhbWFzay9wcm92aWRlcnMnO1xuaW1wb3J0IHsgU0RLUHJvdmlkZXIgfSBmcm9tICcuLi8uLi8uLi9wcm92aWRlci9TREtQcm92aWRlcic7XG5pbXBvcnQgeyBnZXRTdG9yYWdlTWFuYWdlciB9IGZyb20gJy4uLy4uLy4uL3N0b3JhZ2UtbWFuYWdlci9nZXRTdG9yYWdlTWFuYWdlcic7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnZXInO1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IGluaXRpYWxpemVzIHRoZSBzdGF0ZSBvZiBhbiBTREtQcm92aWRlciBpbnN0YW5jZS5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gcGVyZm9ybXMgbXVsdGlwbGUgb3BlcmF0aW9ucyB0byBlbnN1cmUgdGhlIHN0YXRlIG9mIHRoZSBTREtQcm92aWRlciBpbnN0YW5jZVxuICogaXMgcHJvcGVybHkgaW5pdGlhbGl6ZWQuIElmIGRlYnVnIG1vZGUgaXMgZW5hYmxlZCwgaXQgbG9ncyB0aGUgcHJvY2VzcyB0byB0aGUgY29uc29sZS5cbiAqXG4gKiAtIENoZWNrcyBpZiBhbiBpbml0aWFsaXphdGlvbiBpcyBhbHJlYWR5IGluIHByb2dyZXNzIHRvIGF2b2lkIHJlZHVuZGFudCBjYWxscy5cbiAqIC0gRmV0Y2hlcyB0aGUgaW5pdGlhbCBwcm92aWRlciBzdGF0ZSB2aWEgdGhlICdtZXRhbWFza19nZXRQcm92aWRlclN0YXRlJyByZXF1ZXN0LlxuICogLSBJZiB0aGUgaW5pdGlhbCBzdGF0ZSBsYWNrcyBhY2NvdW50IGluZm9ybWF0aW9uLCBhdHRlbXB0cyB0byB1c2UgYGluc3RhbmNlLnNlbGVjdGVkQWRkcmVzc2Agb3IgbWFrZXMgYSByZW1vdGUgJ2V0aF9yZXF1ZXN0QWNjb3VudHMnIGNhbGwgdG8gcG9wdWxhdGUgdGhlIGFjY291bnRzLlxuICpcbiAqIEBwYXJhbSBpbnN0YW5jZSBUaGUgU0RLUHJvdmlkZXIgaW5zdGFuY2Ugd2hvc2Ugc3RhdGUgaXMgdG8gYmUgaW5pdGlhbGl6ZWQgYXN5bmNocm9ub3VzbHkuXG4gKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XG4gKiBAdGhyb3dzIEVycm9yIGlmIHRoZSBpbml0aWFsaXphdGlvbiBmYWlscy5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemVTdGF0ZUFzeW5jKGluc3RhbmNlOiBTREtQcm92aWRlcikge1xuICAvLyBEb24ndCByZW1vdmUgdGhpcyBsb2dpYywgaXQncyByZXF1aXJlZCB0byBpbml0aWFsaXplIHRoZSBzdGF0ZSBpbiBzb21lIGNhc2VzLlxuICBpZiAoaW5zdGFuY2Uuc3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBXb3JrYXJvdW5kOiBJbml0aWFsaXppbmcgdGhlIHN0YXRlIGhlcmUgdG8gYWRkcmVzcyBhbiBpc3N1ZSB3aGVyZSBwcm9wZXJ0aWVzXG4gICAgICogd2VyZSBub3Qgc2V0IGJlZm9yZSB0aGlzIG1ldGhvZCB3YXMgaW52b2tlZCwgcG9zc2libHkgYnkgdGhlIHBhcmVudCBjbGFzcywgbGVhZGluZyB0b1xuICAgICAqIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXG4gICAgICpcbiAgICAgKi9cbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHtcbiAgICAgIGFjY291bnRzOiBudWxsLFxuICAgICAgYXV0b1JlcXVlc3RBY2NvdW50czogZmFsc2UsXG4gICAgICBwcm92aWRlclN0YXRlUmVxdWVzdGVkOiBmYWxzZSxcbiAgICAgIGNoYWluSWQ6ICcnLFxuICAgIH07XG4gIH1cblxuICBjb25zdCB7IHN0YXRlIH0gPSBpbnN0YW5jZTtcbiAgLy8gUmVwbGFjZSBzdXBlci5pbml0aWFsU3RhdGUgbG9naWMgdG8gYXV0b21hdGljYWxseSByZXF1ZXN0IGFjY291bnQgaWYgbm90IGZvdW5kIGluIHByb3ZpZGVyc3RhdGUuXG4gIGxldCBpbml0aWFsU3RhdGU6IFBhcmFtZXRlcnM8TWV0YU1hc2tJbnBhZ2VQcm92aWRlclsnX2luaXRpYWxpemVTdGF0ZSddPlswXTtcblxuICBpZiAoc3RhdGUucHJvdmlkZXJTdGF0ZVJlcXVlc3RlZCkge1xuICAgIGxvZ2dlcihcbiAgICAgIGBbU0RLUHJvdmlkZXI6IGluaXRpYWxpemVTdGF0ZUFzeW5jKCldIGluaXRpYWxpemF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3NgLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUucHJvdmlkZXJTdGF0ZVJlcXVlc3RlZCA9IHRydWU7XG5cbiAgICBsZXQgY2FjaGVkQ2hhaW5JZDogdW5kZWZpbmVkIHwgc3RyaW5nO1xuICAgIGxldCBjYWNoZWRTZWxlY3RlZEFkZHJlc3M6IG51bGwgfCBzdHJpbmcgPSBudWxsO1xuICAgIGxldCByZWxheVBlcnNpc3RlbmNlID0gZmFsc2U7XG5cbiAgICBsZXQgdXNlQ2FjaGUgPSBmYWxzZTtcbiAgICBjb25zdCBzdG9yYWdlTWFuYWdlciA9IGF3YWl0IGdldFN0b3JhZ2VNYW5hZ2VyKHsgZW5hYmxlZDogdHJ1ZSB9KTtcblxuICAgIC8vIEZJWE1FOiBjdXJyZW50bHkgc2V0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHNvIG5ldyBzZGsgZG9uJ3QgYXV0b2Nvbm5lY3Qgd2l0aCBvbGQgd2FsbGV0XG4gICAgLy8gT25seSB1c2UgY2FjaGUgaWYgcmVsYXlQZXJzaXN0ZW5jZSBpcyBlbmFibGVkIGZvciBjdXJyZW50IGNoYW5uZWwuXG4gICAgaWYgKHN0b3JhZ2VNYW5hZ2VyKSB7XG4gICAgICAvLyBUcnkgdG8gaW5pdGlhbGl6ZSBvcHRpbWlzdGFjYWxseSB3aXRoIGNhY2hlZCB2YWx1ZSB3aGljaCB3b3VsZCBiZSB1cGRhdGVkIG9uY2Ugd2FsbGV0IGlzIGZ1bGx5IGNvbm5lY3RlZC5cbiAgICAgIGNvbnN0IGNoYW5uZWxDb25maWcgPSBhd2FpdCBzdG9yYWdlTWFuYWdlci5nZXRQZXJzaXN0ZWRDaGFubmVsQ29uZmlnKHt9KTtcbiAgICAgIHJlbGF5UGVyc2lzdGVuY2UgPSBjaGFubmVsQ29uZmlnPy5yZWxheVBlcnNpc3RlbmNlID8/IGZhbHNlO1xuICAgICAgY2FjaGVkQ2hhaW5JZCA9IGF3YWl0IHN0b3JhZ2VNYW5hZ2VyLmdldENhY2hlZENoYWluSWQoKTtcbiAgICAgIGNvbnN0IGNhY2hlZEFjY291bnRzID0gYXdhaXQgc3RvcmFnZU1hbmFnZXIuZ2V0Q2FjaGVkQWNjb3VudHMoKTtcbiAgICAgIGlmIChjYWNoZWRBY2NvdW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNhY2hlZFNlbGVjdGVkQWRkcmVzcyA9IGNhY2hlZEFjY291bnRzWzBdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxvZ2dlcihcbiAgICAgIGBbU0RLUHJvdmlkZXI6IGluaXRpYWxpemVTdGF0ZUFzeW5jKCldIHJlbGF5UGVyc2lzdGVuY2U9JHtyZWxheVBlcnNpc3RlbmNlfWAsXG4gICAgICB7XG4gICAgICAgIHJlbGF5UGVyc2lzdGVuY2UsXG4gICAgICAgIGNhY2hlZENoYWluSWQsXG4gICAgICAgIGNhY2hlZFNlbGVjdGVkQWRkcmVzcyxcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIGlmIChyZWxheVBlcnNpc3RlbmNlKSB7XG4gICAgICBpZiAoY2FjaGVkQ2hhaW5JZCAmJiBjYWNoZWRTZWxlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgaW5pdGlhbFN0YXRlID0ge1xuICAgICAgICAgIGFjY291bnRzOiBbY2FjaGVkU2VsZWN0ZWRBZGRyZXNzXSxcbiAgICAgICAgICBjaGFpbklkOiBjYWNoZWRDaGFpbklkLFxuICAgICAgICAgIGlzVW5sb2NrZWQ6IGZhbHNlLFxuICAgICAgICB9O1xuXG4gICAgICAgIHVzZUNhY2hlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5pdGlhbFN0YXRlID0gKGF3YWl0IGluc3RhbmNlLnJlcXVlc3Qoe1xuICAgICAgICAgICAgbWV0aG9kOiAnbWV0YW1hc2tfZ2V0UHJvdmlkZXJTdGF0ZScsXG4gICAgICAgICAgfSkpIGFzIFBhcmFtZXRlcnM8TWV0YU1hc2tJbnBhZ2VQcm92aWRlclsnX2luaXRpYWxpemVTdGF0ZSddPlswXTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGluc3RhbmNlLl9sb2cuZXJyb3IoXG4gICAgICAgICAgICAnTWV0YU1hc2s6IEZhaWxlZCB0byBnZXQgaW5pdGlhbCBzdGF0ZS4gUGxlYXNlIHJlcG9ydCB0aGlzIGJ1Zy4nLFxuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzdGF0ZS5wcm92aWRlclN0YXRlUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluaXRpYWxTdGF0ZT8uYWNjb3VudHM/Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKGluc3RhbmNlLmdldFNlbGVjdGVkQWRkcmVzcygpKSB7XG4gICAgICAgIGluaXRpYWxTdGF0ZS5hY2NvdW50cyA9IFtpbnN0YW5jZS5nZXRTZWxlY3RlZEFkZHJlc3MoKSBhcyBzdHJpbmddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZ2VyKFxuICAgICAgICAgIGBbU0RLUHJvdmlkZXI6IGluaXRpYWxpemVTdGF0ZUFzeW5jKCldIEZldGNoIGFjY291bnRzIHJlbW90ZWx5LmAsXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgYWNjb3VudHMgPSAoYXdhaXQgaW5zdGFuY2UucmVxdWVzdCh7XG4gICAgICAgICAgbWV0aG9kOiAnZXRoX3JlcXVlc3RBY2NvdW50cycsXG4gICAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgfSkpIGFzIHN0cmluZ1tdO1xuICAgICAgICBpbml0aWFsU3RhdGUuYWNjb3VudHMgPSBhY2NvdW50cztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGluc3RhbmNlLl9pbml0aWFsaXplU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICBzdGF0ZS5wcm92aWRlclN0YXRlUmVxdWVzdGVkID0gZmFsc2U7XG5cbiAgICBpZiAodXNlQ2FjaGUpIHtcbiAgICAgIC8vIEZvcmNlIGlzQ29ubmVjdGVkIHRvIHRydWUgdG8gYXZvaWQgdW5uZWNlc3NhcnkgcmVxdWVzdCB0byBtZXRhbWFzay5cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGluc3RhbmNlLl9zdGF0ZS5pc0Nvbm5lY3RlZCA9IHRydWU7XG4gICAgICBpbnN0YW5jZS5lbWl0KCdjb25uZWN0JywgeyBjaGFpbklkOiBpbml0aWFsU3RhdGU/LmNoYWluSWQgfSk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgU0RLUHJvdmlkZXIgfSBmcm9tICcuLi8uLi8uLi9wcm92aWRlci9TREtQcm92aWRlcic7XG5cbnR5cGUgSW5pdGlhbGl6ZVN0YXRlQXJncyA9IFBhcmFtZXRlcnM8U0RLUHJvdmlkZXJbJ19pbml0aWFsaXplU3RhdGUnXT5bMF07XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIHN0YXRlIG9mIGFuIFNES1Byb3ZpZGVyIGluc3RhbmNlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIHNldHRpbmcgdGhlIGluaXRpYWwgc3RhdGUgb2YgYW4gU0RLUHJvdmlkZXIgaW5zdGFuY2UuXG4gKiBJZiBkZWJ1ZyBtb2RlIGlzIGVuYWJsZWQsIGl0IGxvZ3MgdGhlIHByb2Nlc3MgdG8gdGhlIGNvbnNvbGUuIEl0IHNldHMgdGhlIGBfc3RhdGUuaW5pdGlhbGl6ZWRgXG4gKiBwcm9wZXJ0eSB0byBmYWxzZSwgdGhlcmVieSBmb3JjaW5nIHJlLWluaXRpYWxpemF0aW9uIHdpdGhvdXQgZXJyb3IuXG4gKlxuICogQHBhcmFtIGluc3RhbmNlIFRoZSBTREtQcm92aWRlciBpbnN0YW5jZSB3aG9zZSBzdGF0ZSBpcyB0byBiZSBpbml0aWFsaXplZC5cbiAqIEBwYXJhbSBzdXBlckluaXRpYWxpemVTdGF0ZSBBIGZ1bmN0aW9uIHJlc3BvbnNpYmxlIGZvciBwZXJmb3JtaW5nIHRoZSBhY3R1YWwgc3RhdGUgaW5pdGlhbGl6YXRpb24uXG4gKiBAcGFyYW0gaW5pdGlhbFN0YXRlIEFuIG9wdGlvbmFsIGluaXRpYWwgc3RhdGUgb2JqZWN0IHRvIGJlIHBhc3NlZCB0byBgc3VwZXJJbml0aWFsaXplU3RhdGVgLlxuICogQHJldHVybnMgdm9pZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZVN0YXRlKFxuICBpbnN0YW5jZTogU0RLUHJvdmlkZXIsXG4gIHN1cGVySW5pdGlhbGl6ZVN0YXRlOiAoaW5pdGlhbFN0YXRlOiBJbml0aWFsaXplU3RhdGVBcmdzKSA9PiB2b2lkLFxuICBpbml0aWFsU3RhdGU/OiBJbml0aWFsaXplU3RhdGVBcmdzIHwgdW5kZWZpbmVkLFxuKTogdm9pZCB7XG4gIGxvZ2dlcihgW1NES1Byb3ZpZGVyOiBpbml0aWFsaXplU3RhdGUoKV0gc2V0IHN0YXRlLl9pbml0aWFsaXplZCB0byBmYWxzZWApO1xuXG4gIC8vIEZvcmNlIHJlLWluaXRpYWxpemUgd2l0aG91dCBlcnJvci5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAvLyBAdHMtaWdub3JlXG4gIGluc3RhbmNlLl9zdGF0ZS5pbml0aWFsaXplZCA9IGZhbHNlO1xuICByZXR1cm4gc3VwZXJJbml0aWFsaXplU3RhdGUoaW5pdGlhbFN0YXRlKTtcbn1cbiIsImV4cG9ydCBlbnVtIFByb3ZpZGVyQ29uc3RhbnRzIHtcbiAgSU5QQUdFID0gJ21ldGFtYXNrLWlucGFnZScsXG4gIENPTlRFTlRfU0NSSVBUID0gJ21ldGFtYXNrLWNvbnRlbnRzY3JpcHQnLFxuICBQUk9WSURFUiA9ICdtZXRhbWFzay1wcm92aWRlcicsXG59XG5cbmV4cG9ydCBjb25zdCBFcnJvck1lc3NhZ2VzID0ge1xuICBNQU5VQUxfRElTQ09OTkVDVDogJ21hbnVhbC1kaXNjb25uZWN0Jyxcbn07XG5cbmV4cG9ydCBjb25zdCBERUZBVUxUX1NES19TT1VSQ0UgPSAnZGlyZWN0JztcblxuZXhwb3J0IGNvbnN0IE1FVEFNQVNLX0NPTk5FQ1RfQkFTRV9VUkwgPSAnaHR0cHM6Ly9tZXRhbWFzay5hcHAubGluay9jb25uZWN0JztcblxuZXhwb3J0IGNvbnN0IE1FVEFNQVNLX0RFRVBMSU5LX0JBU0UgPSAnbWV0YW1hc2s6Ly9jb25uZWN0JztcblxuZXhwb3J0IGNvbnN0IE1FVEFNQVNLX0VJUF82MzY5X1BST1ZJREVSX0lORk8gPSB7XG4gIE5BTUU6ICdNZXRhTWFzaycsXG4gIFJETlM6IFsnaW8ubWV0YW1hc2snLCAnaW8ubWV0YW1hc2suZmxhc2snXSxcbn07XG5cbmV4cG9ydCBjb25zdCBVVUlEX1Y0X1JFR0VYID1cbiAgLyg/Ol5bYS1mMC05XXs4fS1bYS1mMC05XXs0fS00W2EtZjAtOV17M30tW2EtZjAtOV17NH0tW2EtZjAtOV17MTJ9JCl8KD86XjB7OH0tMHs0fS0wezR9LTB7NH0tMHsxMn0kKS91O1xuXG5leHBvcnQgY29uc3QgT05FX01JTlVURV9JTl9NUyA9IDYwICogMTAwMDtcbmV4cG9ydCBjb25zdCBPTkVfSE9VUl9JTl9NUyA9IE9ORV9NSU5VVEVfSU5fTVMgKiA2MDtcbiIsImV4cG9ydCBjb25zdCBSUENfTUVUSE9EUyA9IHtcbiAgTUVUQU1BU0tfR0VUUFJPVklERVJTVEFURTogJ21ldGFtYXNrX2dldFByb3ZpZGVyU3RhdGUnLFxuICBNRVRBTUFTS19DT05ORUNUU0lHTjogJ21ldGFtYXNrX2Nvbm5lY3RTaWduJyxcbiAgTUVUQU1BU0tfQ09OTkVDVFdJVEg6ICdtZXRhbWFza19jb25uZWN0V2l0aCcsXG4gIE1FVEFNQVNLX09QRU46ICdtZXRhbWFza19vcGVuJyxcbiAgTUVUQU1BU0tfQkFUQ0g6ICdtZXRhbWFza19iYXRjaCcsXG4gIFBFUlNPTkFMX1NJR046ICdwZXJzb25hbF9zaWduJyxcbiAgV0FMTEVUX1JFUVVFU1RQRVJNSVNTSU9OUzogJ3dhbGxldF9yZXF1ZXN0UGVybWlzc2lvbnMnLFxuICBXQUxMRVRfUkVWT0tFUEVSTUlTU0lPTlM6ICd3YWxsZXRfcmV2b2tlUGVybWlzc2lvbnMnLFxuICBXQUxMRVRfR0VUUEVSTUlTU0lPTlM6ICd3YWxsZXRfZ2V0UGVybWlzc2lvbnMnLFxuICBXQUxMRVRfV0FUQ0hBU1NFVDogJ3dhbGxldF93YXRjaEFzc2V0JyxcbiAgV0FMTEVUX0FEREVUSEVSRVVNQ0hBSU46ICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbicsXG4gIFdBTExFVF9TV0lUQ0hFVEhFVEhFUkVVTUNIQUlOOiAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nLFxuICBFVEhfUkVRVUVTVEFDQ09VTlRTOiAnZXRoX3JlcXVlc3RBY2NvdW50cycsXG4gIEVUSF9BQ0NPVU5UUzogJ2V0aF9hY2NvdW50cycsXG4gIEVUSF9DSEFJTklEOiAnZXRoX2NoYWluSWQnLFxuICBFVEhfU0VORFRSQU5TQUNUSU9OOiAnZXRoX3NlbmRUcmFuc2FjdGlvbicsXG4gIEVUSF9TSUdOVFlQRUREQVRBOiAnZXRoX3NpZ25UeXBlZERhdGEnLFxuICBFVEhfU0lHTlRZUEVEREFUQV9WMzogJ2V0aF9zaWduVHlwZWREYXRhX3YzJyxcbiAgRVRIX1NJR05UWVBFRERBVEFfVjQ6ICdldGhfc2lnblR5cGVkRGF0YV92NCcsXG4gIEVUSF9TSUdOVFJBTlNBQ1RJT046ICdldGhfc2lnblRyYW5zYWN0aW9uJyxcbiAgRVRIX1NJR046ICdldGhfc2lnbicsXG4gIFBFUlNPTkFMX0VDX1JFQ09WRVI6ICdwZXJzb25hbF9lY1JlY292ZXInLFxufTtcblxuZXhwb3J0IGNvbnN0IE1FVEhPRFNfVE9fUkVESVJFQ1Q6IHsgW21ldGhvZDogc3RyaW5nXTogYm9vbGVhbiB9ID0ge1xuICBbUlBDX01FVEhPRFMuRVRIX1JFUVVFU1RBQ0NPVU5UU106IHRydWUsXG4gIFtSUENfTUVUSE9EUy5FVEhfU0VORFRSQU5TQUNUSU9OXTogdHJ1ZSxcbiAgW1JQQ19NRVRIT0RTLkVUSF9TSUdOVFJBTlNBQ1RJT05dOiB0cnVlLFxuICBbUlBDX01FVEhPRFMuRVRIX1NJR05dOiB0cnVlLFxuICBbUlBDX01FVEhPRFMuUEVSU09OQUxfU0lHTl06IHRydWUsXG4gIC8vIHN0b3AgcmVkaXJlY3RpbmcgdGhlc2UgYXMgd2UgYXJlIGNhY2hpbmcgdmFsdWVzIGluIHRoZSBwcm92aWRlclxuICBbUlBDX01FVEhPRFMuRVRIX0FDQ09VTlRTXTogZmFsc2UsXG4gIFtSUENfTUVUSE9EUy5FVEhfQ0hBSU5JRF06IGZhbHNlLFxuICAvL1xuICBbUlBDX01FVEhPRFMuUEVSU09OQUxfU0lHTl06IHRydWUsXG4gIFtSUENfTUVUSE9EUy5FVEhfU0lHTlRZUEVEREFUQV06IHRydWUsXG4gIFtSUENfTUVUSE9EUy5FVEhfU0lHTlRZUEVEREFUQV9WM106IHRydWUsXG4gIFtSUENfTUVUSE9EUy5FVEhfU0lHTlRZUEVEREFUQV9WNF06IHRydWUsXG4gIFtSUENfTUVUSE9EUy5XQUxMRVRfUkVRVUVTVFBFUk1JU1NJT05TXTogdHJ1ZSxcbiAgW1JQQ19NRVRIT0RTLldBTExFVF9HRVRQRVJNSVNTSU9OU106IHRydWUsXG4gIFtSUENfTUVUSE9EUy5XQUxMRVRfV0FUQ0hBU1NFVF06IHRydWUsXG4gIFtSUENfTUVUSE9EUy5XQUxMRVRfQURERVRIRVJFVU1DSEFJTl06IHRydWUsXG4gIFtSUENfTUVUSE9EUy5XQUxMRVRfU1dJVENIRVRIRVRIRVJFVU1DSEFJTl06IHRydWUsXG4gIFtSUENfTUVUSE9EUy5NRVRBTUFTS19DT05ORUNUU0lHTl06IHRydWUsXG4gIFtSUENfTUVUSE9EUy5NRVRBTUFTS19DT05ORUNUV0lUSF06IHRydWUsXG4gIFtSUENfTUVUSE9EUy5QRVJTT05BTF9FQ19SRUNPVkVSXTogdHJ1ZSxcbiAgW1JQQ19NRVRIT0RTLk1FVEFNQVNLX0JBVENIXTogdHJ1ZSxcbiAgW1JQQ19NRVRIT0RTLk1FVEFNQVNLX09QRU5dOiB0cnVlLFxufTtcblxuZXhwb3J0IGNvbnN0IGxjQW5hbHl0aWNzUlBDcyA9IE9iamVjdC5rZXlzKE1FVEhPRFNfVE9fUkVESVJFQ1QpXG4gIC5maWx0ZXIoKG1ldGhvZCkgPT4gTUVUSE9EU19UT19SRURJUkVDVFttZXRob2RdID09PSB0cnVlKVxuICAubWFwKChtZXRob2QpID0+IG1ldGhvZC50b0xvd2VyQ2FzZSgpKTtcblxuLy8gdW5zdXBwb3J0ZWQgZXh0ZW5zaW9uIGNvbm5lY3RXaXRoIG1ldGhvZHNcbmV4cG9ydCBjb25zdCBycGNXaXRoQWNjb3VudFBhcmFtID0gW1xuICAnZXRoX3NpZ25UeXBlZERhdGEnLFxuICAnZXRoX3NpZ25UeXBlZERhdGFfdjMnLFxuICAnZXRoX3NpZ25UeXBlZERhdGFfdjQnLFxuICAnZXRoX3NpZ24nLFxuXS5tYXAoKG1ldGhvZCkgPT4gbWV0aG9kLnRvTG93ZXJDYXNlKCkpO1xuXG5leHBvcnQgY29uc3QgU1RPUkFHRV9QQVRIID0gJy5zZGstY29tbSc7XG5leHBvcnQgY29uc3QgU1RPUkFHRV9QUk9WSURFUl9UWVBFID0gJ3Byb3ZpZGVyVHlwZSc7XG5leHBvcnQgY29uc3QgU1RPUkFHRV9EQVBQX1NFTEVDVEVEX0FERFJFU1MgPSAnLk1NU0RLX2NhY2hlZF9hZGRyZXNzJztcbmV4cG9ydCBjb25zdCBTVE9SQUdFX0RBUFBfQ0hBSU5JRCA9ICcuTU1TREtfY2FjaGVkX2NoYWluSWQnO1xuXG5leHBvcnQgY29uc3QgRVhURU5TSU9OX0VWRU5UUyA9IHtcbiAgQ0hBSU5fQ0hBTkdFRDogJ2NoYWluQ2hhbmdlZCcsXG4gIEFDQ09VTlRTX0NIQU5HRUQ6ICdhY2NvdW50c0NoYW5nZWQnLFxuICBESVNDT05ORUNUOiAnZGlzY29ubmVjdCcsXG4gIENPTk5FQ1Q6ICdjb25uZWN0JyxcbiAgQ09OTkVDVEVEOiAnY29ubmVjdGVkJyxcbn07XG5cbmV4cG9ydCBjb25zdCBNQVhfTUVTU0FHRV9MRU5HVEggPSAxXzAwMF8wMDA7IC8vIDFNQiBsaW1pdFxuIiwiZXhwb3J0IGVudW0gUFJPVklERVJfVVBEQVRFX1RZUEUge1xuICAvKipcbiAgICogRW1pdHRlZCB3aGVuIHRoZSBzZGsgaXMgdGVybWluYXRlZC5cbiAgICovXG4gIFRFUk1JTkFURSA9ICd0ZXJtaW5hdGUnLFxuICAvKipcbiAgICogRW1pdHRlZCB3aGVuIHRoZSBzZGsgaXMgaW5pdGlhbGl6ZWQgdmlhIGV4dGVuc2lvbi5cbiAgICovXG4gIEVYVEVOU0lPTiA9ICdleHRlbnNpb24nLFxuICAvKipcbiAgICogRW1pdHRlZCB3aGVuIHRoZSBzZGsgaXMgaW5pdGlhbGl6ZWQgdmlhIGFueSBwcm92aWRlcnMgKGV4dGVuc2lvbiAvIG1vYmlsZSAvIGluLWFwcCBicm93c2VyICkuXG4gICAqL1xuICBJTklUSUFMSVpFRCA9ICdpbml0aWFsaXplZCcsXG59XG4iLCJpbXBvcnQge1xuICBSUENfTUVUSE9EUyxcbiAgU1RPUkFHRV9EQVBQX0NIQUlOSUQsXG4gIFNUT1JBR0VfREFQUF9TRUxFQ1RFRF9BRERSRVNTLFxuICBTVE9SQUdFX1BST1ZJREVSX1RZUEUsXG59IGZyb20gJy4uLy4uLy4uL2NvbmZpZyc7XG5pbXBvcnQgeyBNZXRhTWFza1NESyB9IGZyb20gJy4uLy4uLy4uL3Nkayc7XG5pbXBvcnQgeyBNZXRhTWFza1NES0V2ZW50IH0gZnJvbSAnLi4vLi4vLi4vdHlwZXMvTWV0YU1hc2tTREtFdmVudHMnO1xuaW1wb3J0IHsgUFJPVklERVJfVVBEQVRFX1RZUEUgfSBmcm9tICcuLi8uLi8uLi90eXBlcy9Qcm92aWRlclVwZGF0ZVR5cGUnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2VyJztcblxuY29uc3QgaGFzTG9jYWxTdG9hZ2UgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuXG4vKipcbiAqIFRlcm1pbmF0ZXMgdGhlIE1ldGFNYXNrIGNvbm5lY3Rpb24sIHN3aXRjaGluZyBiYWNrIHRvIHRoZSBpbmplY3RlZCBwcm92aWRlciBpZiBjb25uZWN0ZWQgdmlhIGV4dGVuc2lvbi5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGZpcnN0IGNoZWNrcyBpZiB0aGUgU0RLIGlzIHJ1bm5pbmcgd2l0aGluIE1ldGFNYXNrIE1vYmlsZSBXZWJWaWV3OyBpZiBpdCBpcyxcbiAqIG5vIHRlcm1pbmF0aW9uIGlzIHBlcmZvcm1lZC4gSWYgY29ubmVjdGVkIHZpYSBleHRlbnNpb24sIGl0IHJlbW92ZXMgdGhlIGFjdGl2ZSBleHRlbnNpb24gcHJvdmlkZXJcbiAqIGFuZCBzd2l0Y2hlcyBiYWNrIHRvIHRoZSBTREsncyBkZWZhdWx0IHByb3ZpZGVyLiBGaW5hbGx5LCBpdCBlbWl0cyBhIFBST1ZJREVSX1VQREFURSBldmVudCBvZiB0eXBlIFRFUk1JTkFURS5cbiAqXG4gKiBAcGFyYW0gaW5zdGFuY2UgVGhlIE1ldGFNYXNrU0RLIGluc3RhbmNlIHdob3NlIGNvbm5lY3Rpb24gc2hvdWxkIGJlIHRlcm1pbmF0ZWQuXG4gKiBAcmV0dXJucyB2b2lkXG4gKiBAZW1pdHMgRXZlbnRUeXBlLlBST1ZJREVSX1VQREFURSB3aXRoIHBheWxvYWQgUFJPVklERVJfVVBEQVRFX1RZUEUuVEVSTUlOQVRFIHdoZW4gdGhlIHByb3ZpZGVyIGlzIHVwZGF0ZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0ZXJtaW5hdGUoaW5zdGFuY2U6IE1ldGFNYXNrU0RLKSB7XG4gIC8vIG5vdGhpbmcgdG8gZG8gb24gaW5hcHAgYnJvd3Nlci5cbiAgaWYgKGluc3RhbmNlLnBsYXRmb3JtTWFuYWdlcj8uaXNNZXRhTWFza01vYmlsZVdlYlZpZXcoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChoYXNMb2NhbFN0b2FnZSkge1xuICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShTVE9SQUdFX1BST1ZJREVSX1RZUEUpO1xuICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShTVE9SQUdFX0RBUFBfQ0hBSU5JRCk7XG4gICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfREFQUF9TRUxFQ1RFRF9BRERSRVNTKTtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIGNvbm5lY3RlZCB3aXRoIGV4dGVuc2lvbiBwcm92aWRlclxuICAvLyBpZiBpdCBpcywgZGlzY29ubmVjdCBmcm9tIGl0IGFuZCBzd2l0Y2ggYmFjayB0byBpbmplY3RlZCBwcm92aWRlclxuICBpZiAoaW5zdGFuY2UuZXh0ZW5zaW9uQWN0aXZlKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFJldm9rZSBwZXJtaXNzaW9uc1xuICAgICAgYXdhaXQgaW5zdGFuY2UuYWN0aXZlUHJvdmlkZXI/LnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6IFJQQ19NRVRIT0RTLldBTExFVF9SRVZPS0VQRVJNSVNTSU9OUyxcbiAgICAgICAgcGFyYW1zOiBbeyBldGhfYWNjb3VudHM6IHt9IH1dLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZ2dlcihgW01ldGFNYXNrU0RLOiB0ZXJtaW5hdGUoKV0gZXJyb3IgcmV2b2tpbmcgcGVybWlzc2lvbnNgLCBlcnJvcik7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLm9wdGlvbnMuZXh0ZW5zaW9uT25seSkge1xuICAgICAgaW5zdGFuY2UuZW1pdChcbiAgICAgICAgTWV0YU1hc2tTREtFdmVudC5Qcm92aWRlclVwZGF0ZSxcbiAgICAgICAgUFJPVklERVJfVVBEQVRFX1RZUEUuVEVSTUlOQVRFLFxuICAgICAgKTtcblxuICAgICAgbG9nZ2VyKFxuICAgICAgICBgW01ldGFNYXNrU0RLOiB0ZXJtaW5hdGUoKV0gZXh0ZW5zaW9uT25seSAtLS0gcHJldmVudCBzd2l0Y2hpbmcgcHJvdmlkZXJzYCxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUmUtdXNlIGRlZmF1bHQgZXh0ZW5zaW9uIHByb3ZpZGVyIGFzIGRlZmF1bHRcbiAgICBpbnN0YW5jZS5hY3RpdmVQcm92aWRlciA9IGluc3RhbmNlLnNka1Byb3ZpZGVyO1xuICAgIHdpbmRvdy5ldGhlcmV1bSA9IGluc3RhbmNlLmFjdGl2ZVByb3ZpZGVyO1xuICAgIGluc3RhbmNlLmV4dGVuc2lvbkFjdGl2ZSA9IGZhbHNlO1xuICAgIGluc3RhbmNlLmVtaXQoXG4gICAgICBNZXRhTWFza1NES0V2ZW50LlByb3ZpZGVyVXBkYXRlLFxuICAgICAgUFJPVklERVJfVVBEQVRFX1RZUEUuVEVSTUlOQVRFLFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaW5zdGFuY2UuZW1pdChcbiAgICBNZXRhTWFza1NES0V2ZW50LlByb3ZpZGVyVXBkYXRlLFxuICAgIFBST1ZJREVSX1VQREFURV9UWVBFLlRFUk1JTkFURSxcbiAgKTtcblxuICBsb2dnZXIoXG4gICAgYFtNZXRhTWFza1NESzogdGVybWluYXRlKCldIHJlbW90ZUNvbm5lY3Rpb249JHtpbnN0YW5jZS5yZW1vdGVDb25uZWN0aW9ufWAsXG4gICk7XG5cbiAgLy8gT25seSBkaXNjb25uZWN0IGlmIHRoZSBjb25uZWN0aW9uIGlzIGFjdGl2ZVxuICBpbnN0YW5jZS5yZW1vdGVDb25uZWN0aW9uPy5kaXNjb25uZWN0KHtcbiAgICB0ZXJtaW5hdGU6IHRydWUsXG4gICAgc2VuZE1lc3NhZ2U6IHRydWUsXG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IFJQQ19NRVRIT0RTIH0gZnJvbSAnLi4vLi4vLi4vY29uZmlnJztcbmltcG9ydCB7IE1ldGFNYXNrU0RLIH0gZnJvbSAnLi4vLi4vLi4vc2RrJztcbmltcG9ydCB7IGlzSGV4U3RyaW5nLCBzdHJpbmdUb0hleCB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2hleC51dGlscyc7XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgY29ubmVjdHMgdG8gTWV0YU1hc2ssIHJlcXVlc3RzIGFjY291bnQgYWNjZXNzIGFuZCBzaWduIG1lc3NhZ2UuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBmaXJzdCBjaGVja3Mgd2hldGhlciB0aGUgTWV0YU1hc2tTREsgaW5zdGFuY2UgaXMgaW5pdGlhbGl6ZWQuXG4gKiBJZiBub3QsIGl0IGluaXRpYWxpemVzIHRoZSBpbnN0YW5jZS4gSXQgdGhlbiBtYWtlcyBhIHJlcXVlc3QgdG8gYWNjZXNzIGFjY291bnRzXG4gKiBhbmQgdGhlIHNpZ24gdGhlIG1lc3NhZ2Ugd2l0aCB0aGUgZmlyc3QgYWNjb3VudC5cbiAqXG4gKiBAcGFyYW0gaW5zdGFuY2UgVGhlIE1ldGFNYXNrU0RLIGluc3RhbmNlIHRvIGNvbm5lY3QgdG8uXG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgcmVzdWx0IG9mIHBlcnNvbmFsX3NpZ24gb24gdGhlIG1zZy5cbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGFjdGl2ZVByb3ZpZGVyIGlzIHVuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbm5lY3RBbmRTaWduKHtcbiAgaW5zdGFuY2UsXG4gIG1zZyxcbn06IHtcbiAgaW5zdGFuY2U6IE1ldGFNYXNrU0RLO1xuICBtc2c6IHN0cmluZztcbn0pIHtcbiAgaWYgKCFpbnN0YW5jZS5faW5pdGlhbGl6ZWQpIHtcbiAgICBsb2dnZXIoXG4gICAgICBgW01ldGFNYXNrU0RLOiBjb25uZWN0QW5kU2lnbigpXSBwcm92aWRlciBub3QgcmVhZHkgLS0gd2FpdCBmb3IgaW5pdCgpYCxcbiAgICApO1xuXG4gICAgYXdhaXQgaW5zdGFuY2UuaW5pdCgpO1xuICB9XG5cbiAgbG9nZ2VyKFxuICAgIGBbTWV0YU1hc2tTREs6IGNvbm5lY3RBbmRTaWduKCldIGFjdGl2ZVByb3ZpZGVyPSR7aW5zdGFuY2UuYWN0aXZlUHJvdmlkZXJ9YCxcbiAgKTtcblxuICBpZiAoIWluc3RhbmNlLmFjdGl2ZVByb3ZpZGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTREsgc3RhdGUgaW52YWxpZCAtLSB1bmRlZmluZWQgcHJvdmlkZXJgKTtcbiAgfVxuXG4gIC8vIENoZWNrIGlmIG1zZyBpcyBhIGhleCBzdHJpbmcgYW5kIGNvbnZlcnQgaWYgbm90XG4gIGNvbnN0IGhleE1zZyA9IGlzSGV4U3RyaW5nKG1zZykgPyBtc2cgOiBzdHJpbmdUb0hleChtc2cpO1xuXG4gIHJldHVybiBpbnN0YW5jZS5hY3RpdmVQcm92aWRlci5yZXF1ZXN0KHtcbiAgICBtZXRob2Q6IFJQQ19NRVRIT0RTLk1FVEFNQVNLX0NPTk5FQ1RXSVRILFxuICAgIHBhcmFtczogW1xuICAgICAge1xuICAgICAgICBtZXRob2Q6IFJQQ19NRVRIT0RTLlBFUlNPTkFMX1NJR04sXG4gICAgICAgIHBhcmFtczogW2hleE1zZ10sXG4gICAgICB9LFxuICAgIF0sXG4gIH0pO1xufVxuIiwiLy8gSGVscGVyIGZ1bmN0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIC9eMHgoWzAtOUEtRmEtZl17Mn0pKiQvdS50ZXN0KHZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ1RvSGV4KHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICBsZXQgaGV4U3RyaW5nOiBzdHJpbmc7XG5cbiAgaWYgKHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTm9kZS5qcyBlbnZpcm9ubWVudFxuICAgIGhleFN0cmluZyA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmOCcpLnRvU3RyaW5nKCdoZXgnKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgVGV4dEVuY29kZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gV2ViIGVudmlyb25tZW50XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgaGV4U3RyaW5nID0gQXJyYXkuZnJvbSh1aW50OEFycmF5KVxuICAgICAgLm1hcCgoYnl0ZSkgPT4gYnl0ZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSlcbiAgICAgIC5qb2luKCcnKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiAnQnVmZmVyJyBpbiBnbG9iYWwpIHtcbiAgICAvLyBSZWFjdCBOYXRpdmUgZW52aXJvbm1lbnRcbiAgICBoZXhTdHJpbmcgPSBnbG9iYWwuQnVmZmVyLmZyb20odmFsdWUsICd1dGY4JykudG9TdHJpbmcoJ2hleCcpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNvbnZlcnQgc3RyaW5nIHRvIGhleDogTm8gYXZhaWxhYmxlIG1ldGhvZC4nKTtcbiAgfVxuXG4gIHJldHVybiBgMHgke2hleFN0cmluZ31gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9TdHJpbmcoaGV4OiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoIWlzSGV4U3RyaW5nKGhleCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpO1xuICB9XG5cbiAgaWYgKGhleCA9PT0gJzB4Jykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGNvbnN0IGhleFdpdGhvdXRQcmVmaXggPSBoZXguc2xpY2UoMik7XG4gIGxldCBzdHJpbmc6IHN0cmluZztcblxuICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBOb2RlLmpzIGVudmlyb25tZW50XG4gICAgc3RyaW5nID0gQnVmZmVyLmZyb20oaGV4V2l0aG91dFByZWZpeCwgJ2hleCcpLnRvU3RyaW5nKCd1dGY4Jyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIFdlYiBlbnZpcm9ubWVudFxuICAgIGNvbnN0IG1hdGNoZXMgPSBoZXhXaXRob3V0UHJlZml4Lm1hdGNoKC8uezEsMn0vZ3UpO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShtYXRjaGVzLm1hcCgoYnl0ZSkgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKSk7XG4gICAgc3RyaW5nID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpLmRlY29kZShieXRlcyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCA9PT0gJ29iamVjdCcgJiYgJ0J1ZmZlcicgaW4gZ2xvYmFsKSB7XG4gICAgLy8gUmVhY3QgTmF0aXZlIGVudmlyb25tZW50XG4gICAgc3RyaW5nID0gZ2xvYmFsLkJ1ZmZlci5mcm9tKGhleFdpdGhvdXRQcmVmaXgsICdoZXgnKS50b1N0cmluZygndXRmOCcpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGNvbnZlcnQgaGV4IHRvIHN0cmluZzogTm8gYXZhaWxhYmxlIG1ldGhvZC4nKTtcbiAgfVxuXG4gIHJldHVybiBzdHJpbmc7XG59XG4iLCJpbXBvcnQgeyBUcmFja2luZ0V2ZW50cyB9IGZyb20gJ0BtZXRhbWFzay9zZGstY29tbXVuaWNhdGlvbi1sYXllcic7XG5pbXBvcnQgeyBTVE9SQUdFX1BST1ZJREVSX1RZUEUgfSBmcm9tICcuLi8uLi8uLi9jb25maWcnO1xuaW1wb3J0IHsgTWV0YU1hc2tTREsgfSBmcm9tICcuLi8uLi8uLi9zZGsnO1xuaW1wb3J0IHsgTWV0YU1hc2tTREtFdmVudCB9IGZyb20gJy4uLy4uLy4uL3R5cGVzL01ldGFNYXNrU0RLRXZlbnRzJztcbmltcG9ydCB7IFBST1ZJREVSX1VQREFURV9UWVBFIH0gZnJvbSAnLi4vLi4vLi4vdHlwZXMvUHJvdmlkZXJVcGRhdGVUeXBlJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvZ2dlcic7XG5cbi8qKlxuICogQ29ubmVjdHMgdGhlIE1ldGFNYXNrU0RLIGluc3RhbmNlIHRvIHRoZSBNZXRhTWFzayBicm93c2VyIGV4dGVuc2lvbiBhcyB0aGUgYWN0aXZlIHByb3ZpZGVyLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gc3dhcHMgdGhlIGN1cnJlbnQgYWN0aXZlIHByb3ZpZGVyIG9mIHRoZSBTREsgd2l0aCB0aGUgTWV0YU1hc2sgYnJvd3NlciBleHRlbnNpb24gYW5kIHNldHMgaXRcbiAqIGFzIHRoZSBkZWZhdWx0IEV0aGVyZXVtIHByb3ZpZGVyIGluIHRoZSB3aW5kb3cgb2JqZWN0LiBJdCB0aGVuIGF0dGVtcHRzIHRvIGluaXRpYWxpemUgYSBjb25uZWN0aW9uIHdpdGhcbiAqIHRoZSBleHRlbnNpb24gYnkgcmVxdWVzdGluZyBhY2Nlc3MgdG8gdGhlIHVzZXIncyBhY2NvdW50cy5cbiAqXG4gKiBJZiBzdWNjZXNzZnVsLCB0aGUgZnVuY3Rpb24gdXBkYXRlcyB0aGUgbG9jYWwgc3RvcmFnZSB0byByZW1lbWJlciB0aGlzIHByZWZlcmVuY2UgZm9yIGZ1dHVyZSBzZXNzaW9ucy4gQW4gZXZlbnRcbiAqIGFuZCBhbiBhbmFseXRpY3MgZXZlbnQgYXJlIGFsc28gZW1pdHRlZCB0byBpbmRpY2F0ZSB0aGF0IHRoZSBhY3RpdmUgcHJvdmlkZXIgaGFzIGJlZW4gdXBkYXRlZCB0byB0aGUgZXh0ZW5zaW9uLlxuICpcbiAqIEBwYXJhbSBpbnN0YW5jZSBUaGUgY3VycmVudCBpbnN0YW5jZSBvZiB0aGUgTWV0YU1hc2tTREssIHdoaWNoIGNvbnRhaW5zIHVzZXItZGVmaW5lZCBvciBkZWZhdWx0IG9wdGlvbnMuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY29ubmVjdGlvbiBoYXMgYmVlbiBlc3RhYmxpc2hlZCBvciBhbiBlcnJvciBoYXMgYmVlbiBjYXVnaHQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb25uZWN0V2l0aEV4dGVuc2lvblByb3ZpZGVyKGluc3RhbmNlOiBNZXRhTWFza1NESykge1xuICBsb2dnZXIoYFtNZXRhTWFza1NESzogY29ubmVjdFdpdGhFeHRlbnNpb25Qcm92aWRlcigpXSBgLCBpbnN0YW5jZSk7XG5cbiAgLy8gc2F2ZSBhIGNvcHkgb2YgdGhlIGluc3RhbmNlIGJlZm9yZSBpdCBnZXRzIG92ZXJ3cml0dGVuXG4gIGluc3RhbmNlLnNka1Byb3ZpZGVyID0gaW5zdGFuY2UuYWN0aXZlUHJvdmlkZXI7XG4gIGluc3RhbmNlLmFjdGl2ZVByb3ZpZGVyID0gd2luZG93LmV4dGVuc2lvbiBhcyBhbnk7XG4gIC8vIFNldCBleHRlbnNpb24gcHJvdmlkZXIgYXMgZGVmYXVsdCBvbiB3aW5kb3dcbiAgd2luZG93LmV0aGVyZXVtID0gd2luZG93LmV4dGVuc2lvbiBhcyBhbnk7XG5cbiAgdHJ5IHtcbiAgICAvLyBhbHdheXMgY3JlYXRlIGluaXRpYWwgcXVlcnkgdG8gY29ubmVjdCB0aGUgYWNjb3VudFxuICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgd2luZG93LmV4dGVuc2lvbj8ucmVxdWVzdCh7XG4gICAgICBtZXRob2Q6ICdldGhfcmVxdWVzdEFjY291bnRzJyxcbiAgICB9KTtcblxuICAgIGxvZ2dlcihcbiAgICAgIGBbTWV0YU1hc2tTREs6IGNvbm5lY3RXaXRoRXh0ZW5zaW9uUHJvdmlkZXIoKV0gYWNjb3VudHM9JHthY2NvdW50c31gLFxuICAgICk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIGlnbm9yZSBlcnJvclxuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBbTWV0YU1hc2tTREs6IGNvbm5lY3RXaXRoRXh0ZW5zaW9uUHJvdmlkZXIoKV0gY2FuJ3QgcmVxdWVzdCBhY2NvdW50cyBlcnJvcmAsXG4gICAgICBlcnIsXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyByZW1lbWJlciBzZXR0aW5nIGZvciBuZXh0IHRpbWUgKHVudGlsIHRlcm1pbmF0ZWQpXG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfUFJPVklERVJfVFlQRSwgJ2V4dGVuc2lvbicpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hdG9taWMtdXBkYXRlc1xuICBpbnN0YW5jZS5leHRlbnNpb25BY3RpdmUgPSB0cnVlO1xuICBpbnN0YW5jZS5lbWl0KFxuICAgIE1ldGFNYXNrU0RLRXZlbnQuUHJvdmlkZXJVcGRhdGUsXG4gICAgUFJPVklERVJfVVBEQVRFX1RZUEUuRVhURU5TSU9OLFxuICApO1xuXG4gIGlmIChpbnN0YW5jZS5vcHRpb25zLmVuYWJsZUFuYWx5dGljcykge1xuICAgIGluc3RhbmNlLmFuYWx5dGljcz8uc2VuZCh7IGV2ZW50OiBUcmFja2luZ0V2ZW50cy5TREtfVVNFX0VYVEVOU0lPTiB9KTtcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NEVuY29kZShzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCBiYXNlNjRzdHJpbmc6IHN0cmluZztcblxuICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBiYXNlNjRzdHJpbmcgPSBCdWZmZXIuZnJvbShzdHIsICd1dGY4JykudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYmFzZTY0c3RyaW5nID0gYnRvYShcbiAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoLyUoWzAtOUEtRl17Mn0pL2d1LCAoX21hdGNoLCBwMSkgPT5cbiAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChwMSwgMTYpKSxcbiAgICAgICksXG4gICAgKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiAnQnVmZmVyJyBpbiBnbG9iYWwpIHtcbiAgICBiYXNlNjRzdHJpbmcgPSBnbG9iYWwuQnVmZmVyLmZyb20oc3RyLCAndXRmOCcpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBiYXNlNjQgZW5jb2RlOiBObyBhdmFpbGFibGUgbWV0aG9kLicpO1xuICB9XG4gIHJldHVybiBiYXNlNjRzdHJpbmc7XG59XG4iLCJpbXBvcnQgeyBSZW1vdGVDb21tdW5pY2F0aW9uUG9zdE1lc3NhZ2VTdHJlYW0gfSBmcm9tICcuLi8uLi9Qb3N0TWVzc2FnZVN0cmVhbS9SZW1vdGVDb21tdW5pY2F0aW9uUG9zdE1lc3NhZ2VTdHJlYW0nO1xuaW1wb3J0IHtcbiAgTUVUSE9EU19UT19SRURJUkVDVCxcbiAgUlBDX01FVEhPRFMsXG4gIE1BWF9NRVNTQUdFX0xFTkdUSCxcbn0gZnJvbSAnLi4vLi4vY29uZmlnJztcbmltcG9ydCB7XG4gIE1FVEFNQVNLX0NPTk5FQ1RfQkFTRV9VUkwsXG4gIE1FVEFNQVNLX0RFRVBMSU5LX0JBU0UsXG59IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBiYXNlNjRFbmNvZGUgfSBmcm9tICcuLi8uLi91dGlscy9iYXNlNjQnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEV0aGVyZXVtIH0gZnJvbSAnLi4vRXRoZXJldW0nO1xuaW1wb3J0IHsgZXh0cmFjdE1ldGhvZCB9IGZyb20gJy4vZXh0cmFjdE1ldGhvZCc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3cml0ZShcbiAgaW5zdGFuY2U6IFJlbW90ZUNvbW11bmljYXRpb25Qb3N0TWVzc2FnZVN0cmVhbSxcbiAgY2h1bms6IGFueSxcbiAgX2VuY29kaW5nOiBCdWZmZXJFbmNvZGluZyxcbiAgY2FsbGJhY2s6IChlcnJvcj86IEVycm9yIHwgbnVsbCkgPT4gdm9pZCxcbikge1xuICAvLyBTcGVjaWFsIENhc2UgaWYgdHJ1c3RlZCBkZXZpY2UgKFJOIG9yIG1vYmlsZSB3ZWIpLCB3ZSBzdGlsbCBjcmVhdGUgZGVlcGxpbmsgdG8gd2FrZSB1cCB0aGUgY29ubmVjdGlvbi5cbiAgY29uc3QgaXNSZW1vdGVSZWFkeSA9IGluc3RhbmNlLnN0YXRlLnJlbW90ZT8uaXNSZWFkeSgpO1xuICBjb25zdCBzb2NrZXRDb25uZWN0ZWQgPSBpbnN0YW5jZS5zdGF0ZS5yZW1vdGU/LmlzQ29ubmVjdGVkKCk7XG4gIGNvbnN0IGlzUGF1c2VkID0gaW5zdGFuY2Uuc3RhdGUucmVtb3RlPy5pc1BhdXNlZCgpO1xuICBjb25zdCBwcm92aWRlciA9IEV0aGVyZXVtLmdldFByb3ZpZGVyKCk7XG4gIGNvbnN0IGNoYW5uZWxJZCA9IGluc3RhbmNlLnN0YXRlLnJlbW90ZT8uZ2V0Q2hhbm5lbElkKCk7XG4gIGNvbnN0IGF1dGhvcml6ZWQgPSBpbnN0YW5jZS5zdGF0ZS5yZW1vdGU/LmlzQXV0aG9yaXplZCgpO1xuICBjb25zdCB7IGRlZXBsaW5rUHJvdG9jb2wgfSA9IGluc3RhbmNlLnN0YXRlO1xuICBjb25zdCB7XG4gICAgbWV0aG9kOiB0YXJnZXRNZXRob2QsXG4gICAgZGF0YSxcbiAgICB0cmlnZ2VyZWRJbnN0YWxsZXIsXG4gIH0gPSBleHRyYWN0TWV0aG9kKGNodW5rKTtcblxuICBsb2dnZXIoXG4gICAgYFtSQ1BNUzogd3JpdGUoKV0gbWV0aG9kPScke3RhcmdldE1ldGhvZH0nIGlzUmVtb3RlUmVhZHk9JHtpc1JlbW90ZVJlYWR5fSBjaGFubmVsSWQ9JHtjaGFubmVsSWR9IGlzU29ja2V0Q29ubmVjdGVkPSR7c29ja2V0Q29ubmVjdGVkfSBpc1JlbW90ZVBhdXNlZD0ke2lzUGF1c2VkfSBwcm92aWRlckNvbm5lY3RlZD0ke3Byb3ZpZGVyLmlzQ29ubmVjdGVkKCl9YCxcbiAgICBjaHVuayxcbiAgKTtcblxuICBpZiAoIWNoYW5uZWxJZCkge1xuICAgIC8vIGlnbm9yZSBpbml0aWFsIG1ldGFtYXNrX2dldFByb3ZpZGVyU3RhdGUoKSBjYWxsIGZyb20gZXRoZXJldW0uaW5pdCgpXG4gICAgaWYgKHRhcmdldE1ldGhvZCAhPT0gUlBDX01FVEhPRFMuTUVUQU1BU0tfR0VUUFJPVklERVJTVEFURSkge1xuICAgICAgbG9nZ2VyKGBbUkNQTVM6IHdyaXRlKCldICR7dGFyZ2V0TWV0aG9kfSAtLT4gY2hhbm5lbElkIGlzIHVuZGVmaW5lZGApO1xuICAgIH1cblxuICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ2Rpc2Nvbm5lY3RlZCcpKTtcbiAgfVxuXG4gIGxvZ2dlcihcbiAgICBgW1JDUE1TOiB3cml0ZSgpXSByZW1vdGUuaXNQYXVzZWQoKT0ke2luc3RhbmNlLnN0YXRlLnJlbW90ZT8uaXNQYXVzZWQoKX0gYXV0aG9yaXplZD0ke2F1dGhvcml6ZWR9IHJlYWR5PSR7aXNSZW1vdGVSZWFkeX0gc29ja2V0Q29ubmVjdGVkPSR7c29ja2V0Q29ubmVjdGVkfWAsXG4gICAgY2h1bmssXG4gICk7XG5cbiAgLy8gaXNTZWN1cmUgaXMgb25seSBhdmFpbGFibGUgaW4gUk4gYW5kIG1vYmlsZSB3ZWJcbiAgY29uc3QgaXNTZWN1cmUgPSBpbnN0YW5jZS5zdGF0ZS5wbGF0Zm9ybU1hbmFnZXI/LmlzU2VjdXJlKCk7XG4gIGNvbnN0IG1vYmlsZVdlYiA9IGluc3RhbmNlLnN0YXRlLnBsYXRmb3JtTWFuYWdlcj8uaXNNb2JpbGVXZWIoKSA/PyBmYWxzZTtcbiAgY29uc3QgZGVlcGxpbmtQcm90b2NvbEF2YWlsYWJsZSA9XG4gICAgaW5zdGFuY2Uuc3RhdGUucmVtb3RlPy5oYXNEZWVwbGlua1Byb3RvY29sKCkgPz8gZmFsc2U7XG4gIGNvbnN0IGFjdGl2ZURlZXBsaW5rUHJvdG9jb2wgPVxuICAgIGRlZXBsaW5rUHJvdG9jb2xBdmFpbGFibGUgJiYgbW9iaWxlV2ViICYmIGF1dGhvcml6ZWQ7XG5cbiAgdHJ5IHtcbiAgICBpZiAoIXRyaWdnZXJlZEluc3RhbGxlcikge1xuICAgICAgLy8gQ2hlY2sgbWVzc2FnZSBzaXplIGJlZm9yZSBzZW5kaW5nXG4gICAgICBjb25zdCBzdHJpbmdpZmllZERhdGEgPSBKU09OLnN0cmluZ2lmeShkYXRhPy5kYXRhKTtcbiAgICAgIGlmIChzdHJpbmdpZmllZERhdGEubGVuZ3RoID4gTUFYX01FU1NBR0VfTEVOR1RIKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgTWVzc2FnZSBzaXplICR7c3RyaW5naWZpZWREYXRhLmxlbmd0aH0gZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgc2l6ZSBvZiAke01BWF9NRVNTQUdFX0xFTkdUSH0gYnl0ZXNgLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBvbmx5IHJlYXNvbiBub3QgdG8gc2VuZCB2aWEgbmV0d29yayBpcyBiZWNhdXNlIHRoZSBycGMgY2FsbCB3aWxsIGJlIHNlbnQgaW4gdGhlIGRlZXBsaW5rXG4gICAgICBpbnN0YW5jZS5zdGF0ZS5yZW1vdGVcbiAgICAgICAgPy5zZW5kTWVzc2FnZShkYXRhPy5kYXRhKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyKGBbUkNQTVM6IF93cml0ZSgpXSAke3RhcmdldE1ldGhvZH0gc2VudCBzdWNjZXNzZnVsbHlgKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnI6IHVua25vd24pID0+IHtcbiAgICAgICAgICBsb2dnZXIoYFtSQ1BNUzogX3dyaXRlKCldIGVycm9yIHNlbmRpbmcgbWVzc2FnZWAsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghaXNTZWN1cmUpIHtcbiAgICAgIC8vIFJlZGlyZWN0IGVhcmx5IGlmIG5vZGVqcyBvciBicm93c2VyLi4uXG4gICAgICBsb2dnZXIoXG4gICAgICAgIGBbUkNQTVM6IF93cml0ZSgpXSB1bnNlY3VyZSBwbGF0Zm9ybSBmb3IgbWV0aG9kICR7dGFyZ2V0TWV0aG9kfSAtLSByZXR1cm4gY2FsbGJhY2tgLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGlmICh0cmlnZ2VyZWRJbnN0YWxsZXIpIHtcbiAgICAgIGxvZ2dlcihcbiAgICAgICAgYFtSQ1BNUzogX3dyaXRlKCldIHByZXZlbnQgZGVlcGxpbmsgLS0gaW5zdGFsbGF0aW9uIGNvbXBsZXRlZCBzZXBhcmF0ZWx5LmAsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgY29uc3QgcHViS2V5ID0gaW5zdGFuY2Uuc3RhdGUucmVtb3RlPy5nZXRLZXlJbmZvKCk/LmVjaWVzLnB1YmxpYyA/PyAnJztcbiAgICBsZXQgdXJsUGFyYW1zID0gZW5jb2RlVVJJKFxuICAgICAgYGNoYW5uZWxJZD0ke2NoYW5uZWxJZH0mcHVia2V5PSR7cHViS2V5fSZjb21tPXNvY2tldCZ0PWQmdj0yYCxcbiAgICApO1xuXG4gICAgaWYgKGFjdGl2ZURlZXBsaW5rUHJvdG9jb2wpIHtcbiAgICAgIGNvbnN0IGpzb25ycGMgPSBKU09OLnN0cmluZ2lmeShkYXRhPy5kYXRhKTtcbiAgICAgIGNvbnN0IGVuY3J5cHRlZCA9IGluc3RhbmNlLnN0YXRlLnJlbW90ZT8uZW5jcnlwdChqc29ucnBjKTtcbiAgICAgIGlmICghZW5jcnlwdGVkKSB7XG4gICAgICAgIGxvZ2dlcihgW1JDUE1TOiBfd3JpdGUoKV0gZXJyb3IgZW5jcnlwdGluZyBtZXNzYWdlYCk7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhcbiAgICAgICAgICBuZXcgRXJyb3IoJ1JlbW90ZUNvbW11bmljYXRpb25Qb3N0TWVzc2FnZVN0cmVhbSAtIGRpc2Nvbm5lY3RlZCcpLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgZW5jb2RlZCA9IGJhc2U2NEVuY29kZShlbmNyeXB0ZWQpO1xuICAgICAgdXJsUGFyYW1zICs9IGAmc2NoZW1lPSR7ZGVlcGxpbmtQcm90b2NvbH0mcnBjPSR7ZW5jb2RlZH1gO1xuICAgIH1cblxuICAgIGlmICghaW5zdGFuY2Uuc3RhdGUucGxhdGZvcm1NYW5hZ2VyPy5pc01ldGFNYXNrSW5zdGFsbGVkKCkpIHtcbiAgICAgIGxvZ2dlcihcbiAgICAgICAgYFtSQ1BNUzogX3dyaXRlKCldIHByZXZlbnQgZGVlcGxpbmsgdW50aWwgaW5zdGFsbGF0aW9uIGlzIGNvbXBsZXRlZC5gLFxuICAgICAgKTtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgIH1cblxuICAgIGlmIChNRVRIT0RTX1RPX1JFRElSRUNUW3RhcmdldE1ldGhvZF0pIHtcbiAgICAgIGxvZ2dlcihcbiAgICAgICAgYFtSQ1BNUzogX3dyaXRlKCldIHJlZGlyZWN0IGxpbmsgZm9yICcke3RhcmdldE1ldGhvZH0nIHNvY2tldENvbm5lY3RlZD0ke3NvY2tldENvbm5lY3RlZH0gY29ubmVjdD8ke3VybFBhcmFtc31gLFxuICAgICAgKTtcblxuICAgICAgaW5zdGFuY2Uuc3RhdGUucGxhdGZvcm1NYW5hZ2VyPy5vcGVuRGVlcGxpbmsoXG4gICAgICAgIGAke01FVEFNQVNLX0NPTk5FQ1RfQkFTRV9VUkx9PyR7dXJsUGFyYW1zfWAsXG4gICAgICAgIGAke01FVEFNQVNLX0RFRVBMSU5LX0JBU0V9PyR7dXJsUGFyYW1zfWAsXG4gICAgICAgICdfc2VsZicsXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaW5zdGFuY2Uuc3RhdGUucmVtb3RlPy5pc1BhdXNlZCgpKSB7XG4gICAgICBsb2dnZXIoXG4gICAgICAgIGBbUkNQTVM6IF93cml0ZSgpXSBNTSBpcyBQQVVTRUQhIGRlZXBsaW5rIHdpdGggY29ubmVjdCEgdGFyZ2V0TWV0aG9kPSR7dGFyZ2V0TWV0aG9kfWAsXG4gICAgICApO1xuXG4gICAgICBpbnN0YW5jZS5zdGF0ZS5wbGF0Zm9ybU1hbmFnZXI/Lm9wZW5EZWVwbGluayhcbiAgICAgICAgYCR7TUVUQU1BU0tfQ09OTkVDVF9CQVNFX1VSTH0/cmVkaXJlY3Q9dHJ1ZSYke3VybFBhcmFtc31gLFxuICAgICAgICBgJHtNRVRBTUFTS19ERUVQTElOS19CQVNFfT9yZWRpcmVjdD10cnVlJiR7dXJsUGFyYW1zfWAsXG4gICAgICAgICdfc2VsZicsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBbHJlYWR5IGNvbm5lY3RlZCB3aXRoIGN1c3RvbSBycGMgbWV0aG9kIChkb24ndCBuZWVkIHJlZGlyZWN0KSAtIHNlbmQgbWVzc2FnZSB3aXRob3V0IG9wZW5pbmcgbWV0YW1hc2sgbW9iaWxlLlxuICAgICAgLy8gaW5zdGFuY2Ugb25seSBoYXBwZW5zIHdoZW4gbWV0YW1hc2sgd2FzIG9wZW5lZCBpbiBsYXN0IDMwc2Vjb25kcy5cbiAgICAgIGxvZ2dlcihgW1JDUE1TOiBfd3JpdGUoKV0gbWV0aG9kICR7dGFyZ2V0TWV0aG9kfSBkb2Vzbid0IG5lZWQgcmVkaXJlY3QuYCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBsb2dnZXIoYFtSQ1BNUzogX3dyaXRlKCldIGVycm9yIHNlbmRpbmcgbWVzc2FnZWAsIGVycik7XG5cbiAgICByZXR1cm4gY2FsbGJhY2soXG4gICAgICBuZXcgRXJyb3IoJ1JlbW90ZUNvbW11bmljYXRpb25Qb3N0TWVzc2FnZVN0cmVhbSAtIGRpc2Nvbm5lY3RlZCcpLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2soKTtcbn1cbiIsImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcic7XG5cbi8vIFRPRE8gcmVmYWN0b3IgdG8gaGF2ZSBwcm9wZXIgdHlwZXMgb24gZGF0YVxuZXhwb3J0IGNvbnN0IGV4dHJhY3RNZXRob2QgPSAoXG4gIGNodW5rOiBhbnksXG4pOiB7IG1ldGhvZDogc3RyaW5nOyBkYXRhOiBhbnk7IHRyaWdnZXJlZEluc3RhbGxlcj86IGJvb2xlYW4gfSA9PiB7XG4gIGxldCBkYXRhOiBhbnk7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgZGF0YSA9IGNodW5rLnRvSlNPTigpO1xuICAgIGRhdGEuX2lzQnVmZmVyID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhID0gY2h1bms7XG4gIH1cblxuICBjb25zdCB0YXJnZXRNZXRob2QgPSBkYXRhPy5kYXRhPy5tZXRob2QgYXMgc3RyaW5nO1xuXG4gIC8vIENoZWNrIGlmIHRoaXMgcmVxdWVzdCB0cmlnZ2VyZWQgdGhlIGluc3RhbGxlclxuICBsZXQgdHJpZ2dlcmVkSW5zdGFsbGVyID0gZmFsc2U7XG4gIGlmIChcbiAgICB0eXBlb2YgZGF0YT8uZGF0YT8ucGFyYW1zID09PSAnb2JqZWN0JyAmJlxuICAgIGRhdGE/LmRhdGE/LnBhcmFtcz8uX190cmlnZ2VyZWRJbnN0YWxsZXIgPT09IHRydWVcbiAgKSB7XG4gICAgdHJpZ2dlcmVkSW5zdGFsbGVyID0gdHJ1ZTtcbiAgICAvLyB1bndyYXAgdGhlIHBhcmFtcyBvYmplY3RcbiAgICBkYXRhLmRhdGEucGFyYW1zID0gZGF0YS5kYXRhLnBhcmFtcy53cmFwcGVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHsgbWV0aG9kOiB0YXJnZXRNZXRob2QsIGRhdGEsIHRyaWdnZXJlZEluc3RhbGxlciB9O1xufTtcbiIsImltcG9ydCB7XG4gIENvbW11bmljYXRpb25MYXllck1lc3NhZ2UsXG4gIEV2ZW50VHlwZSxcbiAgUmVtb3RlQ29tbXVuaWNhdGlvbixcbn0gZnJvbSAnQG1ldGFtYXNrL3Nkay1jb21tdW5pY2F0aW9uLWxheWVyJztcbmltcG9ydCB7IER1cGxleCB9IGZyb20gJ3JlYWRhYmxlLXN0cmVhbSc7XG5pbXBvcnQgeyBQbGF0Zm9ybU1hbmFnZXIgfSBmcm9tICcuLi9QbGF0Zm9ybS9QbGF0ZmZvcm1NYW5hZ2VyJztcbmltcG9ydCB7IFByb3ZpZGVyQ29uc3RhbnRzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IG9uTWVzc2FnZSB9IGZyb20gJy4uL3NlcnZpY2VzL1JlbW90ZUNvbW11bmljYXRpb25Qb3N0TWVzc2FnZVN0cmVhbS9vbk1lc3NhZ2UnO1xuaW1wb3J0IHsgd3JpdGUgfSBmcm9tICcuLi9zZXJ2aWNlcy9SZW1vdGVDb21tdW5pY2F0aW9uUG9zdE1lc3NhZ2VTdHJlYW0vd3JpdGUnO1xuaW1wb3J0IHsgUG9zdE1lc3NhZ2VTdHJlYW0gfSBmcm9tICcuL1Bvc3RNZXNzYWdlU3RyZWFtJztcblxuaW50ZXJmYWNlIFJlbW90ZUNvbW11bmljYXRpb25Qb3N0TWVzc2FnZVN0cmVhbVN0YXRlIHtcbiAgX25hbWU6IGFueTtcbiAgcmVtb3RlOiBSZW1vdGVDb21tdW5pY2F0aW9uIHwgbnVsbDtcbiAgZGVlcGxpbmtQcm90b2NvbDogYm9vbGVhbjtcbiAgcGxhdGZvcm1NYW5hZ2VyOiBQbGF0Zm9ybU1hbmFnZXIgfCBudWxsO1xufVxuXG5leHBvcnQgY2xhc3MgUmVtb3RlQ29tbXVuaWNhdGlvblBvc3RNZXNzYWdlU3RyZWFtXG4gIGV4dGVuZHMgRHVwbGV4XG4gIGltcGxlbWVudHMgUG9zdE1lc3NhZ2VTdHJlYW1cbntcbiAgcHVibGljIHN0YXRlOiBSZW1vdGVDb21tdW5pY2F0aW9uUG9zdE1lc3NhZ2VTdHJlYW1TdGF0ZSA9IHtcbiAgICBfbmFtZTogbnVsbCxcbiAgICByZW1vdGU6IG51bGwsXG4gICAgZGVlcGxpbmtQcm90b2NvbDogZmFsc2UsXG4gICAgcGxhdGZvcm1NYW5hZ2VyOiBudWxsLFxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBuYW1lLFxuICAgIHJlbW90ZSxcbiAgICBkZWVwbGlua1Byb3RvY29sLFxuICAgIHBsYXRmb3JtTWFuYWdlcixcbiAgfToge1xuICAgIG5hbWU6IFByb3ZpZGVyQ29uc3RhbnRzO1xuICAgIGRlZXBsaW5rUHJvdG9jb2w6IGJvb2xlYW47XG4gICAgcmVtb3RlOiBSZW1vdGVDb21tdW5pY2F0aW9uO1xuICAgIHBsYXRmb3JtTWFuYWdlcjogUGxhdGZvcm1NYW5hZ2VyO1xuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICB9KTtcbiAgICB0aGlzLnN0YXRlLl9uYW1lID0gbmFtZTtcbiAgICB0aGlzLnN0YXRlLnJlbW90ZSA9IHJlbW90ZTtcbiAgICB0aGlzLnN0YXRlLmRlZXBsaW5rUHJvdG9jb2wgPSBkZWVwbGlua1Byb3RvY29sO1xuICAgIHRoaXMuc3RhdGUucGxhdGZvcm1NYW5hZ2VyID0gcGxhdGZvcm1NYW5hZ2VyO1xuXG4gICAgdGhpcy5fb25NZXNzYWdlID0gdGhpcy5fb25NZXNzYWdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zdGF0ZS5yZW1vdGUub24oRXZlbnRUeXBlLk1FU1NBR0UsIHRoaXMuX29uTWVzc2FnZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gcXVlcnlpbmcgdGhlIHNkayBwcm92aWRlciB3aXRoIGV0aGVyZXVtLnJlcXVlc3RcbiAgICovXG4gIGFzeW5jIF93cml0ZShcbiAgICBjaHVuazogYW55LFxuICAgIF9lbmNvZGluZzogQnVmZmVyRW5jb2RpbmcsXG4gICAgY2FsbGJhY2s6IChlcnJvcj86IEVycm9yIHwgbnVsbCkgPT4gdm9pZCxcbiAgKSB7XG4gICAgcmV0dXJuIHdyaXRlKHRoaXMsIGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIF9yZWFkKCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBfb25NZXNzYWdlKG1lc3NhZ2U6IENvbW11bmljYXRpb25MYXllck1lc3NhZ2UpIHtcbiAgICByZXR1cm4gb25NZXNzYWdlKHRoaXMsIG1lc3NhZ2UpO1xuICB9XG5cbiAgc3RhcnQoKSB7XG4gICAgLy8gRXRoZXJldW0uZXRoZXJldW0uaXNDb25uZWN0ZWQgPSAoKSA9PiBSZW1vdGVDb25uZWN0aW9uLmlzQ29ubmVjdGVkKCk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcic7XG5pbXBvcnQgeyBDb21tdW5pY2F0aW9uTGF5ZXJNZXNzYWdlIH0gZnJvbSAnQG1ldGFtYXNrL3Nkay1jb21tdW5pY2F0aW9uLWxheWVyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBSZW1vdGVDb21tdW5pY2F0aW9uUG9zdE1lc3NhZ2VTdHJlYW0gfSBmcm9tICcuLi8uLi9Qb3N0TWVzc2FnZVN0cmVhbS9SZW1vdGVDb21tdW5pY2F0aW9uUG9zdE1lc3NhZ2VTdHJlYW0nO1xuaW1wb3J0IHsgUHJvdmlkZXJDb25zdGFudHMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gb25NZXNzYWdlKFxuICBpbnN0YW5jZTogUmVtb3RlQ29tbXVuaWNhdGlvblBvc3RNZXNzYWdlU3RyZWFtLFxuICBtZXNzYWdlOiBDb21tdW5pY2F0aW9uTGF5ZXJNZXNzYWdlLFxuKSB7XG4gIHRyeSB7XG4gICAgLy8gdmFsaWRhdGUgbWVzc2FnZVxuICAgIC8qIGlmIChpbnN0YW5jZS5zdGF0ZS5fb3JpZ2luICE9PSAnKicgJiYgZXZlbnQub3JpZ2luICE9PSBpbnN0YW5jZS5zdGF0ZS5fb3JpZ2luKSB7XG4gICAgcmV0dXJuO1xuICB9Ki9cblxuICAgIGxvZ2dlcihgW1JDUE1TOiBvbk1lc3NhZ2UoKV0gbWVzc2FnZWAsIG1lc3NhZ2UpO1xuXG4gICAgY29uc3QgdHlwZU9mTXNnID0gdHlwZW9mIG1lc3NhZ2U7XG5cbiAgICBpZiAoIW1lc3NhZ2UgfHwgdHlwZU9mTXNnICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFdlIG9ubHkgd2FudCByZXBseSBmcm9tIE1ldGFNYXNrLlxuICAgIGNvbnN0IHR5cGVPZkRhdGEgPSB0eXBlb2YgbWVzc2FnZT8uZGF0YTtcbiAgICBpZiAodHlwZU9mRGF0YSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIW1lc3NhZ2U/Lm5hbWUpIHtcbiAgICAgIGxvZ2dlcihgW1JDUE1TOiBvbk1lc3NhZ2UoKV0gaWdub3JlIG1lc3NhZ2Ugd2l0aG91dCBuYW1lYCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2U/Lm5hbWUgIT09IFByb3ZpZGVyQ29uc3RhbnRzLlBST1ZJREVSKSB7XG4gICAgICBsb2dnZXIoXG4gICAgICAgIGBbUkNQTVM6IG9uTWVzc2FnZSgpXSBpZ25vcmUgbWVzc2FnZSB3aXRoIHdyb25nIG5hbWUgbWVzc2FnZT0ke21lc3NhZ2V9YCxcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihtZXNzYWdlKSkge1xuICAgICAgY29uc3QgZGF0YSA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpO1xuICAgICAgaW5zdGFuY2UucHVzaChkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2UucHVzaChtZXNzYWdlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGxvZ2dlcihgW1JDUE1TOiBvbk1lc3NhZ2UoKV0gaWdub3JlIG1lc3NhZ2UgZXJyb3IgZXJyPSR7ZXJyfWApO1xuICB9XG59XG4iLCJpbXBvcnQgY3Jvc3NGZXRjaCBmcm9tICdjcm9zcy1mZXRjaCc7XG5cbmxldCBycGNJZCA9IDE7XG5cbmZ1bmN0aW9uIGdldE5leHRScGNJZCgpIHtcbiAgcnBjSWQgKz0gMTtcbiAgcmV0dXJuIHJwY0lkO1xufVxuXG5pbnRlcmZhY2UgUnBjUmVzcG9uc2Uge1xuICBpZDogbnVtYmVyO1xuICBqc29ucnBjOiBzdHJpbmc7XG4gIHJlc3VsdDogdW5rbm93bjtcbn1cblxuZXhwb3J0IGNvbnN0IHJwY1JlcXVlc3RIYW5kbGVyID0gYXN5bmMgKHtcbiAgcnBjRW5kcG9pbnQsXG4gIG1ldGhvZCxcbiAgc2RrSW5mbyxcbiAgcGFyYW1zLFxufToge1xuICBycGNFbmRwb2ludDogc3RyaW5nO1xuICBzZGtJbmZvOiBzdHJpbmc7XG4gIG1ldGhvZDogc3RyaW5nO1xuICBwYXJhbXM6IHVua25vd25bXTtcbn0pID0+IHtcbiAgY29uc3QgYm9keSA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICBqc29ucnBjOiAnMi4wJyxcbiAgICBtZXRob2QsXG4gICAgcGFyYW1zLFxuICAgIGlkOiBnZXROZXh0UnBjSWQoKSxcbiAgfSk7XG5cbiAgY29uc3QgaGVhZGVyczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJldHRpZXIvcHJldHRpZXJcbiAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICB9O1xuICBpZiAocnBjRW5kcG9pbnQuaW5jbHVkZXMoJ2luZnVyYScpKSB7XG4gICAgaGVhZGVyc1snTWV0YW1hc2stU2RrLUluZm8nXSA9IHNka0luZm87XG4gIH1cblxuICBsZXQgcmVzcG9uc2U7XG4gIHRyeSB7XG4gICAgcmVzcG9uc2UgPSBhd2FpdCBjcm9zc0ZldGNoKHJwY0VuZHBvaW50LCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5LFxuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBmcm9tIFJQQzogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBmcm9tIFJQQzogJHtlcnJvcn1gKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggYSBzdGF0dXMgb2YgJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gIH1cblxuICBjb25zdCBycGNSZXNwb25zZSA9IChhd2FpdCByZXNwb25zZS5qc29uKCkpIGFzIFJwY1Jlc3BvbnNlO1xuICByZXR1cm4gcnBjUmVzcG9uc2UucmVzdWx0O1xufTtcbiIsImV4cG9ydCBjb25zdCB3YWl0ID0gKHRpbWU6IG51bWJlcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgfSwgdGltZSk7XG4gIH0pO1xufTtcbiIsImltcG9ydCB7XG4gIENvbW11bmljYXRpb25MYXllclByZWZlcmVuY2UsXG4gIEV2ZW50VHlwZSxcbiAgUGxhdGZvcm1UeXBlLFxuICBSZW1vdGVDb21tdW5pY2F0aW9uLFxufSBmcm9tICdAbWV0YW1hc2svc2RrLWNvbW11bmljYXRpb24tbGF5ZXInO1xuaW1wb3J0IHsgTGlzdGVuZXIgfSBmcm9tICdldmVudGVtaXR0ZXIyJztcbmltcG9ydCBwYWNrYWdlSnNvbiBmcm9tICcuLi8uLi9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHsgTWV0YU1hc2tJbnN0YWxsZXIgfSBmcm9tICcuLi9QbGF0Zm9ybS9NZXRhTWFza0luc3RhbGxlcic7XG5pbXBvcnQgeyBQbGF0Zm9ybU1hbmFnZXIgfSBmcm9tICcuLi9QbGF0Zm9ybS9QbGF0ZmZvcm1NYW5hZ2VyJztcbmltcG9ydCB7IGdldFBvc3RNZXNzYWdlU3RyZWFtIH0gZnJvbSAnLi4vUG9zdE1lc3NhZ2VTdHJlYW0vZ2V0UG9zdE1lc3NhZ2VTdHJlYW0nO1xuaW1wb3J0IHsgTUVUSE9EU19UT19SRURJUkVDVCwgUlBDX01FVEhPRFMgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHsgUHJvdmlkZXJDb25zdGFudHMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgTWV0YU1hc2tTREsgfSBmcm9tICcuLi9zZGsnO1xuaW1wb3J0IHsgRXRoZXJldW0gfSBmcm9tICcuLi9zZXJ2aWNlcy9FdGhlcmV1bSc7XG5pbXBvcnQgeyBSZW1vdGVDb25uZWN0aW9uIH0gZnJvbSAnLi4vc2VydmljZXMvUmVtb3RlQ29ubmVjdGlvbic7XG5pbXBvcnQgeyBycGNSZXF1ZXN0SGFuZGxlciB9IGZyb20gJy4uL3NlcnZpY2VzL3JwYy1yZXF1ZXN0cy9SUENSZXF1ZXN0SGFuZGxlcic7XG5pbXBvcnQgeyBNZXRhTWFza1NES0V2ZW50IH0gZnJvbSAnLi4vdHlwZXMvTWV0YU1hc2tTREtFdmVudHMnO1xuaW1wb3J0IHsgUFJPVklERVJfVVBEQVRFX1RZUEUgfSBmcm9tICcuLi90eXBlcy9Qcm92aWRlclVwZGF0ZVR5cGUnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IHdhaXQgfSBmcm9tICcuLi91dGlscy93YWl0JztcbmltcG9ydCB7IGV4dGVuc2lvbkNvbm5lY3RXaXRoT3ZlcndyaXRlIH0gZnJvbSAnLi9leHRlbnNpb25Db25uZWN0V2l0aE92ZXJ3cml0ZSc7XG5cbmNvbnN0IGluaXRpYWxpemVNb2JpbGVQcm92aWRlciA9IGFzeW5jICh7XG4gIGNoZWNrSW5zdGFsbGF0aW9uT25BbGxDYWxscyA9IGZhbHNlLFxuICBjb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlLFxuICBpbmplY3RQcm92aWRlcixcbiAgc2hvdWxkU2hpbVdlYjMsXG4gIHBsYXRmb3JtTWFuYWdlcixcbiAgaW5zdGFsbGVyLFxuICBzZGssXG4gIHJlbW90ZUNvbm5lY3Rpb24sXG4gIGRlYnVnLFxufToge1xuICBjb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlOiBDb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlO1xuICBjaGVja0luc3RhbGxhdGlvbk9uQWxsQ2FsbHM/OiBib29sZWFuO1xuICBpbmplY3RQcm92aWRlcj86IGJvb2xlYW47XG4gIHNob3VsZFNoaW1XZWIzOiBib29sZWFuO1xuICBzZGs6IE1ldGFNYXNrU0RLO1xuICBwbGF0Zm9ybU1hbmFnZXI6IFBsYXRmb3JtTWFuYWdlcjtcbiAgaW5zdGFsbGVyOiBNZXRhTWFza0luc3RhbGxlcjtcbiAgcmVtb3RlQ29ubmVjdGlvbj86IFJlbW90ZUNvbm5lY3Rpb247XG4gIGRlYnVnOiBib29sZWFuO1xufSkgPT4ge1xuICAvLyBTZXR1cCBzdHJlYW0gZm9yIGNvbnRlbnQgc2NyaXB0IGNvbW11bmljYXRpb25cbiAgY29uc3QgbWV0YW1hc2tTdHJlYW0gPSBnZXRQb3N0TWVzc2FnZVN0cmVhbSh7XG4gICAgbmFtZTogUHJvdmlkZXJDb25zdGFudHMuSU5QQUdFLFxuICAgIHRhcmdldDogUHJvdmlkZXJDb25zdGFudHMuQ09OVEVOVF9TQ1JJUFQsXG4gICAgcGxhdGZvcm1NYW5hZ2VyLFxuICAgIGNvbW11bmljYXRpb25MYXllclByZWZlcmVuY2UsXG4gICAgcmVtb3RlQ29ubmVjdGlvbixcbiAgfSk7XG5cbiAgY29uc3QgcGxhdGZvcm1UeXBlID0gcGxhdGZvcm1NYW5hZ2VyLmdldFBsYXRmb3JtVHlwZSgpO1xuICBjb25zdCBkYXBwSW5mbyA9IHNkay5vcHRpb25zLmRhcHBNZXRhZGF0YTtcbiAgY29uc3Qgc2RrSW5mbyA9IGBTZGsvSmF2YXNjcmlwdCBTZGtWZXJzaW9uLyR7XG4gICAgcGFja2FnZUpzb24udmVyc2lvblxuICB9IFBsYXRmb3JtLyR7cGxhdGZvcm1UeXBlfSBkQXBwLyR7ZGFwcEluZm8udXJsID8/IGRhcHBJbmZvLm5hbWV9IGRBcHBUaXRsZS8ke1xuICAgIGRhcHBJbmZvLm5hbWVcbiAgfWA7XG5cbiAgbGV0IGNhY2hlZEFjY291bnRBZGRyZXNzOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgbGV0IGNhY2hlZENoYWluSWQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBjb25zdCBzdG9yYWdlTWFuYWdlciA9IHNkay5vcHRpb25zLnN0b3JhZ2U/LnN0b3JhZ2VNYW5hZ2VyO1xuXG4gIC8vIGNoZWNrIGlmIGxvY2FsU3RvcmFnZSBpcyBhdmFpbGFibGVcbiAgaWYgKHN0b3JhZ2VNYW5hZ2VyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGNhY2hlZEFkZHJlc3NlcyA9IGF3YWl0IHN0b3JhZ2VNYW5hZ2VyLmdldENhY2hlZEFjY291bnRzKCk7XG4gICAgICBpZiAoY2FjaGVkQWRkcmVzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2FjaGVkQWNjb3VudEFkZHJlc3MgPSBjYWNoZWRBZGRyZXNzZXNbMF07XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgW2luaXRpYWxpemVNb2JpbGVQcm92aWRlcl0gZmFpbGVkIHRvIGdldCBjYWNoZWQgYWRkcmVzc2VzOiAke2Vycn1gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgY2FjaGVkQ2hhaW4gPSBhd2FpdCBzdG9yYWdlTWFuYWdlci5nZXRDYWNoZWRDaGFpbklkKCk7XG4gICAgICBpZiAoY2FjaGVkQ2hhaW4pIHtcbiAgICAgICAgY2FjaGVkQ2hhaW5JZCA9IGNhY2hlZENoYWluO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYFtpbml0aWFsaXplTW9iaWxlUHJvdmlkZXJdIGZhaWxlZCB0byBwYXJzZSBjYWNoZWQgY2hhaW5JZDogJHtlcnJ9YCxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgbG9nZ2VyKFxuICAgIGBbaW5pdGlhbGl6ZU1vYmlsZVByb3ZpZGVyXSBjYWNoZWRBY2NvdW50QWRkcmVzczogJHtjYWNoZWRBY2NvdW50QWRkcmVzc30sIGNhY2hlZENoYWluSWQ6ICR7Y2FjaGVkQ2hhaW5JZH1gLFxuICApO1xuXG4gIC8vIEluaXRpYWxpemUgcHJvdmlkZXIgb2JqZWN0ICh3aW5kb3cuZXRoZXJldW0pXG4gIGNvbnN0IHNob3VsZFNldE9uV2luZG93ID0gIShcbiAgICAhaW5qZWN0UHJvdmlkZXIgfHxcbiAgICAvLyBEb24ndCBpbmplY3QgaWYgaXQncyBub24gYnJvd3NlciBvciBSTlxuICAgIHBsYXRmb3JtVHlwZSA9PT0gUGxhdGZvcm1UeXBlLk5vbkJyb3dzZXIgfHxcbiAgICBwbGF0Zm9ybVR5cGUgPT09IFBsYXRmb3JtVHlwZS5SZWFjdE5hdGl2ZVxuICApO1xuXG4gIC8vIGV0aGVyZXVtLmluaXQgd2lsbCBhdXRvbWF0aWNhbGx5IGNhbGwgbWV0YW1hc2tfZ2V0UHJvdmlkZXJTdGF0ZVxuICBjb25zdCBldGhlcmV1bSA9IEV0aGVyZXVtLmluaXQoe1xuICAgIHNob3VsZFNldE9uV2luZG93LFxuICAgIGNvbm5lY3Rpb25TdHJlYW06IG1ldGFtYXNrU3RyZWFtLFxuICAgIHNob3VsZFNoaW1XZWIzLFxuICAgIHNka0luc3RhbmNlOiBzZGssXG4gIH0pO1xuXG4gIGxldCBpbml0aWFsaXphdGlvbk9uZ29pbmcgPSBmYWxzZTtcbiAgY29uc3Qgc2V0SW5pdGlhbGl6aW5nID0gKG9uZ29pbmc6IGJvb2xlYW4pID0+IHtcbiAgICBpbml0aWFsaXphdGlvbk9uZ29pbmcgPSBvbmdvaW5nO1xuICB9O1xuXG4gIGNvbnN0IGdldEluaXRpYWxpemluZyA9ICgpID0+IHtcbiAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25PbmdvaW5nO1xuICB9O1xuXG4gIGNvbnN0IHNlbmRSZXF1ZXN0ID0gYXN5bmMgKFxuICAgIG1ldGhvZDogc3RyaW5nLFxuICAgIGFyZ3M6IGFueSxcbiAgICBleGVjdXRlUmVxdWVzdDogYW55LFxuICAgIGRlYnVnUmVxdWVzdDogYm9vbGVhbixcbiAgKSA9PiB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBFdGhlcmV1bS5nZXRQcm92aWRlcigpO1xuXG4gICAgaWYgKGluaXRpYWxpemF0aW9uT25nb2luZykge1xuICAgICAgLy8gQWx3YXlzIHJlLWVtaXQgdGhlIGRpc3BsYXlfdXJpIGV2ZW50XG4gICAgICBwcm92aWRlci5lbWl0KCdkaXNwbGF5X3VyaScsIHJlbW90ZUNvbm5lY3Rpb24/LnN0YXRlLnFyY29kZUxpbmsgfHwgJycpO1xuXG4gICAgICAvLyBtYWtlIHN1cmUgdGhlIGFjdGl2ZSBtb2RhbCBpcyBkaXNwbGF5ZWRcbiAgICAgIHJlbW90ZUNvbm5lY3Rpb24/LnNob3dBY3RpdmVNb2RhbCgpO1xuXG4gICAgICBsZXQgbG9vcCA9IGdldEluaXRpYWxpemluZygpO1xuICAgICAgd2hpbGUgKGxvb3ApIHtcbiAgICAgICAgY29uc3QgaW5pdGlhbGl6aW5nID0gZ2V0SW5pdGlhbGl6aW5nKCk7XG4gICAgICAgIGNvbnN0IGF1dGhvcml6ZWQgPSByZW1vdGVDb25uZWN0aW9uPy5pc0F1dGhvcml6ZWQoKTtcbiAgICAgICAgbG9vcCA9IGluaXRpYWxpemluZyAmJiAhYXV0aG9yaXplZDtcbiAgICAgICAgbG9nZ2VyKFxuICAgICAgICAgIGBbaW5pdGlhbGl6ZU1vYmlsZVByb3ZpZGVyOiBzZW5kUmVxdWVzdCgpXSB3YWl0aW5nIGZvciBpbml0aWFsaXphdGlvbiB0byBjb21wbGV0ZSAtIGluaXRpYWxpemluZzogJHtpbml0aWFsaXppbmd9IGF1dGhvcml6ZWQ6ICR7YXV0aG9yaXplZH1gLFxuICAgICAgICApO1xuICAgICAgICAvLyBXYWl0IGZvciBhbHJlYWR5IG9uZ29pbmcgbWV0aG9kIHRoYXQgdHJpZ2dlcmVkIGluc3RhbGxhdGlvbiB0byBjb21wbGV0ZVxuICAgICAgICBhd2FpdCB3YWl0KDEwMDApO1xuICAgICAgfVxuXG4gICAgICBsb2dnZXIoXG4gICAgICAgIGBbaW5pdGlhbGl6ZU1vYmlsZVByb3ZpZGVyOiBzZW5kUmVxdWVzdCgpXSBpbml0aWFsIG1ldGhvZCBjb21wbGV0ZWQgLS0gcHJldmVudCBpbnN0YWxsYXRpb24gYW5kIGNhbGwgcHJvdmlkZXJgLFxuICAgICAgKTtcbiAgICAgIC8vIFByZXZpb3VzIGluaXQgaGFzIGNvbXBsZXRlZCwgbWVhbmluZyB3ZSBjYW4gc2FmZWx5IGludGVycnVwIGFuZCBjYWxsIHRoZSBwcm92aWRlci5cbiAgICAgIHJldHVybiBleGVjdXRlUmVxdWVzdCguLi5hcmdzKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc0luc3RhbGxlZCA9IHBsYXRmb3JtTWFuYWdlci5pc01ldGFNYXNrSW5zdGFsbGVkKCk7XG4gICAgLy8gQWxzbyBjaGVjayB0aGF0IHNvY2tldCBpcyBjb25uZWN0ZWQgLS0gb3RoZXJ3aXNlIGl0IHdvdWxkIGJlIGluIGluY29uaGVyYW50IHN0YXRlLlxuICAgIGNvbnN0IHNvY2tldENvbm5lY3RlZCA9IHJlbW90ZUNvbm5lY3Rpb24/LmlzQ29ubmVjdGVkKCk7XG5cbiAgICBsZXQgc2VsZWN0ZWRBZGRyZXNzOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICBsZXQgY29ubmVjdGVkQWNjb3VudHM6IHN0cmluZ1tdIHwgbnVsbCA9IG51bGw7XG4gICAgbGV0IGNoYWluSWQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gICAgc2VsZWN0ZWRBZGRyZXNzID0gcHJvdmlkZXIuZ2V0U2VsZWN0ZWRBZGRyZXNzKCkgPz8gY2FjaGVkQWNjb3VudEFkZHJlc3M7XG4gICAgY2hhaW5JZCA9IHByb3ZpZGVyLmdldENoYWluSWQoKSB8fCBjYWNoZWRDaGFpbklkO1xuXG4gICAgLy8ga2VlcCBjYWNoZWQgdmFsdWVzIGZvciBzZWxlY3RlZEFkZHJlc3MgYW5kIGNoYWluSWRcbiAgICBpZiAoc2VsZWN0ZWRBZGRyZXNzKSB7XG4gICAgICBpZiAoc3RvcmFnZU1hbmFnZXIgJiYgc2VsZWN0ZWRBZGRyZXNzICE9PSBjYWNoZWRBY2NvdW50QWRkcmVzcykge1xuICAgICAgICBzdG9yYWdlTWFuYWdlci5wZXJzaXN0QWNjb3VudHMoW3NlbGVjdGVkQWRkcmVzc10pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgYFtpbml0aWFsaXplTW9iaWxlUHJvdmlkZXJdIGZhaWxlZCB0byBwZXJzaXN0IGFjY291bnQ6ICR7ZXJyfWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoYWluSWQpIHtcbiAgICAgIGNhY2hlZENoYWluSWQgPSBjaGFpbklkO1xuICAgICAgaWYgKHN0b3JhZ2VNYW5hZ2VyKSB7XG4gICAgICAgIHN0b3JhZ2VNYW5hZ2VyLnBlcnNpc3RDaGFpbklkKGNoYWluSWQpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgYFtpbml0aWFsaXplTW9iaWxlUHJvdmlkZXJdIGZhaWxlZCB0byBwZXJzaXN0IGNoYWluSWQ6ICR7ZXJyfWAsXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbG9nZ2VyKCdbaW5pdGlhbGl6ZU1vYmlsZVByb3ZpZGVyOiBzZW5kUmVxdWVzdCgpXScsIHtcbiAgICAgIHNlbGVjdGVkQWRkcmVzcyxcbiAgICAgIGNoYWluSWQsXG4gICAgfSk7XG5cbiAgICBpZiAoZGVidWdSZXF1ZXN0KSB7XG4gICAgICBsb2dnZXIoXG4gICAgICAgIGBbaW5pdGlhbGl6ZU1vYmlsZVByb3ZpZGVyOiBzZW5kUmVxdWVzdCgpXSBtZXRob2Q9JHttZXRob2R9IG9uZ29pbmc9JHtpbml0aWFsaXphdGlvbk9uZ29pbmd9IHNlbGVjdGVkQWRkcmVzcz0ke3NlbGVjdGVkQWRkcmVzc30gaXNJbnN0YWxsZWQ9JHtpc0luc3RhbGxlZH0gY2hlY2tJbnN0YWxsYXRpb25PbkFsbENhbGxzPSR7Y2hlY2tJbnN0YWxsYXRpb25PbkFsbENhbGxzfSBzb2NrZXRDb25uZWN0ZWQ9JHtzb2NrZXRDb25uZWN0ZWR9YCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBldGhfYWNjb3VudHMgdG8gYWxsb3cgd29ya2luZyB3aXRoIHJlYWQtb25seSBSUENcbiAgICBpZiAoXG4gICAgICBzZWxlY3RlZEFkZHJlc3MgJiZcbiAgICAgIG1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSBSUENfTUVUSE9EUy5FVEhfQUNDT1VOVFMudG9Mb3dlckNhc2UoKVxuICAgICkge1xuICAgICAgcmV0dXJuIFtzZWxlY3RlZEFkZHJlc3NdO1xuICAgIH1cblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgZXRoX2NoYWluSWQgdG8gYWxsb3cgd29ya2luZyB3aXRoIHJlYWQtb25seSBSUENcbiAgICBpZiAoXG4gICAgICBjaGFpbklkICYmXG4gICAgICBtZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gUlBDX01FVEhPRFMuRVRIX0NIQUlOSUQudG9Mb3dlckNhc2UoKVxuICAgICkge1xuICAgICAgcmV0dXJuIGNoYWluSWQ7XG4gICAgfVxuXG4gICAgY29uc3QgQUxMT1dFRF9DT05ORUNUX01FVEhPRFMgPSBbXG4gICAgICBSUENfTUVUSE9EUy5FVEhfUkVRVUVTVEFDQ09VTlRTLFxuICAgICAgUlBDX01FVEhPRFMuV0FMTEVUX1JFUVVFU1RQRVJNSVNTSU9OUyxcbiAgICAgIFJQQ19NRVRIT0RTLk1FVEFNQVNLX0NPTk5FQ1RTSUdOLFxuICAgICAgUlBDX01FVEhPRFMuTUVUQU1BU0tfQ09OTkVDVFdJVEgsXG4gICAgXTtcblxuICAgIC8vIGlzIGl0IGEgcmVhZG9ubHkgbWV0aG9kIHdpdGggaW5mdXJhIHN1cHBvcnRlZCBjaGFpbj9cbiAgICBjb25zdCBpc1JlYWRPbmx5TWV0aG9kID0gIU1FVEhPRFNfVE9fUkVESVJFQ1RbbWV0aG9kXTtcbiAgICBjb25zdCBycGNFbmRwb2ludCA9IHNkay5vcHRpb25zLnJlYWRvbmx5UlBDTWFwPy5bY2hhaW5JZCBhcyBgMHgke3N0cmluZ31gXTtcbiAgICBpZiAocnBjRW5kcG9pbnQgJiYgaXNSZWFkT25seU1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gYXJncz8uWzBdPy5wYXJhbXM7XG5cbiAgICAgICAgY29uc3QgcmVhZE9ubHlSZXNwb25zZSA9IGF3YWl0IHJwY1JlcXVlc3RIYW5kbGVyKHtcbiAgICAgICAgICBycGNFbmRwb2ludCxcbiAgICAgICAgICBzZGtJbmZvLFxuICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICBwYXJhbXM6IHBhcmFtcyB8fCBbXSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRlYnVnUmVxdWVzdCkge1xuICAgICAgICAgIGxvZ2dlcihgaW5pdGlhbGl6ZVByb3ZpZGVyOjpSZWFkT25seVJQQ1Jlc3BvbnNlICR7cmVhZE9ubHlSZXNwb25zZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVhZE9ubHlSZXNwb25zZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBMb2cgZXJyb3IgYW5kIGZhbGxiYWNrIHRvIG1vYmlsZSBwcm92aWRlclxuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgYFtpbml0aWFsaXplTW9iaWxlUHJvdmlkZXI6IHNlbmRSZXF1ZXN0KCldIG1ldGhvZD0ke21ldGhvZH0gcmVhZE9ubHlSUENSZXF1ZXN0IGZhaWxlZDpgLFxuICAgICAgICAgIGVycixcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAoIWlzSW5zdGFsbGVkIHx8IChpc0luc3RhbGxlZCAmJiAhc29ja2V0Q29ubmVjdGVkKSkgJiZcbiAgICAgIG1ldGhvZCAhPT0gUlBDX01FVEhPRFMuTUVUQU1BU0tfR0VUUFJPVklERVJTVEFURVxuICAgICkge1xuICAgICAgY29uc3QgcGFyYW1zID0gYXJncz8uWzBdPy5wYXJhbXMgfHwgW107XG5cbiAgICAgIGlmIChcbiAgICAgICAgQUxMT1dFRF9DT05ORUNUX01FVEhPRFMuaW5kZXhPZihtZXRob2QpICE9PSAtMSB8fFxuICAgICAgICBjaGVja0luc3RhbGxhdGlvbk9uQWxsQ2FsbHNcbiAgICAgICkge1xuICAgICAgICBzZXRJbml0aWFsaXppbmcodHJ1ZSk7XG5cbiAgICAgICAgY29uc3QgaXNDb25uZWN0V2l0aCA9IG1ldGhvZCA9PT0gUlBDX01FVEhPRFMuTUVUQU1BU0tfQ09OTkVDVFdJVEg7XG4gICAgICAgIC8vIE9ubHkgdXNlZCB3aXRoIGNvbm5lY3RXaXRoXG4gICAgICAgIGNvbnN0IHJwY0luc3RhbGxJZCA9IGAke0RhdGUubm93KCl9YDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBpbnN0YWxsZXIuc3RhcnQoe1xuICAgICAgICAgICAgd2FpdDogZmFsc2UsXG4gICAgICAgICAgICBjb25uZWN0V2l0aDogaXNDb25uZWN0V2l0aFxuICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbnQgbmVlZCBhIGJldHRlciBpZCwgdGhpcyBpcyBvbmx5IGZvciBjdXJyZW50IHVzZXIgc2Vzc2lvbi5cbiAgICAgICAgICAgICAgICAgIC8vIGZ1dHVyZSBycGMgY2FsbHMgd2lsbCBoYXZlIGlkcyBnZW5lcmF0ZWQgdmlhIEpTT04tUlBDIHBhY2thZ2UuXG4gICAgICAgICAgICAgICAgICBpZDogcnBjSW5zdGFsbElkLFxuICAgICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyB3YWl0IGZvciBhdXRob3JpemF0aW9uXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXV0aG9yaXplZCA9IHJlbW90ZUNvbm5lY3Rpb24/LmlzQXV0aG9yaXplZCgpO1xuICAgICAgICAgICAgaWYgKGF1dGhvcml6ZWQpIHtcbiAgICAgICAgICAgICAgbG9nZ2VyKFxuICAgICAgICAgICAgICAgIGBbaW5pdGlhbGl6ZU1vYmlsZVByb3ZpZGVyOiBzZW5kUmVxdWVzdCgpXSBhbHJlYWR5IGF1dGhvcml6ZWRgLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW1vdGVDb25uZWN0aW9uPy5nZXRDb25uZWN0b3IoKS5vbmNlKEV2ZW50VHlwZS5BVVRIT1JJWkVELCAoKSA9PiB7XG4gICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQWxzbyBkZXRlY3QgY2hhbmdlcyBvZiBwcm92aWRlclxuICAgICAgICAgICAgc2RrLm9uY2UoXG4gICAgICAgICAgICAgIEV2ZW50VHlwZS5QUk9WSURFUl9VUERBVEUsXG4gICAgICAgICAgICAgICh0eXBlOiBQUk9WSURFUl9VUERBVEVfVFlQRSkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ2dlcihcbiAgICAgICAgICAgICAgICAgIGBbaW5pdGlhbGl6ZU1vYmlsZVByb3ZpZGVyOiBzZW5kUmVxdWVzdCgpXSBQUk9WSURFUl9VUERBVEUgLS0tIHJlbW90ZSBwcm92aWRlciByZXF1ZXN0IGludGVydXB0ZWQgdHlwZT0ke3R5cGV9YCxcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFBST1ZJREVSX1VQREFURV9UWVBFLkVYVEVOU0lPTikge1xuICAgICAgICAgICAgICAgICAgcmVqZWN0KEV2ZW50VHlwZS5QUk9WSURFUl9VUERBVEUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdDb25uZWN0aW9uIFRlcm1pbmF0ZWQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAoaW5zdGFsbEVycm9yOiB1bmtub3duKSB7XG4gICAgICAgICAgaWYgKFBST1ZJREVSX1VQREFURV9UWVBFLkVYVEVOU0lPTiA9PT0gaW5zdGFsbEVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgICAgIGBbaW5pdGlhbGl6ZU1vYmlsZVByb3ZpZGVyOiBzZW5kUmVxdWVzdCgpXSBleHRlbnNpb24gcHJvdmlkZXIgZGV0ZWN0OiByZS1jcmVhdGUgJHttZXRob2R9IG9uIHRoZSBhY3RpdmUgcHJvdmlkZXJgLFxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBtZXRhbWFza19jb25uZWN0U2lnbiwgc3BsaXQgdGhlIHJlcXVlc3QgaW4gMiBwYXJ0cyAoY29ubmVjdCArIHNpZ24pXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG1ldGhvZC50b0xvd2VyQ2FzZSgpID09PVxuICAgICAgICAgICAgICBSUENfTUVUSE9EUy5NRVRBTUFTS19DT05ORUNUU0lHTi50b0xvd2VyQ2FzZSgpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgY29uc3QgYWNjb3VudHMgPSAoYXdhaXQgc2RrLmdldFByb3ZpZGVyKCk/LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogUlBDX01FVEhPRFMuRVRIX1JFUVVFU1RBQ0NPVU5UUyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICAgICAgICB9KSkgYXMgc3RyaW5nW107XG4gICAgICAgICAgICAgIGlmICghYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTREsgc3RhdGUgaW52YWxpZCAtLSB1bmRlZmluZWQgYWNjb3VudHNgKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc2RrLmdldFByb3ZpZGVyKCk/LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogUlBDX01FVEhPRFMuUEVSU09OQUxfU0lHTixcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtwYXJhbXNbMF0sIGFjY291bnRzWzBdXSxcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgLy8gRW1pdCBjb25uZWN0UmVzcG9uc2VcbiAgICAgICAgICAgICAgc2RrLmVtaXQoTWV0YU1hc2tTREtFdmVudC5Db25uZWN0V2l0aFJlc3BvbnNlLCByZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgbWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09XG4gICAgICAgICAgICAgIFJQQ19NRVRIT0RTLk1FVEFNQVNLX0NPTk5FQ1RXSVRILnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBjb25zdCBbcnBjXSA9IHBhcmFtcztcbiAgICAgICAgICAgICAgLy8gT3ZlcndyaXRlIHJwYyBtZXRob2Qgd2l0aCBjb3JyZWN0IGFjY291bnQgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBleHRlbnNpb25Db25uZWN0V2l0aE92ZXJ3cml0ZSh7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBycGMubWV0aG9kLFxuICAgICAgICAgICAgICAgIHNkayxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHJwYy5wYXJhbXMsXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIC8vIEVtaXQgY29ubmVjdFJlc3BvbnNlXG4gICAgICAgICAgICAgIHNkay5lbWl0KE1ldGFNYXNrU0RLRXZlbnQuQ29ubmVjdFdpdGhSZXNwb25zZSwgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbG9nZ2VyKFxuICAgICAgICAgICAgICBgW2luaXRpYWxpemVNb2JpbGVQcm92aWRlcjogc2VuZFJlcXVlc3QoKV0gc2VuZGluZyAnJHttZXRob2R9JyBvbiBhY3RpdmUgcHJvdmlkZXJgLFxuICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgLy8gUmUtY3JlYXRlIHRoZSBxdWVyeSBvbiB0aGUgYWN0aXZlIHByb3ZpZGVyXG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgc2RrLmdldFByb3ZpZGVyKCk/LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoaW5zdGFsbEVycm9yID09PSBFdmVudFR5cGUuUkVKRUNURUQpIHtcbiAgICAgICAgICAgIC8vIENsb3NlIG1vZGFsLCBjb25uZWN0aW9uIHdhcyByZWplY3RlZFxuICAgICAgICAgICAgcmVtb3RlQ29ubmVjdGlvbj8uY2xvc2VNb2RhbCgpO1xuICAgICAgICAgICAgc2RrLmdldFByb3ZpZGVyKCk/LmhhbmRsZURpc2Nvbm5lY3QoeyB0ZXJtaW5hdGU6IGZhbHNlIH0pO1xuXG4gICAgICAgICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignVXNlciByZWplY3RlZCBjb25uZWN0aW9uJyksIHtcbiAgICAgICAgICAgICAgY29kZTogNDAwMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxvZ2dlcihcbiAgICAgICAgICAgIGBbaW5pdGlhbGl6ZU1vYmlsZVByb3ZpZGVyOiBzZW5kUmVxdWVzdCgpXSBmYWlsZWQgdG8gc3RhcnQgaW5zdGFsbGVyOiAke2luc3RhbGxFcnJvcn1gLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICB0aHJvdyBpbnN0YWxsRXJyb3I7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SW5pdGlhbGl6aW5nKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIHNob3VsZCBub3cgaGF2ZSBvYnRhaW5lZCB0aGUgYXV0aG9yaXphdGlvbiBhbmQgYWNjb3VudCBpbmZvcyBzbyB3ZSBjYW4gc2tpcCBzZW5kaW5nIHRoYXQgcnBjIGNhbGwuXG4gICAgICAgIGlmIChtZXRob2QgPT09IFJQQ19NRVRIT0RTLkVUSF9SRVFVRVNUQUNDT1VOVFMpIHtcbiAgICAgICAgICAvLyB3YWl0IGZvciBwcm92aWRlciBhZGRyZXNzIHRvIGJlIHVwZGF0ZWRcbiAgICAgICAgICBjb25uZWN0ZWRBY2NvdW50cyA9IGF3YWl0IG5ldyBQcm9taXNlPHN0cmluZ1tdPigocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgYWNjb3VudHMgfSA9IHByb3ZpZGVyLmdldFN0YXRlKCk7XG5cbiAgICAgICAgICAgICAgaWYgKGFjY291bnRzKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShhY2NvdW50cyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgICBgW2luaXRpYWxpemVNb2JpbGVQcm92aWRlcjogc2VuZFJlcXVlc3QoKV0gc2VsZWN0ZWRBZGRyZXNzOiAke3NlbGVjdGVkQWRkcmVzc30gLS0tIFNLSVAgcnBjIGNhbGxgLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICByZXR1cm4gY29ubmVjdGVkQWNjb3VudHM7XG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kID09PSBSUENfTUVUSE9EUy5NRVRBTUFTS19DT05ORUNUV0lUSCkge1xuICAgICAgICAgIC8vIHdhaXQgZm9yICB0cmFja2VyIHRvIGJlIHVwZGF0ZWRcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZUNvdW50ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IG1heE1lc3NhZ2VzID0gNTsgLy8gV2FpdCBmb3IgNSBtZXNzYWdlcyBiZWZvcmUgdGltaW5nIG91dFxuICAgICAgICAgICAgY29uc3Qgb25SUENVcGRhdGUgPSAoe1xuICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICByZWplY3QsXG4gICAgICAgICAgICB9OiB7XG4gICAgICAgICAgICAgIHJlc29sdmU6ICh2YWx1ZTogdW5rbm93bikgPT4gdm9pZDtcbiAgICAgICAgICAgICAgcmVqZWN0OiAocmVhc29uPzogYW55KSA9PiB2b2lkO1xuICAgICAgICAgICAgfSkgPT4ge1xuICAgICAgICAgICAgICBtZXNzYWdlQ291bnQgKz0gMTtcbiAgICAgICAgICAgICAgY29uc3QgTG9jYWx0cmFja2VyID0gcmVtb3RlQ29ubmVjdGlvblxuICAgICAgICAgICAgICAgID8uZ2V0Q29ubmVjdG9yKClcbiAgICAgICAgICAgICAgICAuZ2V0UlBDTWV0aG9kVHJhY2tlcigpO1xuXG4gICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IExvY2FsdHJhY2tlcj8uW3JwY0luc3RhbGxJZF07XG4gICAgICAgICAgICAgIGxvZ2dlcihgVFJBQ0tFUjogdXBkYXRlIG1ldGhvZCAke3JwY0luc3RhbGxJZH1gLCB0YXJnZXQpO1xuXG4gICAgICAgICAgICAgIGlmICh0YXJnZXQ/LnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcihcbiAgICAgICAgICAgICAgICAgIGBbaW5pdGlhbGl6ZU1vYmlsZVByb3ZpZGVyOiBzZW5kUmVxdWVzdCgpXSBmb3VuZCByZXN1bHRgLFxuICAgICAgICAgICAgICAgICAgdGFyZ2V0LnJlc3VsdCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIC8vIEVtaXQgY29ubmVjdFdpdGggcmVzcG9uc2VcbiAgICAgICAgICAgICAgICBzZGsuZW1pdChNZXRhTWFza1NES0V2ZW50LkNvbm5lY3RXaXRoUmVzcG9uc2UsIHRhcmdldC5yZXN1bHQpO1xuXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0Py5lcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlcihcbiAgICAgICAgICAgICAgICAgIGBbaW5pdGlhbGl6ZU1vYmlsZVByb3ZpZGVyOiBzZW5kUmVxdWVzdCgpXSBmb3VuZCBlcnJvcmAsXG4gICAgICAgICAgICAgICAgICB0YXJnZXQuZXJyb3IsXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHJlamVjdCh0YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlQ291bnQgPj0gbWF4TWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgICAgICAgICBgW2luaXRpYWxpemVNb2JpbGVQcm92aWRlcjogc2VuZFJlcXVlc3QoKV0gbWF4IG1lc3NhZ2UgY291bnQgcmVhY2hlZCB3aXRob3V0IHJlc3VsdGAsXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ01heCBtZXNzYWdlIGNvdW50IHJlYWNoZWQgd2l0aG91dCByZXN1bHQnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gbm90IGZvdW5kIHlldCwgbmVlZCB0byB3YWl0IGZvciBuZXh0IHVwZGF0ZVxuICAgICAgICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgICAgICAgYFtpbml0aWFsaXplTW9iaWxlUHJvdmlkZXI6IHNlbmRSZXF1ZXN0KCldIG5vdCBmb3VuZCB5ZXQsIG5lZWQgdG8gd2FpdCBmb3IgbmV4dCB1cGRhdGVgLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgbGV0IGxpc3RlbmVyOiBSZW1vdGVDb21tdW5pY2F0aW9uIHwgTGlzdGVuZXIgfCB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgcnBjVXBkYXRlSGFuZGxlcjogKCgpID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHRyYWNrZXIgPSByZW1vdGVDb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgPy5nZXRDb25uZWN0b3IoKVxuICAgICAgICAgICAgICAgIC5nZXRSUENNZXRob2RUcmFja2VyKCk7XG4gICAgICAgICAgICAgIGxvZ2dlcihgVFJBQ0tFUjogbWV0aG9kICR7cnBjSW5zdGFsbElkfWAsIHRyYWNrZXIpO1xuXG4gICAgICAgICAgICAgIGlmICh0cmFja2VyPy5bcnBjSW5zdGFsbElkXS5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgICAgICAgICBgW2luaXRpYWxpemVNb2JpbGVQcm92aWRlcjogc2VuZFJlcXVlc3QoKV0gZm91bmQgcmVzdWx0YCxcbiAgICAgICAgICAgICAgICAgIHRyYWNrZXI/LltycGNJbnN0YWxsSWRdLnJlc3VsdCxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJlc29sdmUodHJhY2tlcj8uW3JwY0luc3RhbGxJZF0ucmVzdWx0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0cmFja2VyPy5bcnBjSW5zdGFsbElkXS5lcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlcihcbiAgICAgICAgICAgICAgICAgIGBbaW5pdGlhbGl6ZU1vYmlsZVByb3ZpZGVyOiBzZW5kUmVxdWVzdCgpXSBmb3VuZCBlcnJvcmAsXG4gICAgICAgICAgICAgICAgICB0cmFja2VyPy5bcnBjSW5zdGFsbElkXS5lcnJvcixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJlamVjdCh0cmFja2VyPy5bcnBjSW5zdGFsbElkXS5lcnJvcik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBycGNVcGRhdGVIYW5kbGVyID0gKCkgPT4gb25SUENVcGRhdGUoeyByZXNvbHZlLCByZWplY3QgfSk7XG5cbiAgICAgICAgICAgICAgbGlzdGVuZXIgPSByZW1vdGVDb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgPy5nZXRDb25uZWN0b3IoKVxuICAgICAgICAgICAgICAgIC5vbihFdmVudFR5cGUuUlBDX1VQREFURSwgcnBjVXBkYXRlSGFuZGxlcik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHJwY1VwZGF0ZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgbGlzdGVuZXI/Lm9mZihFdmVudFR5cGUuUlBDX1VQREFURSwgcnBjVXBkYXRlSGFuZGxlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxvZ2dlcihgVFJBQ0tFUjogcmVzdWx0YCwgcmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZ2dlcihgW2luaXRpYWxpemVNb2JpbGVQcm92aWRlcjogc2VuZFJlcXVlc3QoKV0gZXJyb3I6YCwgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5mb3JtIG5leHQgc3RlcCB0aGF0IHRoaXMgbWV0aG9kIHRyaWdnZXJlZCBpbnN0YWxsZXJcbiAgICAgICAgLy8gVE9ETzogY2hhbmdlIGxvZ2ljIHRvIGF2b2lkIHRoaXMgY2FsbCBhbmQgaW5zdGVhZCBzZW5kIGluaXRpYWwgbWV0aG9kIGluIHRoZSBpbnN0YWxsZXIgdG8gYXZvaWQgYmFjayBhbmQgZm9ydGggb24gbW9iaWxlLlxuICAgICAgICBpZiAoYXJnc1swXSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBhcmdzWzBdLnBhcmFtcyA9IHtcbiAgICAgICAgICAgIF9fdHJpZ2dlcmVkSW5zdGFsbGVyOiB0cnVlLFxuICAgICAgICAgICAgd3JhcHBlZFBhcmFtczogYXJnc1swXS5wYXJhbXMsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHJlcXVlc3QgKG90aGVyd2lzZSB0aGUgcnBjIGNhbGwgaXMgbm90IHNlbnQpXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXhlY3V0ZVJlcXVlc3QoLi4uYXJncyk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfSBlbHNlIGlmIChwbGF0Zm9ybU1hbmFnZXIuaXNTZWN1cmUoKSAmJiBNRVRIT0RTX1RPX1JFRElSRUNUW21ldGhvZF0pIHtcbiAgICAgICAgLy8gU2hvdWxkIGJlIGNvbm5lY3RlZCB0byBjYWxsIGYgPT0+IHJlZGlyZWN0IHRvIFJQQ01TXG4gICAgICAgIHJldHVybiBleGVjdXRlUmVxdWVzdCguLi5hcmdzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNkay5pc0V4dGVuc2lvbkFjdGl2ZSgpKSB7XG4gICAgICAgIC8vIEl0IG1lYW5zIHRoZXJlIHdhcyBhIHN3aXRjaCBvZiBwcm92aWRlciB3aGlsZSB3YWl0aW5nIGZvciBpbml0aWFsaXphdGlvbiAtLSByZWRpcmVjdCB0byB0aGUgZXh0ZW5zaW9uLlxuICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgYFtpbml0aWFsaXplTW9iaWxlUHJvdmlkZXI6IHNlbmRSZXF1ZXN0KCldIEVYVEVOU0lPTiBhY3RpdmUgLSByZWRpcmVjdCByZXF1ZXN0ICcke21ldGhvZH0nIHRvIGl0YCxcbiAgICAgICAgICBhcmdzLFxuICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyByZWRpcmVjdCB0byBleHRlbnNpb25cbiAgICAgICAgcmV0dXJuIGF3YWl0IHNkay5nZXRQcm92aWRlcigpPy5yZXF1ZXN0KHtcbiAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgcGFyYW1zLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgbG9nZ2VyKFxuICAgICAgICBgW2luaXRpYWxpemVNb2JpbGVQcm92aWRlcjogc2VuZFJlcXVlc3QoKV0gbWV0aG9kPSR7bWV0aG9kfSAtLS0gc2tpcCAtLS0gbm90IGNvbm5lY3RlZC9pbnN0YWxsZWRgLFxuICAgICAgKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ01ldGFNYXNrIGlzIG5vdCBjb25uZWN0ZWQvaW5zdGFsbGVkLCBwbGVhc2UgY2FsbCBldGhfcmVxdWVzdEFjY291bnRzIHRvIGNvbm5lY3QgZmlyc3QuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJwY1Jlc3BvbnNlID0gYXdhaXQgZXhlY3V0ZVJlcXVlc3QoLi4uYXJncyk7XG4gICAgICBsb2dnZXIoXG4gICAgICAgIGBbaW5pdGlhbGl6ZU1vYmlsZVByb3ZpZGVyOiBzZW5kUmVxdWVzdCgpXSBtZXRob2Q9JHttZXRob2R9IHJwY1Jlc3BvbnNlYCxcbiAgICAgICAgcnBjUmVzcG9uc2UsXG4gICAgICApO1xuXG4gICAgICAvLyBDaGVjayBmb3Igd2FsbGV0X3JlcXVlc3RQZXJtaXNzaW9ucyB0byB1cGRhdGUgbG9jYWwgbGlzdCBvZiBhY2NvdW50cyBzaW5jZSBtZXRhbWFzayBtb2JpbGUgZG9lc24ndCB1cGRhdGUgdGhlIGxpc3QgYXV0b21hdGljYWxseVxuICAgICAgaWYgKG1ldGhvZCA9PT0gUlBDX01FVEhPRFMuV0FMTEVUX1JFUVVFU1RQRVJNSVNTSU9OUykge1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IHJwY1Jlc3BvbnNlIGFzIHtcbiAgICAgICAgICBjYXZlYXRzOiB7IHR5cGU6IHN0cmluZzsgdmFsdWU6IHN0cmluZ1tdIH1bXTtcbiAgICAgICAgICBwYXJlbnRDYXBhYmlsaXR5OiBzdHJpbmc7XG4gICAgICAgIH1bXTtcblxuICAgICAgICBjb25zdCBhY2NvdW50c1RvUGVyc2lzdCA9IHBlcm1pc3Npb25zLnJlZHVjZShcbiAgICAgICAgICAoYWNjOiBzdHJpbmdbXSwgcGVybWlzc2lvbikgPT4ge1xuICAgICAgICAgICAgaWYgKHBlcm1pc3Npb24ucGFyZW50Q2FwYWJpbGl0eSA9PT0gJ2V0aF9hY2NvdW50cycpIHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdHJpY3RlZEFjY291bnRzID0gcGVybWlzc2lvbi5jYXZlYXRzLmZpbmQoXG4gICAgICAgICAgICAgICAgKGNhdmVhdCkgPT4gY2F2ZWF0LnR5cGUgPT09ICdyZXN0cmljdFJldHVybmVkQWNjb3VudHMnLFxuICAgICAgICAgICAgICApPy52YWx1ZTtcblxuICAgICAgICAgICAgICBpZiAocmVzdHJpY3RlZEFjY291bnRzKSB7XG4gICAgICAgICAgICAgICAgYWNjLnB1c2goLi4ucmVzdHJpY3RlZEFjY291bnRzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICB9LFxuICAgICAgICAgIFtdLFxuICAgICAgICApO1xuXG4gICAgICAgIGxvZ2dlcihcbiAgICAgICAgICBgW2luaXRpYWxpemVNb2JpbGVQcm92aWRlcjogc2VuZFJlcXVlc3QoKV0gYWNjb3VudHNUb1BlcnNpc3Q6YCxcbiAgICAgICAgICBhY2NvdW50c1RvUGVyc2lzdCxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoYWNjb3VudHNUb1BlcnNpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIEVtdWxhdGUgJ2FjY291bnRzQ2hhbmdlZCcgb24gdGhlIHByb3ZpZGVyXG4gICAgICAgICAgcHJvdmlkZXIuaGFuZGxlQWNjb3VudHNDaGFuZ2VkKGFjY291bnRzVG9QZXJzaXN0LCBmYWxzZSk7XG4gICAgICAgICAgLy8gcHJvdmlkZXIuZW1pdCgnYWNjb3VudHNDaGFuZ2VkJywgYWNjb3VudHNUb1BlcnNpc3QpO1xuICAgICAgICAgIHN0b3JhZ2VNYW5hZ2VyPy5wZXJzaXN0QWNjb3VudHMoYWNjb3VudHNUb1BlcnNpc3QpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBycGNSZXNwb25zZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgW2luaXRpYWxpemVNb2JpbGVQcm92aWRlcjogc2VuZFJlcXVlc3QoKV0gZXJyb3I6YCwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuXG4gIC8vIFdyYXAgZXRoZXJldW0ucmVxdWVzdCBjYWxsIHRvIGNoZWNrIGlmIHRoZSB1c2VyIG5lZWRzIHRvIGluc3RhbGwgTWV0YU1hc2tcbiAgY29uc3QgeyByZXF1ZXN0IH0gPSBldGhlcmV1bTtcbiAgLy8gcmVxdWVzdDxUPihhcmdzOiBSZXF1ZXN0QXJndW1lbnRzKTogUHJvbWlzZTxNYXliZTxUPj47XG4gIGV0aGVyZXVtLnJlcXVlc3QgPSBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgIHJldHVybiBzZW5kUmVxdWVzdChhcmdzPy5bMF0ubWV0aG9kLCBhcmdzLCByZXF1ZXN0LCBkZWJ1Zyk7XG4gIH07XG5cbiAgLy8gc2VuZDxUPihwYXlsb2FkOiBTZW5kU3luY0pzb25ScGNSZXF1ZXN0KTogSnNvblJwY1Jlc3BvbnNlPFQ+O1xuICBjb25zdCB7IHNlbmQgfSA9IGV0aGVyZXVtO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gIC8vIEB0cy1pZ25vcmUgLy8gVE9ETyByZW1vdmUgc3VwcG9ydCBmb3IgZGVwcmVjYXRlZCBtZXRob2RcbiAgZXRoZXJldW0uc2VuZCA9IGFzeW5jICguLi5hcmdzKSA9PiB7XG4gICAgcmV0dXJuIHNlbmRSZXF1ZXN0KGFyZ3M/LlswXSBhcyBzdHJpbmcsIGFyZ3MsIHNlbmQsIGRlYnVnKTtcbiAgfTtcblxuICBsb2dnZXIoYFtpbml0aWFsaXplTW9iaWxlUHJvdmlkZXI6IHNlbmRSZXF1ZXN0KCldIG1ldGFtYXNrU3RyZWFtLnN0YXJ0KClgKTtcbiAgbWV0YW1hc2tTdHJlYW0uc3RhcnQoKTtcbiAgcmV0dXJuIGV0aGVyZXVtO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaW5pdGlhbGl6ZU1vYmlsZVByb3ZpZGVyO1xuIiwiaW1wb3J0IHsgQ29tbXVuaWNhdGlvbkxheWVyUHJlZmVyZW5jZSB9IGZyb20gJ0BtZXRhbWFzay9zZGstY29tbXVuaWNhdGlvbi1sYXllcic7XG5pbXBvcnQgeyBQbGF0Zm9ybU1hbmFnZXIgfSBmcm9tICcuLi9QbGF0Zm9ybS9QbGF0ZmZvcm1NYW5hZ2VyJztcbmltcG9ydCB7IFByb3ZpZGVyQ29uc3RhbnRzIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IFJlbW90ZUNvbm5lY3Rpb24gfSBmcm9tICcuLi9zZXJ2aWNlcy9SZW1vdGVDb25uZWN0aW9uJztcbmltcG9ydCB7IFBvc3RNZXNzYWdlU3RyZWFtIH0gZnJvbSAnLi9Qb3N0TWVzc2FnZVN0cmVhbSc7XG5pbXBvcnQgeyBSZW1vdGVDb21tdW5pY2F0aW9uUG9zdE1lc3NhZ2VTdHJlYW0gfSBmcm9tICcuL1JlbW90ZUNvbW11bmljYXRpb25Qb3N0TWVzc2FnZVN0cmVhbSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgR2V0UG9zdE1lc3NhZ2VTdHJlYW1Qcm9wcyB7XG4gIG5hbWU6IFByb3ZpZGVyQ29uc3RhbnRzO1xuICB0YXJnZXQ6IFByb3ZpZGVyQ29uc3RhbnRzO1xuICByZW1vdGVDb25uZWN0aW9uPzogUmVtb3RlQ29ubmVjdGlvbjtcbiAgcGxhdGZvcm1NYW5hZ2VyOiBQbGF0Zm9ybU1hbmFnZXI7XG4gIGNvbW11bmljYXRpb25MYXllclByZWZlcmVuY2U6IENvbW11bmljYXRpb25MYXllclByZWZlcmVuY2U7XG59XG5cbmV4cG9ydCBjb25zdCBnZXRQb3N0TWVzc2FnZVN0cmVhbSA9ICh7XG4gIG5hbWUsXG4gIHJlbW90ZUNvbm5lY3Rpb24sXG59OiBHZXRQb3N0TWVzc2FnZVN0cmVhbVByb3BzKTogUG9zdE1lc3NhZ2VTdHJlYW0gPT4ge1xuICBpZiAoIXJlbW90ZUNvbm5lY3Rpb24gfHwgIXJlbW90ZUNvbm5lY3Rpb24/LmdldENvbm5lY3RvcigpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHJlbW90ZSBjb25uZWN0aW9uIHBhcmFtZXRlcmApO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBSZW1vdGVDb21tdW5pY2F0aW9uUG9zdE1lc3NhZ2VTdHJlYW0oe1xuICAgIG5hbWUsXG4gICAgcmVtb3RlOiByZW1vdGVDb25uZWN0aW9uPy5nZXRDb25uZWN0b3IoKSxcbiAgICBkZWVwbGlua1Byb3RvY29sOiByZW1vdGVDb25uZWN0aW9uPy5zdGF0ZS5kZWVwbGlua1Byb3RvY29sLFxuICAgIHBsYXRmb3JtTWFuYWdlcjogcmVtb3RlQ29ubmVjdGlvbj8uZ2V0UGxhdGZvcm1NYW5hZ2VyKCksXG4gIH0pO1xufTtcbiIsImltcG9ydCB7IHJwY1dpdGhBY2NvdW50UGFyYW0sIFJQQ19NRVRIT0RTIH0gZnJvbSAnLi4vY29uZmlnJztcbmltcG9ydCB7IE1ldGFNYXNrU0RLIH0gZnJvbSAnLi4vc2RrJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5cbmV4cG9ydCBjb25zdCBleHRlbnNpb25Db25uZWN0V2l0aE92ZXJ3cml0ZSA9IGFzeW5jICh7XG4gIG1ldGhvZCxcbiAgc2RrLFxuICBwYXJhbXMsXG59OiB7XG4gIG1ldGhvZDogc3RyaW5nO1xuICBzZGs6IE1ldGFNYXNrU0RLO1xuICBwYXJhbXM6IGFueTtcbn0pID0+IHtcbiAgaWYgKCFzZGsuaXNFeHRlbnNpb25BY3RpdmUoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgU0RLIHN0YXRlIGludmFsaWQgLS0gZXh0ZW5zaW9uIGlzIG5vdCBhY3RpdmVgKTtcbiAgfVxuXG4gIGxvZ2dlcihcbiAgICBgW01ldGFNYXNrUHJvdmlkZXI6IGV4dGVuc2lvbkNvbm5lY3RXaXRoT3ZlcndyaXRlKCldIE92ZXJ3cml0aW5nIHJlcXVlc3QgbWV0aG9kYCxcbiAgICBtZXRob2QsXG4gICAgcGFyYW1zLFxuICApO1xuXG4gIGNvbnN0IGFjY291bnRzID0gKGF3YWl0IHNkay5nZXRQcm92aWRlcigpPy5yZXF1ZXN0KHtcbiAgICBtZXRob2Q6IFJQQ19NRVRIT0RTLkVUSF9SRVFVRVNUQUNDT1VOVFMsXG4gICAgcGFyYW1zOiBbXSxcbiAgfSkpIGFzIHN0cmluZ1tdO1xuICBpZiAoIWFjY291bnRzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgU0RLIHN0YXRlIGludmFsaWQgLS0gdW5kZWZpbmVkIGFjY291bnRzYCk7XG4gIH1cblxuICBpZiAobWV0aG9kPy50b0xvd2VyQ2FzZSgpID09PSBSUENfTUVUSE9EUy5QRVJTT05BTF9TSUdOLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjb25zdCBjb25uZWN0ZWRScGMgPSB7XG4gICAgICBtZXRob2QsXG4gICAgICBwYXJhbXM6IFtwYXJhbXNbMF0sIGFjY291bnRzWzBdXSxcbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCBzZGsuZ2V0UHJvdmlkZXIoKT8ucmVxdWVzdChjb25uZWN0ZWRScGMpO1xuICB9IGVsc2UgaWYgKFxuICAgIG1ldGhvZD8udG9Mb3dlckNhc2UoKSA9PT0gUlBDX01FVEhPRFMuRVRIX1NFTkRUUkFOU0FDVElPTi50b0xvd2VyQ2FzZSgpXG4gICkge1xuICAgIGNvbnN0IGNvbm5lY3RlZFJwYyA9IHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIHBhcmFtczogW1xuICAgICAgICB7XG4gICAgICAgICAgLi4ucGFyYW1zWzBdLFxuICAgICAgICAgIGZyb206IGFjY291bnRzWzBdLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9O1xuICAgIHJldHVybiBhd2FpdCBzZGsuZ2V0UHJvdmlkZXIoKT8ucmVxdWVzdChjb25uZWN0ZWRScGMpO1xuICB9XG5cbiAgLy8gVE9ETzogaW1wbGVtZW50IG92ZXJ3cml0ZSBmb3IgZWFjaCByZW1haW5pbmcgc2lnbmVkVHlwZWQgbWV0aG9kc1xuICBpZiAocnBjV2l0aEFjY291bnRQYXJhbS5pbmNsdWRlcyhtZXRob2QudG9Mb3dlckNhc2UoKSkpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBgTWV0YU1hc2tTREsgY29ubmVjdFdpdGggbWV0aG9kPSR7bWV0aG9kfSAtLSBub3QgaGFuZGxlZCBieSB0aGUgZXh0ZW5zaW9uIC0tIGNhbGwgc2VwYXJhdGVseWAsXG4gICAgKTtcbiAgICByZXR1cm4gYWNjb3VudHM7XG4gIH1cblxuICAvLyBSZS1jcmVhdGUgdGhlIHF1ZXJ5IG9uIHRoZSBhY3RpdmUgcHJvdmlkZXJcbiAgcmV0dXJuIGF3YWl0IHNkay5nZXRQcm92aWRlcigpPy5yZXF1ZXN0KHtcbiAgICBtZXRob2QsXG4gICAgcGFyYW1zLFxuICB9KTtcbn07XG4iLCJpbXBvcnQgeyBDb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlIH0gZnJvbSAnQG1ldGFtYXNrL3Nkay1jb21tdW5pY2F0aW9uLWxheWVyJztcbmltcG9ydCB7IE1ldGFNYXNrSW5zdGFsbGVyIH0gZnJvbSAnLi4vLi4vLi4vUGxhdGZvcm0vTWV0YU1hc2tJbnN0YWxsZXInO1xuaW1wb3J0IHsgUGxhdGZvcm1NYW5hZ2VyIH0gZnJvbSAnLi4vLi4vLi4vUGxhdGZvcm0vUGxhdGZmb3JtTWFuYWdlcic7XG5pbXBvcnQgaW5pdGlhbGl6ZU1vYmlsZVByb3ZpZGVyIGZyb20gJy4uLy4uLy4uL3Byb3ZpZGVyL2luaXRpYWxpemVNb2JpbGVQcm92aWRlcic7XG5pbXBvcnQgeyBNZXRhTWFza1NESyB9IGZyb20gJy4uLy4uLy4uL3Nkayc7XG5pbXBvcnQgeyBpbml0RXZlbnRMaXN0ZW5lcnMgfSBmcm9tICcuL2luaXRFdmVudExpc3RlbmVycyc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIE1ldGFNYXNrIHByb3ZpZGVyIGFuZCBldmVudCBsaXN0ZW5lcnMgZm9yIHRoZSBTREsgaW5zdGFuY2UuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBmaXJzdCBpbml0aWFsaXplcyB0aGUgYWN0aXZlIHByb3ZpZGVyIGJ5IGNhbGxpbmcgJ2luaXRpYWxpemVQcm92aWRlcicgd2l0aCByZWxldmFudCBvcHRpb25zLlxuICogSXQgdGhlbiBzZXRzIHVwIGV2ZW50IGxpc3RlbmVycyBmb3IgdGhlIFNESyBpbnN0YW5jZSBieSBjYWxsaW5nICdpbml0RXZlbnRMaXN0ZW5lcnMnLlxuICpcbiAqIEBwYXJhbSBpbnN0YW5jZSBUaGUgTWV0YU1hc2tTREsgaW5zdGFuY2UgZm9yIHdoaWNoIHRoZSBwcm92aWRlciBhbmQgZXZlbnQgbGlzdGVuZXJzIHdpbGwgYmUgaW5pdGlhbGl6ZWQuXG4gKiBAcmV0dXJucyB2b2lkXG4gKiBAYXN5bmNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemVQcm92aWRlckFuZEV2ZW50TGlzdGVuZXJzKFxuICBpbnN0YW5jZTogTWV0YU1hc2tTREssXG4pIHtcbiAgY29uc3QgeyBvcHRpb25zIH0gPSBpbnN0YW5jZTtcblxuICAvLyBDcmVhdGUgYSBsb2NhbCBjb3B5IG9mIHRoZSBwcm92aWRlciBzZXR1cCBvcHRpb25zXG4gIGNvbnN0IHByb3ZpZGVyT3B0aW9ucyA9IHtcbiAgICBjb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlOlxuICAgICAgb3B0aW9ucy5jb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlID8/XG4gICAgICBDb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlLlNPQ0tFVCxcbiAgICBwbGF0Zm9ybU1hbmFnZXI6IGluc3RhbmNlLnBsYXRmb3JtTWFuYWdlciBhcyBQbGF0Zm9ybU1hbmFnZXIsXG4gICAgc2RrOiBpbnN0YW5jZSxcbiAgICBjaGVja0luc3RhbGxhdGlvbk9uQWxsQ2FsbHM6IG9wdGlvbnMuY2hlY2tJbnN0YWxsYXRpb25PbkFsbENhbGxzIGFzIGJvb2xlYW4sXG4gICAgaW5qZWN0UHJvdmlkZXI6IG9wdGlvbnMuaW5qZWN0UHJvdmlkZXIgPz8gdHJ1ZSxcbiAgICBzaG91bGRTaGltV2ViMzogb3B0aW9ucy5zaG91bGRTaGltV2ViMyA/PyB0cnVlLFxuICAgIGV4dGVuc2lvbk9ubHk6IG9wdGlvbnMuZXh0ZW5zaW9uT25seSA/PyB0cnVlLFxuICAgIGluc3RhbGxlcjogaW5zdGFuY2UuaW5zdGFsbGVyIGFzIE1ldGFNYXNrSW5zdGFsbGVyLFxuICAgIHJlbW90ZUNvbm5lY3Rpb246IGluc3RhbmNlLnJlbW90ZUNvbm5lY3Rpb24sXG4gICAgZGVidWc6IGluc3RhbmNlLmRlYnVnLFxuICB9O1xuXG4gIC8vIEluamVjdCBvdXIgcHJvdmlkZXIgaW50byB3aW5kb3cuZXRoZXJldW1cbiAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBpbml0aWFsaXplTW9iaWxlUHJvdmlkZXIocHJvdmlkZXJPcHRpb25zKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hdG9taWMtdXBkYXRlc1xuICBpbnN0YW5jZS5hY3RpdmVQcm92aWRlciA9IHByb3ZpZGVyO1xuXG4gIGluaXRFdmVudExpc3RlbmVycyhpbnN0YW5jZSk7XG59XG4iLCJpbXBvcnQge1xuICBDb25uZWN0aW9uU3RhdHVzLFxuICBTZXJ2aWNlU3RhdHVzLFxufSBmcm9tICdAbWV0YW1hc2svc2RrLWNvbW11bmljYXRpb24tbGF5ZXInO1xuaW1wb3J0IHsgTWV0YU1hc2tTREsgfSBmcm9tICcuLi8uLi8uLi9zZGsnO1xuaW1wb3J0IHsgTWV0YU1hc2tTREtFdmVudCB9IGZyb20gJy4uLy4uLy4uL3R5cGVzL01ldGFNYXNrU0RLRXZlbnRzJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBldmVudCBsaXN0ZW5lcnMgZm9yIE1ldGFNYXNrIFNESydzIHJlbW90ZSBjb25uZWN0aW9uLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gYXR0YWNoZXMgbGlzdGVuZXJzIGZvciBDT05ORUNUSU9OX1NUQVRVUyBhbmQgU0VSVklDRV9TVEFUVVMgZXZlbnRzXG4gKiBvbiB0aGUgcmVtb3RlIGNvbm5lY3Rpb24ncyBjb25uZWN0b3IuIFRoZXNlIGV2ZW50cyBhcmUgdGhlbiBlbWl0dGVkIG9uIHRoZSBpbnN0YW5jZVxuICogaXRzZWxmLCBlZmZlY3RpdmVseSBwcm9wYWdhdGluZyB0aGVzZSBldmVudHMgdG8gd2hvZXZlciBpcyB1c2luZyB0aGUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIGluc3RhbmNlIFRoZSBNZXRhTWFza1NESyBpbnN0YW5jZSBmb3Igd2hpY2ggZXZlbnQgbGlzdGVuZXJzIGFyZSBiZWluZyBpbml0aWFsaXplZC5cbiAqIEByZXR1cm5zIHZvaWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluaXRFdmVudExpc3RlbmVycyhpbnN0YW5jZTogTWV0YU1hc2tTREspIHtcbiAgaW5zdGFuY2UucmVtb3RlQ29ubmVjdGlvblxuICAgID8uZ2V0Q29ubmVjdG9yKClcbiAgICA/Lm9uKFxuICAgICAgTWV0YU1hc2tTREtFdmVudC5Db25uZWN0aW9uU3RhdHVzLFxuICAgICAgKGNvbm5lY3Rpb25TdGF0dXM6IENvbm5lY3Rpb25TdGF0dXMpID0+IHtcbiAgICAgICAgaW5zdGFuY2UuZW1pdChNZXRhTWFza1NES0V2ZW50LkNvbm5lY3Rpb25TdGF0dXMsIGNvbm5lY3Rpb25TdGF0dXMpO1xuICAgICAgfSxcbiAgICApO1xuXG4gIGluc3RhbmNlLnJlbW90ZUNvbm5lY3Rpb25cbiAgICA/LmdldENvbm5lY3RvcigpXG4gICAgPy5vbihNZXRhTWFza1NES0V2ZW50LlNlcnZpY2VTdGF0dXMsIChzZXJ2aWNlU3RhdHVzOiBTZXJ2aWNlU3RhdHVzKSA9PiB7XG4gICAgICBpbnN0YW5jZS5lbWl0KE1ldGFNYXNrU0RLRXZlbnQuU2VydmljZVN0YXR1cywgc2VydmljZVN0YXR1cyk7XG4gICAgfSk7XG59XG4iLCJpbXBvcnQge1xuICBERUZBVUxUX1NFUlZFUl9VUkwsXG4gIFNlbmRBbmFseXRpY3MsXG4gIEFuYWx5dGljc1Byb3BzLFxuICBUcmFja2luZ0V2ZW50cyxcbn0gZnJvbSAnQG1ldGFtYXNrL3Nkay1jb21tdW5pY2F0aW9uLWxheWVyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgcGFja2FnZUpzb24gZnJvbSAnLi4vLi4vcGFja2FnZS5qc29uJztcblxuZXhwb3J0IGNvbnN0IEFOQUxZVElDU19DT05TVEFOVFMgPSB7XG4gIERFRkFVTFRfSUQ6ICdzZGsnLFxuICBOT19WRVJTSU9OOiAnTk9ORScsXG59O1xuXG5leHBvcnQgY2xhc3MgQW5hbHl0aWNzIHtcbiAgcHJpdmF0ZSBzZXJ2ZXJVUkw6IHN0cmluZyA9IERFRkFVTFRfU0VSVkVSX1VSTDtcblxuICBwcml2YXRlIGVuYWJsZWQ6IGJvb2xlYW47XG5cbiAgcHJpdmF0ZSByZWFkb25seSBvcmlnaW5hdG9ySW5mbzogUmVhZG9ubHk8QW5hbHl0aWNzUHJvcHNbJ29yaWdpbmF0b3JJbmZvJ10+O1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBzZXJ2ZXJVcmwsXG4gICAgZW5hYmxlZCxcbiAgICBvcmlnaW5hdG9ySW5mbyxcbiAgfToge1xuICAgIHNlcnZlclVybDogc3RyaW5nO1xuICAgIG9yaWdpbmF0b3JJbmZvOiBBbmFseXRpY3NQcm9wc1snb3JpZ2luYXRvckluZm8nXTtcbiAgICBlbmFibGVkPzogYm9vbGVhbjtcbiAgfSkge1xuICAgIHRoaXMuc2VydmVyVVJMID0gc2VydmVyVXJsO1xuICAgIHRoaXMub3JpZ2luYXRvckluZm8gPSBvcmlnaW5hdG9ySW5mbztcbiAgICB0aGlzLmVuYWJsZWQgPSBlbmFibGVkID8/IHRydWU7XG4gIH1cblxuICBzZW5kKHtcbiAgICBldmVudCxcbiAgICBwYXJhbXMsXG4gIH06IHtcbiAgICBldmVudDogVHJhY2tpbmdFdmVudHM7XG4gICAgcGFyYW1zPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIH0pIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHByb3BzOiBBbmFseXRpY3NQcm9wcyA9IHtcbiAgICAgIGlkOiBBTkFMWVRJQ1NfQ09OU1RBTlRTLkRFRkFVTFRfSUQsXG4gICAgICBldmVudCxcbiAgICAgIHNka1ZlcnNpb246IHBhY2thZ2VKc29uLnZlcnNpb24sXG4gICAgICAuLi50aGlzLm9yaWdpbmF0b3JJbmZvLFxuICAgICAgcGFyYW1zLFxuICAgIH07XG4gICAgbG9nZ2VyKGBbQW5hbHl0aWNzOiBzZW5kKCldIGV2ZW50OiAke2V2ZW50fWAsIHByb3BzKTtcblxuICAgIFNlbmRBbmFseXRpY3MocHJvcHMsIHRoaXMuc2VydmVyVVJMKS5jYXRjaCgoZXJyb3I6IHVua25vd24pID0+IHtcbiAgICAgIGxvZ2dlcihgW0FuYWx5dGljczogc2VuZCgpXSBlcnJvcjogJHtlcnJvcn1gKTtcbiAgICB9KTtcbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IGV4dHJhY3RGYXZpY29uID0gKCkgPT4ge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBsZXQgZmF2aWNvbjtcbiAgY29uc3Qgbm9kZUxpc3QgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGluaycpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci1mb3Itb2ZcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChcbiAgICAgIG5vZGVMaXN0W2ldLmdldEF0dHJpYnV0ZSgncmVsJykgPT09ICdpY29uJyB8fFxuICAgICAgbm9kZUxpc3RbaV0uZ2V0QXR0cmlidXRlKCdyZWwnKSA9PT0gJ3Nob3J0Y3V0IGljb24nXG4gICAgKSB7XG4gICAgICBmYXZpY29uID0gbm9kZUxpc3RbaV0uZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYXZpY29uO1xufTtcbiIsImltcG9ydCB7IE1ldGFNYXNrU0RLIH0gZnJvbSAnLi4vLi4vLi4vc2RrJztcbmltcG9ydCB7IGV4dHJhY3RGYXZpY29uIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvZXh0cmFjdEZhdmljb24nO1xuXG4vKipcbiAqIFZhbGlkYXRlcyBhbmQgYXR0YWNoZXMgRGFwcCBtZXRhZGF0YSB0byBhIE1ldGFNYXNrIFNESyBpbnN0YW5jZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyAnaWNvblVybCcgYW5kICd1cmwnIGluIHRoZSBEYXBwIG1ldGFkYXRhLCBlbnN1cmluZyB0aGV5IHN0YXJ0IHdpdGggJ2h0dHA6Ly8nIG9yICdodHRwczovLycuXG4gKiBJZiB0aGVzZSBVUkxzIGFyZSBpbmNvcnJlY3RseSBmb3JtYXR0ZWQsIGFuIGVycm9yIGlzIHRocm93bi4gVmFsaWQgbWV0YWRhdGEgaXMgdGhlbiBhdHRhY2hlZCB0byB0aGUgU0RLIGluc3RhbmNlLlxuICogTm90ZTogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBoYW5kbGUgZmF2aWNvbiBleHRyYWN0aW9uIG9yIGJhc2U2NCBjb252ZXJzaW9uLlxuICpcbiAqIEBwYXJhbSBpbnN0YW5jZSBUaGUgTWV0YU1hc2tTREsgaW5zdGFuY2UgZm9yIHdoaWNoIERhcHAgbWV0YWRhdGEgd2lsbCBiZSBzZXQgdXAuXG4gKiBAcmV0dXJucyB2b2lkXG4gKi9cblxuY29uc3QgQkFTRV82NF9JQ09OX01BWF9MRU5HVEggPSAxNjM0MDA7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZXR1cERhcHBNZXRhZGF0YShpbnN0YW5jZTogTWV0YU1hc2tTREspIHtcbiAgY29uc3QgeyBvcHRpb25zIH0gPSBpbnN0YW5jZTtcblxuICAvLyBDaGVjayBpZiBpY29uVXJsIGFuZCB1cmwgYXJlIHZhbGlkXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZXF1aXJlLXVuaWNvZGUtcmVnZXhwXG4gIGNvbnN0IHVybFBhdHRlcm4gPSAvXihodHRwfGh0dHBzKTpcXC9cXC9bXlxcc10qJC87IC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiBmb3IgVVJMcyBzdGFydGluZyB3aXRoIGh0dHA6Ly8gb3IgaHR0cHM6Ly9cblxuICBpZiAob3B0aW9ucy5kYXBwTWV0YWRhdGEpIHtcbiAgICBpZiAoXG4gICAgICBvcHRpb25zLmRhcHBNZXRhZGF0YS5pY29uVXJsICYmXG4gICAgICAhdXJsUGF0dGVybi50ZXN0KG9wdGlvbnMuZGFwcE1ldGFkYXRhLmljb25VcmwpXG4gICAgKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdJbnZhbGlkIGRhcHBNZXRhZGF0YS5pY29uVXJsOiBVUkwgbXVzdCBzdGFydCB3aXRoIGh0dHA6Ly8gb3IgaHR0cHM6Ly8nLFxuICAgICAgKTtcblxuICAgICAgb3B0aW9ucy5kYXBwTWV0YWRhdGEuaWNvblVybCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGNoZWNrIGVuc3VyZXMgdGhhdCB0aGUgYmFzZTY0SWNvbiBzdHJpbmcgaW4gdGhlIGRhcHBNZXRhZGF0YSBkb2VzIG5vdCBleGNlZWQgMTYzLDQwMCBjaGFyYWN0ZXJzLlxuICAgIC8vIFRoZSBjaGFyYWN0ZXIgbGltaXQgaXMgaW1wb3J0YW50IGJlY2F1c2UgYSBsb25nZXIgYmFzZTY0LWVuY29kZWQgc3RyaW5nIGNhdXNlcyB0aGUgY29ubmVjdGlvbiB0byB0aGUgbW9iaWxlIGFwcCB0byBmYWlsLlxuICAgIC8vIEtlZXBpbmcgdGhlIGJhc2U2NEljb24gc3RyaW5nIGxlbmd0aCBiZWxvdyB0aGlzIHRocmVzaG9sZCBlbnN1cmVzIHJlbGlhYmxlIGNvbW11bmljYXRpb24gYW5kIGZ1bmN0aW9uYWxpdHkuXG4gICAgaWYgKFxuICAgICAgb3B0aW9ucy5kYXBwTWV0YWRhdGEuYmFzZTY0SWNvbiAmJlxuICAgICAgb3B0aW9ucy5kYXBwTWV0YWRhdGEuYmFzZTY0SWNvbi5sZW5ndGggPiBCQVNFXzY0X0lDT05fTUFYX0xFTkdUSFxuICAgICkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAnSW52YWxpZCBkYXBwTWV0YWRhdGEuYmFzZTY0SWNvbjogQmFzZTY0LWVuY29kZWQgaWNvbiBzdHJpbmcgbGVuZ3RoIG11c3QgYmUgbGVzcyB0aGFuIDE2MzQwMCBjaGFyYWN0ZXJzJyxcbiAgICAgICk7XG5cbiAgICAgIG9wdGlvbnMuZGFwcE1ldGFkYXRhLmJhc2U2NEljb24gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgb3B0aW9ucy5kYXBwTWV0YWRhdGEudXJsICYmXG4gICAgICAhdXJsUGF0dGVybi50ZXN0KG9wdGlvbnMuZGFwcE1ldGFkYXRhLnVybClcbiAgICApIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgJ0ludmFsaWQgZGFwcE1ldGFkYXRhLnVybDogVVJMIG11c3Qgc3RhcnQgd2l0aCBodHRwOi8vIG9yIGh0dHBzOi8vJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZmF2aWNvbiA9IGV4dHJhY3RGYXZpY29uKCk7XG5cbiAgICBpZiAoXG4gICAgICBmYXZpY29uICYmXG4gICAgICAhb3B0aW9ucy5kYXBwTWV0YWRhdGEuaWNvblVybCAmJlxuICAgICAgIW9wdGlvbnMuZGFwcE1ldGFkYXRhLmJhc2U2NEljb25cbiAgICApIHtcbiAgICAgIGNvbnN0IGZhdmljb25VcmwgPSBgJHt3aW5kb3cubG9jYXRpb24ucHJvdG9jb2x9Ly8ke3dpbmRvdy5sb2NhdGlvbi5ob3N0fSR7ZmF2aWNvbn1gO1xuXG4gICAgICBvcHRpb25zLmRhcHBNZXRhZGF0YS5pY29uVXJsID0gZmF2aWNvblVybDtcbiAgICB9XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXRvbWljLXVwZGF0ZXNcbiAgaW5zdGFuY2UuZGFwcE1ldGFkYXRhID0gb3B0aW9ucy5kYXBwTWV0YWRhdGE7XG59XG4iLCJpbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tICd1dWlkJztcbmltcG9ydCB7IFBsYXRmb3JtVHlwZSB9IGZyb20gJ0BtZXRhbWFzay9zZGstY29tbXVuaWNhdGlvbi1sYXllcic7XG5pbXBvcnQgeyBNZXRhTWFza1NESyB9IGZyb20gJy4uLy4uL3Nkayc7XG5pbXBvcnQgeyBiYXNlNjRFbmNvZGUgfSBmcm9tICcuLi8uLi91dGlscy9iYXNlNjQnO1xuXG5pbnRlcmZhY2UgRGFwcElkZW50aWZpZXIge1xuICB1cmw6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJldHJpZXZlcyBvciBnZW5lcmF0ZXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgYSBkYXBwIGJhc2VkIG9uIGl0cyBtZXRhZGF0YSxcbiAqIGFuZCBkZXRlcm1pbmVzIHRoZSBwbGF0Zm9ybSB0eXBlIGZyb20gd2hpY2ggdGhlIHJlcXVlc3QgaXMgb3JpZ2luYXRpbmcuXG4gKlxuICogQHBhcmFtIHtTREtJbnN0YW5jZX0gc2RrSW5zdGFuY2UgLSBUaGUgU0RLIGluc3RhbmNlIGNvbnRhaW5pbmcgbWV0YWRhdGEgYW5kIHBsYXRmb3JtIG1hbmFnZXIgaW5mb3JtYXRpb24uXG4gKlxuICogVGhlIGBzZGtJbnN0YW5jZWAgcGFyYW1ldGVyIHNob3VsZCBoYXZlIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxuICogLSBgZGFwcE1ldGFkYXRhYCAob3B0aW9uYWwpOiBBbiBvYmplY3QgY29udGFpbmluZyBtZXRhZGF0YSBhYm91dCB0aGUgZGFwcC5cbiAqICAgLSBgdXJsYDogVGhlIFVSTCBvZiB0aGUgZGFwcCAoZS5nLiwgJ2h0dHBzOi8vZXhhbXBsZS5jb20nKS5cbiAqICAgLSBgbmFtZWA6IFRoZSBuYW1lIG9mIHRoZSBkYXBwIChlLmcuLCAnRXhhbXBsZSBEYXBwJykuXG4gKiAtIGBwbGF0Zm9ybU1hbmFnZXJgIChvcHRpb25hbCk6IEFuIG9iamVjdCByZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgcGxhdGZvcm0tc3BlY2lmaWMgZGV0YWlscy5cbiAqICAgLSBgZ2V0UGxhdGZvcm1UeXBlYDogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHBsYXRmb3JtIHR5cGUsIHR5cGljYWxseSBhbiBlbnVtIGxpa2UgYFBsYXRmb3JtVHlwZS5EZXNrdG9wV2ViYCBvciBgUGxhdGZvcm1UeXBlLk1ldGFNYXNrTW9iaWxlV2Vidmlld2AuXG4gKlxuICogQHJldHVybnMge3sgaWQ6IHN0cmluZywgZnJvbTogc3RyaW5nIH19IC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICogLSBgaWRgOiBBIHVuaXF1ZSBpZGVudGlmaWVyIChVVUlEKSBmb3IgdGhlIGRhcHAsIGdlbmVyYXRlZCBiYXNlZCBvbiB0aGUgZGFwcCdzIFVSTCBhbmQgbmFtZS5cbiAqIC0gYGZyb21gOiBBIHN0cmluZyBpbmRpY2F0aW5nIHRoZSBwbGF0Zm9ybSB0eXBlIGZyb20gd2hpY2ggdGhlIHJlcXVlc3Qgb3JpZ2luYXRlczpcbiAqICAgLSBgJ2V4dGVuc2lvbidgIGlmIHRoZSBwbGF0Zm9ybSB0eXBlIGlzIGBEZXNrdG9wV2ViYC5cbiAqICAgLSBgJ21vYmlsZSdgIGlmIHRoZSBwbGF0Zm9ybSB0eXBlIGlzIGBNZXRhTWFza01vYmlsZVdlYnZpZXdgLlxuICogICAtIGAnTi9BJ2AgaWYgdGhlIHBsYXRmb3JtIHR5cGUgaXMgbmVpdGhlciBvZiB0aGUgYWJvdmUgb3IgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiBnZXRQbGF0Zm9ybURldGFpbHMoc2RrSW5zdGFuY2U6IE1ldGFNYXNrU0RLKSB7XG4gIGNvbnN0IHsgZGFwcE1ldGFkYXRhIH0gPSBzZGtJbnN0YW5jZTtcbiAgY29uc3QgdXJsID0gZGFwcE1ldGFkYXRhPy51cmwgPz8gJ25vX3VybCc7XG4gIGNvbnN0IG5hbWUgPSBkYXBwTWV0YWRhdGE/Lm5hbWUgPz8gJ25vX25hbWUnO1xuICBjb25zdCBpZCA9IGdldE9yQ3JlYXRlVXVpZEZvcklkZW50aWZpZXIoeyB1cmwsIG5hbWUgfSk7XG5cbiAgY29uc3QgcGxhdEZvcm1UeXBlID0gc2RrSW5zdGFuY2UucGxhdGZvcm1NYW5hZ2VyPy5nZXRQbGF0Zm9ybVR5cGUoKTtcbiAgY29uc3QgaXNFeHRlbnNpb24gPSBwbGF0Rm9ybVR5cGUgPT09IFBsYXRmb3JtVHlwZS5EZXNrdG9wV2ViO1xuICBjb25zdCBpc0luQXBwQnJvd3NlciA9IHBsYXRGb3JtVHlwZSA9PT0gUGxhdGZvcm1UeXBlLk1ldGFNYXNrTW9iaWxlV2VidmlldztcblxuICBsZXQgZnJvbSA9ICdOL0EnO1xuICBpZiAoaXNFeHRlbnNpb24pIHtcbiAgICBmcm9tID0gJ2V4dGVuc2lvbic7XG4gIH0gZWxzZSBpZiAoaXNJbkFwcEJyb3dzZXIpIHtcbiAgICBmcm9tID0gJ21vYmlsZSc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlkLFxuICAgIGZyb20sXG4gIH07XG59XG5cbi8qKlxuICogR2V0cyBvciBjcmVhdGVzIGEgdW5pcXVlIGlkZW50aWZpZXIgKFVVSUQpIGJhc2VkIG9uIHRoZSBwcm92aWRlZCB1cmwgYW5kIG5hbWUuXG4gKiBUaGUgaWRlbnRpZmllciBpcyBzdG9yZWQgaW4gbG9jYWxTdG9yYWdlIHVzaW5nIGEgQmFzZTY0IGVuY29kZWQgY29tYmluYXRpb24gb2YgYHVybGAgYW5kIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge0RhcHBJZGVudGlmaWVyfSBpZGVudGlmaWVyIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGB1cmxgIGFuZCBgbmFtZWAgb2YgdGhlIGRhcHAuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciAoVVVJRCkgZm9yIHRoZSBkYXBwLlxuICovXG5mdW5jdGlvbiBnZXRPckNyZWF0ZVV1aWRGb3JJZGVudGlmaWVyKHsgdXJsLCBuYW1lIH06IERhcHBJZGVudGlmaWVyKTogc3RyaW5nIHtcbiAgY29uc3QgcmF3SWRlbnRpZmllciA9IHVybCArIG5hbWU7XG4gIGNvbnN0IGVuY29kZWRJZGVudGlmaWVyID0gYmFzZTY0RW5jb2RlKHJhd0lkZW50aWZpZXIpO1xuXG4gIGlmICghbG9jYWxTdG9yYWdlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgbGV0IHN0b3JlZFV1aWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShlbmNvZGVkSWRlbnRpZmllcikgPz8gJyc7XG5cbiAgaWYgKCFzdG9yZWRVdWlkKSB7XG4gICAgc3RvcmVkVXVpZCA9IHV1aWR2NCgpO1xuICAgIHRyeSB7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShlbmNvZGVkSWRlbnRpZmllciwgc3RvcmVkVXVpZCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RvcmVkVXVpZDtcbn1cbmV4cG9ydCB7IGdldE9yQ3JlYXRlVXVpZEZvcklkZW50aWZpZXIsIGdldFBsYXRmb3JtRGV0YWlscyB9O1xuIiwiaW1wb3J0IHsgYW5hbHl0aWNzIH0gZnJvbSAnQG1ldGFtYXNrL3Nkay1hbmFseXRpY3MnO1xuaW1wb3J0IHsgaXNBbmFseXRpY3NUcmFja2VkUnBjTWV0aG9kIH0gZnJvbSAnQG1ldGFtYXNrL3Nkay1jb21tdW5pY2F0aW9uLWxheWVyJztcblxuLyoqXG4gKiBUcmFja3MgdGhlIG91dGNvbWUgb2YgYW4gUlBDIG1ldGhvZCBmb3IgYW5hbHl0aWNzLlxuICpcbiAqIEBwYXJhbSBtZXRob2QgLSBUaGUgUlBDIG1ldGhvZCBuYW1lLlxuICogQHBhcmFtIHJlc3AgLSBUaGUgcmVzcG9uc2Ugb2JqZWN0IGZyb20gdGhlIFJQQyBjYWxsLlxuICogQHBhcmFtIGNhdWdodEVycm9yIC0gQW55IGVycm9yIGNhdWdodCBkdXJpbmcgdGhlIFJQQyBjYWxsLlxuICovXG5leHBvcnQgY29uc3QgdHJhY2tScGNPdXRjb21lID0gKFxuICBtZXRob2Q6IHN0cmluZyxcbiAgcmVzcDogYW55LFxuICBjYXVnaHRFcnJvcjogYW55LFxuKTogdm9pZCA9PiB7XG4gIGlmIChpc0FuYWx5dGljc1RyYWNrZWRScGNNZXRob2QobWV0aG9kKSkge1xuICAgIGNvbnN0IHJlc3BvbnNlSW5kaWNhdGVzRXJyb3IgPVxuICAgICAgcmVzcCAmJiB0eXBlb2YgcmVzcCA9PT0gJ29iamVjdCcgJiYgcmVzcCAhPT0gbnVsbCAmJiAnZXJyb3InIGluIHJlc3A7XG5cbiAgICBpZiAoY2F1Z2h0RXJyb3IgfHwgcmVzcG9uc2VJbmRpY2F0ZXNFcnJvcikge1xuICAgICAgLy8gRGV0ZXJtaW5lIGlmIGl0J3MgYSB1c2VyIHJlamVjdGlvbiAoRUlQLTExOTMgc3BlY2lmaWMgY29kZSlcbiAgICAgIGNvbnN0IGVycm9yT2JqID0gY2F1Z2h0RXJyb3IgfHwgKHJlc3AgYXMgYW55KT8uZXJyb3I7XG4gICAgICBpZiAoZXJyb3JPYmogJiYgZXJyb3JPYmouY29kZSA9PT0gNDAwMSkge1xuICAgICAgICBhbmFseXRpY3MudHJhY2soJ3Nka19hY3Rpb25fcmVqZWN0ZWQnLCB7IGFjdGlvbjogbWV0aG9kIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5hbHl0aWNzLnRyYWNrKCdzZGtfYWN0aW9uX2ZhaWxlZCcsIHsgYWN0aW9uOiBtZXRob2QgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuYWx5dGljcy50cmFjaygnc2RrX2FjdGlvbl9zdWNjZWVkZWQnLCB7IGFjdGlvbjogbWV0aG9kIH0pO1xuICAgIH1cbiAgfVxufTtcbiIsImltcG9ydCB7IE1ldGFNYXNrSW5wYWdlUHJvdmlkZXIgfSBmcm9tICdAbWV0YW1hc2svcHJvdmlkZXJzJztcbmltcG9ydCB7XG4gIGlzQW5hbHl0aWNzVHJhY2tlZFJwY01ldGhvZCxcbiAgVHJhY2tpbmdFdmVudHMsXG59IGZyb20gJ0BtZXRhbWFzay9zZGstY29tbXVuaWNhdGlvbi1sYXllcic7XG5pbXBvcnQgeyBhbmFseXRpY3MgfSBmcm9tICdAbWV0YW1hc2svc2RrLWFuYWx5dGljcyc7XG5cbmltcG9ydCB7IGxjQW5hbHl0aWNzUlBDcywgUlBDX01FVEhPRFMgfSBmcm9tICcuLi9jb25maWcnO1xuaW1wb3J0IHsgTWV0YU1hc2tTREsgfSBmcm9tICcuLi9zZGsnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IGhhbmRsZUJhdGNoTWV0aG9kIH0gZnJvbSAnLi9leHRlbnNpb25Qcm92aWRlckhlbHBlcnMvaGFuZGxlQmF0Y2hNZXRob2QnO1xuaW1wb3J0IHsgaGFuZGxlQ29ubmVjdFNpZ25NZXRob2QgfSBmcm9tICcuL2V4dGVuc2lvblByb3ZpZGVySGVscGVycy9oYW5kbGVDb25uZWN0U2lnbk1ldGhvZCc7XG5pbXBvcnQgeyBoYW5kbGVDb25uZWN0V2l0aE1ldGhvZCB9IGZyb20gJy4vZXh0ZW5zaW9uUHJvdmlkZXJIZWxwZXJzL2hhbmRsZUNvbm5lY3RXaXRoTWV0aG9kJztcbmltcG9ydCB7IGdldFBsYXRmb3JtRGV0YWlscyB9IGZyb20gJy4vZXh0ZW5zaW9uUHJvdmlkZXJIZWxwZXJzL2hhbmRsZVV1aWQnO1xuaW1wb3J0IHsgdHJhY2tScGNPdXRjb21lIH0gZnJvbSAnLi9leHRlbnNpb25Qcm92aWRlckhlbHBlcnMvYW5hbHl0aWNzSGVscGVyJztcblxuZXhwb3J0IGludGVyZmFjZSBSZXF1ZXN0QXJndW1lbnRzIHtcbiAgbWV0aG9kOiBzdHJpbmc7XG4gIHBhcmFtcz86IGFueVtdO1xufVxuXG5leHBvcnQgY29uc3Qgd3JhcEV4dGVuc2lvblByb3ZpZGVyID0gKHtcbiAgcHJvdmlkZXIsXG4gIHNka0luc3RhbmNlLFxufToge1xuICBwcm92aWRlcjogTWV0YU1hc2tJbnBhZ2VQcm92aWRlcjtcbiAgc2RrSW5zdGFuY2U6IE1ldGFNYXNrU0RLO1xufSkgPT4ge1xuICBpZiAoJ3N0YXRlJyBpbiBwcm92aWRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignSU5WQUxJRCBFWFRFTlNJT04gUFJPVklERVInKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJveHkocHJvdmlkZXIsIHtcbiAgICBnZXQodGFyZ2V0LCBwcm9wS2V5KSB7XG4gICAgICBpZiAocHJvcEtleSA9PT0gJ3JlcXVlc3QnKSB7XG4gICAgICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiAoYXJnczogUmVxdWVzdEFyZ3VtZW50cykge1xuICAgICAgICAgIGxvZ2dlcihgW3dyYXBFeHRlbnNpb25Qcm92aWRlcigpXSBPdmVyd3JpdGluZyByZXF1ZXN0IG1ldGhvZGAsIGFyZ3MpO1xuXG4gICAgICAgICAgY29uc3QgeyBtZXRob2QsIHBhcmFtcyB9ID0gYXJncztcbiAgICAgICAgICBjb25zdCB0cmFja0V2ZW50ID0gbGNBbmFseXRpY3NSUENzLmluY2x1ZGVzKG1ldGhvZC50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgICAgIGNvbnN0IHsgaWQsIGZyb20gfSA9IGdldFBsYXRmb3JtRGV0YWlscyhzZGtJbnN0YW5jZSk7XG5cbiAgICAgICAgICBpZiAodHJhY2tFdmVudCkge1xuICAgICAgICAgICAgc2RrSW5zdGFuY2UuYW5hbHl0aWNzPy5zZW5kKHtcbiAgICAgICAgICAgICAgZXZlbnQ6IFRyYWNraW5nRXZlbnRzLlNES19SUENfUkVRVUVTVCxcbiAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNBbmFseXRpY3NUcmFja2VkUnBjTWV0aG9kKG1ldGhvZCkpIHtcbiAgICAgICAgICAgIGFuYWx5dGljcy50cmFjaygnc2RrX2FjdGlvbl9yZXF1ZXN0ZWQnLCB7IGFjdGlvbjogbWV0aG9kIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtZXRob2QgPT09IFJQQ19NRVRIT0RTLk1FVEFNQVNLX0JBVENIICYmIEFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUJhdGNoTWV0aG9kKHtcbiAgICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICB0cmFja0V2ZW50LFxuICAgICAgICAgICAgICBzZGtJbnN0YW5jZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG1ldGhvZC50b0xvd2VyQ2FzZSgpID09PVxuICAgICAgICAgICAgICBSUENfTUVUSE9EUy5NRVRBTUFTS19DT05ORUNUU0lHTi50b0xvd2VyQ2FzZSgpICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHBhcmFtcylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVDb25uZWN0U2lnbk1ldGhvZCh7IHRhcmdldCwgcGFyYW1zIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIG1ldGhvZC50b0xvd2VyQ2FzZSgpID09PVxuICAgICAgICAgICAgICBSUENfTUVUSE9EUy5NRVRBTUFTS19DT05ORUNUV0lUSC50b0xvd2VyQ2FzZSgpICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHBhcmFtcylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVDb25uZWN0V2l0aE1ldGhvZCh7IHRhcmdldCwgcGFyYW1zIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCByZXNwO1xuICAgICAgICAgIGxldCBjYXVnaHRFcnJvcjogYW55ID0gbnVsbDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcCA9IGF3YWl0IHRhcmdldC5yZXF1ZXN0KGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKHRyYWNrRXZlbnQpIHtcbiAgICAgICAgICAgICAgc2RrSW5zdGFuY2UuYW5hbHl0aWNzPy5zZW5kKHtcbiAgICAgICAgICAgICAgICBldmVudDogVHJhY2tpbmdFdmVudHMuU0RLX1JQQ19SRVFVRVNUX0RPTkUsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyYWNrUnBjT3V0Y29tZShtZXRob2QsIHJlc3AsIGNhdWdodEVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09ICdnZXRDaGFpbklkJykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm92aWRlci5jaGFpbklkO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSAnZ2V0TmV0d29ya1ZlcnNpb24nKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLm5ldHdvcmtWZXJzaW9uO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSAnZ2V0U2VsZWN0ZWRBZGRyZXNzJykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBwcm92aWRlci5zZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09ICdpc0Nvbm5lY3RlZCcpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBUT0RPOiBhbGxvd2VkIGJlY2F1c2Ugb2YgaXNzdWUgb24gaW5wYXZnZSBwcm92aWRlclxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLl9zdGF0ZS5pc0Nvbm5lY3RlZDtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRhcmdldFtwcm9wS2V5IGFzIGtleW9mIE1ldGFNYXNrSW5wYWdlUHJvdmlkZXJdO1xuICAgIH0sXG4gIH0pO1xufTtcbiIsImltcG9ydCB7IE1ldGFNYXNrSW5wYWdlUHJvdmlkZXIgfSBmcm9tICdAbWV0YW1hc2svcHJvdmlkZXJzJztcbmltcG9ydCB7IFRyYWNraW5nRXZlbnRzIH0gZnJvbSAnQG1ldGFtYXNrL3Nkay1jb21tdW5pY2F0aW9uLWxheWVyJztcbmltcG9ydCB7IE1ldGFNYXNrU0RLIH0gZnJvbSAnLi4vLi4vc2RrJztcbmltcG9ydCB7IFJlcXVlc3RBcmd1bWVudHMgfSBmcm9tICcuLi93cmFwRXh0ZW5zaW9uUHJvdmlkZXInO1xuaW1wb3J0IHsgZ2V0UGxhdGZvcm1EZXRhaWxzIH0gZnJvbSAnLi9oYW5kbGVVdWlkJztcbmltcG9ydCB7IHRyYWNrUnBjT3V0Y29tZSB9IGZyb20gJy4vYW5hbHl0aWNzSGVscGVyJztcblxuZXhwb3J0IGNvbnN0IGhhbmRsZUJhdGNoTWV0aG9kID0gYXN5bmMgKHtcbiAgdGFyZ2V0LFxuICBhcmdzLFxuICB0cmFja0V2ZW50LFxuICBzZGtJbnN0YW5jZSxcbn06IHtcbiAgdGFyZ2V0OiBNZXRhTWFza0lucGFnZVByb3ZpZGVyO1xuICBhcmdzOiBSZXF1ZXN0QXJndW1lbnRzO1xuICB0cmFja0V2ZW50OiBib29sZWFuO1xuICBzZGtJbnN0YW5jZTogTWV0YU1hc2tTREs7XG59KSA9PiB7XG4gIGlmIChhcmdzLm1ldGhvZCAhPT0gJ21ldGFtYXNrX2JhdGNoJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1c2FnZScpO1xuICB9XG5cbiAgLy8gcGFyYW1zIGlzIGEgbGlzdCBvZiBSUENzIHRvIGNhbGxcbiAgY29uc3QgcmVzcG9uc2VzID0gW107XG4gIGNvbnN0IHBhcmFtcyA9IGFyZ3M/LnBhcmFtcyA/PyBbXTtcbiAgZm9yIChjb25zdCBycGMgb2YgcGFyYW1zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0YXJnZXQ/LnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBycGMubWV0aG9kLFxuICAgICAgcGFyYW1zOiBycGMucGFyYW1zLFxuICAgIH0pO1xuICAgIHJlc3BvbnNlcy5wdXNoKHJlc3BvbnNlKTtcbiAgfVxuXG4gIGNvbnN0IHsgaWQsIGZyb20gfSA9IGdldFBsYXRmb3JtRGV0YWlscyhzZGtJbnN0YW5jZSk7XG5cbiAgaWYgKHRyYWNrRXZlbnQpIHtcbiAgICBzZGtJbnN0YW5jZS5hbmFseXRpY3M/LnNlbmQoe1xuICAgICAgZXZlbnQ6IFRyYWNraW5nRXZlbnRzLlNES19SUENfUkVRVUVTVF9ET05FLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1ldGhvZDogYXJncy5tZXRob2QsXG4gICAgICAgIGZyb20sXG4gICAgICAgIGlkLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIGZvciAoY29uc3QgaW5kaXZpZHVhbFJlc3Agb2YgcmVzcG9uc2VzKSB7XG4gICAgdHJhY2tScGNPdXRjb21lKGFyZ3MubWV0aG9kLCBpbmRpdmlkdWFsUmVzcCwgbnVsbCk7XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2VzO1xufTtcbiIsImltcG9ydCB7IE1ldGFNYXNrSW5wYWdlUHJvdmlkZXIgfSBmcm9tICdAbWV0YW1hc2svcHJvdmlkZXJzJztcbmltcG9ydCB7IFJQQ19NRVRIT0RTIH0gZnJvbSAnLi4vLi4vY29uZmlnJztcbmltcG9ydCB7IHRyYWNrUnBjT3V0Y29tZSB9IGZyb20gJy4vYW5hbHl0aWNzSGVscGVyJztcblxuZXhwb3J0IGNvbnN0IGhhbmRsZUNvbm5lY3RTaWduTWV0aG9kID0gYXN5bmMgKHtcbiAgdGFyZ2V0LFxuICBwYXJhbXMsXG59OiB7XG4gIHRhcmdldDogTWV0YU1hc2tJbnBhZ2VQcm92aWRlcjtcbiAgcGFyYW1zOiBhbnlbXTtcbn0pID0+IHtcbiAgbGV0IHJlc3A6IGFueTtcbiAgbGV0IGNhdWdodEVycm9yOiBhbnkgPSBudWxsO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgYWNjb3VudHMgPSAoYXdhaXQgdGFyZ2V0LnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBSUENfTUVUSE9EUy5FVEhfUkVRVUVTVEFDQ09VTlRTLFxuICAgICAgcGFyYW1zOiBbXSxcbiAgICB9KSkgYXMgc3RyaW5nW107XG5cbiAgICBpZiAoIWFjY291bnRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTREsgc3RhdGUgaW52YWxpZCAtLSB1bmRlZmluZWQgYWNjb3VudHMnKTtcbiAgICB9XG5cbiAgICByZXNwID0gYXdhaXQgdGFyZ2V0LnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBSUENfTUVUSE9EUy5QRVJTT05BTF9TSUdOLFxuICAgICAgcGFyYW1zOiBbcGFyYW1zWzBdLCBhY2NvdW50c1swXV0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3A7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cmFja1JwY091dGNvbWUoUlBDX01FVEhPRFMuUEVSU09OQUxfU0lHTiwgcmVzcCwgY2F1Z2h0RXJyb3IpO1xuICB9XG59O1xuIiwiaW1wb3J0IHsgTWV0YU1hc2tJbnBhZ2VQcm92aWRlciB9IGZyb20gJ0BtZXRhbWFzay9wcm92aWRlcnMnO1xuaW1wb3J0IHsgUlBDX01FVEhPRFMsIHJwY1dpdGhBY2NvdW50UGFyYW0gfSBmcm9tICcuLi8uLi9jb25maWcnO1xuaW1wb3J0IHsgdHJhY2tScGNPdXRjb21lIH0gZnJvbSAnLi9hbmFseXRpY3NIZWxwZXInO1xuXG5leHBvcnQgY29uc3QgaGFuZGxlQ29ubmVjdFdpdGhNZXRob2QgPSBhc3luYyAoe1xuICB0YXJnZXQsXG4gIHBhcmFtcyxcbn06IHtcbiAgdGFyZ2V0OiBNZXRhTWFza0lucGFnZVByb3ZpZGVyO1xuICBwYXJhbXM6IGFueVtdO1xufSkgPT4ge1xuICBjb25zdCBbcnBjXSA9IHBhcmFtcztcbiAgY29uc3QgY3VycmVudFJwY01ldGhvZCA9IHJwYy5tZXRob2Q7XG4gIGNvbnN0IGN1cnJlbnRScGNQYXJhbXMgPSBycGMucGFyYW1zO1xuXG4gIGxldCByZXNwOiBhbnk7XG4gIGxldCBjYXVnaHRFcnJvcjogYW55ID0gbnVsbDtcblxuICB0cnkge1xuICAgIGNvbnN0IGFjY291bnRzID0gKGF3YWl0IHRhcmdldC5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogUlBDX01FVEhPRFMuRVRIX1JFUVVFU1RBQ0NPVU5UUyxcbiAgICAgIHBhcmFtczogW10sXG4gICAgfSkpIGFzIHN0cmluZ1tdO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFjY291bnRzKSB8fCAhYWNjb3VudHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NESyBzdGF0ZSBpbnZhbGlkIC0tIHVuZGVmaW5lZCBhY2NvdW50cycpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGN1cnJlbnRScGNNZXRob2Q/LnRvTG93ZXJDYXNlKCkgPT09XG4gICAgICBSUENfTUVUSE9EUy5QRVJTT05BTF9TSUdOLnRvTG93ZXJDYXNlKClcbiAgICApIHtcbiAgICAgIHJlc3AgPSBhd2FpdCB0YXJnZXQucmVxdWVzdCh7XG4gICAgICAgIG1ldGhvZDogY3VycmVudFJwY01ldGhvZCxcbiAgICAgICAgcGFyYW1zOiBbY3VycmVudFJwY1BhcmFtc1swXSwgYWNjb3VudHNbMF1dLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzcDtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBjdXJyZW50UnBjTWV0aG9kPy50b0xvd2VyQ2FzZSgpID09PVxuICAgICAgUlBDX01FVEhPRFMuRVRIX1NFTkRUUkFOU0FDVElPTi50b0xvd2VyQ2FzZSgpXG4gICAgKSB7XG4gICAgICByZXNwID0gYXdhaXQgdGFyZ2V0LnJlcXVlc3Qoe1xuICAgICAgICBtZXRob2Q6IGN1cnJlbnRScGNNZXRob2QsXG4gICAgICAgIHBhcmFtczogW3sgLi4uY3VycmVudFJwY1BhcmFtc1swXSwgZnJvbTogYWNjb3VudHNbMF0gfV0sXG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXNwO1xuICAgIH1cblxuICAgIGlmIChycGNXaXRoQWNjb3VudFBhcmFtLmluY2x1ZGVzKGN1cnJlbnRScGNNZXRob2QudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYE1ldGFNYXNrU0RLIGNvbm5lY3RXaXRoIG1ldGhvZD0ke2N1cnJlbnRScGNNZXRob2R9IC0tIG5vdCBoYW5kbGVkIGJ5IHRoZSBleHRlbnNpb24gLS0gY2FsbCBzZXBhcmF0ZWx5YCxcbiAgICAgICk7XG4gICAgICByZXNwID0gYWNjb3VudHM7XG4gICAgICByZXR1cm4gcmVzcDtcbiAgICB9XG5cbiAgICByZXNwID0gYXdhaXQgdGFyZ2V0LnJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiBjdXJyZW50UnBjTWV0aG9kLFxuICAgICAgcGFyYW1zOiBjdXJyZW50UnBjUGFyYW1zLFxuICAgIH0pO1xuICAgIHJldHVybiByZXNwO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH0gZmluYWxseSB7XG4gICAgdHJhY2tScGNPdXRjb21lKGN1cnJlbnRScGNNZXRob2QsIHJlc3AsIGNhdWdodEVycm9yKTtcbiAgfVxufTtcbiIsImltcG9ydCB7IE1ldGFNYXNrSW5wYWdlUHJvdmlkZXIgfSBmcm9tICdAbWV0YW1hc2svcHJvdmlkZXJzJztcbmltcG9ydCB7IE1FVEFNQVNLX0VJUF82MzY5X1BST1ZJREVSX0lORk8sIFVVSURfVjRfUkVHRVggfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgU0RLUHJvdmlkZXIgfSBmcm9tICcuLi9wcm92aWRlci9TREtQcm92aWRlcic7XG5cbmV4cG9ydCBlbnVtIEVJUDY5NjNFdmVudE5hbWVzIHtcbiAgQW5ub3VuY2UgPSAnZWlwNjk2Mzphbm5vdW5jZVByb3ZpZGVyJyxcbiAgUmVxdWVzdCA9ICdlaXA2OTYzOnJlcXVlc3RQcm92aWRlcicsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVJUDY5NjNQcm92aWRlckluZm8ge1xuICB1dWlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgaWNvbjogc3RyaW5nO1xuICByZG5zOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRUlQNjk2M1Byb3ZpZGVyRGV0YWlsIHtcbiAgaW5mbzogRUlQNjk2M1Byb3ZpZGVySW5mbztcbiAgcHJvdmlkZXI6IFNES1Byb3ZpZGVyO1xufVxuXG5leHBvcnQgdHlwZSBFSVA2OTYzQW5ub3VuY2VQcm92aWRlckV2ZW50ID0gQ3VzdG9tRXZlbnQgJiB7XG4gIHR5cGU6IEVJUDY5NjNFdmVudE5hbWVzLkFubm91bmNlO1xuICBkZXRhaWw6IEVJUDY5NjNQcm92aWRlckRldGFpbDtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBlaXA2OTYzUmVxdWVzdFByb3ZpZGVyKCk6IFByb21pc2U8TWV0YU1hc2tJbnBhZ2VQcm92aWRlcj4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcignZWlwNjk2M1JlcXVlc3RQcm92aWRlciB0aW1lZCBvdXQnKSk7XG4gICAgfSwgNTAwKTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgRUlQNjk2M0V2ZW50TmFtZXMuQW5ub3VuY2UsXG4gICAgICAoZWlwNjk2M0Fubm91bmNlUHJvdmlkZXJFdmVudCkgPT4ge1xuICAgICAgICBjb25zdCBldmVudCA9XG4gICAgICAgICAgZWlwNjk2M0Fubm91bmNlUHJvdmlkZXJFdmVudCBhcyBFSVA2OTYzQW5ub3VuY2VQcm92aWRlckV2ZW50O1xuXG4gICAgICAgIGNvbnN0IHsgZGV0YWlsOiB7IGluZm8sIHByb3ZpZGVyIH0gPSB7fSB9ID0gZXZlbnQ7XG5cbiAgICAgICAgY29uc3QgeyBuYW1lLCByZG5zLCB1dWlkIH0gPSBpbmZvID8/IHt9O1xuXG4gICAgICAgIGNvbnN0IGlzVmFsaWQgPVxuICAgICAgICAgIFVVSURfVjRfUkVHRVgudGVzdCh1dWlkKSAmJlxuICAgICAgICAgIChuYW1lIGFzIHN0cmluZykuc3RhcnRzV2l0aChNRVRBTUFTS19FSVBfNjM2OV9QUk9WSURFUl9JTkZPLk5BTUUpICYmXG4gICAgICAgICAgTUVUQU1BU0tfRUlQXzYzNjlfUFJPVklERVJfSU5GTy5SRE5TLmluY2x1ZGVzKHJkbnMpO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG5cbiAgICAgICAgICByZXNvbHZlKHByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICApO1xuXG4gICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KEVJUDY5NjNFdmVudE5hbWVzLlJlcXVlc3QpKTtcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBNZXRhTWFza0lucGFnZVByb3ZpZGVyIH0gZnJvbSAnQG1ldGFtYXNrL3Byb3ZpZGVycyc7XG5pbXBvcnQgeyBNZXRhTWFza1NESyB9IGZyb20gJy4uL3Nkayc7XG5pbXBvcnQgeyB3cmFwRXh0ZW5zaW9uUHJvdmlkZXIgfSBmcm9tICcuLi9wcm92aWRlci93cmFwRXh0ZW5zaW9uUHJvdmlkZXInO1xuaW1wb3J0IHsgZWlwNjk2M1JlcXVlc3RQcm92aWRlciB9IGZyb20gJy4vZWlwNjk2M1JlcXVlc3RQcm92aWRlcic7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRCcm93c2VyRXh0ZW5zaW9uKHtcbiAgbXVzdEJlTWV0YU1hc2ssXG4gIHNka0luc3RhbmNlLFxufToge1xuICBtdXN0QmVNZXRhTWFzazogYm9vbGVhbjtcbiAgc2RrSW5zdGFuY2U6IE1ldGFNYXNrU0RLO1xufSk6IFByb21pc2U8TWV0YU1hc2tJbnBhZ2VQcm92aWRlcj4ge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3dpbmRvdyBub3QgYXZhaWxhYmxlJyk7XG4gIH1cblxuICB0cnkge1xuICAgIC8vIFRyeSBFSVAtNjk2MyBmaXJzdFxuICAgIGNvbnN0IGV4dGVuc2lvblByb3ZpZGVyID0gYXdhaXQgZWlwNjk2M1JlcXVlc3RQcm92aWRlcigpO1xuICAgIHJldHVybiB3cmFwRXh0ZW5zaW9uUHJvdmlkZXIoeyBwcm92aWRlcjogZXh0ZW5zaW9uUHJvdmlkZXIsIHNka0luc3RhbmNlIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTGVnYWN5IGZhbGxiYWNrIG9ubHkgZm9yIG5vbi1NZXRhTWFzayBjYXNlc1xuICAgIGlmICghbXVzdEJlTWV0YU1hc2sgJiYgd2luZG93LmV0aGVyZXVtKSB7XG4gICAgICByZXR1cm4gd3JhcEV4dGVuc2lvblByb3ZpZGVyKHtcbiAgICAgICAgcHJvdmlkZXI6IHdpbmRvdy5ldGhlcmV1bSxcbiAgICAgICAgc2RrSW5zdGFuY2UsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVyIG5vdCBmb3VuZCcpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBNZXRhTWFza1NESyB9IGZyb20gJy4uLy4uLy4uL3Nkayc7XG5pbXBvcnQgeyBSUENfVVJMU19NQVAgfSBmcm9tICcuL3NldHVwUmVhZE9ubHlSUENQcm92aWRlcnMnO1xuXG5leHBvcnQgY29uc3Qgc2V0dXBJbmZ1cmFQcm92aWRlciA9IGFzeW5jIChpbnN0YW5jZTogTWV0YU1hc2tTREspID0+IHtcbiAgY29uc3QgeyBvcHRpb25zIH0gPSBpbnN0YW5jZTtcbiAgY29uc3QgeyBpbmZ1cmFBUElLZXkgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKCFpbmZ1cmFBUElLZXkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBpbmZ1cmFScGNVcmxzOiBSUENfVVJMU19NQVAgPSB7XG4gICAgLy8gIyMjIyMjIEV0aGVyZXVtICMjIyMjI1xuICAgIC8vIE1haW5uZXRcbiAgICAnMHgxJzogYGh0dHBzOi8vbWFpbm5ldC5pbmZ1cmEuaW8vdjMvJHtpbmZ1cmFBUElLZXl9YCxcbiAgICAvLyBHb2VybGlcbiAgICAnMHg1JzogYGh0dHBzOi8vZ29lcmxpLmluZnVyYS5pby92My8ke2luZnVyYUFQSUtleX1gLFxuICAgIC8vIFNlcG9saWEgMTExNTUxMTFcbiAgICAnMHhhYTM2YTcnOiBgaHR0cHM6Ly9zZXBvbGlhLmluZnVyYS5pby92My8ke2luZnVyYUFQSUtleX1gLFxuICAgIC8vICMjIyMjIyBMaW5lYSAjIyMjIyNcbiAgICAvLyBNYWlubmV0IEFscGhhXG4gICAgJzB4ZTcwOCc6IGBodHRwczovL2xpbmVhLW1haW5uZXQuaW5mdXJhLmlvL3YzLyR7aW5mdXJhQVBJS2V5fWAsXG4gICAgLy8gVGVzdG5ldCAoIGxpbmVhIGdvZXJsaSApXG4gICAgJzB4ZTcwNCc6IGBodHRwczovL2xpbmVhLWdvZXJsaS5pbmZ1cmEuaW8vdjMvJHtpbmZ1cmFBUElLZXl9YCxcbiAgICAvLyAjIyMjIyMgUG9seWdvbiAjIyMjIyNcbiAgICAvLyBNYWlubmV0XG4gICAgJzB4ODknOiBgaHR0cHM6Ly9wb2x5Z29uLW1haW5uZXQuaW5mdXJhLmlvL3YzLyR7aW5mdXJhQVBJS2V5fWAsXG4gICAgLy8gTXVtYmFpXG4gICAgJzB4MTM4ODEnOiBgaHR0cHM6Ly9wb2x5Z29uLW11bWJhaS5pbmZ1cmEuaW8vdjMvJHtpbmZ1cmFBUElLZXl9YCxcbiAgICAvLyAjIyMjIyMgT3B0aW1pc20gIyMjIyMjXG4gICAgLy8gTWFpbm5ldFxuICAgICcweDQ1JzogYGh0dHBzOi8vb3B0aW1pc20tbWFpbm5ldC5pbmZ1cmEuaW8vdjMvJHtpbmZ1cmFBUElLZXl9YCxcbiAgICAvLyBHb2VybGlcbiAgICAnMHgxYTQnOiBgaHR0cHM6Ly9vcHRpbWlzbS1nb2VybGkuaW5mdXJhLmlvL3YzLyR7aW5mdXJhQVBJS2V5fWAsXG4gICAgLy8gIyMjIyMjIEFyYml0cnVtICMjIyMjI1xuICAgIC8vIE1haW5uZXRcbiAgICAnMHhhNGIxJzogYGh0dHBzOi8vYXJiaXRydW0tbWFpbm5ldC5pbmZ1cmEuaW8vdjMvJHtpbmZ1cmFBUElLZXl9YCxcbiAgICAvLyBHb2VybGlcbiAgICAnMHg2NmVlZCc6IGBodHRwczovL2FyYml0cnVtLWdvZXJsaS5pbmZ1cmEuaW8vdjMvJHtpbmZ1cmFBUElLZXl9YCxcbiAgICAvLyAjIyMjIyMgUGFsbSAjIyMjIyNcbiAgICAvLyBNYWlubmV0XG4gICAgJzB4MmExNWMzMDhkJzogYGh0dHBzOi8vcGFsbS1tYWlubmV0LmluZnVyYS5pby92My8ke2luZnVyYUFQSUtleX1gLFxuICAgIC8vIFRlc3RuZXRcbiAgICAnMHgyYTE1YzMwODMnOiBgaHR0cHM6Ly9wYWxtLXRlc3RuZXQuaW5mdXJhLmlvL3YzLyR7aW5mdXJhQVBJS2V5fWAsXG4gICAgLy8gIyMjIyMjIEF2YWxhbmNoZSBDLUNoYWluICMjIyMjI1xuICAgIC8vIE1haW5uZXRcbiAgICAnMHhhODZhJzogYGh0dHBzOi8vYXZhbGFuY2hlLW1haW5uZXQuaW5mdXJhLmlvL3YzLyR7aW5mdXJhQVBJS2V5fWAsXG4gICAgLy8gRnVqaVxuICAgICcweGE4NjknOiBgaHR0cHM6Ly9hdmFsYW5jaGUtZnVqaS5pbmZ1cmEuaW8vdjMvJHtpbmZ1cmFBUElLZXl9YCxcbiAgICAvLyAvLyAjIyMjIyMgTkVBUiAjIyMjIyNcbiAgICAvLyAvLyBNYWlubmV0XG4gICAgLy8gJzB4NGU0NTQxNTInOiBgaHR0cHM6Ly9uZWFyLW1haW5uZXQuaW5mdXJhLmlvL3YzLyR7aW5mdXJhQVBJS2V5fWAsXG4gICAgLy8gLy8gVGVzdG5ldFxuICAgIC8vICcweDRlNDU0MTUzJzogYGh0dHBzOi8vbmVhci10ZXN0bmV0LmluZnVyYS5pby92My8ke2luZnVyYUFQSUtleX1gLFxuICAgIC8vICMjIyMjIyBBdXJvcmEgIyMjIyMjXG4gICAgLy8gTWFpbm5ldFxuICAgICcweDRlNDU0MTUyJzogYGh0dHBzOi8vYXVyb3JhLW1haW5uZXQuaW5mdXJhLmlvL3YzLyR7aW5mdXJhQVBJS2V5fWAsXG4gICAgLy8gVGVzdG5ldFxuICAgICcweDRlNDU0MTUzJzogYGh0dHBzOi8vYXVyb3JhLXRlc3RuZXQuaW5mdXJhLmlvL3YzLyR7aW5mdXJhQVBJS2V5fWAsXG4gICAgLy8gIyMjIyMjIFN0YXJrTmV0ICMjIyMjI1xuICAgIC8vIE1haW5uZXRcbiAgICAnMHg1MzRlNWY0ZDQxNDk0ZSc6IGBodHRwczovL3N0YXJrbmV0LW1haW5uZXQuaW5mdXJhLmlvL3YzLyR7aW5mdXJhQVBJS2V5fWAsXG4gICAgLy8gR29lcmxpXG4gICAgJzB4NTM0ZTVmNDc0ZjQ1NTI0YzQ5JzogYGh0dHBzOi8vc3RhcmtuZXQtZ29lcmxpLmluZnVyYS5pby92My8ke2luZnVyYUFQSUtleX1gLFxuICAgIC8vIEdvZXJsaSAyXG4gICAgJzB4NTM0ZTVmNDc0ZjQ1NTI0YzQ5MzInOiBgaHR0cHM6Ly9zdGFya25ldC1nb2VybGkyLmluZnVyYS5pby92My8ke2luZnVyYUFQSUtleX1gLFxuICAgIC8vICMjIyMjIyBDZWxvICMjIyMjI1xuICAgIC8vIE1haW5uZXRcbiAgICAnMHhhNGVjJzogYGh0dHBzOi8vY2Vsby1tYWlubmV0LmluZnVyYS5pby92My8ke2luZnVyYUFQSUtleX1gLFxuICAgIC8vIEFsZmFqb3JlcyBUZXN0bmV0XG4gICAgJzB4YWVmMyc6IGBodHRwczovL2NlbG8tYWxmYWpvcmVzLmluZnVyYS5pby92My8ke2luZnVyYUFQSUtleX1gLFxuICB9O1xuXG4gIC8vIHNob3VsZCB3ZSBlbmFibGUgY2hlY2sgaWYgaW5mdXJhIGFwaUtleSBpcyB2YWxpZD9cbiAgLy8gdHJ5IHtcbiAgLy8gICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJwY1JlcXVlc3RIYW5kbGVyKHtcbiAgLy8gICAgIC8vIGNoYWluSWQ6ICcweDEnLFxuICAvLyAgICAgcnBjRW5kcG9pbnQ6IGluZnVyYVJwY1VybHNbJzB4MSddLFxuICAvLyAgICAgbWV0aG9kOiAnbmV0X3ZlcnNpb24nLFxuICAvLyAgICAgcGFyYW1zOiBbXSxcbiAgLy8gICB9KTtcbiAgLy8gICBpZiAoaW5zdGFuY2UuZGVidWcpIHtcbiAgLy8gICAgIGNvbnNvbGUuZGVidWcoXG4gIC8vICAgICAgIGBbc2V0dXBJbmZ1cmFQcm92aWRlcl0gdGVzdCBpbmZ1cmFBcGlLZXk9JHtpbmZ1cmFBUElLZXl9IHJlc3BvbnNlOmAsXG4gIC8vICAgICAgIHJlc3BvbnNlLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG4gIC8vIH0gY2F0Y2ggKGVycikge1xuICAvLyAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBJbmZ1cmEgU2V0dGluZ3NgKTtcbiAgLy8gfVxuXG4gIGlmIChpbnN0YW5jZS5vcHRpb25zLnJlYWRvbmx5UlBDTWFwKSB7XG4gICAgLy8gYWRkIGluZnVyYSBycGMgdXJscyB0byByZWFkb25seVJQQ01hcFxuICAgIGluc3RhbmNlLm9wdGlvbnMucmVhZG9ubHlSUENNYXAgPSB7XG4gICAgICAuLi5pbnN0YW5jZS5vcHRpb25zLnJlYWRvbmx5UlBDTWFwLFxuICAgICAgLi4uaW5mdXJhUnBjVXJscyxcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGluc3RhbmNlLm9wdGlvbnMucmVhZG9ubHlSUENNYXAgPSBpbmZ1cmFScGNVcmxzO1xuICB9XG59O1xuIiwiaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IE1ldGFNYXNrU0RLIH0gZnJvbSAnLi4vLi4vLi4vc2RrJztcblxuZXhwb3J0IGludGVyZmFjZSBSUENfVVJMU19NQVAge1xuICBbY2hhaW5JZDogYDB4JHtzdHJpbmd9YF06IHN0cmluZztcbn1cblxuZXhwb3J0IGNvbnN0IHNldHVwUmVhZE9ubHlSUENQcm92aWRlcnMgPSBhc3luYyAoaW5zdGFuY2U6IE1ldGFNYXNrU0RLKSA9PiB7XG4gIGNvbnN0IHsgb3B0aW9ucyB9ID0gaW5zdGFuY2U7XG4gIGNvbnN0IHsgcmVhZG9ubHlSUENNYXAgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKCFyZWFkb25seVJQQ01hcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgbG9nZ2VyKFxuICAgICAgYFtNZXRhTWFza1NESzogc2V0dXBSZWFkT25seVJQQ1Byb3ZpZGVycygpXSBTZXR0aW5nIHVwIFJlYWRvbmx5IFJQQyBQcm92aWRlcnNgLFxuICAgICAgcmVhZG9ubHlSUENNYXAsXG4gICAgKTtcblxuICAgIGluc3RhbmNlLnNldFJlYWRPbmx5UlBDQ2FsbHModHJ1ZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBJbmZ1cmEgU2V0dGluZ3NgKTtcbiAgfVxufTtcbiIsImltcG9ydCBCb3dzZXIgZnJvbSAnYm93c2VyJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XG5cbnZhciBPTkJPQVJESU5HX1NUQVRFID0ge1xyXG4gICAgSU5TVEFMTEVEOiAnSU5TVEFMTEVEJyxcclxuICAgIE5PVF9JTlNUQUxMRUQ6ICdOT1RfSU5TVEFMTEVEJyxcclxuICAgIFJFR0lTVEVSRUQ6ICdSRUdJU1RFUkVEJyxcclxuICAgIFJFR0lTVEVSSU5HOiAnUkVHSVNURVJJTkcnLFxyXG4gICAgUkVMT0FESU5HOiAnUkVMT0FESU5HJyxcclxufTtcclxudmFyIEVYVEVOU0lPTl9ET1dOTE9BRF9VUkwgPSB7XHJcbiAgICBDSFJPTUU6ICdodHRwczovL2Nocm9tZS5nb29nbGUuY29tL3dlYnN0b3JlL2RldGFpbC9tZXRhbWFzay9ua2JpaGZiZW9nYWVhb2VobGVmbmtvZGJlZmdwZ2tubicsXHJcbiAgICBGSVJFRk9YOiAnaHR0cHM6Ly9hZGRvbnMubW96aWxsYS5vcmcvZmlyZWZveC9hZGRvbi9ldGhlci1tZXRhbWFzay8nLFxyXG4gICAgREVGQVVMVDogJ2h0dHBzOi8vbWV0YW1hc2suaW8nLFxyXG59O1xyXG4vLyBzZXNzaW9uU3RvcmFnZSBrZXlcclxudmFyIFJFR0lTVFJBVElPTl9JTl9QUk9HUkVTUyA9ICdSRUdJU1RSQVRJT05fSU5fUFJPR1JFU1MnO1xyXG4vLyBmb3J3YXJkZXIgaWZyYW1lIGlkXHJcbnZhciBGT1JXQVJERVJfSUQgPSAnRk9SV0FSREVSX0lEJztcclxudmFyIE9uYm9hcmRpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBPbmJvYXJkaW5nKF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IuZm9yd2FyZGVyT3JpZ2luLCBmb3J3YXJkZXJPcmlnaW4gPSBfYyA9PT0gdm9pZCAwID8gJ2h0dHBzOi8vZndkLm1ldGFtYXNrLmlvJyA6IF9jLCBfZCA9IF9iLmZvcndhcmRlck1vZGUsIGZvcndhcmRlck1vZGUgPSBfZCA9PT0gdm9pZCAwID8gT25ib2FyZGluZy5GT1JXQVJERVJfTU9ERS5JTkpFQ1QgOiBfZDtcclxuICAgICAgICB0aGlzLmZvcndhcmRlck9yaWdpbiA9IGZvcndhcmRlck9yaWdpbjtcclxuICAgICAgICB0aGlzLmZvcndhcmRlck1vZGUgPSBmb3J3YXJkZXJNb2RlO1xyXG4gICAgICAgIHRoaXMuc3RhdGUgPSBPbmJvYXJkaW5nLmlzTWV0YU1hc2tJbnN0YWxsZWQoKVxyXG4gICAgICAgICAgICA/IE9OQk9BUkRJTkdfU1RBVEUuSU5TVEFMTEVEXHJcbiAgICAgICAgICAgIDogT05CT0FSRElOR19TVEFURS5OT1RfSU5TVEFMTEVEO1xyXG4gICAgICAgIHZhciBicm93c2VyID0gT25ib2FyZGluZy5fZGV0ZWN0QnJvd3NlcigpO1xyXG4gICAgICAgIGlmIChicm93c2VyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG93bmxvYWRVcmwgPSBFWFRFTlNJT05fRE9XTkxPQURfVVJMW2Jyb3dzZXJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kb3dubG9hZFVybCA9IEVYVEVOU0lPTl9ET1dOTE9BRF9VUkwuREVGQVVMVDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fb25NZXNzYWdlID0gdGhpcy5fb25NZXNzYWdlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fb25NZXNzYWdlRnJvbUZvcndhcmRlciA9IHRoaXMuX29uTWVzc2FnZUZyb21Gb3J3YXJkZXIuYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLl9vcGVuRm9yd2FyZGVyID0gdGhpcy5fb3BlbkZvcndhcmRlci5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX29wZW5Eb3dubG9hZFBhZ2UgPSB0aGlzLl9vcGVuRG93bmxvYWRQYWdlLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zdGFydE9uYm9hcmRpbmcgPSB0aGlzLnN0YXJ0T25ib2FyZGluZy5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc3RvcE9uYm9hcmRpbmcgPSB0aGlzLnN0b3BPbmJvYXJkaW5nLmJpbmQodGhpcyk7XHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9vbk1lc3NhZ2UpO1xyXG4gICAgICAgIGlmIChmb3J3YXJkZXJNb2RlID09PSBPbmJvYXJkaW5nLkZPUldBUkRFUl9NT0RFLklOSkVDVCAmJlxyXG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFJFR0lTVFJBVElPTl9JTl9QUk9HUkVTUykgPT09ICd0cnVlJykge1xyXG4gICAgICAgICAgICBPbmJvYXJkaW5nLl9pbmplY3RGb3J3YXJkZXIodGhpcy5mb3J3YXJkZXJPcmlnaW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIE9uYm9hcmRpbmcucHJvdG90eXBlLl9vbk1lc3NhZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICBpZiAoZXZlbnQub3JpZ2luICE9PSB0aGlzLmZvcndhcmRlck9yaWdpbikge1xyXG4gICAgICAgICAgICAvLyBJZ25vcmluZyBub24tZm9yd2FyZGVyIG1lc3NhZ2VcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEudHlwZSA9PT0gJ21ldGFtYXNrOnJlbG9hZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29uTWVzc2FnZUZyb21Gb3J3YXJkZXIoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLmRlYnVnKFwiVW5rbm93biBtZXNzYWdlIGZyb20gJ1wiICsgZXZlbnQub3JpZ2luICsgXCInIHdpdGggZGF0YSBcIiArIEpTT04uc3RyaW5naWZ5KGV2ZW50LmRhdGEpKTtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIE9uYm9hcmRpbmcucHJvdG90eXBlLl9vbk1lc3NhZ2VVbmtub3duU3RhdGVFcnJvciA9IGZ1bmN0aW9uIChzdGF0ZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gc3RhdGU6ICdcIiArIHN0YXRlICsgXCInXCIpO1xyXG4gICAgfTtcclxuICAgIE9uYm9hcmRpbmcucHJvdG90eXBlLl9vbk1lc3NhZ2VGcm9tRm9yd2FyZGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBPTkJPQVJESU5HX1NUQVRFLlJFTE9BRElORzogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE9OQk9BUkRJTkdfU1RBVEUuTk9UX0lOU1RBTExFRDogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE9OQk9BUkRJTkdfU1RBVEUuSU5TVEFMTEVEOiByZXR1cm4gWzMgLypicmVhayovLCAzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgT05CT0FSRElOR19TVEFURS5SRUdJU1RFUklORzogcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIE9OQk9BUkRJTkdfU1RBVEUuUkVHSVNURVJFRDogcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdJZ25vcmluZyBtZXNzYWdlIHdoaWxlIHJlbG9hZGluZycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA4XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1JlbG9hZGluZyBub3cgdG8gcmVnaXN0ZXIgd2l0aCBNZXRhTWFzaycpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gT05CT0FSRElOR19TVEFURS5SRUxPQURJTkc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA4XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1JlZ2lzdGVyaW5nIHdpdGggTWV0YU1hc2snKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IE9OQk9BUkRJTkdfU1RBVEUuUkVHSVNURVJJTkc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIE9uYm9hcmRpbmcuX3JlZ2lzdGVyKCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gT05CT0FSRElOR19TVEFURS5SRUdJU1RFUkVEO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zb3VyY2UucG9zdE1lc3NhZ2UoeyB0eXBlOiAnbWV0YW1hc2s6cmVnaXN0cmF0aW9uQ29tcGxldGVkJyB9LCBldmVudC5vcmlnaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3BPbmJvYXJkaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnQWxyZWFkeSByZWdpc3RlcmluZyAtIGlnbm9yaW5nIHJlbG9hZCBtZXNzYWdlJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnQWxyZWFkeSByZWdpc3RlcmVkIC0gaWdub3JpbmcgcmVsb2FkIG1lc3NhZ2UnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbk1lc3NhZ2VVbmtub3duU3RhdGVFcnJvcih0aGlzLnN0YXRlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSA4O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyBvbmJvYXJkaW5nIGJ5IG9wZW5pbmcgdGhlIE1ldGFNYXNrIGRvd25sb2FkIHBhZ2UgYW5kIHRoZSBPbmJvYXJkaW5nIGZvcndhcmRlclxyXG4gICAgICovXHJcbiAgICBPbmJvYXJkaW5nLnByb3RvdHlwZS5zdGFydE9uYm9hcmRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShSRUdJU1RSQVRJT05fSU5fUFJPR1JFU1MsICd0cnVlJyk7XHJcbiAgICAgICAgdGhpcy5fb3BlbkRvd25sb2FkUGFnZSgpO1xyXG4gICAgICAgIHRoaXMuX29wZW5Gb3J3YXJkZXIoKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIG9uYm9hcmRpbmcgcmVnaXN0cmF0aW9uLCBpbmNsdWRpbmcgcmVtb3ZpbmcgdGhlIGluamVjdGVkIGZvcndhcmRlciAoaWYgYW55KVxyXG4gICAgICpcclxuICAgICAqIFR5cGljYWxseSB0aGlzIGZ1bmN0aW9uIGlzIG5vdCBuZWNlc3NhcnksIGJ1dCBpdCBjYW4gYmUgdXNlZnVsIGZvciBjYXNlcyB3aGVyZVxyXG4gICAgICogb25ib2FyZGluZyBjb21wbGV0ZXMgYmVmb3JlIHRoZSBmb3J3YXJkZXIgaGFzIHJlZ2lzdGVyZWQuXHJcbiAgICAgKi9cclxuICAgIE9uYm9hcmRpbmcucHJvdG90eXBlLnN0b3BPbmJvYXJkaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChzZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFJFR0lTVFJBVElPTl9JTl9QUk9HUkVTUykgPT09ICd0cnVlJykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mb3J3YXJkZXJNb2RlID09PSBPbmJvYXJkaW5nLkZPUldBUkRFUl9NT0RFLklOSkVDVCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnUmVtb3ZpbmcgZm9yd2FyZGVyJyk7XHJcbiAgICAgICAgICAgICAgICBPbmJvYXJkaW5nLl9yZW1vdmVGb3J3YXJkZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFJFR0lTVFJBVElPTl9JTl9QUk9HUkVTUywgJ2ZhbHNlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9uYm9hcmRpbmcucHJvdG90eXBlLl9vcGVuRm9yd2FyZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZvcndhcmRlck1vZGUgPT09IE9uYm9hcmRpbmcuRk9SV0FSREVSX01PREUuT1BFTl9UQUIpIHtcclxuICAgICAgICAgICAgd2luZG93Lm9wZW4odGhpcy5mb3J3YXJkZXJPcmlnaW4sICdfYmxhbmsnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIE9uYm9hcmRpbmcuX2luamVjdEZvcndhcmRlcih0aGlzLmZvcndhcmRlck9yaWdpbik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE9uYm9hcmRpbmcucHJvdG90eXBlLl9vcGVuRG93bmxvYWRQYWdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHdpbmRvdy5vcGVuKHRoaXMuZG93bmxvYWRVcmwsICdfYmxhbmsnKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBNZXRhTWFzayBleHRlbnNpb24gaXMgaW5zdGFsbGVkXHJcbiAgICAgKi9cclxuICAgIE9uYm9hcmRpbmcuaXNNZXRhTWFza0luc3RhbGxlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gQm9vbGVhbih3aW5kb3cuZXRoZXJldW0gJiYgd2luZG93LmV0aGVyZXVtLmlzTWV0YU1hc2spO1xyXG4gICAgfTtcclxuICAgIE9uYm9hcmRpbmcuX3JlZ2lzdGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3cuZXRoZXJldW0ucmVxdWVzdCh7XHJcbiAgICAgICAgICAgIG1ldGhvZDogJ3dhbGxldF9yZWdpc3Rlck9uYm9hcmRpbmcnLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIE9uYm9hcmRpbmcuX2luamVjdEZvcndhcmRlciA9IGZ1bmN0aW9uIChmb3J3YXJkZXJPcmlnaW4pIHtcclxuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuYm9keTtcclxuICAgICAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XHJcbiAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzAnKTtcclxuICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcwJyk7XHJcbiAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcclxuICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzcmMnLCBmb3J3YXJkZXJPcmlnaW4pO1xyXG4gICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2lkJywgRk9SV0FSREVSX0lEKTtcclxuICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKGlmcmFtZSwgY29udGFpbmVyLmNoaWxkcmVuWzBdKTtcclxuICAgIH07XHJcbiAgICBPbmJvYXJkaW5nLl9yZW1vdmVGb3J3YXJkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKEZPUldBUkRFUl9JRCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmUoKTtcclxuICAgIH07XHJcbiAgICBPbmJvYXJkaW5nLl9kZXRlY3RCcm93c2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBicm93c2VySW5mbyA9IEJvd3Nlci5wYXJzZSh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XHJcbiAgICAgICAgaWYgKGJyb3dzZXJJbmZvLmJyb3dzZXIubmFtZSA9PT0gJ0ZpcmVmb3gnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnRklSRUZPWCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKFsnQ2hyb21lJywgJ0Nocm9taXVtJ10uaW5jbHVkZXMoYnJvd3NlckluZm8uYnJvd3Nlci5uYW1lIHx8ICcnKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ0NIUk9NRSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIE9uYm9hcmRpbmcuRk9SV0FSREVSX01PREUgPSB7XHJcbiAgICAgICAgSU5KRUNUOiAnSU5KRUNUJyxcclxuICAgICAgICBPUEVOX1RBQjogJ09QRU5fVEFCJyxcclxuICAgIH07XHJcbiAgICByZXR1cm4gT25ib2FyZGluZztcclxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgT25ib2FyZGluZztcbiIsImltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBNZXRhTWFza0luc3RhbGxlciB9IGZyb20gJy4uLy4uL1BsYXRmb3JtL01ldGFNYXNrSW5zdGFsbGVyJztcbmltcG9ydCB7IHdhaXQgYXMgd2FpdFByb21pc2UgfSBmcm9tICcuLi8uLi91dGlscy93YWl0JztcblxuLyoqXG4gKiBJbml0aWF0ZXMgdGhlIE1ldGFNYXNrIGluc3RhbGxhdGlvbiBwcm9jZXNzLCBvcHRpb25hbGx5IHdhaXRpbmcgZm9yIHByb3ZpZGVycyB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBmaXJzdCBsb2dzIGRlYnVnIGluZm9ybWF0aW9uIGlmIGRlYnVnZ2luZyBpcyBlbmFibGVkLiBJZiB0aGUgYHdhaXRgIG9wdGlvbiBpcyBzZXQgdG8gdHJ1ZSxcbiAqIGl0IHdhaXRzIGZvciBhIHNwZWNpZmllZCB0aW1lICgxIHNlY29uZCBieSBkZWZhdWx0KSB0byBhbGxvdyBwcm92aWRlcnMgdG8gZXN0YWJsaXNoIGEgY29ubmVjdGlvbi5cbiAqIEFmdGVyIHdhaXRpbmcgb3IgaW1tZWRpYXRlbHkgKGlmIGB3YWl0YCBpcyBmYWxzZSksIGl0IHByb2NlZWRzIHRvIGNoZWNrIGZvciBNZXRhTWFzayBpbnN0YWxsYXRpb24uXG4gKlxuICogQHBhcmFtIGluc3RhbmNlIFRoZSBNZXRhTWFza0luc3RhbGxlciBpbnN0YW5jZSByZXNwb25zaWJsZSBmb3IgY2hlY2tpbmcgTWV0YU1hc2sgaW5zdGFsbGF0aW9uLlxuICogQHBhcmFtIG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgYSBib29sZWFuIGB3YWl0YCBwcm9wZXJ0eSB0byBpbmRpY2F0ZSB3aGV0aGVyIHRvIHdhaXQgZm9yIHByb3ZpZGVycyB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uLlxuICogQHJldHVybnMgUHJvbWlzZTxib29sZWFuPiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXN1bHQgb2YgYGNoZWNrSW5zdGFsbGF0aW9uYCwgaW5kaWNhdGluZyB3aGV0aGVyIE1ldGFNYXNrIGlzIGluc3RhbGxlZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0SW5zdGFsbGVyKFxuICBpbnN0YW5jZTogTWV0YU1hc2tJbnN0YWxsZXIsXG4gIHsgd2FpdCA9IGZhbHNlIH06IHsgd2FpdDogYm9vbGVhbiB9LFxuKSB7XG4gIGxvZ2dlcihgW01ldGFtYXNrSW5zdGFsbGVyOiBzdGFydEluc3RhbGxlcigpXSB3YWl0PSR7d2FpdH1gKTtcblxuICAvLyBHaXZlIGVub3VnaCB0aW1lIGZvciBwcm92aWRlcnMgdG8gbWFrZSBjb25uZWN0aW9uXG4gIGlmICh3YWl0KSB7XG4gICAgYXdhaXQgd2FpdFByb21pc2UoMTAwMCk7XG4gIH1cblxuICByZXR1cm4gYXdhaXQgaW5zdGFuY2UuY2hlY2tJbnN0YWxsYXRpb24oKTtcbn1cbiIsImltcG9ydCB7IGNoZWNrSW5zdGFsbGF0aW9uIH0gZnJvbSAnLi4vc2VydmljZXMvTWV0YU1hc2tJbnN0YWxsZXIvY2hlY2tJbnN0YWxsYXRpb24nO1xuaW1wb3J0IHsgcmVkaXJlY3RUb1Byb3Blckluc3RhbGwgfSBmcm9tICcuLi9zZXJ2aWNlcy9NZXRhTWFza0luc3RhbGxlci9yZWRpcmVjdFRvUHJvcGVySW5zdGFsbCc7XG5pbXBvcnQgeyBzdGFydERlc2t0b3BPbmJvYXJkaW5nIH0gZnJvbSAnLi4vc2VydmljZXMvTWV0YU1hc2tJbnN0YWxsZXIvc3RhcnREZXNrdG9wT25ib2FyZGluZyc7XG5pbXBvcnQgeyBzdGFydEluc3RhbGxlciB9IGZyb20gJy4uL3NlcnZpY2VzL01ldGFNYXNrSW5zdGFsbGVyL3N0YXJ0SW5zdGFsbGVyJztcbmltcG9ydCB7IFJlbW90ZUNvbm5lY3Rpb24gfSBmcm9tICcuLi9zZXJ2aWNlcy9SZW1vdGVDb25uZWN0aW9uJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBQbGF0Zm9ybU1hbmFnZXIgfSBmcm9tICcuL1BsYXRmZm9ybU1hbmFnZXInO1xuXG4vLyBldGhlcmV1bS5vbignY29ubmVjdCcsIGhhbmRsZXI6IChjb25uZWN0SW5mbzogQ29ubmVjdEluZm8pID0+IHZvaWQpO1xuLy8gZXRoZXJldW0ub24oJ2Rpc2Nvbm5lY3QnLCBoYW5kbGVyOiAoZXJyb3I6IFByb3ZpZGVyUnBjRXJyb3IpID0+IHZvaWQpO1xuXG5pbnRlcmZhY2UgSW5zdGFsbGVyUHJvcHMge1xuICBwcmVmZXJEZXNrdG9wOiBib29sZWFuO1xuICByZW1vdGU6IFJlbW90ZUNvbm5lY3Rpb247XG4gIHBsYXRmb3JtTWFuYWdlcjogUGxhdGZvcm1NYW5hZ2VyO1xuICBkZWJ1Zz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUlBDQ2FsbCB7XG4gIG1ldGhvZDogc3RyaW5nO1xuICBwYXJhbXM6IHVua25vd247XG4gIGlkOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBNZXRhTWFza0luc3RhbGxlclN0YXRlIHtcbiAgaXNJbnN0YWxsaW5nOiBib29sZWFuO1xuICBoYXNJbnN0YWxsZWQ6IGJvb2xlYW47XG4gIHJlc2VuZFJlcXVlc3Q6IGFueTtcbiAgcHJlZmVyRGVza3RvcDogYm9vbGVhbjtcbiAgcGxhdGZvcm1NYW5hZ2VyOiBQbGF0Zm9ybU1hbmFnZXIgfCBudWxsO1xuICBjb25uZWN0V2l0aD86IFJQQ0NhbGw7XG4gIHJlbW90ZTogUmVtb3RlQ29ubmVjdGlvbiB8IG51bGw7XG4gIGRlYnVnOiBib29sZWFuO1xufVxuXG4vKipcbiAqIFNpbmdsZXRvbiBjbGFzcyBpbnN0YW5jZVxuICovXG5leHBvcnQgY2xhc3MgTWV0YU1hc2tJbnN0YWxsZXIge1xuICBwcml2YXRlIHN0YXRpYyBpbnN0YW5jZTogTWV0YU1hc2tJbnN0YWxsZXI7XG5cbiAgcHVibGljIHN0YXRlOiBNZXRhTWFza0luc3RhbGxlclN0YXRlID0ge1xuICAgIGlzSW5zdGFsbGluZzogZmFsc2UsXG4gICAgaGFzSW5zdGFsbGVkOiBmYWxzZSxcbiAgICByZXNlbmRSZXF1ZXN0OiBudWxsLFxuICAgIHByZWZlckRlc2t0b3A6IGZhbHNlLFxuICAgIHBsYXRmb3JtTWFuYWdlcjogbnVsbCxcbiAgICByZW1vdGU6IG51bGwsXG4gICAgZGVidWc6IGZhbHNlLFxuICAgIGNvbm5lY3RXaXRoOiB1bmRlZmluZWQsXG4gIH07XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHtcbiAgICByZW1vdGUsXG4gICAgcHJlZmVyRGVza3RvcCxcbiAgICBwbGF0Zm9ybU1hbmFnZXIsXG4gICAgZGVidWcgPSBmYWxzZSxcbiAgfTogSW5zdGFsbGVyUHJvcHMpIHtcbiAgICB0aGlzLnN0YXRlLnJlbW90ZSA9IHJlbW90ZTtcbiAgICB0aGlzLnN0YXRlLnByZWZlckRlc2t0b3AgPSBwcmVmZXJEZXNrdG9wO1xuICAgIHRoaXMuc3RhdGUucGxhdGZvcm1NYW5hZ2VyID0gcGxhdGZvcm1NYW5hZ2VyO1xuICAgIHRoaXMuc3RhdGUuZGVidWcgPSBkZWJ1ZztcbiAgfVxuXG4gIHN0YXJ0RGVza3RvcE9uYm9hcmRpbmcoKSB7XG4gICAgcmV0dXJuIHN0YXJ0RGVza3RvcE9uYm9hcmRpbmcoKTtcbiAgfVxuXG4gIGFzeW5jIHJlZGlyZWN0VG9Qcm9wZXJJbnN0YWxsKCkge1xuICAgIHJldHVybiByZWRpcmVjdFRvUHJvcGVySW5zdGFsbCh0aGlzKTtcbiAgfVxuXG4gIGFzeW5jIGNoZWNrSW5zdGFsbGF0aW9uKCkge1xuICAgIHJldHVybiBjaGVja0luc3RhbGxhdGlvbih0aGlzKTtcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0KHtcbiAgICB3YWl0ID0gZmFsc2UsXG4gICAgY29ubmVjdFdpdGgsXG4gIH06IHtcbiAgICB3YWl0OiBib29sZWFuO1xuICAgIGNvbm5lY3RXaXRoPzogUlBDQ2FsbDtcbiAgfSkge1xuICAgIHRoaXMuc3RhdGUuY29ubmVjdFdpdGggPSBjb25uZWN0V2l0aDtcbiAgICBsb2dnZXIoYFtNZXRhTWFza0luc3RhbGxlcjogc3RhcnQoKV0gd2FpdD0ke3dhaXR9YCwgY29ubmVjdFdpdGgpO1xuICAgIGF3YWl0IHN0YXJ0SW5zdGFsbGVyKHRoaXMsIHsgd2FpdCB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IE1ldGFNYXNrT25ib2FyZGluZyBmcm9tICdAbWV0YW1hc2svb25ib2FyZGluZyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi8uLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgRXRoZXJldW0gfSBmcm9tICcuLi9FdGhlcmV1bSc7XG5cbi8qKlxuICogSW5pdGlhdGVzIHRoZSBNZXRhTWFzayBkZXNrdG9wIG9uYm9hcmRpbmcgcHJvY2Vzcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRlc3Ryb3lzIHRoZSBleGlzdGluZyBFdGhlcmV1bSBvYmplY3QgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgd2luZG93IGNvbnRleHQsXG4gKiBlZmZlY3RpdmVseSBjbGVhcmluZyBhbnkgcHJpb3IgRXRoZXJldW0tcmVsYXRlZCBzdGF0ZS4gSXQgdGhlbiBpbnN0YW50aWF0ZXMgYSBuZXcgTWV0YU1hc2tPbmJvYXJkaW5nIG9iamVjdFxuICogYW5kIHN0YXJ0cyB0aGUgb25ib2FyZGluZyBwcm9jZXNzIGZvciBNZXRhTWFzayBvbiBkZXNrdG9wIHBsYXRmb3Jtcy5cbiAqXG4gKiBAcGFyYW0gaW5zdGFuY2UgVGhlIE1ldGFNYXNrSW5zdGFsbGVyIGluc3RhbmNlIHVzZWQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cbiAqIEByZXR1cm5zIFByb21pc2U8dm9pZD4gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHZvaWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdGFydERlc2t0b3BPbmJvYXJkaW5nKCkge1xuICBsb2dnZXIoXG4gICAgYFtNZXRhbWFza0luc3RhbGxlcjogc3RhcnREZXNrdG9wT25ib2FyZGluZygpIHN0YXJ0aW5nIGRlc2t0b3Agb25ib2FyZGluZ2AsXG4gICk7XG5cbiAgRXRoZXJldW0uZGVzdHJveSgpO1xuICBpZiAod2luZG93LmV0aGVyZXVtKSB7XG4gICAgd2luZG93LmV0aGVyZXVtID0gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IG9uYm9hcmRpbmdFeHRlbnNpb24gPSBuZXcgTWV0YU1hc2tPbmJvYXJkaW5nKCk7XG4gIG9uYm9hcmRpbmdFeHRlbnNpb24uc3RhcnRPbmJvYXJkaW5nKCk7XG59XG4iLCJpbXBvcnQgeyBQbGF0Zm9ybVR5cGUgfSBmcm9tICdAbWV0YW1hc2svc2RrLWNvbW11bmljYXRpb24tbGF5ZXInO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IE1ldGFNYXNrSW5zdGFsbGVyIH0gZnJvbSAnLi4vLi4vUGxhdGZvcm0vTWV0YU1hc2tJbnN0YWxsZXInO1xuXG4vKipcbiAqIFJlZGlyZWN0cyB0aGUgdXNlciB0byB0aGUgYXBwcm9wcmlhdGUgTWV0YU1hc2sgaW5zdGFsbGF0aW9uIG1ldGhvZCBiYXNlZCBvbiB0aGUgcGxhdGZvcm0gdHlwZS5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gZGV0ZXJtaW5lcyB0aGUgcGxhdGZvcm0gdHlwZSB1c2luZyB0aGUgcGxhdGZvcm1NYW5hZ2VyIG9mIHRoZSBwcm92aWRlZCBNZXRhTWFza0luc3RhbGxlciBzdGF0ZS5cbiAqIElmIHRoZSBwbGF0Zm9ybSBpcyBhIE1ldGFNYXNrIE1vYmlsZSBXZWJ2aWV3LCB0aGUgZnVuY3Rpb24gcmV0dXJucyBmYWxzZSwgYXMgbm8gaW5zdGFsbGF0aW9uIGlzIG5lZWRlZC5cbiAqIEZvciBkZXNrdG9wIHdlYiBwbGF0Zm9ybXMsIHRoZSBmdW5jdGlvbiBpbml0aWF0ZXMgdGhlIGRlc2t0b3Agb25ib2FyZGluZyBwcm9jZXNzIGlmIGBwcmVmZXJEZXNrdG9wYCBpcyB0cnVlLlxuICogSWYgbm9uZSBvZiB0aGVzZSBjb25kaXRpb25zIGFyZSBtZXQsIGl0IGluaXRpYXRlcyBhIHJlbW90ZSBjb25uZWN0aW9uIGZvciBNZXRhTWFzayBpbnN0YWxsYXRpb24uXG4gKlxuICogQHBhcmFtIGluc3RhbmNlIFRoZSBNZXRhTWFza0luc3RhbGxlciBpbnN0YW5jZSB1c2VkIHRvIGRldGVybWluZSBwbGF0Zm9ybSB0eXBlIGFuZCBpbml0aWF0ZSBhcHByb3ByaWF0ZSBpbnN0YWxsYXRpb24gbWV0aG9kcy5cbiAqIEByZXR1cm5zIFByb21pc2U8Ym9vbGVhbj4gUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0cnVlIGlmIGluc3RhbGxhdGlvbiBvciByZW1vdGUgY29ubmVjdGlvbiBpcyBzdWNjZXNzZnVsLCBhbmQgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQHRocm93cyBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHJlbW90ZSBzdGFydENvbm5lY3Rpb24gZmFpbHMuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWRpcmVjdFRvUHJvcGVySW5zdGFsbChpbnN0YW5jZTogTWV0YU1hc2tJbnN0YWxsZXIpIHtcbiAgY29uc3QgeyBzdGF0ZSB9ID0gaW5zdGFuY2U7XG5cbiAgY29uc3QgcGxhdGZvcm1UeXBlID0gc3RhdGUucGxhdGZvcm1NYW5hZ2VyPy5nZXRQbGF0Zm9ybVR5cGUoKTtcblxuICBsb2dnZXIoXG4gICAgYFtNZXRhbWFza0luc3RhbGxlcjogcmVkaXJlY3RUb1Byb3Blckluc3RhbGwoKV0gcGxhdGZvcm09JHtwbGF0Zm9ybVR5cGV9YCxcbiAgKTtcblxuICAvLyBJZiBpdCdzIHJ1bm5pbmcgb24gb3VyIG1vYmlsZSBpbi1hcHAgYnJvd3NlciBidXQgY29tbXVuaWNhdGlvbiBpcyBzdGlsbCBub3Qgd29ya2luZ1xuICBpZiAocGxhdGZvcm1UeXBlID09PSBQbGF0Zm9ybVR5cGUuTWV0YU1hc2tNb2JpbGVXZWJ2aWV3KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gSWYgaXMgbm90IGluc3RhbGxlZCwgc3RhcnQgcmVtb3RlIGNvbm5lY3Rpb25cbiAgc3RhdGUuaXNJbnN0YWxsaW5nID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICBhd2FpdCBzdGF0ZS5yZW1vdGU/LnN0YXJ0Q29ubmVjdGlvbih7IGNvbm5lY3RXaXRoOiBzdGF0ZS5jb25uZWN0V2l0aCB9KTtcblxuICAgIHN0YXRlLmlzSW5zdGFsbGluZyA9IGZhbHNlO1xuICAgIHN0YXRlLmhhc0luc3RhbGxlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHN0YXRlLmlzSW5zdGFsbGluZyA9IGZhbHNlO1xuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuIiwiaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IE1ldGFNYXNrSW5zdGFsbGVyIH0gZnJvbSAnLi4vLi4vUGxhdGZvcm0vTWV0YU1hc2tJbnN0YWxsZXInO1xuXG4vKipcbiAqIENoZWNrcyBmb3IgdGhlIGluc3RhbGxhdGlvbiBvZiB0aGUgTWV0YU1hc2sgZXh0ZW5zaW9uIGFuZCByZWRpcmVjdHMgdG8gdGhlIGluc3RhbGxhdGlvbiBwYWdlIGlmIG5vdCBpbnN0YWxsZWQuXG4gKlxuICogVGhlIGZ1bmN0aW9uIGZpcnN0IHZlcmlmaWVzIGlmIE1ldGFNYXNrIGlzIGFscmVhZHkgaW5zdGFsbGVkIHVzaW5nIHRoZSBwbGF0Zm9ybU1hbmFnZXIgb2YgdGhlIGdpdmVuIE1ldGFNYXNrSW5zdGFsbGVyIHN0YXRlLlxuICogSWYgTWV0YU1hc2sgaXMgaW5zdGFsbGVkLCB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlLiBJZiBub3QsIGl0IHRyaWdnZXJzIGEgcmVkaXJlY3Rpb24gdG8gdGhlIGFwcHJvcHJpYXRlIGluc3RhbGxhdGlvbiBwYWdlLlxuICpcbiAqIEBwYXJhbSBpbnN0YW5jZSBUaGUgTWV0YU1hc2tJbnN0YWxsZXIgaW5zdGFuY2UgdXNlZCB0byBjaGVjayBpbnN0YWxsYXRpb24gYW5kIHBlcmZvcm0gcmVkaXJlY3Rpb24uXG4gKiBAcmV0dXJucyBQcm9taXNlPGJvb2xlYW4+IFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdHJ1ZSBpZiBNZXRhTWFzayBpcyBpbnN0YWxsZWQsIG90aGVyd2lzZSByZWRpcmVjdHMgdG8gdGhlIGluc3RhbGxhdGlvbiBwYWdlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2hlY2tJbnN0YWxsYXRpb24oaW5zdGFuY2U6IE1ldGFNYXNrSW5zdGFsbGVyKSB7XG4gIGNvbnN0IHsgc3RhdGUgfSA9IGluc3RhbmNlO1xuXG4gIGNvbnN0IGlzSW5zdGFsbGVkID0gc3RhdGUucGxhdGZvcm1NYW5hZ2VyPy5pc01ldGFNYXNrSW5zdGFsbGVkKCk7XG5cbiAgbG9nZ2VyKGBbTWV0YW1hc2tJbnN0YWxsZXI6IGNoZWNrSW5zdGFsbGF0aW9uKCldIGlzSW5zdGFsbGVkPSR7aXNJbnN0YWxsZWR9YCk7XG5cbiAgLy8gTm8gbmVlZCB0byBkbyBhbnl0aGluZ1xuICBpZiAoaXNJbnN0YWxsZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBhd2FpdCBpbnN0YW5jZS5yZWRpcmVjdFRvUHJvcGVySW5zdGFsbCgpO1xufVxuIiwiaW1wb3J0IHsgVHJhY2tpbmdFdmVudHMgfSBmcm9tICdAbWV0YW1hc2svc2RrLWNvbW11bmljYXRpb24tbGF5ZXInO1xuaW1wb3J0IHR5cGUgeyBDb21wb25lbnRzIH0gZnJvbSAnQG1ldGFtYXNrL3Nkay1pbnN0YWxsLW1vZGFsLXdlYic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW5zdGFsbFdpZGdldFByb3BzIGV4dGVuZHMgQ29tcG9uZW50cy5NbUluc3RhbGxNb2RhbCB7XG4gIHBhcmVudEVsZW1lbnQ6IEVsZW1lbnQ7XG4gIG9uQ2xvc2U6IChzaG91bGRUZXJtaW5hdGU/OiBib29sZWFuKSA9PiB2b2lkO1xuICBtZXRhTWFza0luc3RhbGxlcjoge1xuICAgIHN0YXJ0RGVza3RvcE9uYm9hcmRpbmc6ICgpID0+IHZvaWQ7XG4gIH07XG4gIG9uQW5hbHl0aWNzRXZlbnQ6IChldmVudDoge1xuICAgIGV2ZW50OiBUcmFja2luZ0V2ZW50cztcbiAgICBwYXJhbXM/OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcbiAgfSkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQZW5kaW5nV2lkZ2V0UHJvcHMgZXh0ZW5kcyBDb21wb25lbnRzLk1tUGVuZGluZ01vZGFsIHtcbiAgcGFyZW50RWxlbWVudDogRWxlbWVudDtcbiAgb25DbG9zZTogKCkgPT4gdm9pZDtcbiAgb25EaXNjb25uZWN0PzogKCkgPT4gdm9pZDtcbiAgdXBkYXRlT1RQVmFsdWU6IChvdHBWYWx1ZTogc3RyaW5nKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdFdpZGdldFByb3BzIGV4dGVuZHMgQ29tcG9uZW50cy5NbVNlbGVjdE1vZGFsIHtcbiAgcGFyZW50RWxlbWVudDogRWxlbWVudDtcbiAgb25DbG9zZTogKHNob3VsZFRlcm1pbmF0ZT86IGJvb2xlYW4pID0+IHZvaWQ7XG4gIGNvbm5lY3RXaXRoRXh0ZW5zaW9uOiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb2RhbExvYWRlciB7XG4gIHByaXZhdGUgY29udGFpbmVyczogUmVjb3JkPHN0cmluZywgRWxlbWVudCB8IHVuZGVmaW5lZD4gPSB7XG4gICAgaW5zdGFsbDogdW5kZWZpbmVkLFxuICAgIHBlbmRpbmc6IHVuZGVmaW5lZCxcbiAgICBzZWxlY3Q6IHVuZGVmaW5lZCxcbiAgfTtcblxuICBwcml2YXRlIGRlZmluZWQ6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+ID0ge1xuICAgIGluc3RhbGw6IGZhbHNlLFxuICAgIHBlbmRpbmc6IGZhbHNlLFxuICAgIHNlbGVjdDogZmFsc2UsXG4gIH07XG5cbiAgcHJpdmF0ZSBkZWJ1ZzogYm9vbGVhbjtcblxuICBwcml2YXRlIHNka1ZlcnNpb24/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoeyBkZWJ1Zywgc2RrVmVyc2lvbiB9OiB7IGRlYnVnPzogYm9vbGVhbjsgc2RrVmVyc2lvbj86IHN0cmluZyB9KSB7XG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnID8/IGZhbHNlO1xuICAgIHRoaXMuc2RrVmVyc2lvbiA9IHNka1ZlcnNpb247XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxvYWRDb21wb25lbnQodHlwZTogJ2luc3RhbGwnIHwgJ3BlbmRpbmcnIHwgJ3NlbGVjdCcpIHtcbiAgICBpZiAodGhpcy5kZWZpbmVkW3R5cGVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kZWZpbmVkW3R5cGVdID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgbG9hZGVyID0gYXdhaXQgaW1wb3J0KFxuICAgICAgICAvKiB3ZWJwYWNrQ2h1bmtOYW1lOiBcInNkay1pbnN0YWxsLW1vZGFsXCIgKi9cbiAgICAgICAgJ0BtZXRhbWFzay9zZGstaW5zdGFsbC1tb2RhbC13ZWIvZGlzdC9sb2FkZXInXG4gICAgICApO1xuICAgICAgY29uc29sZS5sb2coJ2xvYWRlcicsIGxvYWRlcik7XG4gICAgICBsb2FkZXIuZGVmaW5lQ3VzdG9tRWxlbWVudHMoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGxvYWQgJHt0eXBlfSBtb2RhbDpgLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcmVuZGVySW5zdGFsbE1vZGFsKHByb3BzOiBJbnN0YWxsV2lkZ2V0UHJvcHMpIHtcbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgY29uc29sZS5kZWJ1ZygnTW9kYWxMb2FkZXI6IHJlbmRlckluc3RhbGxNb2RhbCcsIHByb3BzKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRhaW5lcnMuaW5zdGFsbCA9IHByb3BzLnBhcmVudEVsZW1lbnQ7XG4gICAgYXdhaXQgdGhpcy5sb2FkQ29tcG9uZW50KCdpbnN0YWxsJyk7XG5cbiAgICBjb25zdCBtb2RhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXG4gICAgICAnbW0taW5zdGFsbC1tb2RhbCcsXG4gICAgKSBhcyBIVE1MTW1JbnN0YWxsTW9kYWxFbGVtZW50O1xuICAgIG1vZGFsLmxpbmsgPSBwcm9wcy5saW5rO1xuICAgIG1vZGFsLnByZWZlckRlc2t0b3AgPSBwcm9wcy5wcmVmZXJEZXNrdG9wO1xuICAgIG1vZGFsLnNka1ZlcnNpb24gPSBwcm9wcy5zZGtWZXJzaW9uID8/IHRoaXMuc2RrVmVyc2lvbjtcbiAgICBtb2RhbC5hZGRFdmVudExpc3RlbmVyKCdjbG9zZScsICh7IGRldGFpbDogeyBzaG91bGRUZXJtaW5hdGUgfSB9KSA9PlxuICAgICAgcHJvcHMub25DbG9zZShzaG91bGRUZXJtaW5hdGUpLFxuICAgICk7XG5cbiAgICBtb2RhbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgJ3N0YXJ0RGVza3RvcE9uYm9hcmRpbmcnLFxuICAgICAgcHJvcHMubWV0YU1hc2tJbnN0YWxsZXIuc3RhcnREZXNrdG9wT25ib2FyZGluZyxcbiAgICApO1xuXG4gICAgbW9kYWwuYWRkRXZlbnRMaXN0ZW5lcigndHJhY2tBbmFseXRpY3MnLCAoKGU6IEN1c3RvbUV2ZW50KSA9PlxuICAgICAgcHJvcHMub25BbmFseXRpY3NFdmVudD8uKGUuZGV0YWlsKSkgYXMgRXZlbnRMaXN0ZW5lcik7XG4gICAgcHJvcHMucGFyZW50RWxlbWVudC5hcHBlbmRDaGlsZChtb2RhbCk7XG4gIH1cblxuICBhc3luYyByZW5kZXJTZWxlY3RNb2RhbChwcm9wczogU2VsZWN0V2lkZ2V0UHJvcHMpIHtcbiAgICB0aGlzLmNvbnRhaW5lcnMuc2VsZWN0ID0gcHJvcHMucGFyZW50RWxlbWVudDtcbiAgICBhd2FpdCB0aGlzLmxvYWRDb21wb25lbnQoJ3NlbGVjdCcpO1xuXG4gICAgY29uc3QgbW9kYWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgJ21tLXNlbGVjdC1tb2RhbCcsXG4gICAgKSBhcyBIVE1MTW1TZWxlY3RNb2RhbEVsZW1lbnQ7XG4gICAgbW9kYWwubGluayA9IHByb3BzLmxpbms7XG4gICAgbW9kYWwuc2RrVmVyc2lvbiA9IHByb3BzLnNka1ZlcnNpb24gPz8gdGhpcy5zZGtWZXJzaW9uO1xuICAgIG1vZGFsLnByZWZlckRlc2t0b3AgPSBwcm9wcy5wcmVmZXJEZXNrdG9wO1xuICAgIG1vZGFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgKHsgZGV0YWlsOiB7IHNob3VsZFRlcm1pbmF0ZSB9IH0pID0+XG4gICAgICBwcm9wcy5vbkNsb3NlKHNob3VsZFRlcm1pbmF0ZSksXG4gICAgKTtcbiAgICBtb2RhbC5hZGRFdmVudExpc3RlbmVyKCdjb25uZWN0V2l0aEV4dGVuc2lvbicsIHByb3BzLmNvbm5lY3RXaXRoRXh0ZW5zaW9uKTtcbiAgICBwcm9wcy5wYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKG1vZGFsKTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy51cGRhdGVRUkNvZGUocHJvcHMubGluayksIDEwMCk7XG4gIH1cblxuICBhc3luYyByZW5kZXJQZW5kaW5nTW9kYWwocHJvcHM6IFBlbmRpbmdXaWRnZXRQcm9wcykge1xuICAgIHRoaXMuY29udGFpbmVycy5wZW5kaW5nID0gcHJvcHMucGFyZW50RWxlbWVudDtcbiAgICBhd2FpdCB0aGlzLmxvYWRDb21wb25lbnQoJ3BlbmRpbmcnKTtcblxuICAgIGNvbnN0IG1vZGFsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcbiAgICAgICdtbS1wZW5kaW5nLW1vZGFsJyxcbiAgICApIGFzIEhUTUxNbVBlbmRpbmdNb2RhbEVsZW1lbnQ7XG4gICAgbW9kYWwuc2RrVmVyc2lvbiA9IHByb3BzLnNka1ZlcnNpb24gPz8gdGhpcy5zZGtWZXJzaW9uO1xuICAgIG1vZGFsLmRpc3BsYXlPVFAgPSBwcm9wcy5kaXNwbGF5T1RQO1xuICAgIG1vZGFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgcHJvcHMub25DbG9zZSk7XG4gICAgbW9kYWwuYWRkRXZlbnRMaXN0ZW5lcigndXBkYXRlT1RQVmFsdWUnLCAoeyBkZXRhaWw6IHsgb3RwVmFsdWUgfSB9KSA9PlxuICAgICAgcHJvcHMudXBkYXRlT1RQVmFsdWUob3RwVmFsdWUpLFxuICAgICk7XG5cbiAgICBpZiAocHJvcHMub25EaXNjb25uZWN0KSB7XG4gICAgICBtb2RhbC5hZGRFdmVudExpc3RlbmVyKCdkaXNjb25uZWN0JywgcHJvcHMub25EaXNjb25uZWN0KTtcbiAgICB9XG5cbiAgICBwcm9wcy5wYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKG1vZGFsKTtcbiAgfVxuXG4gIHVwZGF0ZU9UUFZhbHVlKG90cFZhbHVlOiBzdHJpbmcpIHtcbiAgICBjb25zdCB0cnlVcGRhdGUgPSAoKSA9PiB7XG4gICAgICBjb25zdCBtb2RhbCA9IHRoaXMuY29udGFpbmVycy5wZW5kaW5nPy5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAnbW0tcGVuZGluZy1tb2RhbCcsXG4gICAgICApIGFzIEhUTUxNbVBlbmRpbmdNb2RhbEVsZW1lbnQgfCBudWxsO1xuICAgICAgaWYgKG1vZGFsKSB7XG4gICAgICAgIG1vZGFsLm90cENvZGUgPSBvdHBWYWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdHJ5VXBkYXRlKCk7XG4gICAgfSwgODAwKTtcbiAgfVxuXG4gIHVwZGF0ZVFSQ29kZShsaW5rOiBzdHJpbmcpIHtcbiAgICBjb25zdCBpbnN0YWxsTW9kYWwgPSB0aGlzLmNvbnRhaW5lcnMuaW5zdGFsbD8ucXVlcnlTZWxlY3RvcihcbiAgICAgICdtbS1pbnN0YWxsLW1vZGFsJyxcbiAgICApIGFzIEhUTUxNbUluc3RhbGxNb2RhbEVsZW1lbnQgfCBudWxsO1xuICAgIGlmIChpbnN0YWxsTW9kYWwpIHtcbiAgICAgIGluc3RhbGxNb2RhbC5saW5rID0gbGluaztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc2VsZWN0TW9kYWwgPSB0aGlzLmNvbnRhaW5lcnMuc2VsZWN0Py5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAnbW0tc2VsZWN0LW1vZGFsJyxcbiAgICAgICkgYXMgSFRNTE1tU2VsZWN0TW9kYWxFbGVtZW50IHwgbnVsbDtcbiAgICAgIGlmIChzZWxlY3RNb2RhbCkge1xuICAgICAgICBzZWxlY3RNb2RhbC5saW5rID0gbGluaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB1bm1vdW50KCkge1xuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuY29udGFpbmVycykuZm9yRWFjaCgoW2tleSwgY29udGFpbmVyXSkgPT4ge1xuICAgICAgY29udGFpbmVyPy5wYXJlbnROb2RlPy5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuICAgICAgdGhpcy5jb250YWluZXJzW2tleSBhcyBrZXlvZiB0eXBlb2YgdGhpcy5jb250YWluZXJzXSA9IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgVHJhY2tpbmdFdmVudHMgfSBmcm9tICdAbWV0YW1hc2svc2RrLWNvbW11bmljYXRpb24tbGF5ZXInO1xuaW1wb3J0IHBhY2thZ2VKc29uIGZyb20gJy4uLy4uLy4uL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBNZXRhTWFza0luc3RhbGxlciB9IGZyb20gJy4uLy4uL1BsYXRmb3JtL01ldGFNYXNrSW5zdGFsbGVyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uLy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgTW9kYWxMb2FkZXIgZnJvbSAnLi9Nb2RhbC13ZWInO1xuXG5jb25zdCBzZGtXZWJJbnN0YWxsTW9kYWwgPSAoe1xuICBsaW5rLFxuICBkZWJ1ZyxcbiAgaW5zdGFsbGVyLFxuICB0ZXJtaW5hdGUsXG4gIGNvbm5lY3RXaXRoRXh0ZW5zaW9uLFxuICBwcmVmZXJEZXNrdG9wLFxuICBvbkFuYWx5dGljc0V2ZW50LFxufToge1xuICBsaW5rOiBzdHJpbmc7XG4gIGRlYnVnPzogYm9vbGVhbjtcbiAgcHJlZmVyRGVza3RvcD86IGJvb2xlYW47XG4gIGluc3RhbGxlcjogTWV0YU1hc2tJbnN0YWxsZXI7XG4gIHRlcm1pbmF0ZT86ICgpID0+IHZvaWQ7XG4gIGNvbm5lY3RXaXRoRXh0ZW5zaW9uPzogKCkgPT4gdm9pZDtcbiAgb25BbmFseXRpY3NFdmVudDogKHtcbiAgICBldmVudCxcbiAgICBwYXJhbXMsXG4gIH06IHtcbiAgICBldmVudDogVHJhY2tpbmdFdmVudHM7XG4gICAgcGFyYW1zPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gIH0pID0+IHZvaWQ7XG59KSA9PiB7XG4gIGxldCBtb2RhbExvYWRlcjogTW9kYWxMb2FkZXIgfCBudWxsID0gbnVsbDtcbiAgbGV0IGRpdjogSFRNTERpdkVsZW1lbnQgfCBudWxsID0gbnVsbDtcblxuICBsb2dnZXIoXG4gICAgYFtVSTogSW5zdGFsbE1vZGFsLXdlYjogc2RrV2ViSW5zdGFsbE1vZGFsKCldICMjIyMjIyMjIyMjIyMjIyMjIyBJbnN0YWxsaW5nIE1vZGFsICMjIyMjIyMjIyMjIyMjIyMjYCxcbiAgKTtcbiAgbG9nZ2VyKGBbVUk6IEluc3RhbGxNb2RhbC13ZWI6IHNka1dlYkluc3RhbGxNb2RhbCgpXSBsaW5rPSR7bGlua31gKTtcbiAgbG9nZ2VyKFxuICAgIGBbVUk6IEluc3RhbGxNb2RhbC13ZWI6IHNka1dlYkluc3RhbGxNb2RhbCgpXSBucHggdXJpLXNjaGVtZSBvcGVuIFwiJHtsaW5rfVwiIC0taW9zYCxcbiAgKTtcblxuICBsb2dnZXIoXG4gICAgYFtVSTogSW5zdGFsbE1vZGFsLXdlYjogc2RrV2ViSW5zdGFsbE1vZGFsKCldIG5weCB1cmktc2NoZW1lIG9wZW4gXCIke2xpbmt9XCIgLS1hbmRyb2lkYCxcbiAgKTtcblxuICBsb2dnZXIoXG4gICAgYFtVSTogSW5zdGFsbE1vZGFsLXdlYjogc2RrV2ViSW5zdGFsbE1vZGFsKCldIGFkYiBzaGVsbCBhbSBzdGFydCAtYSBhbmRyb2lkLmludGVudC5hY3Rpb24uVklFVyAtZCBcIiR7bGlua31cImAsXG4gICk7XG5cbiAgY29uc3QgdW5tb3VudCA9IChzaG91bGRUZXJtaW5hdGU/OiBib29sZWFuKSA9PiB7XG4gICAgbG9nZ2VyKFxuICAgICAgYFtVSTogSW5zdGFsbE1vZGFsLXdlYjogc2RrV2ViSW5zdGFsbE1vZGFsKCldIGluc3RhbGxNb2RhbC13ZWIgdW5tb3VudGluZyBpbnN0YWxsIG1vZGFsIC0tIHNob3VsZFRlcm1pbmF0ZTpgLFxuICAgICAgc2hvdWxkVGVybWluYXRlLFxuICAgICAgZGl2LFxuICAgICk7XG5cbiAgICAvLyBSZW1vdmUgdGhlIG5vZGUgZnJvbSB0aGUgRE9NXG4gICAgaWYgKGRpdj8ucGFyZW50Tm9kZSkge1xuICAgICAgZGl2LnBhcmVudE5vZGU/LnJlbW92ZUNoaWxkKGRpdik7XG4gICAgfVxuICAgIGRpdiA9IG51bGw7XG4gICAgbW9kYWxMb2FkZXIgPSBudWxsO1xuICAgIGlmIChzaG91bGRUZXJtaW5hdGUgPT09IHRydWUpIHtcbiAgICAgIHRlcm1pbmF0ZT8uKCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IG1vdW50ID0gKHFyY29kZUxpbms6IHN0cmluZykgPT4ge1xuICAgIGxvZ2dlcihcbiAgICAgICdbVUk6IEluc3RhbGxNb2RhbC13ZWI6IHNka1dlYkluc3RhbGxNb2RhbCgpXSBpbnN0YWxsTW9kYWwtd2ViIG1vdW50aW5nIGluc3RhbGwgbW9kYWwnLFxuICAgICAgZGl2LFxuICAgICk7XG5cbiAgICBpZiAoZGl2KSB7XG4gICAgICBkaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICBtb2RhbExvYWRlcj8udXBkYXRlUVJDb2RlKHFyY29kZUxpbmspO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1vZGFsTG9hZGVyID0gbmV3IE1vZGFsTG9hZGVyKHsgZGVidWcsIHNka1ZlcnNpb246IHBhY2thZ2VKc29uLnZlcnNpb24gfSk7XG4gICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgIGlmICh3aW5kb3cuZXh0ZW5zaW9uKSB7XG4gICAgICAvLyBXaGVuIGV4dGVuc2lvbiBpcyBhdmFpbGFibGUsIHdlIGFsbG93IHN3aXRjaGluZyBiZXR3ZWVuIGV4dGVuc2lvbiBhbmQgbW9iaWxlXG4gICAgICBtb2RhbExvYWRlclxuICAgICAgICAucmVuZGVyU2VsZWN0TW9kYWwoe1xuICAgICAgICAgIHBhcmVudEVsZW1lbnQ6IGRpdixcbiAgICAgICAgICBjb25uZWN0V2l0aEV4dGVuc2lvbjogKCkgPT4ge1xuICAgICAgICAgICAgdW5tb3VudCgpO1xuICAgICAgICAgICAgY29ubmVjdFdpdGhFeHRlbnNpb24/LigpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25DbG9zZTogdW5tb3VudCxcbiAgICAgICAgICBsaW5rLFxuICAgICAgICAgIHByZWZlckRlc2t0b3A6IHByZWZlckRlc2t0b3AgPz8gZmFsc2UsXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kYWxMb2FkZXJcbiAgICAgICAgLnJlbmRlckluc3RhbGxNb2RhbCh7XG4gICAgICAgICAgcGFyZW50RWxlbWVudDogZGl2LFxuICAgICAgICAgIHByZWZlckRlc2t0b3A6IHByZWZlckRlc2t0b3AgPz8gZmFsc2UsXG4gICAgICAgICAgbGluayxcbiAgICAgICAgICBtZXRhTWFza0luc3RhbGxlcjogaW5zdGFsbGVyLFxuICAgICAgICAgIG9uQ2xvc2U6IHVubW91bnQsXG4gICAgICAgICAgb25BbmFseXRpY3NFdmVudCxcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGBbVUk6IEluc3RhbGxNb2RhbC13ZWI6IHNka1dlYkluc3RhbGxNb2RhbCgpXWAsIGVycik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4geyBtb3VudCwgdW5tb3VudCB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc2RrV2ViSW5zdGFsbE1vZGFsO1xuIiwiaW1wb3J0IHBhY2thZ2VKc29uIGZyb20gJy4uLy4uLy4uL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi8uLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IE1vZGFsTG9hZGVyIGZyb20gJy4vTW9kYWwtd2ViJztcblxuY29uc3Qgc2RrV2ViUGVuZGluZ01vZGFsID0gKHtcbiAgb25EaXNjb25uZWN0LFxuICBkZWJ1Zyxcbn06IHtcbiAgb25EaXNjb25uZWN0PzogKCkgPT4gdm9pZDtcbiAgZGVidWc/OiBib29sZWFuO1xufSkgPT4ge1xuICBsZXQgZGl2OiBIVE1MRGl2RWxlbWVudCB8IG51bGwgPSBudWxsO1xuICBsZXQgbW9kYWxMb2FkZXI6IE1vZGFsTG9hZGVyIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3QgdW5tb3VudCA9ICgpID0+IHtcbiAgICBsb2dnZXIoXG4gICAgICBgW1VJOiBwZW5kaW5nTW9kYWwtd2ViOiBzZGtXZWJQZW5kaW5nTW9kYWwoKV0gcGVuZGluZ01vZGFsLXdlYiB1bm1vdW50YCxcbiAgICAgIGRpdixcbiAgICApO1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBub2RlIGZyb20gdGhlIERPTVxuICAgIGlmIChkaXY/LnBhcmVudE5vZGUpIHtcbiAgICAgIGRpdi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRpdik7XG4gICAgfVxuXG4gICAgZGl2ID0gbnVsbDtcbiAgICBtb2RhbExvYWRlciA9IG51bGw7XG4gIH07XG5cbiAgY29uc3QgdXBkYXRlT1RQVmFsdWUgPSAob3RwVmFsdWU6IHN0cmluZykgPT4ge1xuICAgIGxvZ2dlcihcbiAgICAgIGBbVUk6IHBlbmRpbmdNb2RhbC13ZWI6IHNka1dlYlBlbmRpbmdNb2RhbCgpXSBwZW5kaW5nTW9kYWwtd2ViIHVwZGF0ZU9UUFZhbHVlYCxcbiAgICAgIG90cFZhbHVlLFxuICAgICk7XG5cbiAgICBpZiAobW9kYWxMb2FkZXIpIHtcbiAgICAgIG1vZGFsTG9hZGVyLnVwZGF0ZU9UUFZhbHVlKG90cFZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgbW91bnQgPSAoXG4gICAge1xuICAgICAgZGlzcGxheU9UUCxcbiAgICB9OiB7XG4gICAgICBkaXNwbGF5T1RQOiBib29sZWFuO1xuICAgIH0gPSB7XG4gICAgICBkaXNwbGF5T1RQOiB0cnVlLFxuICAgIH0sXG4gICkgPT4ge1xuICAgIGxvZ2dlcihcbiAgICAgIGBbVUk6IHBlbmRpbmdNb2RhbC13ZWI6IHNka1dlYlBlbmRpbmdNb2RhbCgpXSBwZW5kaW5nTW9kYWwtd2ViIG1vdW50YCxcbiAgICAgIGRpdixcbiAgICApO1xuXG4gICAgaWYgKGRpdikge1xuICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1vZGFsTG9hZGVyID0gbmV3IE1vZGFsTG9hZGVyKHsgZGVidWcsIHNka1ZlcnNpb246IHBhY2thZ2VKc29uLnZlcnNpb24gfSk7XG4gICAgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuXG4gICAgbW9kYWxMb2FkZXJcbiAgICAgIC5yZW5kZXJQZW5kaW5nTW9kYWwoe1xuICAgICAgICBwYXJlbnRFbGVtZW50OiBkaXYsXG4gICAgICAgIG9uQ2xvc2U6IHVubW91bnQsXG4gICAgICAgIG9uRGlzY29ubmVjdCxcbiAgICAgICAgdXBkYXRlT1RQVmFsdWUsXG4gICAgICAgIGRpc3BsYXlPVFAsXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgW1VJOiBwZW5kaW5nTW9kYWwtd2ViOiBzZGtXZWJQZW5kaW5nTW9kYWwoKV1gLCBlcnIpO1xuICAgICAgfSk7XG4gIH07XG5cbiAgLy8gQXV0byBtb3VudCBvbiBpbml0aWFsaXphdGlvblxuICBtb3VudCgpO1xuXG4gIHJldHVybiB7IG1vdW50LCB1bm1vdW50LCB1cGRhdGVPVFBWYWx1ZSB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc2RrV2ViUGVuZGluZ01vZGFsO1xuIiwiaW1wb3J0IHsgUmVtb3RlQ29tbXVuaWNhdGlvbiB9IGZyb20gJ0BtZXRhbWFzay9zZGstY29tbXVuaWNhdGlvbi1sYXllcic7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHBhY2thZ2VKc29uIGZyb20gJy4uLy4uLy4uLy4uL3BhY2thZ2UuanNvbic7XG5pbXBvcnQge1xuICBSZW1vdGVDb25uZWN0aW9uUHJvcHMsXG4gIFJlbW90ZUNvbm5lY3Rpb25TdGF0ZSxcbn0gZnJvbSAnLi4vUmVtb3RlQ29ubmVjdGlvbic7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbm5lY3RvciBmb3IgTWV0YU1hc2sgcmVtb3RlIGNvbW11bmljYXRpb24gYmFzZWQgb24gcHJvdmlkZWQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgQ3VycmVudCBzdGF0ZSBvZiB0aGUgUmVtb3RlQ29ubmVjdGlvbiBjbGFzcyBpbnN0YW5jZS5cbiAqIEBwYXJhbSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHJlbW90ZSBjb25uZWN0aW9uLlxuICogQHJldHVybnMgdm9pZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZUNvbm5lY3RvcihcbiAgc3RhdGU6IFJlbW90ZUNvbm5lY3Rpb25TdGF0ZSxcbiAgb3B0aW9uczogUmVtb3RlQ29ubmVjdGlvblByb3BzLFxuKSB7XG4gIGlmIChzdGF0ZS5jb25uZWN0b3IpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBsb2dnZXIoYFtSZW1vdGVDb25uZWN0aW9uOiBpbml0aWFsaXplQ29ubmVjdG9yKCldIGluaXRpYWxpemUgY29ubmVjdG9yYCk7XG5cbiAgLy8gQ2hlY2sgaWYgZXhpc3RpbmcgY2hhbm5lbCBjb25maWcgdG8gcmUtdXNlIHByZXZpb3VzIGVjaWVzIGtleSBpZiBub3QgZGlyZWN0bHkgcHJvdmlkZWRcbiAgc3RhdGUuY29ubmVjdG9yID0gbmV3IFJlbW90ZUNvbW11bmljYXRpb24oe1xuICAgIGFub25JZDogb3B0aW9ucy5hbm9uSWQsXG4gICAgcGxhdGZvcm1UeXBlOiBvcHRpb25zLnBsYXRmb3JtTWFuYWdlci5nZXRQbGF0Zm9ybVR5cGUoKSxcbiAgICBjb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlOiBvcHRpb25zLmNvbW11bmljYXRpb25MYXllclByZWZlcmVuY2UsXG4gICAgdHJhbnNwb3J0czogb3B0aW9ucy50cmFuc3BvcnRzLFxuICAgIGRhcHBNZXRhZGF0YTogeyAuLi5vcHRpb25zLmRhcHBNZXRhZGF0YSwgc291cmNlOiBvcHRpb25zLl9zb3VyY2UgfSxcbiAgICBhbmFseXRpY3M6IG9wdGlvbnMuZW5hYmxlQW5hbHl0aWNzLFxuICAgIGNvbW11bmljYXRpb25TZXJ2ZXJVcmw6IG9wdGlvbnMuY29tbXVuaWNhdGlvblNlcnZlclVybCxcbiAgICBzZGtWZXJzaW9uOiBwYWNrYWdlSnNvbi52ZXJzaW9uLFxuICAgIGNvbnRleHQ6ICdkYXBwJyxcbiAgICBlY2llczogb3B0aW9ucy5lY2llcyxcbiAgICBzdG9yYWdlOiBvcHRpb25zLnN0b3JhZ2UsXG4gICAgbG9nZ2luZzogb3B0aW9ucy5sb2dnaW5nLFxuICB9KTtcblxuICBpZiAob3B0aW9ucy50aW1lcikge1xuICAgIGxvZ2dlcihcbiAgICAgIGBbUmVtb3RlQ29ubmVjdGlvbjogaW5pdGlhbGl6ZUNvbm5lY3RvcigpXSByZXNldCBiYWNrZ3JvdW5kIHRpbWVyYCxcbiAgICAgIG9wdGlvbnMudGltZXIsXG4gICAgKTtcblxuICAgIG9wdGlvbnMudGltZXI/LnN0b3BCYWNrZ3JvdW5kVGltZXI/LigpO1xuICAgIG9wdGlvbnMudGltZXI/LnJ1bkJhY2tncm91bmRUaW1lcj8uKCgpID0+IHtcbiAgICAgIC8vIFVzZWQgdG8gbWFpbnRhaW4gdGhlIGNvbm5lY3Rpb24gd2hlbiB0aGUgYXBwIGlzIGJhY2tncm91bmRlZC5cbiAgICAgIC8vIGNvbnNvbGUuZGVidWcoYFJ1bm5pbmcgYmFja2dyb3VuZCB0aW1lcmApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sIDEwMDAwKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgUmVtb3RlQ29ubmVjdGlvblN0YXRlIH0gZnJvbSAnLi4vUmVtb3RlQ29ubmVjdGlvbic7XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbnVwTGlzdGVuZXJzKHN0YXRlOiBSZW1vdGVDb25uZWN0aW9uU3RhdGUpOiB2b2lkIHtcbiAgc3RhdGUubGlzdGVuZXJzLmZvckVhY2goKHsgZXZlbnQsIGhhbmRsZXIgfSkgPT4ge1xuICAgIHN0YXRlLmNvbm5lY3Rvcj8ub2ZmKGV2ZW50LCBoYW5kbGVyKTtcbiAgfSk7XG4gIHN0YXRlLmxpc3RlbmVycyA9IFtdO1xufVxuIiwiaW1wb3J0IHsgYW5hbHl0aWNzIH0gZnJvbSAnQG1ldGFtYXNrL3Nkay1hbmFseXRpY3MnO1xuaW1wb3J0IHsgRXZlbnRUeXBlIH0gZnJvbSAnQG1ldGFtYXNrL3Nkay1jb21tdW5pY2F0aW9uLWxheWVyJztcbmltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBQUk9WSURFUl9VUERBVEVfVFlQRSB9IGZyb20gJy4uLy4uLy4uL3R5cGVzL1Byb3ZpZGVyVXBkYXRlVHlwZSc7XG5pbXBvcnQgeyBzaG93SW5zdGFsbE1vZGFsIH0gZnJvbSAnLi4vTW9kYWxNYW5hZ2VyL3Nob3dJbnN0YWxsTW9kYWwnO1xuaW1wb3J0IHtcbiAgUmVtb3RlQ29ubmVjdGlvblByb3BzLFxuICBSZW1vdGVDb25uZWN0aW9uU3RhdGUsXG59IGZyb20gJy4uL1JlbW90ZUNvbm5lY3Rpb24nO1xuaW1wb3J0IHtcbiAgTUVUQU1BU0tfQ09OTkVDVF9CQVNFX1VSTCxcbiAgTUVUQU1BU0tfREVFUExJTktfQkFTRSxcbn0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBIYW5kbGVzIHRoZSBkaXNjb25uZWN0aW9uIHByb2Nlc3MgZm9yIGEgTWV0YU1hc2sgY29ubmVjdGlvbiBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZSBhbmQgcHJvdmlkZWQgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgQ3VycmVudCBzdGF0ZSBvZiB0aGUgUmVtb3RlQ29ubmVjdGlvbiBjbGFzcyBpbnN0YW5jZS5cbiAqIEBwYXJhbSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIGRpc2Nvbm5lY3Rpb24uXG4gKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb25uZWN0V2l0aE1vZGFsSW5zdGFsbGVyKFxuICBzdGF0ZTogUmVtb3RlQ29ubmVjdGlvblN0YXRlLFxuICBvcHRpb25zOiBSZW1vdGVDb25uZWN0aW9uUHJvcHMsXG4gIGxpbmtQYXJhbXM6IHN0cmluZyxcbikge1xuICBjb25zdCBjb25uZWN0aW9uVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGFuYWx5dGljcy50cmFjaygnc2RrX2Nvbm5lY3Rpb25fZmFpbGVkJywge1xuICAgICAgdHJhbnNwb3J0X3R5cGU6ICd3ZWJzb2NrZXQnLFxuICAgIH0pO1xuICB9LCA2MF8wMDApO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaWYgKCFzdGF0ZS5jb25uZWN0b3IpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ05vIGNvbm5lY3RvciBhdmFpbGFibGUnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbG9nZ2VyKGBbUmVtb3RlQ29ubmVjdGlvbjogY29ubmVjdFdpdGhNb2RhbEluc3RhbGxlcigpXWAsIHtcbiAgICAgIHN0YXRlLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIGxpbmtQYXJhbXMsXG4gICAgfSk7XG5cbiAgICBjb25zdCBpbnN0YWxsTGluayA9IGAke1xuICAgICAgc3RhdGUudXNlRGVlcGxpbmsgPyBNRVRBTUFTS19ERUVQTElOS19CQVNFIDogTUVUQU1BU0tfQ09OTkVDVF9CQVNFX1VSTFxuICAgIH0/JHtsaW5rUGFyYW1zfWA7XG4gICAgc2hvd0luc3RhbGxNb2RhbChzdGF0ZSwgb3B0aW9ucywgaW5zdGFsbExpbmspO1xuXG4gICAgLy8gRXZlbnQgbWVhbnMgYnJvd3NlciBleHRlbnNpb24gaXMgc2VsZWN0ZWQsIGludGVycnVwdCBncmFjZWZ1bGx5LlxuICAgIG9wdGlvbnMuc2RrLm9uY2UoXG4gICAgICBFdmVudFR5cGUuUFJPVklERVJfVVBEQVRFLFxuICAgICAgYXN5bmMgKHR5cGU6IFBST1ZJREVSX1VQREFURV9UWVBFKSA9PiB7XG4gICAgICAgIC8vIGhhbmRsZSB0aGUgcHJvdmlkZXIgY2hhbmdlIGluIGluaXRpYWxpemVQcm92aWRlclxuICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgYFtSZW1vdGVDb25uZWN0aW9uOiBjb25uZWN0V2l0aE1vZGFsSW5zdGFsbGVyKCldIG9uY2UgcHJvdmlkZXJfdXBkYXRlIC0tIHJlc29sdmluZyBzdGFydENvbm5lY3Rpb24gcHJvbWlzZWAsXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFBST1ZJREVSX1VQREFURV9UWVBFLlRFUk1JTkFURSkge1xuICAgICAgICAgIGNvbnN0IHJlamVjdGVkID0ge1xuICAgICAgICAgICAgY29kZTogNDAwMSxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdVc2VyIHJlamVjdGVkIHRoZSByZXF1ZXN0LicsXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvblRpbWVvdXQpO1xuICAgICAgICAgIHJlamVjdChyZWplY3RlZCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlamVjdCh0eXBlKTtcbiAgICAgIH0sXG4gICAgKTtcblxuICAgIHN0YXRlLmNvbm5lY3Rvci5vbmNlKEV2ZW50VHlwZS5BVVRIT1JJWkVELCAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvblRpbWVvdXQpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuXG4gICAgc3RhdGUuY29ubmVjdG9yLm9uY2UoRXZlbnRUeXBlLlJFSkVDVEVELCAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQoY29ubmVjdGlvblRpbWVvdXQpO1xuICAgICAgcmVqZWN0KEV2ZW50VHlwZS5SRUpFQ1RFRCk7XG4gICAgfSk7XG5cbiAgICBzdGF0ZS5jb25uZWN0b3Iub25jZShFdmVudFR5cGUuQ0xJRU5UU19SRUFEWSwgYXN5bmMgKCkgPT4ge1xuICAgICAgbG9nZ2VyKFxuICAgICAgICBgW1JlbW90ZUNvbm5lY3Rpb246IGNvbm5lY3RXaXRoTW9kYWxJbnN0YWxsZXIoKV0gb25jZSBjbGllbnRzX3JlYWR5IC0tIHJlc29sdmluZyBzdGFydENvbm5lY3Rpb24gcHJvbWlzZWAsXG4gICAgICApO1xuXG4gICAgICAvLyBBbGxvdyBpbml0aWFsaXplUHJvdmlkZXIgdG8gY29tcGxldGUgYW5kIHNlbmQgdGhlIGV0aF9yZXF1ZXN0QWNjb3VudHNcbiAgICAgIGNsZWFyVGltZW91dChjb25uZWN0aW9uVGltZW91dCk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgVHJhY2tpbmdFdmVudHMgfSBmcm9tICdAbWV0YW1hc2svc2RrLWNvbW11bmljYXRpb24tbGF5ZXInO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7XG4gIFJlbW90ZUNvbm5lY3Rpb25Qcm9wcyxcbiAgUmVtb3RlQ29ubmVjdGlvblN0YXRlLFxufSBmcm9tICcuLi9SZW1vdGVDb25uZWN0aW9uJztcblxuLyoqXG4gKiBEaXNwbGF5IHRoZSBpbnN0YWxsYXRpb24gbW9kYWxcbiAqXG4gKiBAcGFyYW0gcGFyYW0ubGluayBsaW5rIG9mIHRoZSBxcmNvZGVcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaG93SW5zdGFsbE1vZGFsKFxuICBzdGF0ZTogUmVtb3RlQ29ubmVjdGlvblN0YXRlLFxuICBvcHRpb25zOiBSZW1vdGVDb25uZWN0aW9uUHJvcHMsXG4gIGxpbms6IHN0cmluZyxcbik6IHZvaWQge1xuICBzdGF0ZS5pbnN0YWxsTW9kYWwgPSBvcHRpb25zLm1vZGFscy5pbnN0YWxsPy4oe1xuICAgIGxpbmssXG4gICAgcHJlZmVyRGVza3RvcDogc3RhdGUucHJlZmVyRGVza3RvcCxcbiAgICBpbnN0YWxsZXI6IG9wdGlvbnMuZ2V0TWV0YU1hc2tJbnN0YWxsZXIoKSxcbiAgICB0ZXJtaW5hdGU6ICgpID0+IHtcbiAgICAgIGxvZ2dlcihcbiAgICAgICAgYFtSZW1vdGVDb25uZWN0aW9uOiBzaG93SW5zdGFsbE1vZGFsKCkgPT4gdGVybWluYXRlKCldIHRlcm1pbmF0ZSBjb25uZWN0aW9uYCxcbiAgICAgICk7XG5cbiAgICAgIC8vIFRlcm1pbmF0ZSB3aXRoIHNwZWNpZmljIGVycm9yIGNvZGVcbiAgICAgIG9wdGlvbnMuc2RrLnRlcm1pbmF0ZSgpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKGBbTU1TREtdIGZhaWxlZCB0byB0ZXJtaW5hdGUgY29ubmVjdGlvbmAsIGVycik7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRlYnVnOiBzdGF0ZS5kZXZlbG9wZXJNb2RlLFxuICAgIGNvbm5lY3RXaXRoRXh0ZW5zaW9uOiAoKSA9PiB7XG4gICAgICBvcHRpb25zLmNvbm5lY3RXaXRoRXh0ZW5zaW9uUHJvdmlkZXI/LigpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgb25BbmFseXRpY3NFdmVudDogKHtcbiAgICAgIGV2ZW50LFxuICAgICAgcGFyYW1zLFxuICAgIH06IHtcbiAgICAgIGV2ZW50OiBUcmFja2luZ0V2ZW50cztcbiAgICAgIHBhcmFtcz86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gICAgfSkgPT4ge1xuICAgICAgY29uc3QgZXh0ZW5kZWQgPSB7XG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgc2RrVmVyc2lvbjogb3B0aW9ucy5zZGsuZ2V0VmVyc2lvbigpLFxuICAgICAgICBkYXBwSWQ6IG9wdGlvbnMuZGFwcE1ldGFkYXRhPy5uYW1lLFxuICAgICAgICBzb3VyY2U6IG9wdGlvbnMuX3NvdXJjZSxcbiAgICAgICAgdXJsOiBvcHRpb25zLmRhcHBNZXRhZGF0YT8udXJsLFxuICAgICAgfTtcbiAgICAgIHN0YXRlLmFuYWx5dGljcz8uc2VuZCh7IGV2ZW50LCBwYXJhbXM6IGV4dGVuZGVkIH0pO1xuICAgIH0sXG4gIH0pO1xuICBzdGF0ZS5pbnN0YWxsTW9kYWw/Lm1vdW50Py4obGluayk7XG59XG4iLCJpbXBvcnQgeyBSZXF1ZXN0QXJndW1lbnRzIH0gZnJvbSAnQG1ldGFtYXNrL3Byb3ZpZGVycyc7XG5pbXBvcnQgeyBFdmVudFR5cGUgfSBmcm9tICdAbWV0YW1hc2svc2RrLWNvbW11bmljYXRpb24tbGF5ZXInO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEV0aGVyZXVtIH0gZnJvbSAnLi4vLi4vRXRoZXJldW0nO1xuaW1wb3J0IHsgUmVtb3RlQ29ubmVjdGlvbiwgUmVtb3RlQ29ubmVjdGlvblN0YXRlIH0gZnJvbSAnLi4vUmVtb3RlQ29ubmVjdGlvbic7XG5pbXBvcnQgeyBjbGVhbnVwTGlzdGVuZXJzIH0gZnJvbSAnLi9jbGVhbnVwTGlzdGVuZXJzJztcblxuLy8gRGVmaW5lIHNwZWNpZmljIHR5cGVzIGZvciBlYWNoIGV2ZW50IGhhbmRsZXJcbnR5cGUgU0RLUlBDQ2FsbEhhbmRsZXIgPSAocmVxdWVzdFBhcmFtczogUmVxdWVzdEFyZ3VtZW50cykgPT4gUHJvbWlzZTx2b2lkPjtcbnR5cGUgV2FsbGV0SW5pdEhhbmRsZXIgPSAoZGF0YToge1xuICBhY2NvdW50czogc3RyaW5nW107XG4gIGNoYWluSWQ6IHN0cmluZztcbn0pID0+IFByb21pc2U8dm9pZD47XG50eXBlIEF1dGhvcml6ZWRIYW5kbGVyID0gKCkgPT4gUHJvbWlzZTx2b2lkPjtcbnR5cGUgQ2xpZW50c0Rpc2Nvbm5lY3RlZEhhbmRsZXIgPSAoKSA9PiB2b2lkO1xudHlwZSBUZXJtaW5hdGVIYW5kbGVyID0gKCkgPT4gdm9pZDtcblxuLy8gVW5pb24gdHlwZSBmb3IgYWxsIHBvc3NpYmxlIGhhbmRsZXJzXG5leHBvcnQgdHlwZSBFdmVudEhhbmRsZXIgPVxuICB8IFNES1JQQ0NhbGxIYW5kbGVyXG4gIHwgV2FsbGV0SW5pdEhhbmRsZXJcbiAgfCBBdXRob3JpemVkSGFuZGxlclxuICB8IENsaWVudHNEaXNjb25uZWN0ZWRIYW5kbGVyXG4gIHwgVGVybWluYXRlSGFuZGxlcjtcblxuLyoqXG4gKiBTZXRzIHVwIGV2ZW50IGxpc3RlbmVycyBmb3IgTWV0YU1hc2sgcmVtb3RlIGNvbW11bmljYXRpb24gYW5kIGhhbmRsZXMgcmVzcG9uc2VzIGFjY29yZGluZ2x5LlxuICpcbiAqIEBwYXJhbSBzdGF0ZSBDdXJyZW50IHN0YXRlIG9mIHRoZSBSZW1vdGVDb25uZWN0aW9uIGNsYXNzIGluc3RhbmNlLlxuICogQHBhcmFtIG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgZXZlbnRzLlxuICogQHJldHVybnMgdm9pZFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0dXBMaXN0ZW5lcnMoXG4gIHN0YXRlOiBSZW1vdGVDb25uZWN0aW9uU3RhdGUsXG4gIF9vcHRpb25zOiBSZW1vdGVDb25uZWN0aW9uWydvcHRpb25zJ10sXG4pOiB2b2lkIHtcbiAgaWYgKCFzdGF0ZS5jb25uZWN0b3IpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBDbGVhciBleGlzdGluZyBsaXN0ZW5lcnMgaWYgYW55XG4gIGNsZWFudXBMaXN0ZW5lcnMoc3RhdGUpO1xuXG4gIGZ1bmN0aW9uIGFkZExpc3RlbmVyKGV2ZW50OiBFdmVudFR5cGUsIGhhbmRsZXI6IEV2ZW50SGFuZGxlcikge1xuICAgIHN0YXRlLmNvbm5lY3Rvcj8ub24oZXZlbnQsIGhhbmRsZXIpO1xuICAgIHN0YXRlLmxpc3RlbmVycy5wdXNoKHsgZXZlbnQsIGhhbmRsZXIgfSk7XG4gIH1cblxuICBhZGRMaXN0ZW5lcihFdmVudFR5cGUuV0FMTEVUX0lOSVQsIChhc3luYyAoeyBhY2NvdW50cywgY2hhaW5JZCB9KSA9PiB7XG4gICAgbG9nZ2VyKFxuICAgICAgYFtSZW1vdGVDb25uZWN0aW9uOiBzZXR1cExpc3RlbmVycygpID0+IEV2ZW50VHlwZS5XQUxMRVRfSU5JVF0gJ3dhbGxldF9pbml0JyBhY2NvdW50cz0ke2FjY291bnRzfSBjaGFpbklkPSR7Y2hhaW5JZH1gLFxuICAgICk7XG5cbiAgICBjb25zdCBwcm92aWRlciA9IEV0aGVyZXVtLmdldFByb3ZpZGVyKCk7XG4gICAgcHJvdmlkZXIuX3NldENvbm5lY3RlZCgpO1xuXG4gICAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgICAgYWNjb3VudHMsXG4gICAgICBjaGFpbklkLFxuICAgICAgaXNVbmxvY2tlZDogZmFsc2UsXG4gICAgfTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHByb3ZpZGVyLl9pbml0aWFsaXplU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICBwcm92aWRlci5lbWl0KCdjaGFpbkNoYW5nZWQnLCBjaGFpbklkKTtcbiAgICBwcm92aWRlci5lbWl0KCdhY2NvdW50c0NoYW5nZWQnLCBhY2NvdW50cyk7XG4gIH0pIGFzIFdhbGxldEluaXRIYW5kbGVyKTtcblxuICBhZGRMaXN0ZW5lcihFdmVudFR5cGUuQVVUSE9SSVpFRCwgKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgbG9nZ2VyKFxuICAgICAgICBgW1JlbW90ZUNvbm5lY3Rpb246IHNldHVwTGlzdGVuZXJzKCkgPT4gRXZlbnRUeXBlLkFVVEhPUklaRURdICdhdXRob3JpemVkJyBjbG9zaW5nIG1vZGFsc2AsXG4gICAgICAgIHN0YXRlLnBlbmRpbmdNb2RhbCxcbiAgICAgICAgc3RhdGUuaW5zdGFsbE1vZGFsLFxuICAgICAgKTtcblxuICAgICAgLy8gRm9yY2UgY29ubmVjdGVkIHN0YXRlIG9uIHByb3ZpZGVyXG4gICAgICAvLyBUaGlzIHByZXZlbnRzIHNvbWUgcnBjIG1ldGhvZCBiZWluZyByZWNlaXZlZCBpbiBFdGhlcmV1bSBiZWZvcmUgY29ubmVjdGVkIHN0YXRlIGlzLlxuICAgICAgY29uc3QgcHJvdmlkZXIgPSBFdGhlcmV1bS5nZXRQcm92aWRlcigpO1xuICAgICAgcHJvdmlkZXIuX3NldENvbm5lY3RlZCgpO1xuXG4gICAgICAvLyBjbG9zZSBtb2RhbHNcbiAgICAgIHN0YXRlLnBlbmRpbmdNb2RhbD8udW5tb3VudD8uKCk7XG4gICAgICBzdGF0ZS5pbnN0YWxsTW9kYWw/LnVubW91bnQ/LihmYWxzZSk7XG4gICAgICBzdGF0ZS5vdHBBbnN3ZXIgPSB1bmRlZmluZWQ7XG4gICAgICBzdGF0ZS5hdXRob3JpemVkID0gdHJ1ZTtcblxuICAgICAgbG9nZ2VyKFxuICAgICAgICBgW1JlbW90ZUNvbm5lY3Rpb246IHNldHVwTGlzdGVuZXJzKCkgPT4gRXZlbnRUeXBlLkFVVEhPUklaRURdICdhdXRob3JpemVkJyBwcm92aWRlci5zdGF0ZWAsXG4gICAgICAgIHByb3ZpZGVyLmdldFN0YXRlKCksXG4gICAgICApO1xuXG4gICAgICBhd2FpdCBwcm92aWRlci5mb3JjZUluaXRpYWxpemVTdGF0ZSgpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSWdub3JlIGVycm9yIGlmIGFscmVhZHkgaW5pdGlhbGl6ZWQuXG4gICAgICAvLyBjb25zb2xlLmRlYnVnKGBJR05PUkUgRVJST1JgLCBlcnIpO1xuICAgIH1cbiAgfSkgYXMgQXV0aG9yaXplZEhhbmRsZXIpO1xuXG4gIC8vIFNob3VsZCBub3QgYmUgbmVlZGVkIGFueW1vcmUgYnV0IGtlZXBpbmcgZm9yIHJlZmVyZW5jZSBpZiBuZWVkZWQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgd2l0aCBvbGRlciBTREsgKHByZSBhc3luYyBjb21tdW5pY2F0aW9uKVxuICAvLyBhZGRMaXN0ZW5lcihFdmVudFR5cGUuQ0xJRU5UU19ESVNDT05ORUNURUQsICgoKSA9PiB7XG4gIC8vICAgbG9nZ2VyKFxuICAvLyAgICAgYFtSZW1vdGVDb25uZWN0aW9uOiBzZXR1cExpc3RlbmVycygpID0+IEV2ZW50VHlwZS5DTElFTlRTX0RJU0NPTk5FQ1RFRF0gcmVjZWl2ZWQgJyR7RXZlbnRUeXBlLkNMSUVOVFNfRElTQ09OTkVDVEVEfSdgLFxuICAvLyAgICk7XG5cbiAgLy8gICBpZiAoIXN0YXRlLnBsYXRmb3JtTWFuYWdlcj8uaXNTZWN1cmUoKSkge1xuICAvLyAgICAgY29uc3QgcHJvdmlkZXIgPSBFdGhlcmV1bS5nZXRQcm92aWRlcigpO1xuICAvLyAgICAgcHJvdmlkZXIuaGFuZGxlRGlzY29ubmVjdCh7IHRlcm1pbmF0ZTogZmFsc2UgfSk7XG4gIC8vICAgICBzdGF0ZS5wZW5kaW5nTW9kYWw/LnVwZGF0ZU9UUFZhbHVlPy4oJycpO1xuICAvLyAgIH1cbiAgLy8gfSkgYXMgQ2xpZW50c0Rpc2Nvbm5lY3RlZEhhbmRsZXIpO1xuXG4gIGFkZExpc3RlbmVyKEV2ZW50VHlwZS5URVJNSU5BVEUsICgoKSA9PiB7XG4gICAgc3RhdGUucGVuZGluZ01vZGFsPy51bm1vdW50Py4oKTtcbiAgICBzdGF0ZS5pbnN0YWxsTW9kYWw/LnVubW91bnQ/Lih0cnVlKTtcbiAgICBzdGF0ZS5wZW5kaW5nTW9kYWwgPSB1bmRlZmluZWQ7XG4gICAgc3RhdGUuaW5zdGFsbE1vZGFsID0gdW5kZWZpbmVkO1xuICAgIHN0YXRlLm90cEFuc3dlciA9IHVuZGVmaW5lZDtcbiAgICBzdGF0ZS5jb25uZWN0b3I/LmRpc2Nvbm5lY3QoeyB0ZXJtaW5hdGU6IHRydWUgfSk7XG4gICAgc3RhdGUuYXV0aG9yaXplZCA9IGZhbHNlO1xuXG4gICAgY29uc3QgcHJvdmlkZXIgPSBFdGhlcmV1bS5nZXRQcm92aWRlcigpO1xuICAgIHByb3ZpZGVyLmhhbmRsZURpc2Nvbm5lY3QoeyB0ZXJtaW5hdGU6IHRydWUgfSk7XG5cbiAgICAvLyBDbGVhbiB1cCBhbGwgbGlzdGVuZXJzXG4gICAgY2xlYW51cExpc3RlbmVycyhzdGF0ZSk7XG5cbiAgICBsb2dnZXIoYFtSZW1vdGVDb25uZWN0aW9uOiBzZXR1cExpc3RlbmVycygpXSBBbGwgbGlzdGVuZXJzIGNsZWFuZWQgdXBgKTtcbiAgfSkgYXMgVGVybWluYXRlSGFuZGxlcik7XG59XG4iLCJpbXBvcnQgeyBhbmFseXRpY3MgfSBmcm9tICdAbWV0YW1hc2svc2RrLWFuYWx5dGljcyc7XG5pbXBvcnQge1xuICBERUZBVUxUX1NFU1NJT05fVElNRU9VVF9NUyxcbiAgRXZlbnRUeXBlLFxuICBPcmlnaW5hdG9ySW5mbyxcbn0gZnJvbSAnQG1ldGFtYXNrL3Nkay1jb21tdW5pY2F0aW9uLWxheWVyJztcbmltcG9ydCBwYWNrYWdlSnNvbiBmcm9tICcuLi8uLi8uLi8uLi9wYWNrYWdlLmpzb24nO1xuaW1wb3J0IHtcbiAgTUVUQU1BU0tfQ09OTkVDVF9CQVNFX1VSTCxcbiAgTUVUQU1BU0tfREVFUExJTktfQkFTRSxcbn0gZnJvbSAnLi4vLi4vLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IFJQQ0NhbGwgfSBmcm9tICcuLi8uLi8uLi9QbGF0Zm9ybS9NZXRhTWFza0luc3RhbGxlcic7XG5pbXBvcnQgeyBiYXNlNjRFbmNvZGUgfSBmcm9tICcuLi8uLi8uLi91dGlscy9iYXNlNjQnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IEV0aGVyZXVtIH0gZnJvbSAnLi4vLi4vRXRoZXJldW0nO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZUNvbm5lY3RvciB9IGZyb20gJy4uL0Nvbm5lY3Rpb25Jbml0aWFsaXplcic7XG5pbXBvcnQgeyBzZXR1cExpc3RlbmVycyB9IGZyb20gJy4uL0V2ZW50TGlzdGVuZXJzJztcbmltcG9ydCB7XG4gIFJlbW90ZUNvbm5lY3Rpb25Qcm9wcyxcbiAgUmVtb3RlQ29ubmVjdGlvblN0YXRlLFxufSBmcm9tICcuLi9SZW1vdGVDb25uZWN0aW9uJztcbmltcG9ydCB7IGNvbm5lY3RXaXRoRGVlcGxpbmsgfSBmcm9tICcuL2Nvbm5lY3RXaXRoRGVlcGxpbmsnO1xuaW1wb3J0IHsgY29ubmVjdFdpdGhNb2RhbEluc3RhbGxlciB9IGZyb20gJy4vY29ubmVjdFdpdGhNb2RhbEluc3RhbGxlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhcnRDb25uZWN0aW9uRXh0cmFzIHtcbiAgaW5pdGlhbENoZWNrPzogYm9vbGVhbjtcbiAgY29ubmVjdFdpdGg/OiBSUENDYWxsO1xufVxuXG4vKipcbiAqIEluaXRpYXRlcyB0aGUgY29ubmVjdGlvbiBwcm9jZXNzIHRvIE1ldGFNYXNrLCBjaG9vc2luZyB0aGUgYXBwcm9wcmlhdGUgY29ubmVjdGlvbiBtZXRob2QgYmFzZWQgb24gc3RhdGUgYW5kIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHN0YXRlIEN1cnJlbnQgc3RhdGUgb2YgdGhlIFJlbW90ZUNvbm5lY3Rpb24gY2xhc3MgaW5zdGFuY2UuXG4gKiBAcGFyYW0gb3B0aW9ucyBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBjb25uZWN0aW9uLlxuICogQHJldHVybnMgUHJvbWlzZTx2b2lkPlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RhcnRDb25uZWN0aW9uKFxuICBzdGF0ZTogUmVtb3RlQ29ubmVjdGlvblN0YXRlLFxuICBvcHRpb25zOiBSZW1vdGVDb25uZWN0aW9uUHJvcHMsXG4gIHsgaW5pdGlhbENoZWNrLCBjb25uZWN0V2l0aCB9OiBTdGFydENvbm5lY3Rpb25FeHRyYXMgPSB7fSxcbik6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIC8vIEluaXRpYWxpemUgdGhlIGNvbm5lY3RvciAtIHdpbGwgc2tpcCBpZiBhbHJlYWR5IGluaXRpYWxpemVkXG4gICAgaW5pdGlhbGl6ZUNvbm5lY3RvcihzdGF0ZSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIXN0YXRlLmNvbm5lY3Rvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBjb25uZWN0b3IgZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBsaXN0ZW5lcnMgYXJlIHNldCB1cFxuICAgIHNldHVwTGlzdGVuZXJzKHN0YXRlLCBvcHRpb25zKTtcblxuICAgIGNvbnN0IHByb3ZpZGVyID0gRXRoZXJldW0uZ2V0UHJvdmlkZXIoKTtcblxuICAgIC8vIHJlc2V0IGF1dGhvcml6YXRpb24gc3RhdGVcbiAgICBzdGF0ZS5hdXRob3JpemVkID0gZmFsc2U7XG5cbiAgICAvLyBFc3RhYmxpc2ggc29ja2V0IGNvbm5lY3Rpb25cbiAgICBwcm92aWRlci5lbWl0KCdjb25uZWN0aW5nJyk7XG5cbiAgICBjb25zdCBjaGFubmVsQ29uZmlnID0gYXdhaXQgc3RhdGUuY29ubmVjdG9yPy5vcmlnaW5hdG9yU2Vzc2lvbkNvbm5lY3QoKTtcbiAgICBsb2dnZXIoXG4gICAgICBgW1JlbW90ZUNvbm5lY3Rpb246IHN0YXJ0Q29ubmVjdGlvbigpXSBhZnRlciBvcmlnaW5hdG9yU2Vzc2lvbkNvbm5lY3QgaW5pdGlhbENoZWNrPSR7aW5pdGlhbENoZWNrfWAsXG4gICAgICBjaGFubmVsQ29uZmlnLFxuICAgICk7XG5cbiAgICBsZXQgY2hhbm5lbElkID0gY2hhbm5lbENvbmZpZz8uY2hhbm5lbElkID8/ICcnO1xuICAgIGxldCBwdWJLZXkgPSBzdGF0ZS5jb25uZWN0b3IuZ2V0S2V5SW5mbygpPy5lY2llcy5wdWJsaWMgPz8gJyc7XG4gICAgbGV0IHByaXZLZXkgPSBzdGF0ZS5jb25uZWN0b3IuZ2V0S2V5SW5mbygpPy5lY2llcy5wcml2YXRlID8/ICcnO1xuXG4gICAgaWYgKGluaXRpYWxDaGVjayAmJiAhY2hhbm5lbENvbmZpZykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIGlmICghY2hhbm5lbENvbmZpZyAmJiAhaW5pdGlhbENoZWNrKSB7XG4gICAgICBjb25zdCBuZXdDaGFubmVsID0gYXdhaXQgc3RhdGUuY29ubmVjdG9yLmdlbmVyYXRlQ2hhbm5lbElkQ29ubmVjdCgpO1xuICAgICAgY2hhbm5lbElkID0gbmV3Q2hhbm5lbC5jaGFubmVsSWQgPz8gJyc7XG4gICAgICBwdWJLZXkgPSBuZXdDaGFubmVsLnB1YktleSA/PyAnJztcbiAgICAgIHByaXZLZXkgPSBuZXdDaGFubmVsLnByaXZLZXkgPz8gJyc7XG5cbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAvLyBTYXZlIGNoYW5uZWxJZCB0byBzdG9yYWdlIGZvciByZS11c2UgdW50aWwgaXQgZXhwaXJlcyBvciBpcyB0ZXJtaW5hdGVkXG4gICAgICBzdGF0ZS5jb25uZWN0b3Iuc3RhdGUuc3RvcmFnZU1hbmFnZXI/LnBlcnNpc3RDaGFubmVsQ29uZmlnKHtcbiAgICAgICAgY2hhbm5lbElkLFxuICAgICAgICBsb2NhbEtleTogcHJpdktleSxcbiAgICAgICAgbGFzdEFjdGl2ZTogbm93LFxuICAgICAgICB2YWxpZFVudGlsOiBub3cgKyBERUZBVUxUX1NFU1NJT05fVElNRU9VVF9NUyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpbml0aWFsQ2hlY2sgJiYgY2hhbm5lbENvbmZpZz8uY2hhbm5lbElkKSB7XG4gICAgICBpZiAoIXN0YXRlLmNvbm5lY3Rvcj8uaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgYFtSZW1vdGVDb25uZWN0aW9uOiBzdGFydENvbm5lY3Rpb24oKV0gcmVjb25uZWN0aW5nIHRvIGNoYW5uZWwgaW5pdGlhbENoZWNrPSR7aW5pdGlhbENoZWNrfWAsXG4gICAgICAgICAgY2hhbm5lbENvbmZpZyxcbiAgICAgICAgKTtcblxuICAgICAgICBhd2FpdCBzdGF0ZS5jb25uZWN0b3I/LmNvbm5lY3RUb0NoYW5uZWwoe1xuICAgICAgICAgIGNoYW5uZWxJZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAvLyBBZGQgY29uZGl0aW9uIHRvIGhhbmRsZSBmdWxsIHJlbGF5IHBlcnNpc3RlbmNlXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgaWYgKGNoYW5uZWxDb25maWcgJiYgIXN0YXRlLmNvbm5lY3Rvcj8uaXNDb25uZWN0ZWQoKSkge1xuICAgICAgbG9nZ2VyKFxuICAgICAgICBgW1JlbW90ZUNvbm5lY3Rpb246IHN0YXJ0Q29ubmVjdGlvbigpXSByZWNvbm5lY3RpbmcgdG8gY2hhbm5lbGAsXG4gICAgICAgIGNoYW5uZWxDb25maWcsXG4gICAgICApO1xuXG4gICAgICBhd2FpdCBzdGF0ZS5jb25uZWN0b3I/LmNvbm5lY3RUb0NoYW5uZWwoe1xuICAgICAgICBjaGFubmVsSWQsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBxckNvZGVPcmlnaW4gPSBzdGF0ZS5wbGF0Zm9ybU1hbmFnZXI/LmlzU2VjdXJlKCkgPyAnJyA6ICcmdD1xJztcbiAgICBjb25zdCBzZGtWZXJzaW9uID0gcGFja2FnZUpzb24udmVyc2lvbjtcbiAgICBjb25zdCB7IGljb25VcmwsIG5hbWUsIHVybCwgc2NoZW1lIH0gPSBvcHRpb25zLmRhcHBNZXRhZGF0YSB8fCB7fTtcbiAgICBjb25zdCBwbGF0Zm9ybVR5cGUgPSBzdGF0ZS5wbGF0Zm9ybU1hbmFnZXI/LmdldFBsYXRmb3JtVHlwZSgpO1xuXG4gICAgbGV0IGRhcHBJZCA9ICdOL0EnO1xuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIHdpbmRvdy5sb2NhdGlvbiAmJlxuICAgICAgd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lXG4gICAgKSB7XG4gICAgICBkYXBwSWQgPSB3aW5kb3cubG9jYXRpb24uaG9zdG5hbWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRhcHBJZCA9IG5hbWUgYXMgc3RyaW5nO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRhcHBJZCA9IHVybCBhcyBzdHJpbmc7XG4gICAgfVxuXG4gICAgY29uc3Qgb3JpZ2luYXRvckluZm86IE9yaWdpbmF0b3JJbmZvID0ge1xuICAgICAgdXJsOiB1cmwgPz8gJycsXG4gICAgICB0aXRsZTogbmFtZSA/PyAnJyxcbiAgICAgIGljb246IGljb25VcmwsXG4gICAgICBzY2hlbWU6IHNjaGVtZSA/PyAnJyxcbiAgICAgIGFwaVZlcnNpb246IHNka1ZlcnNpb24sXG4gICAgICBkYXBwSWQ6IGRhcHBJZCB8fCB1cmwgfHwgJ04vQScsXG4gICAgICBhbm9uSWQ6IG9wdGlvbnMuYW5vbklkLFxuICAgICAgcGxhdGZvcm06IHBsYXRmb3JtVHlwZSA/PyAnJyxcbiAgICAgIHNvdXJjZTogb3B0aW9ucy5fc291cmNlID8/ICcnLFxuICAgIH07XG4gICAgY29uc3QgYmFzZTY0T3JpZ2luYXRvckluZm8gPSBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkob3JpZ2luYXRvckluZm8pKTtcblxuICAgIGxldCBsaW5rUGFyYW1zID0gYGNoYW5uZWxJZD0ke2NoYW5uZWxJZH0mdj0yJmNvbW09JHtcbiAgICAgIHN0YXRlLmNvbW11bmljYXRpb25MYXllclByZWZlcmVuY2UgPz8gJydcbiAgICB9JnB1YmtleT0ke3B1YktleX0ke3FyQ29kZU9yaWdpbn0mb3JpZ2luYXRvckluZm89JHtiYXNlNjRPcmlnaW5hdG9ySW5mb31gO1xuXG4gICAgaWYgKGNvbm5lY3RXaXRoKSB7XG4gICAgICBjb25zdCBiYXNlNjRScGMgPSBiYXNlNjRFbmNvZGUoSlNPTi5zdHJpbmdpZnkoY29ubmVjdFdpdGgpKTtcbiAgICAgIGxpbmtQYXJhbXMgKz0gYCZycGM9JHtiYXNlNjRScGN9YDtcblxuICAgICAgY29uc3QgdHJhY2tlciA9IHN0YXRlLmNvbm5lY3Rvci5nZXRSUENNZXRob2RUcmFja2VyKCk7XG4gICAgICAvLyBBZGQgcnBjTWV0aG9kIHRvIHRyYWNrZXJcbiAgICAgIGlmICh0cmFja2VyKSB7XG4gICAgICAgIHRyYWNrZXJbYCR7Y29ubmVjdFdpdGguaWR9YF0gPSB7XG4gICAgICAgICAgLi4uY29ubmVjdFdpdGgsXG4gICAgICAgICAgaWQ6IGAke2Nvbm5lY3RXaXRoLmlkfWAsXG4gICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbmNvZGVkTGlua1BhcmFtcyA9IGVuY29kZVVSSShsaW5rUGFyYW1zKTtcbiAgICBjb25zdCBxcmNvZGVMaW5rID0gYCR7XG4gICAgICBzdGF0ZS51c2VEZWVwbGluayA/IE1FVEFNQVNLX0RFRVBMSU5LX0JBU0UgOiBNRVRBTUFTS19DT05ORUNUX0JBU0VfVVJMXG4gICAgfT8ke2xpbmtQYXJhbXN9YDtcbiAgICBzdGF0ZS5xcmNvZGVMaW5rID0gcXJjb2RlTGluaztcblxuICAgIGlmIChzdGF0ZS5kZXZlbG9wZXJNb2RlKSB7XG4gICAgICBsb2dnZXIoXG4gICAgICAgIGBbUmVtb3RlQ29ubmVjdGlvbjogc3RhcnRDb25uZWN0aW9uKCldIHFyY29kZUxpbms9JHtlbmNvZGVkTGlua1BhcmFtc31gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBlbWl0IHFyY29kZSB1cmwgbGlua1xuICAgIHByb3ZpZGVyLmVtaXQoJ2Rpc3BsYXlfdXJpJywgcXJjb2RlTGluayk7XG5cbiAgICBhbmFseXRpY3MudHJhY2soJ3Nka19jb25uZWN0aW9uX2luaXRpYXRlZCcsIHtcbiAgICAgIHRyYW5zcG9ydF90eXBlOiAnd2Vic29ja2V0JyxcbiAgICB9KTtcblxuICAgIC8vIGZpcnN0IGhhbmRsZSBzZWN1cmUgY29ubmVjdGlvblxuICAgIGlmIChzdGF0ZS5wbGF0Zm9ybU1hbmFnZXI/LmlzU2VjdXJlKCkpIHtcbiAgICAgIGNvbnN0IGNvbm5lY3Rpb25UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGFuYWx5dGljcy50cmFjaygnc2RrX2Nvbm5lY3Rpb25fZmFpbGVkJywge1xuICAgICAgICAgIHRyYW5zcG9ydF90eXBlOiAnd2Vic29ja2V0JyxcbiAgICAgICAgfSk7XG4gICAgICB9LCA2MF8wMDApO1xuXG4gICAgICBhd2FpdCBjb25uZWN0V2l0aERlZXBsaW5rKHN0YXRlLCBlbmNvZGVkTGlua1BhcmFtcyk7XG4gICAgICAvLyB3YWl0IGZvciBhdXRob3JpemVkIGV2ZW50XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBpZiAoc3RhdGUuY29ubmVjdG9yPy5pc0F1dGhvcml6ZWQoKSkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0aW9uVGltZW91dCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmNvbm5lY3Rvcj8ub25jZShFdmVudFR5cGUuQVVUSE9SSVpFRCwgKCkgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dChjb25uZWN0aW9uVGltZW91dCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzdGF0ZS5jb25uZWN0b3I/Lm9uY2UoRXZlbnRUeXBlLlJFSkVDVEVELCAoKSA9PiB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgICAgICByZWplY3QoRXZlbnRUeXBlLlJFSkVDVEVEKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29ubmVjdFdpdGhNb2RhbEluc3RhbGxlcihzdGF0ZSwgb3B0aW9ucywgZW5jb2RlZExpbmtQYXJhbXMpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYFtzdGFydENvbm5lY3Rpb25dIGVycm9yYCwgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG4iLCJpbXBvcnQge1xuICBNRVRBTUFTS19ERUVQTElOS19CQVNFLFxuICBNRVRBTUFTS19DT05ORUNUX0JBU0VfVVJMLFxufSBmcm9tICcuLi8uLi8uLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgUmVtb3RlQ29ubmVjdGlvblN0YXRlIH0gZnJvbSAnLi4vUmVtb3RlQ29ubmVjdGlvbic7XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuZCBvcGVucyBhIHVuaXZlcnNhbCBsaW5rIG9yIGRlZXBsaW5rIGZvciBNZXRhTWFzayBjb25uZWN0aW9uIGJhc2VkIG9uIGdpdmVuIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHN0YXRlIEN1cnJlbnQgc3RhdGUgb2YgdGhlIFJlbW90ZUNvbm5lY3Rpb24gY2xhc3MgaW5zdGFuY2UuXG4gKiBAcGFyYW0gbGlua1BhcmFtcyBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHBhcmFtZXRlcnMgdXNlZCB0byBmb3JtIHRoZSB1bml2ZXJzYWwgYW5kIGRlZXAgbGlua3MuXG4gKiBAcmV0dXJucyBQcm9taXNlPHZvaWQ+XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjb25uZWN0V2l0aERlZXBsaW5rKFxuICBzdGF0ZTogUmVtb3RlQ29ubmVjdGlvblN0YXRlLFxuICBsaW5rUGFyYW1zOiBzdHJpbmcsXG4pOiBQcm9taXNlPHZvaWQ+IHtcbiAgY29uc3QgdW5pdmVyc2FsTGluayA9IGAke01FVEFNQVNLX0NPTk5FQ1RfQkFTRV9VUkx9PyR7bGlua1BhcmFtc31gO1xuICBjb25zdCBkZWVwbGluayA9IGAke01FVEFNQVNLX0RFRVBMSU5LX0JBU0V9PyR7bGlua1BhcmFtc31gO1xuXG4gIC8vIGNvbnNvbGUubG9nKCdPUEVOIExJTksnLCB1bml2ZXJzYWxMaW5rKTtcbiAgc3RhdGUucGxhdGZvcm1NYW5hZ2VyPy5vcGVuRGVlcGxpbms/Lih1bml2ZXJzYWxMaW5rLCBkZWVwbGluaywgJ19zZWxmJyk7XG59XG4iLCJpbXBvcnQge1xuICBDaGFubmVsQ29uZmlnLFxuICBDb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlLFxuICBEYXBwTWV0YWRhdGEsXG4gIERpc2Nvbm5lY3RPcHRpb25zLFxuICBFQ0lFU1Byb3BzLFxuICBFdmVudFR5cGUsXG4gIEtleUluZm8sXG4gIFJlbW90ZUNvbW11bmljYXRpb24sXG4gIFN0b3JhZ2VNYW5hZ2VyUHJvcHMsXG4gIFRyYWNraW5nRXZlbnRzLFxufSBmcm9tICdAbWV0YW1hc2svc2RrLWNvbW11bmljYXRpb24tbGF5ZXInO1xuaW1wb3J0IHsgTWV0YU1hc2tJbnN0YWxsZXIgfSBmcm9tICcuLi8uLi9QbGF0Zm9ybS9NZXRhTWFza0luc3RhbGxlcic7XG5pbXBvcnQgeyBQbGF0Zm9ybU1hbmFnZXIgfSBmcm9tICcuLi8uLi9QbGF0Zm9ybS9QbGF0ZmZvcm1NYW5hZ2VyJztcbmltcG9ydCB7IE1ldGFNYXNrU0RLIH0gZnJvbSAnLi4vLi4vc2RrJztcbmltcG9ydCB7IFNES0xvZ2dpbmdPcHRpb25zIH0gZnJvbSAnLi4vLi4vdHlwZXMvU0RLTG9nZ2luZ09wdGlvbnMnO1xuaW1wb3J0IEluc3RhbGxNb2RhbCBmcm9tICcuLi8uLi91aS9JbnN0YWxsTW9kYWwvaW5zdGFsbE1vZGFsJztcbmltcG9ydCBQZW5kaW5nTW9kYWwgZnJvbSAnLi4vLi4vdWkvSW5zdGFsbE1vZGFsL3BlbmRpbmdNb2RhbCc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi8uLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgQW5hbHl0aWNzIH0gZnJvbSAnLi4vQW5hbHl0aWNzJztcbmltcG9ydCB7IEV0aGVyZXVtIH0gZnJvbSAnLi4vRXRoZXJldW0nO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZUNvbm5lY3RvciB9IGZyb20gJy4vQ29ubmVjdGlvbkluaXRpYWxpemVyJztcbmltcG9ydCB7IGNsZWFudXBDb25uZWN0b3IgfSBmcm9tICcuL0Nvbm5lY3Rpb25Jbml0aWFsaXplci9jbGVhbnVwQ29ubmVjdG9yJztcbmltcG9ydCB7IHN0YXJ0Q29ubmVjdGlvbiwgU3RhcnRDb25uZWN0aW9uRXh0cmFzIH0gZnJvbSAnLi9Db25uZWN0aW9uTWFuYWdlcic7XG5pbXBvcnQgeyBFdmVudEhhbmRsZXIsIHNldHVwTGlzdGVuZXJzIH0gZnJvbSAnLi9FdmVudExpc3RlbmVycyc7XG5pbXBvcnQgeyBzaG93QWN0aXZlTW9kYWwgfSBmcm9tICcuL01vZGFsTWFuYWdlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVtb3RlQ29ubmVjdGlvblByb3BzIHtcbiAgYW5vbklkOiBzdHJpbmc7XG4gIHRpbWVyPzoge1xuICAgIHJ1bkJhY2tncm91bmRUaW1lcj86IChjYjogKCkgPT4gdm9pZCwgbXM6IG51bWJlcikgPT4gbnVtYmVyO1xuICAgIHN0b3BCYWNrZ3JvdW5kVGltZXI/OiAoKSA9PiB2b2lkO1xuICB9O1xuICBjb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlOiBDb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlO1xuICBkYXBwTWV0YWRhdGE/OiBEYXBwTWV0YWRhdGE7XG4gIF9zb3VyY2U/OiBzdHJpbmc7XG4gIGVuYWJsZUFuYWx5dGljcz86IGJvb2xlYW47XG4gIGFuYWx5dGljczogQW5hbHl0aWNzO1xuICBzZGs6IE1ldGFNYXNrU0RLO1xuICB0cmFuc3BvcnRzPzogc3RyaW5nW107XG4gIHBsYXRmb3JtTWFuYWdlcjogUGxhdGZvcm1NYW5hZ2VyO1xuICBjb21tdW5pY2F0aW9uU2VydmVyVXJsPzogc3RyaW5nO1xuICBlY2llcz86IEVDSUVTUHJvcHM7XG4gIHN0b3JhZ2U/OiBTdG9yYWdlTWFuYWdlclByb3BzO1xuICBsb2dnaW5nPzogU0RLTG9nZ2luZ09wdGlvbnM7XG4gIHByZWZlckRlc2t0b3A/OiBib29sZWFuO1xuICAvLyBQcmV2ZW50IGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuICBnZXRNZXRhTWFza0luc3RhbGxlcjogKCkgPT4gTWV0YU1hc2tJbnN0YWxsZXI7XG4gIGNvbm5lY3RXaXRoRXh0ZW5zaW9uUHJvdmlkZXI/OiAoKSA9PiB2b2lkO1xuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHRoZSAnZGlzcGxheV91cmknIGV2ZW50IG9uIHRoZSBwcm92aWRlciBpbnN0ZWFkLlxuICAgKiBMaXN0ZW4gdG8gdGhpcyBldmVudCB0byBnZXQgdGhlIFFSIGNvZGUgVVJMIGFuZCBjdXN0b21pemUgeW91ciBVSS5cbiAgICogRXhhbXBsZTpcbiAgICogc2RrLmdldFByb3ZpZGVyKCkub24oJ2Rpc3BsYXlfdXJpJywgKHVyaTogc3RyaW5nKSA9PiB7XG4gICAqICAgLy8gVXNlIHRoZSB1cmkgdG8gZGlzcGxheSBhIFFSIGNvZGUgb3IgY3VzdG9taXplIHlvdXIgVUlcbiAgICogfSk7XG4gICAqL1xuICBtb2RhbHM6IHtcbiAgICBvblBlbmRpbmdNb2RhbERpc2Nvbm5lY3Q/OiAoKSA9PiB2b2lkO1xuICAgIGluc3RhbGw/OiAoYXJnczoge1xuICAgICAgbGluazogc3RyaW5nO1xuICAgICAgZGVidWc/OiBib29sZWFuO1xuICAgICAgcHJlZmVyRGVza3RvcD86IGJvb2xlYW47XG4gICAgICBpbnN0YWxsZXI6IE1ldGFNYXNrSW5zdGFsbGVyO1xuICAgICAgdGVybWluYXRlPzogKCkgPT4gdm9pZDtcbiAgICAgIGNvbm5lY3RXaXRoRXh0ZW5zaW9uPzogKCkgPT4gdm9pZDtcbiAgICAgIG9uQW5hbHl0aWNzRXZlbnQ6ICh7XG4gICAgICAgIGV2ZW50LFxuICAgICAgICBwYXJhbXMsXG4gICAgICB9OiB7XG4gICAgICAgIGV2ZW50OiBUcmFja2luZ0V2ZW50cztcbiAgICAgICAgcGFyYW1zPzogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgICB9KSA9PiB2b2lkO1xuICAgIH0pID0+IHtcbiAgICAgIHVubW91bnQ/OiAoc2hvdWxkVGVybWluYXRlPzogYm9vbGVhbikgPT4gdm9pZDtcbiAgICAgIG1vdW50PzogKGxpbms6IHN0cmluZykgPT4gdm9pZDtcbiAgICB9O1xuICAgIG90cD86ICh7XG4gICAgICBkZWJ1ZyxcbiAgICAgIG9uRGlzY29ubmVjdCxcbiAgICB9OiB7XG4gICAgICBkZWJ1Zz86IGJvb2xlYW47XG4gICAgICBvbkRpc2Nvbm5lY3Q/OiAoKSA9PiB2b2lkO1xuICAgIH0pID0+IHtcbiAgICAgIG1vdW50PzogKCkgPT4gdm9pZDtcbiAgICAgIHVwZGF0ZU9UUFZhbHVlPzogKG90cFZhbHVlOiBzdHJpbmcpID0+IHZvaWQ7XG4gICAgICB1bm1vdW50PzogKCkgPT4gdm9pZDtcbiAgICB9O1xuICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlbW90ZUNvbm5lY3Rpb25TdGF0ZSB7XG4gIGNvbm5lY3Rvcj86IFJlbW90ZUNvbW11bmljYXRpb247XG4gIHFyY29kZUxpbms/OiBzdHJpbmc7XG4gIHVzZURlZXBsaW5rPzogYm9vbGVhbjtcbiAgZGV2ZWxvcGVyTW9kZTogYm9vbGVhbjtcbiAgYW5hbHl0aWNzPzogQW5hbHl0aWNzO1xuICBhdXRob3JpemVkOiBib29sZWFuO1xuICByZWNvbm5lY3Rpb246IGJvb2xlYW47XG4gIGRlZXBsaW5rUHJvdG9jb2w6IGJvb2xlYW47XG4gIHByZWZlckRlc2t0b3A/OiBib29sZWFuO1xuICBsaXN0ZW5lcnM6IHsgZXZlbnQ6IEV2ZW50VHlwZTsgaGFuZGxlcjogRXZlbnRIYW5kbGVyIH1bXTtcbiAgY29tbXVuaWNhdGlvbkxheWVyUHJlZmVyZW5jZT86IENvbW11bmljYXRpb25MYXllclByZWZlcmVuY2U7XG4gIHBsYXRmb3JtTWFuYWdlcj86IFBsYXRmb3JtTWFuYWdlcjtcbiAgcGVuZGluZ01vZGFsPzoge1xuICAgIG1vdW50PzogKHByb3BzPzogeyBkaXNwbGF5T1RQPzogYm9vbGVhbiB9KSA9PiB2b2lkO1xuICAgIHVwZGF0ZU9UUFZhbHVlPzogKG90cFZhbHVlOiBzdHJpbmcpID0+IHZvaWQ7XG4gICAgdW5tb3VudD86ICgpID0+IHZvaWQ7XG4gIH07XG5cbiAgaW5zdGFsbE1vZGFsPzoge1xuICAgIHVubW91bnQ/OiAoc2hvdWxkVGVybWluYXRlOiBib29sZWFuKSA9PiB2b2lkO1xuICAgIG1vdW50PzogKGxpbms6IHN0cmluZykgPT4gdm9pZDtcbiAgfTtcbiAgLyoqXG4gICAqIFdhaXQgZm9yIHZhbHVlIGZyb20gbWV0YW1hc2sgbW9iaWxlXG4gICAqL1xuICBvdHBBbnN3ZXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBSZW1vdGVDb25uZWN0aW9uIHtcbiAgcHJpdmF0ZSBvcHRpb25zOiBSZW1vdGVDb25uZWN0aW9uUHJvcHM7XG5cbiAgcHVibGljIHN0YXRlOiBSZW1vdGVDb25uZWN0aW9uU3RhdGUgPSB7XG4gICAgY29ubmVjdG9yOiB1bmRlZmluZWQsXG4gICAgcXJjb2RlTGluazogdW5kZWZpbmVkLFxuICAgIGFuYWx5dGljczogdW5kZWZpbmVkLFxuICAgIGRldmVsb3Blck1vZGU6IGZhbHNlLFxuICAgIGF1dGhvcml6ZWQ6IGZhbHNlLFxuICAgIHJlY29ubmVjdGlvbjogZmFsc2UsXG4gICAgcHJlZmVyRGVza3RvcDogZmFsc2UsXG4gICAgZGVlcGxpbmtQcm90b2NvbDogZmFsc2UsXG4gICAgbGlzdGVuZXJzOiBbXSxcbiAgICBjb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlOiB1bmRlZmluZWQsXG4gICAgcGxhdGZvcm1NYW5hZ2VyOiB1bmRlZmluZWQsXG4gICAgcGVuZGluZ01vZGFsOiB1bmRlZmluZWQsXG4gICAgaW5zdGFsbE1vZGFsOiB1bmRlZmluZWQsXG4gICAgb3RwQW5zd2VyOiB1bmRlZmluZWQsXG4gIH07XG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogUmVtb3RlQ29ubmVjdGlvblByb3BzKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICBjb25zdCBkZXZlbG9wZXJNb2RlID1cbiAgICAgIG9wdGlvbnMubG9nZ2luZz8uZGV2ZWxvcGVyTW9kZSA9PT0gdHJ1ZSB8fCBvcHRpb25zLmxvZ2dpbmc/LnNkayA9PT0gdHJ1ZTtcbiAgICB0aGlzLnN0YXRlLmRldmVsb3Blck1vZGUgPSBkZXZlbG9wZXJNb2RlO1xuICAgIHRoaXMuc3RhdGUuYW5hbHl0aWNzID0gb3B0aW9ucy5hbmFseXRpY3M7XG4gICAgdGhpcy5zdGF0ZS5wcmVmZXJEZXNrdG9wID0gb3B0aW9ucy5wcmVmZXJEZXNrdG9wID8/IGZhbHNlO1xuICAgIHRoaXMuc3RhdGUudXNlRGVlcGxpbmsgPSBvcHRpb25zLnNkay5vcHRpb25zLnVzZURlZXBsaW5rO1xuICAgIHRoaXMuc3RhdGUuY29tbXVuaWNhdGlvbkxheWVyUHJlZmVyZW5jZSA9XG4gICAgICBvcHRpb25zLmNvbW11bmljYXRpb25MYXllclByZWZlcmVuY2U7XG4gICAgdGhpcy5zdGF0ZS5wbGF0Zm9ybU1hbmFnZXIgPSBvcHRpb25zLnBsYXRmb3JtTWFuYWdlcjtcblxuICAgIC8vIFNldCBkZWZhdWx0IG1vZGFscyBpbXBsZW1lbnRhdGlvblxuICAgIC8vIEB0cy1lcnJvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgaWYgKCFvcHRpb25zLm1vZGFscy5pbnN0YWxsKSB7XG4gICAgICAvLyBAdHMtZXJyb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgb3B0aW9ucy5tb2RhbHMuaW5zdGFsbCA9IEluc3RhbGxNb2RhbDtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMubW9kYWxzLm90cCkge1xuICAgICAgb3B0aW9ucy5tb2RhbHMub3RwID0gUGVuZGluZ01vZGFsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIHdpbGwgc3RhcnQgdGhlIGluc3RhbGxlciBvciBwZW5kaW5nIG1vZGFsIGFuZCByZXNvbHZlIG9uY2UgaXQgaXMgZGlzcGxheWVkLlxuICAgKiBJdCBkb2Vzbid0IHdhaXQgZm9yIHRoZSBhY3R1YWwgY29ubmVjdGlvbiB0byBiZSBhdXRob3JpemVkLlxuICAgKi9cbiAgYXN5bmMgc3RhcnRDb25uZWN0aW9uKGV4dHJhcz86IFN0YXJ0Q29ubmVjdGlvbkV4dHJhcyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBzdGFydENvbm5lY3Rpb24odGhpcy5zdGF0ZSwgdGhpcy5vcHRpb25zLCBleHRyYXMpO1xuICB9XG5cbiAgYXN5bmMgaW5pdFJlbW90ZUNvbW11bmljYXRpb24oe1xuICAgIHNka0luc3RhbmNlLFxuICB9OiB7XG4gICAgc2RrSW5zdGFuY2U6IE1ldGFNYXNrU0RLO1xuICB9KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgLy8gZ2V0IGNoYW5uZWwgY29uZmlnXG4gICAgY29uc3QgY2hhbm5lbENvbmZpZyA9XG4gICAgICBhd2FpdCBzZGtJbnN0YW5jZS5vcHRpb25zLnN0b3JhZ2U/LnN0b3JhZ2VNYW5hZ2VyPy5nZXRQZXJzaXN0ZWRDaGFubmVsQ29uZmlnKCk7XG5cbiAgICBpZiAoIXRoaXMub3B0aW9ucy5lY2llcykge1xuICAgICAgY29uc3QgZWNpZXNQcm9wczogRUNJRVNQcm9wcyA9IHtcbiAgICAgICAgcHJpdmF0ZUtleTogY2hhbm5lbENvbmZpZz8ubG9jYWxLZXksXG4gICAgICB9O1xuICAgICAgdGhpcy5vcHRpb25zLmVjaWVzID0gZWNpZXNQcm9wcztcbiAgICB9XG4gICAgaW5pdGlhbGl6ZUNvbm5lY3Rvcih0aGlzLnN0YXRlLCB0aGlzLm9wdGlvbnMpO1xuICAgIGF3YWl0IHRoaXMuZ2V0Q29ubmVjdG9yKCk/LmluaXRGcm9tRGFwcFN0b3JhZ2UoKTtcblxuICAgIHNldHVwTGlzdGVuZXJzKHRoaXMuc3RhdGUsIHRoaXMub3B0aW9ucyk7XG4gIH1cblxuICBzaG93QWN0aXZlTW9kYWwoKSB7XG4gICAgcmV0dXJuIHNob3dBY3RpdmVNb2RhbCh0aGlzLnN0YXRlKTtcbiAgfVxuXG4gIGNsb3NlTW9kYWwoKSB7XG4gICAgdGhpcy5zdGF0ZS5wZW5kaW5nTW9kYWw/LnVubW91bnQ/LigpO1xuICAgIHRoaXMuc3RhdGUuaW5zdGFsbE1vZGFsPy51bm1vdW50Py4oZmFsc2UpO1xuICB9XG5cbiAgZ2V0VW5pdmVyc2FsTGluaygpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUucXJjb2RlTGluaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb25uZWN0aW9uIG5vdCBzdGFydGVkLiBydW4gc3RhcnRDb25uZWN0aW9uKCkgZmlyc3QuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0YXRlLnFyY29kZUxpbms7XG4gIH1cblxuICBnZXRDaGFubmVsQ29uZmlnKCk6IENoYW5uZWxDb25maWcgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmNvbm5lY3Rvcj8uZ2V0Q2hhbm5lbENvbmZpZygpO1xuICB9XG5cbiAgZ2V0S2V5SW5mbygpOiBLZXlJbmZvIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5jb25uZWN0b3I/LmdldEtleUluZm8oKTtcbiAgfVxuXG4gIGdldENvbm5lY3RvcigpIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUuY29ubmVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgcmVtb3RlIGNvbm5lY3RvcmApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5jb25uZWN0b3I7XG4gIH1cblxuICBnZXRQbGF0Zm9ybU1hbmFnZXIoKTogUGxhdGZvcm1NYW5hZ2VyIHtcbiAgICBpZiAoIXRoaXMuc3RhdGUucGxhdGZvcm1NYW5hZ2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsYXRmb3JtTWFuYWdlciBub3QgYXZhaWxhYmxlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RhdGUucGxhdGZvcm1NYW5hZ2VyO1xuICB9XG5cbiAgaXNDb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuY29ubmVjdG9yPy5pc1JlYWR5KCkgfHwgZmFsc2U7XG4gIH1cblxuICBpc0F1dGhvcml6ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUuY29ubmVjdG9yPy5pc0F1dGhvcml6ZWQoKSB8fCBmYWxzZTtcbiAgfVxuXG4gIGlzUGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmNvbm5lY3Rvcj8uaXNQYXVzZWQoKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3Qob3B0aW9ucz86IERpc2Nvbm5lY3RPcHRpb25zKTogdm9pZCB7XG4gICAgbG9nZ2VyKGBbUmVtb3RlQ29ubmVjdGlvbjogZGlzY29ubmVjdCgpXWAsIG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnM/LnRlcm1pbmF0ZSkge1xuICAgICAgRXRoZXJldW0uZ2V0UHJvdmlkZXIoKS5oYW5kbGVEaXNjb25uZWN0KHtcbiAgICAgICAgdGVybWluYXRlOiB0cnVlLFxuICAgICAgfSk7XG4gICAgICB0aGlzLnN0YXRlLnBlbmRpbmdNb2RhbD8udW5tb3VudD8uKCk7XG4gICAgICB0aGlzLnN0YXRlLm90cEFuc3dlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5jb25uZWN0b3I/LmRpc2Nvbm5lY3Qob3B0aW9ucyk7XG4gICAgY2xlYW51cENvbm5lY3Rvcih0aGlzLnN0YXRlKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IFJlbW90ZUNvbm5lY3Rpb25TdGF0ZSB9IGZyb20gJy4uL1JlbW90ZUNvbm5lY3Rpb24nO1xuXG4vKipcbiAqIERpc3BsYXlzIHRoZSByZWxldmFudCBhY3RpdmUgbW9kYWwgYmFzZWQgb24gdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZS5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgQ3VycmVudCBzdGF0ZSBvZiB0aGUgUmVtb3RlQ29ubmVjdGlvbiBjbGFzcyBpbnN0YW5jZS5cbiAqIEByZXR1cm5zIHZvaWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3dBY3RpdmVNb2RhbChzdGF0ZTogUmVtb3RlQ29ubmVjdGlvblN0YXRlKTogdm9pZCB7XG4gIGlmIChzdGF0ZS5hdXRob3JpemVkKSB7XG4gICAgbG9nZ2VyKGBbUmVtb3RlQ29ubmVjdGlvbjogc2hvd0FjdGl2ZU1vZGFsKCldIGFscmVhZHkgYXV0aG9yaXplZGApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5wZW5kaW5nTW9kYWwpIHtcbiAgICAvLyBvbmx5IGRpc3BsYXkgdGhlIG1vZGFsIGlmIHRoZSBjb25uZWN0aW9uIGlzIG5vdCBhdXRob3JpemVkXG4gICAgc3RhdGUucGVuZGluZ01vZGFsLm1vdW50Py4oKTtcbiAgfSBlbHNlIGlmIChzdGF0ZS5pbnN0YWxsTW9kYWwpIHtcbiAgICBzdGF0ZS5pbnN0YWxsTW9kYWwubW91bnQ/LihzdGF0ZS5xcmNvZGVMaW5rIHx8ICcnKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IGNsZWFudXBMaXN0ZW5lcnMgfSBmcm9tICcuLi9FdmVudExpc3RlbmVycy9jbGVhbnVwTGlzdGVuZXJzJztcbmltcG9ydCB7IFJlbW90ZUNvbm5lY3Rpb25TdGF0ZSB9IGZyb20gJy4uL1JlbW90ZUNvbm5lY3Rpb24nO1xuXG5leHBvcnQgZnVuY3Rpb24gY2xlYW51cENvbm5lY3RvcihzdGF0ZTogUmVtb3RlQ29ubmVjdGlvblN0YXRlKSB7XG4gIGxvZ2dlcihgW1JlbW90ZUNvbm5lY3Rpb246IGNsZWFudXBDb25uZWN0b3IoKV0gY2xlYW5pbmcgdXAgY29ubmVjdG9yYCk7XG5cbiAgaWYgKHN0YXRlLmNvbm5lY3Rvcikge1xuICAgIGNsZWFudXBMaXN0ZW5lcnMoc3RhdGUpO1xuICAgIHN0YXRlLmNvbm5lY3Rvci5kaXNjb25uZWN0KHsgdGVybWluYXRlOiB0cnVlIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgbG9nZ2VyKFxuICAgICAgICBgW1JlbW90ZUNvbm5lY3Rpb246IGNsZWFudXBDb25uZWN0b3IoKV0gZXJyb3IgZGlzY29ubmVjdGluZyBjb25uZWN0b3JgLFxuICAgICAgICBlcnJvcixcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IENvbW11bmljYXRpb25MYXllclByZWZlcmVuY2UgfSBmcm9tICdAbWV0YW1hc2svc2RrLWNvbW11bmljYXRpb24tbGF5ZXInO1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCB7IE1ldGFNYXNrU0RLIH0gZnJvbSAnLi4vLi4vLi4vc2RrJztcbmltcG9ydCB7IE1ldGFNYXNrU0RLRXZlbnQgfSBmcm9tICcuLi8uLi8uLi90eXBlcy9NZXRhTWFza1NES0V2ZW50cyc7XG5pbXBvcnQgeyBQUk9WSURFUl9VUERBVEVfVFlQRSB9IGZyb20gJy4uLy4uLy4uL3R5cGVzL1Byb3ZpZGVyVXBkYXRlVHlwZSc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgaGFuZGxlQXV0b0FuZEV4dGVuc2lvbkNvbm5lY3Rpb25zIH0gZnJvbSAnLi9oYW5kbGVBdXRvQW5kRXh0ZW5zaW9uQ29ubmVjdGlvbnMnO1xuaW1wb3J0IHsgaW5pdGlhbGl6ZVByb3ZpZGVyQW5kRXZlbnRMaXN0ZW5lcnMgfSBmcm9tICcuL2luaXRpYWxpemVQcm92aWRlckFuZEV2ZW50TGlzdGVuZXJzJztcbmltcG9ydCB7IHNldHVwQW5hbHl0aWNzIH0gZnJvbSAnLi9zZXR1cEFuYWx5dGljcyc7XG5pbXBvcnQgeyBzZXR1cEFuYWx5dGljc1YyIH0gZnJvbSAnLi9zZXR1cEFuYWx5dGljc1YyJztcbmltcG9ydCB7IHNldHVwRGFwcE1ldGFkYXRhIH0gZnJvbSAnLi9zZXR1cERhcHBNZXRhZGF0YSc7XG5pbXBvcnQgeyBzZXR1cEV4dGVuc2lvblByZWZlcmVuY2VzIH0gZnJvbSAnLi9zZXR1cEV4dGVuc2lvblByZWZlcmVuY2VzJztcbmltcG9ydCB7IHNldHVwSW5mdXJhUHJvdmlkZXIgfSBmcm9tICcuL3NldHVwSW5mdXJhUHJvdmlkZXInO1xuaW1wb3J0IHsgc2V0dXBQbGF0Zm9ybU1hbmFnZXIgfSBmcm9tICcuL3NldHVwUGxhdGZvcm1NYW5hZ2VyJztcbmltcG9ydCB7IHNldHVwUmVhZE9ubHlSUENQcm92aWRlcnMgfSBmcm9tICcuL3NldHVwUmVhZE9ubHlSUENQcm92aWRlcnMnO1xuaW1wb3J0IHsgc2V0dXBSZW1vdGVDb25uZWN0aW9uQW5kSW5zdGFsbGVyIH0gZnJvbSAnLi9zZXR1cFJlbW90ZUNvbm5lY3Rpb25BbmRJbnN0YWxsZXInO1xuaW1wb3J0IHsgc2V0dXBTdG9yYWdlTWFuYWdlciB9IGZyb20gJy4vc2V0dXBTdG9yYWdlJztcblxuLyoqXG4gKiBQZXJmb3JtcyB0aGUgY29tcGxldGUgaW5pdGlhbGl6YXRpb24gb2YgdGhlIE1ldGFNYXNrIFNESyBpbnN0YW5jZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHNldHMgdXAgdGhlIFNESyB3aXRoIGEgc2VyaWVzIG9mIGFzeW5jaHJvbm91cyB0YXNrcywgaW5jbHVkaW5nOlxuICogLSBTZXR0aW5nIHVwIGRlZmF1bHQgb3B0aW9ucyBhbmQgbG9nZ2luZyBwcmVmZXJlbmNlcy5cbiAqIC0gQ29uZmlndXJpbmcgdGhlIHBsYXRmb3JtIG1hbmFnZXIuXG4gKiAtIEluaXRpYWxpemluZyBhbmFseXRpY3MuXG4gKiAtIFNldHRpbmcgdXAgc3RvcmFnZSBtYW5hZ2VyLlxuICogLSBDb25maWd1cmluZyBEYXBwIG1ldGFkYXRhLlxuICogLSBTZXR0aW5nIHVwIEluZnVyYSBwcm92aWRlci5cbiAqIC0gU2V0dGluZyB1cCByZWFkLW9ubHkgUlBDIHByb3ZpZGVycy5cbiAqIC0gSGFuZGxpbmcgZXh0ZW5zaW9uIHByZWZlcmVuY2VzLlxuICogLSBTZXR0aW5nIHVwIHJlbW90ZSBjb25uZWN0aW9ucyBhbmQgaW5zdGFsbGVyLlxuICogLSBJbml0aWFsaXppbmcgdGhlIHByb3ZpZGVyIGFuZCBldmVudCBsaXN0ZW5lcnMuXG4gKiAtIEhhbmRsaW5nIGF1dG9tYXRpYyBhbmQgZXh0ZW5zaW9uLWJhc2VkIGNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSBpbnN0YW5jZSBUaGUgTWV0YU1hc2tTREsgaW5zdGFuY2UgdG8gYmUgZnVsbHkgaW5pdGlhbGl6ZWQuXG4gKiBAcmV0dXJucyB2b2lkXG4gKiBAYXN5bmNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBlcmZvcm1TREtJbml0aWFsaXphdGlvbihpbnN0YW5jZTogTWV0YU1hc2tTREspIHtcbiAgY29uc3QgeyBvcHRpb25zIH0gPSBpbnN0YW5jZTtcblxuICAvLyBTZXQgZGVmYXVsdCBvcHRpb25zIGlmIG5vdCBwcm92aWRlZFxuICBvcHRpb25zLmxvZ2dpbmcgPSBvcHRpb25zLmxvZ2dpbmcgPz8ge307XG4gIG9wdGlvbnMuY29tbXVuaWNhdGlvbkxheWVyUHJlZmVyZW5jZSA9XG4gICAgb3B0aW9ucy5jb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlID8/IENvbW11bmljYXRpb25MYXllclByZWZlcmVuY2UuU09DS0VUO1xuXG4gIC8vIFRPRE86IGl0IG5lZWQgdG8gYmUgcmVtb3ZlZCBhbmQgaXQgd2FzIGFkZGVkIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgLy8gQHRzLWlnbm9yZVxuICBpZiAob3B0aW9ucy5lbmFibGVEZWJ1ZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZGVidWcuZW5hYmxlKCdNTV9TREsnKTtcbiAgICBjb25zb2xlLndhcm4oJ2VuYWJsZURlYnVnIGlzIHJlbW92ZWQuIFBsZWFzZSB1c2UgZW5hYmxlQW5hbHl0aWNzIGluc3RlYWQuJyk7XG4gIH1cblxuICBvcHRpb25zLmVuYWJsZUFuYWx5dGljcyA9IG9wdGlvbnMuZW5hYmxlQW5hbHl0aWNzID8/IHRydWU7XG4gIG9wdGlvbnMuaW5qZWN0UHJvdmlkZXIgPSBvcHRpb25zLmluamVjdFByb3ZpZGVyID8/IHRydWU7XG4gIG9wdGlvbnMuc2hvdWxkU2hpbVdlYjMgPSBvcHRpb25zLnNob3VsZFNoaW1XZWIzID8/IHRydWU7XG4gIG9wdGlvbnMuZXh0ZW5zaW9uT25seSA9IG9wdGlvbnMuZXh0ZW5zaW9uT25seSA/PyB0cnVlO1xuICBvcHRpb25zLnVzZURlZXBsaW5rID0gb3B0aW9ucy51c2VEZWVwbGluayA/PyB0cnVlO1xuICBvcHRpb25zLnN0b3JhZ2UgPSBvcHRpb25zLnN0b3JhZ2UgPz8ge1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gIH07XG5cbiAgaWYgKG9wdGlvbnMuaGVhZGxlc3MpIHtcbiAgICBkZWJ1ZygnW01ldGFNYXNrU0RLOiBwZXJmb3JtU0RLSW5pdGlhbGl6YXRpb24oKV0gaGVhZGxlc3MgbW9kZSBlbmFibGVkJyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgIGNvbnN0IG5vb3AgPSAoKSA9PiB7fTtcbiAgICBjb25zdCBfbW9kYWxzID0ge1xuICAgICAgaW5zdGFsbDogKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1vdW50OiBub29wLFxuICAgICAgICAgIHVubW91bnQ6IG5vb3AsXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH07XG4gICAgY29uc3QgX3VpID0ge1xuICAgICAgaW5zdGFsbGVyOiBub29wLFxuICAgIH07XG4gICAgb3B0aW9ucy5tb2RhbHMgPSBfbW9kYWxzO1xuICAgIG9wdGlvbnMudWkgPSBfdWk7XG4gIH1cblxuICBjb25zdCBkZXZlbG9wZXJNb2RlID0gb3B0aW9ucy5sb2dnaW5nPy5kZXZlbG9wZXJNb2RlID09PSB0cnVlO1xuICBpbnN0YW5jZS5kZWJ1ZyA9IG9wdGlvbnMubG9nZ2luZz8uc2RrIHx8IGRldmVsb3Blck1vZGU7XG5cbiAgbG9nZ2VyKCdbTWV0YU1hc2tTREs6IHBlcmZvcm1TREtJbml0aWFsaXphdGlvbigpXSBvcHRpb25zJywgaW5zdGFuY2Uub3B0aW9ucyk7XG5cbiAgLy8gTWFrZSBzdXJlIHRvIGVuYWJsZSBhbGwgbG9ncyBpZiBkZXZlbG9wZXIgbW9kZSBpcyBvblxuICBjb25zdCBydW50aW1lTG9nZ2luZyA9IHsgLi4ub3B0aW9ucy5sb2dnaW5nIH07XG5cbiAgaWYgKGRldmVsb3Blck1vZGUpIHtcbiAgICBydW50aW1lTG9nZ2luZy5zZGsgPSB0cnVlO1xuICAgIHJ1bnRpbWVMb2dnaW5nLmVjaWVzTGF5ZXIgPSB0cnVlO1xuICAgIHJ1bnRpbWVMb2dnaW5nLmtleUV4Y2hhbmdlTGF5ZXIgPSB0cnVlO1xuICAgIHJ1bnRpbWVMb2dnaW5nLnJlbW90ZUxheWVyID0gdHJ1ZTtcbiAgICBydW50aW1lTG9nZ2luZy5zZXJ2aWNlTGF5ZXIgPSB0cnVlO1xuICAgIHJ1bnRpbWVMb2dnaW5nLnBsYWludGV4dCA9IHRydWU7XG4gIH1cblxuICBhd2FpdCBzZXR1cFBsYXRmb3JtTWFuYWdlcihpbnN0YW5jZSk7XG5cbiAgYXdhaXQgc2V0dXBBbmFseXRpY3MoaW5zdGFuY2UpO1xuXG4gIGF3YWl0IHNldHVwQW5hbHl0aWNzVjIoaW5zdGFuY2UpO1xuXG4gIGF3YWl0IHNldHVwU3RvcmFnZU1hbmFnZXIoaW5zdGFuY2UpO1xuXG4gIGF3YWl0IHNldHVwRGFwcE1ldGFkYXRhKGluc3RhbmNlKTtcblxuICBhd2FpdCBzZXR1cEluZnVyYVByb3ZpZGVyKGluc3RhbmNlKTtcblxuICBhd2FpdCBzZXR1cFJlYWRPbmx5UlBDUHJvdmlkZXJzKGluc3RhbmNlKTtcblxuICBjb25zdCB7IG1ldGFtYXNrQnJvd3NlckV4dGVuc2lvbiwgcHJlZmVyRXh0ZW5zaW9uLCBzaG91bGRSZXR1cm4gfSA9XG4gICAgYXdhaXQgc2V0dXBFeHRlbnNpb25QcmVmZXJlbmNlcyhpbnN0YW5jZSk7XG5cbiAgaWYgKHNob3VsZFJldHVybikge1xuICAgIGxvZ2dlcihcbiAgICAgICdbTWV0YU1hc2tTREs6IHBlcmZvcm1TREtJbml0aWFsaXphdGlvbigpXSBzaG91bGRSZXR1cm49dHJ1ZSAtLS0gcHJldmVudCBzZGsgaW5pdGlhbGl6YXRpb24nLFxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgYXdhaXQgc2V0dXBSZW1vdGVDb25uZWN0aW9uQW5kSW5zdGFsbGVyKGluc3RhbmNlLCBtZXRhbWFza0Jyb3dzZXJFeHRlbnNpb24pO1xuXG4gIC8vIGluaXRpYWxpemUgbW9iaWxlIHByb3ZpZGVyIGFuZCBldmVudCBsaXN0ZW5lcnNcbiAgYXdhaXQgaW5pdGlhbGl6ZVByb3ZpZGVyQW5kRXZlbnRMaXN0ZW5lcnMoaW5zdGFuY2UpO1xuICBhd2FpdCBoYW5kbGVBdXRvQW5kRXh0ZW5zaW9uQ29ubmVjdGlvbnMoaW5zdGFuY2UsIHByZWZlckV4dGVuc2lvbik7XG5cbiAgdHJ5IHtcbiAgICBhd2FpdCBpbnN0YW5jZS5yZW1vdGVDb25uZWN0aW9uPy5zdGFydENvbm5lY3Rpb24oeyBpbml0aWFsQ2hlY2s6IHRydWUgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBgW01ldGFNYXNrU0RLOiBzZXR1cFJlbW90ZUNvbm5lY3Rpb25BbmRJbnN0YWxsZXIoKV0gRXJyb3Igd2hpbGUgY2hlY2tpbmcgaW5zdGFsbGF0aW9uYCxcbiAgICAgIGVycixcbiAgICApO1xuICB9XG5cbiAgaW5zdGFuY2UuZW1pdChcbiAgICBNZXRhTWFza1NES0V2ZW50LlByb3ZpZGVyVXBkYXRlLFxuICAgIFBST1ZJREVSX1VQREFURV9UWVBFLklOSVRJQUxJWkVELFxuICApO1xufVxuIiwiaW1wb3J0IHsgUGxhdGZvcm1NYW5hZ2VyIH0gZnJvbSAnLi4vLi4vLi4vUGxhdGZvcm0vUGxhdGZmb3JtTWFuYWdlcic7XG5pbXBvcnQgeyBNZXRhTWFza1NESyB9IGZyb20gJy4uLy4uLy4uL3Nkayc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW5kIHNldHMgdXAgdGhlIFBsYXRmb3JtTWFuYWdlciBmb3IgdGhlIE1ldGFNYXNrU0RLIGluc3RhbmNlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gY29uc3RydWN0cyBhIG5ldyBQbGF0Zm9ybU1hbmFnZXIgd2l0aCB2YXJpb3VzIHNldHRpbmdzLCBzdWNoIGFzXG4gKiBkZWVwIGxpbmtpbmcgcHJlZmVyZW5jZXMsIHdha2UgbG9jayBzdGF0dXMsIGFuZCBkZWJ1ZyBtb2RlLCBiYXNlZCBvbiB0aGUgcHJvdmlkZWRcbiAqIG9wdGlvbnMgd2l0aGluIHRoZSBNZXRhTWFza1NESyBpbnN0YW5jZS4gVGhlIGluaXRpYWxpemVkIFBsYXRmb3JtTWFuYWdlciBpcyB0aGVuXG4gKiBzdG9yZWQgYmFjayBpbnRvIHRoZSBNZXRhTWFza1NESyBpbnN0YW5jZSBmb3IgZnVydGhlciB1c2UuXG4gKlxuICogQHBhcmFtIGluc3RhbmNlIFRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSBNZXRhTWFza1NESywgd2hpY2ggY29udGFpbnMgdXNlci1kZWZpbmVkIG9yIGRlZmF1bHQgb3B0aW9ucy5cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBQbGF0Zm9ybU1hbmFnZXIgaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IHNldCB1cC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldHVwUGxhdGZvcm1NYW5hZ2VyKGluc3RhbmNlOiBNZXRhTWFza1NESykge1xuICBjb25zdCB7IG9wdGlvbnMgfSA9IGluc3RhbmNlO1xuXG4gIGluc3RhbmNlLnBsYXRmb3JtTWFuYWdlciA9IG5ldyBQbGF0Zm9ybU1hbmFnZXIoe1xuICAgIHVzZURlZXBMaW5rOiBvcHRpb25zLnVzZURlZXBsaW5rID8/IGZhbHNlLFxuICAgIHByZWZlcnJlZE9wZW5MaW5rOiBvcHRpb25zLm9wZW5EZWVwbGluayxcbiAgICBkZWJ1ZzogaW5zdGFuY2UuZGVidWcsXG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgREVGQVVMVF9TRVJWRVJfVVJMIH0gZnJvbSAnQG1ldGFtYXNrL3Nkay1jb21tdW5pY2F0aW9uLWxheWVyJztcbmltcG9ydCB7IEFuYWx5dGljcyB9IGZyb20gJy4uLy4uL0FuYWx5dGljcyc7XG5pbXBvcnQgeyBNZXRhTWFza1NESyB9IGZyb20gJy4uLy4uLy4uL3Nkayc7XG5cbi8qKlxuICogU2V0cyB1cCB0aGUgYW5hbHl0aWNzIGluc3RhbmNlIGZvciB0aGUgTWV0YU1hc2sgU0RLLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaW5pdGlhbGl6ZXMgYW4gQW5hbHl0aWNzIG9iamVjdCBhbmQgYXR0YWNoZXMgaXQgdG8gdGhlIE1ldGFNYXNrIFNESyBpbnN0YW5jZS5cbiAqIFRoZSBhbmFseXRpY3Mgb2JqZWN0IGlzIGNvbmZpZ3VyZWQgYmFzZWQgb24gdmFyaW91cyBvcHRpb25zIGxpa2UgdGhlIHNlcnZlciBVUkwsIGRlYnVnIHNldHRpbmdzLCBhbmQgRGFwcCBtZXRhZGF0YS5cbiAqXG4gKiBAcGFyYW0gaW5zdGFuY2UgVGhlIE1ldGFNYXNrU0RLIGluc3RhbmNlIGZvciB3aGljaCBhbmFseXRpY3Mgd2lsbCBiZSBzZXQgdXAuXG4gKiBAcmV0dXJucyB2b2lkXG4gKiBAYXN5bmNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldHVwQW5hbHl0aWNzKGluc3RhbmNlOiBNZXRhTWFza1NESykge1xuICBjb25zdCB7IG9wdGlvbnMgfSA9IGluc3RhbmNlO1xuXG4gIGNvbnN0IHBsYXRmb3JtVHlwZSA9IGluc3RhbmNlLnBsYXRmb3JtTWFuYWdlcj8uZ2V0UGxhdGZvcm1UeXBlKCk7XG5cbiAgaW5zdGFuY2UuYW5hbHl0aWNzID0gbmV3IEFuYWx5dGljcyh7XG4gICAgc2VydmVyVXJsOiBvcHRpb25zLmNvbW11bmljYXRpb25TZXJ2ZXJVcmwgPz8gREVGQVVMVF9TRVJWRVJfVVJMLFxuICAgIGVuYWJsZWQ6IG9wdGlvbnMuZW5hYmxlQW5hbHl0aWNzLFxuICAgIG9yaWdpbmF0b3JJbmZvOiB7XG4gICAgICB1cmw6IG9wdGlvbnMuZGFwcE1ldGFkYXRhLnVybCA/PyAnJyxcbiAgICAgIHRpdGxlOiBvcHRpb25zLmRhcHBNZXRhZGF0YS5uYW1lID8/ICcnLFxuICAgICAgZGFwcElkOiBpbnN0YW5jZS5nZXREYXBwSWQoKSxcbiAgICAgIHBsYXRmb3JtOiBwbGF0Zm9ybVR5cGUgPz8gJycsXG4gICAgICBzb3VyY2U6IG9wdGlvbnMuX3NvdXJjZSA/PyAnJyxcbiAgICAgIGFub25JZDogJycsXG4gICAgfSxcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBhbmFseXRpY3MgfSBmcm9tICdAbWV0YW1hc2svc2RrLWFuYWx5dGljcyc7XG5pbXBvcnQgeyBNZXRhTWFza1NESyB9IGZyb20gJy4uLy4uLy4uL3Nkayc7XG5cbi8qKlxuICogU2V0cyB1cCB0aGUgYW5hbHl0aWNzIGluc3RhbmNlIGZvciB0aGUgTWV0YU1hc2sgU0RLLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZW5hYmxlcyB0aGUgZ2xvYmFsIGFuYWx5dGljcyBjbGllbnQgYW5kIHNldHMgdGhlIGdsb2JhbCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSBpbnN0YW5jZSBUaGUgTWV0YU1hc2tTREsgaW5zdGFuY2UgZm9yIHdoaWNoIGFuYWx5dGljcyB3aWxsIGJlIHNldCB1cC5cbiAqIEByZXR1cm5zIHZvaWRcbiAqIEBhc3luY1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0dXBBbmFseXRpY3NWMihpbnN0YW5jZTogTWV0YU1hc2tTREspIHtcbiAgaWYgKCFpbnN0YW5jZS5vcHRpb25zLmVuYWJsZUFuYWx5dGljcykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChcbiAgICAhaW5zdGFuY2UucGxhdGZvcm1NYW5hZ2VyPy5pc0Jyb3dzZXIoKSAmJlxuICAgICFpbnN0YW5jZS5wbGF0Zm9ybU1hbmFnZXI/LmlzUmVhY3ROYXRpdmUoKVxuICApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB2ZXJzaW9uID0gaW5zdGFuY2UuZ2V0VmVyc2lvbigpO1xuICBjb25zdCBkYXBwSWQgPSBpbnN0YW5jZS5nZXREYXBwSWQoKTtcbiAgY29uc3QgYW5vbklkID0gYXdhaXQgaW5zdGFuY2UuZ2V0QW5vbklkKCk7XG4gIGNvbnN0IHBsYXRmb3JtID0gaW5zdGFuY2UucGxhdGZvcm1NYW5hZ2VyPy5nZXRQbGF0Zm9ybVR5cGUoKSBhcyBzdHJpbmc7XG4gIGNvbnN0IGludGVncmF0aW9uVHlwZSA9IGluc3RhbmNlLm9wdGlvbnMuX3NvdXJjZSBhcyBzdHJpbmc7XG5cbiAgYW5hbHl0aWNzLnNldEdsb2JhbFByb3BlcnR5KCdzZGtfdmVyc2lvbicsIHZlcnNpb24pO1xuICBhbmFseXRpY3Muc2V0R2xvYmFsUHJvcGVydHkoJ2RhcHBfaWQnLCBkYXBwSWQpO1xuICBhbmFseXRpY3Muc2V0R2xvYmFsUHJvcGVydHkoJ2Fub25faWQnLCBhbm9uSWQpO1xuICBhbmFseXRpY3Muc2V0R2xvYmFsUHJvcGVydHkoJ3BsYXRmb3JtJywgcGxhdGZvcm0pO1xuICBhbmFseXRpY3Muc2V0R2xvYmFsUHJvcGVydHkoJ2ludGVncmF0aW9uX3R5cGUnLCBpbnRlZ3JhdGlvblR5cGUpO1xuXG4gIGFuYWx5dGljcy5lbmFibGUoKTtcblxuICBhbmFseXRpY3MudHJhY2soJ3Nka19pbml0aWFsaXplZCcsIHt9KTtcbn1cbiIsImltcG9ydCB7IE1ldGFNYXNrU0RLIH0gZnJvbSAnLi4vLi4vLi4vc2RrJztcbmltcG9ydCB7IGdldFN0b3JhZ2VNYW5hZ2VyIH0gZnJvbSAnLi4vLi4vLi4vc3RvcmFnZS1tYW5hZ2VyL2dldFN0b3JhZ2VNYW5hZ2VyJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbmQgc2V0cyB1cCB0aGUgc3RvcmFnZSBtYW5hZ2VyIGZvciB0aGUgTWV0YU1hc2tTREsgaW5zdGFuY2UuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjaGVja3MgaWYgdGhlIHN0b3JhZ2Ugb3B0aW9uIGlzIGVuYWJsZWQgaW4gdGhlIFNESyBpbnN0YW5jZS4gSWYgZW5hYmxlZCwgaXQgdXNlcyB0aGUgYGdldFN0b3JhZ2VNYW5hZ2VyYFxuICogZnVuY3Rpb24gdG8gb2J0YWluIGFuIGluc3RhbmNlIG9mIHRoZSBzdG9yYWdlIG1hbmFnZXIgY29uZmlndXJlZCB3aXRoIHRoZSBvcHRpb25zIHByb3ZpZGVkIHdpdGhpbiB0aGUgTWV0YU1hc2tTREsgaW5zdGFuY2UuXG4gKiBUaGlzIHN0b3JhZ2UgbWFuYWdlciBpcyB0aGVuIHN0b3JlZCBiYWNrIGludG8gdGhlIG9wdGlvbnMgZm9yIGxhdGVyIHVzZS5cbiAqXG4gKiBAcGFyYW0gaW5zdGFuY2UgVGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgdGhlIE1ldGFNYXNrU0RLLCB3aGljaCBjb250YWlucyB1c2VyLWRlZmluZWQgb3IgZGVmYXVsdCBvcHRpb25zLlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHN0b3JhZ2UgbWFuYWdlciBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgc2V0IHVwLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0dXBTdG9yYWdlTWFuYWdlcihpbnN0YW5jZTogTWV0YU1hc2tTREspIHtcbiAgY29uc3QgeyBvcHRpb25zIH0gPSBpbnN0YW5jZTtcblxuICBpZiAob3B0aW9ucy5zdG9yYWdlPy5lbmFibGVkID09PSB0cnVlICYmICFvcHRpb25zLnN0b3JhZ2Uuc3RvcmFnZU1hbmFnZXIpIHtcbiAgICBvcHRpb25zLnN0b3JhZ2Uuc3RvcmFnZU1hbmFnZXIgPSBhd2FpdCBnZXRTdG9yYWdlTWFuYWdlcihvcHRpb25zLnN0b3JhZ2UpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBUcmFja2luZ0V2ZW50cyB9IGZyb20gJ0BtZXRhbWFzay9zZGstY29tbXVuaWNhdGlvbi1sYXllcic7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgU0RLUHJvdmlkZXIgfSBmcm9tICcuLi8uLi8uLi9wcm92aWRlci9TREtQcm92aWRlcic7XG5pbXBvcnQge1xuICBFWFRFTlNJT05fRVZFTlRTLFxuICBSUENfTUVUSE9EUyxcbiAgU1RPUkFHRV9QUk9WSURFUl9UWVBFLFxufSBmcm9tICcuLi8uLi8uLi9jb25maWcnO1xuaW1wb3J0IHsgTWV0YU1hc2tTREsgfSBmcm9tICcuLi8uLi8uLi9zZGsnO1xuaW1wb3J0IHsgZ2V0QnJvd3NlckV4dGVuc2lvbiB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2dldC1icm93c2VyLWV4dGVuc2lvbic7XG5pbXBvcnQgeyBFdGhlcmV1bSB9IGZyb20gJy4uLy4uL0V0aGVyZXVtJztcbmltcG9ydCB7IHdyYXBFeHRlbnNpb25Qcm92aWRlciB9IGZyb20gJy4uLy4uLy4uL3Byb3ZpZGVyL3dyYXBFeHRlbnNpb25Qcm92aWRlcic7XG5cbi8qKlxuICogU2V0cyB1cCB0aGUgZXh0ZW5zaW9uIHByZWZlcmVuY2VzIGZvciB0aGUgTWV0YU1hc2sgU0RLIGluc3RhbmNlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gaWRlbnRpZnkgaWYgdGhlIE1ldGFNYXNrIGV4dGVuc2lvbiBpcyBpbnN0YWxsZWQgYW5kIGFjdGl2ZSBpbiB0aGUgYnJvd3Nlci5cbiAqIElmIHRoZSBleHRlbnNpb24gaXMgZm91bmQsIHRoZSByZWxldmFudCBNZXRhTWFzayBTREsgaW5zdGFuY2UgcHJvcGVydGllcyBhcmUgdXBkYXRlZCBhY2NvcmRpbmdseS5cbiAqIFRoZSBmdW5jdGlvbiBhbHNvIGNoZWNrcyBpZiB0aGUgU0RLIGlzIHJ1bm5pbmcgaW4gTWV0YU1hc2sncyBpbi1hcHAgYnJvd3NlciBvbiBtb2JpbGUgZGV2aWNlcy5cbiAqIEJhc2VkIG9uIHRoZXNlIGNoZWNrcywgdGhlIGZ1bmN0aW9uIHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgd2hldGhlciB0aGVcbiAqIGV4dGVuc2lvbiBpcyBwcmVmZXJyZWQsIHdoZXRoZXIgdGhlIGluaXRpYWxpemF0aW9uIHByb2Nlc3Mgc2hvdWxkIHJldHVybiBlYXJseSwgYW5kIHRoZSBkZXRlY3RlZFxuICogTWV0YU1hc2sgYnJvd3NlciBleHRlbnNpb24uXG4gKlxuICogQHBhcmFtIHtNZXRhTWFza1NES30gaW5zdGFuY2UgLSBUaGUgTWV0YU1hc2tTREsgaW5zdGFuY2UgZm9yIHdoaWNoIGV4dGVuc2lvbiBwcmVmZXJlbmNlcyB3aWxsIGJlIHNldCB1cC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqICAgLSBwcmVmZXJFeHRlbnNpb246IEJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgZXh0ZW5zaW9uIGlzIHByZWZlcnJlZC5cbiAqICAgLSBzaG91bGRSZXR1cm46IEJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgaW5pdGlhbGl6YXRpb24gcHJvY2VzcyBzaG91bGQgcmV0dXJuIGVhcmx5LlxuICogICAtIG1ldGFtYXNrQnJvd3NlckV4dGVuc2lvbjogVGhlIGRldGVjdGVkIE1ldGFNYXNrIGJyb3dzZXIgZXh0ZW5zaW9uLCBpZiBhbnkuXG4gKiBAYXN5bmNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldHVwRXh0ZW5zaW9uUHJlZmVyZW5jZXMoaW5zdGFuY2U6IE1ldGFNYXNrU0RLKSB7XG4gIGNvbnN0IHsgb3B0aW9ucyB9ID0gaW5zdGFuY2U7XG5cbiAgbGV0IG1ldGFtYXNrQnJvd3NlckV4dGVuc2lvbjtcbiAgbGV0IHByZWZlckV4dGVuc2lvbiA9IGZhbHNlO1xuICBsZXQgc2hvdWxkUmV0dXJuID0gZmFsc2U7XG5cbiAgaWYgKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgd2luZG93LmV0aGVyZXVtICYmXG4gICAgIWluc3RhbmNlLnBsYXRmb3JtTWFuYWdlcj8uaXNNZXRhTWFza01vYmlsZVdlYlZpZXcoKVxuICApIHtcbiAgICBwcmVmZXJFeHRlbnNpb24gPVxuICAgICAgbG9jYWxTdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9QUk9WSURFUl9UWVBFKSA9PT0gJ2V4dGVuc2lvbic7XG5cbiAgICB0cnkge1xuICAgICAgbWV0YW1hc2tCcm93c2VyRXh0ZW5zaW9uID0gYXdhaXQgZ2V0QnJvd3NlckV4dGVuc2lvbih7XG4gICAgICAgIG11c3RCZU1ldGFNYXNrOiB0cnVlLFxuICAgICAgICBzZGtJbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICB9KTtcblxuICAgICAgd2luZG93LmV4dGVuc2lvbiA9IG1ldGFtYXNrQnJvd3NlckV4dGVuc2lvbjtcblxuICAgICAgLy8gUHJvcGFnYXRlIGJyb3dzZXIgZXh0ZW5zaW9uIGV2ZW50cyBvbnRvIHRoZSBtYWluIHByb3ZpZGVyIHNpbmNlIHNvbWUgY2xpZW50cyBvbmx5IHN1YnNjcmliZSB0byB0aGUgbWFpbiBtb2JpbGUgcHJvdmlkZXIuXG4gICAgICBtZXRhbWFza0Jyb3dzZXJFeHRlbnNpb24ub24oRVhURU5TSU9OX0VWRU5UUy5DSEFJTl9DSEFOR0VELCAoY2hhaW5JZCkgPT4ge1xuICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgYFtNZXRhTWFza1NESzogc2V0dXBFeHRlbnNpb25QcmVmZXJlbmNlcygpXSBQUk9QQUdBVEUgY2hhaW5DaGFuZ2VkIGNoYWluSWQ9JHtjaGFpbklkfWAsXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgaGFzTW9iaWxlUHJvdmlkZXIgPSBCb29sZWFuKGluc3RhbmNlLnNka1Byb3ZpZGVyKTtcblxuICAgICAgICBpZiAoaGFzTW9iaWxlUHJvdmlkZXIpIHtcbiAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICAgLmdldE1vYmlsZVByb3ZpZGVyKClcbiAgICAgICAgICAgIC5lbWl0KEVYVEVOU0lPTl9FVkVOVFMuQ0hBSU5fQ0hBTkdFRCwgY2hhaW5JZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBtZXRhbWFza0Jyb3dzZXJFeHRlbnNpb24ub24oXG4gICAgICAgIEVYVEVOU0lPTl9FVkVOVFMuQUNDT1VOVFNfQ0hBTkdFRCxcbiAgICAgICAgYXN5bmMgKGFjY291bnRzKSA9PiB7XG4gICAgICAgICAgbG9nZ2VyKFxuICAgICAgICAgICAgYFtNZXRhTWFza1NESzogc2V0dXBFeHRlbnNpb25QcmVmZXJlbmNlcygpXSBQUk9QQUdBVEUgYWNjb3VudHNDaGFuZ2VkIGFjY291bnRzPSR7YWNjb3VudHN9YCxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY29uc3QgaGFzTW9iaWxlUHJvdmlkZXIgPSBCb29sZWFuKGluc3RhbmNlLnNka1Byb3ZpZGVyKTtcblxuICAgICAgICAgIGNvbnN0IGlzRXh0ZW5zaW9uQWN0aXZlID0gQm9vbGVhbihpbnN0YW5jZS5leHRlbnNpb25BY3RpdmUpO1xuXG4gICAgICAgICAgaWYgKGhhc01vYmlsZVByb3ZpZGVyKSB7XG4gICAgICAgICAgICBpbnN0YW5jZVxuICAgICAgICAgICAgICAuZ2V0TW9iaWxlUHJvdmlkZXIoKVxuICAgICAgICAgICAgICAuZW1pdChFWFRFTlNJT05fRVZFTlRTLkFDQ09VTlRTX0NIQU5HRUQsIGFjY291bnRzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNFeHRlbnNpb25BY3RpdmUgJiYgKGFjY291bnRzIGFzIHN0cmluZ1tdKT8ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBnZXRQZXJtaXNzaW9uc1Jlc3BvbnNlID0gYXdhaXQgaW5zdGFuY2VcbiAgICAgICAgICAgICAgLmdldFByb3ZpZGVyKClcbiAgICAgICAgICAgICAgPy5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFJQQ19NRVRIT0RTLldBTExFVF9HRVRQRVJNSVNTSU9OUyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSBnZXRQZXJtaXNzaW9uc1Jlc3BvbnNlIGFzIHtcbiAgICAgICAgICAgICAgY2F2ZWF0czogeyB0eXBlOiBzdHJpbmc7IHZhbHVlOiBzdHJpbmdbXSB9W107XG4gICAgICAgICAgICAgIHBhcmVudENhcGFiaWxpdHk6IHN0cmluZztcbiAgICAgICAgICAgIH1bXTtcblxuICAgICAgICAgICAgaWYgKHBlcm1pc3Npb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGluc3RhbmNlLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlcihcbiAgICAgICAgICAgICAgICAgIGBbTWV0YU1hc2tTREs6IHNldHVwRXh0ZW5zaW9uUHJlZmVyZW5jZXMoKV0gZXJyb3IgdGVybWluYXRpbmcgb24gcGVybWlzc2lvbnMgcmV2b2tlZGAsXG4gICAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgKTtcblxuICAgICAgbWV0YW1hc2tCcm93c2VyRXh0ZW5zaW9uLm9uKEVYVEVOU0lPTl9FVkVOVFMuRElTQ09OTkVDVCwgKGVycm9yKSA9PiB7XG4gICAgICAgIGxvZ2dlcihcbiAgICAgICAgICBgW01ldGFNYXNrU0RLOiBzZXR1cEV4dGVuc2lvblByZWZlcmVuY2VzKCldIFBST1BBR0FURSBkaXNjb25uZWN0IGVycm9yPSR7ZXJyb3J9YCxcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBoYXNNb2JpbGVQcm92aWRlciA9IEJvb2xlYW4oaW5zdGFuY2Uuc2RrUHJvdmlkZXIpO1xuXG4gICAgICAgIGlmIChoYXNNb2JpbGVQcm92aWRlcikge1xuICAgICAgICAgIGluc3RhbmNlLmdldE1vYmlsZVByb3ZpZGVyKCkuZW1pdChFWFRFTlNJT05fRVZFTlRTLkRJU0NPTk5FQ1QsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIG1ldGFtYXNrQnJvd3NlckV4dGVuc2lvbi5vbihFWFRFTlNJT05fRVZFTlRTLkNPTk5FQ1QsIChhcmdzKSA9PiB7XG4gICAgICAgIGxvZ2dlcihcbiAgICAgICAgICBgW01ldGFNYXNrU0RLOiBzZXR1cEV4dGVuc2lvblByZWZlcmVuY2VzKCldIFBST1BBR0FURSBjb25uZWN0IGFyZ3M9JHthcmdzfWAsXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgaGFzTW9iaWxlUHJvdmlkZXIgPSBCb29sZWFuKGluc3RhbmNlLnNka1Byb3ZpZGVyKTtcblxuICAgICAgICBpZiAoaGFzTW9iaWxlUHJvdmlkZXIpIHtcbiAgICAgICAgICBpbnN0YW5jZS5nZXRNb2JpbGVQcm92aWRlcigpLmVtaXQoRVhURU5TSU9OX0VWRU5UUy5DT05ORUNULCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIG1ldGFtYXNrQnJvd3NlckV4dGVuc2lvbi5vbihFWFRFTlNJT05fRVZFTlRTLkNPTk5FQ1RFRCwgKGFyZ3MpID0+IHtcbiAgICAgICAgbG9nZ2VyKFxuICAgICAgICAgICdbTWV0YU1hc2tTREs6IHNldHVwRXh0ZW5zaW9uUHJlZmVyZW5jZXMoKV0gUFJPUEFHQVRFIGNvbm5lY3RlZCcsXG4gICAgICAgICAgYXJncyxcbiAgICAgICAgKTtcblxuICAgICAgICBjb25zdCBoYXNNb2JpbGVQcm92aWRlciA9IEJvb2xlYW4oaW5zdGFuY2Uuc2RrUHJvdmlkZXIpO1xuXG4gICAgICAgIGlmIChoYXNNb2JpbGVQcm92aWRlcikge1xuICAgICAgICAgIGluc3RhbmNlLmdldE1vYmlsZVByb3ZpZGVyKCkuZW1pdChFWFRFTlNJT05fRVZFTlRTLkNPTk5FQ1RFRCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSWdub3JlIGVycm9yIGlmIG1ldGFtYXNrIGV4dGVuc2lvbiBub3QgZm91bmRcbiAgICAgIHdpbmRvdy5leHRlbnNpb24gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIEV0aGVyZXVtLmRlc3Ryb3koKTtcbiAgfSBlbHNlIGlmIChpbnN0YW5jZS5wbGF0Zm9ybU1hbmFnZXI/LmlzTWV0YU1hc2tNb2JpbGVXZWJWaWV3KCkpIHtcbiAgICBpbnN0YW5jZS5hbmFseXRpY3M/LnNlbmQoeyBldmVudDogVHJhY2tpbmdFdmVudHMuU0RLX1VTRV9JTkFQUF9CUk9XU0VSIH0pO1xuICAgIC8vIFRPRE86IFJlbW92ZSBGb3JjZSB3cmFwcGluZyBpbnBhZ2UgcHJvdmlkZXIgdW50aWwgaXQgaW1wbGVtZW50cyBsYXRlc3QgcHJvdmlkZXIgaW50ZXJmYWNlXG4gICAgaW5zdGFuY2UuYWN0aXZlUHJvdmlkZXIgPSB3cmFwRXh0ZW5zaW9uUHJvdmlkZXIoe1xuICAgICAgcHJvdmlkZXI6IHdpbmRvdy5ldGhlcmV1bSBhcyBhbnksXG4gICAgICBzZGtJbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgfSkgYXMgU0RLUHJvdmlkZXI7XG4gICAgaW5zdGFuY2UuX2luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgIHNob3VsZFJldHVybiA9IHRydWU7XG4gIH1cblxuICBpZiAobWV0YW1hc2tCcm93c2VyRXh0ZW5zaW9uICYmIG9wdGlvbnMuZXh0ZW5zaW9uT25seSkge1xuICAgIGxvZ2dlcihcbiAgICAgIGBbTWV0YU1hc2tTREs6IHNldHVwRXh0ZW5zaW9uUHJlZmVyZW5jZXMoKV0gRVhURU5TSU9OIE9OTFkgLS0tIHByZXZlbnQgc2RrIGluaXRpYWxpemF0aW9uYCxcbiAgICApO1xuXG4gICAgaW5zdGFuY2UuYW5hbHl0aWNzPy5zZW5kKHsgZXZlbnQ6IFRyYWNraW5nRXZlbnRzLlNES19VU0VfRVhURU5TSU9OIH0pO1xuICAgIGluc3RhbmNlLmFjdGl2ZVByb3ZpZGVyID0gbWV0YW1hc2tCcm93c2VyRXh0ZW5zaW9uIGFzIFNES1Byb3ZpZGVyOyAvLyBUT0RPIHNob3VsZCBiZSBNZXRhTWFza0luUGFnZVByb3ZpZGVyXG4gICAgaW5zdGFuY2UuZXh0ZW5zaW9uQWN0aXZlID0gdHJ1ZTtcbiAgICBpbnN0YW5jZS5leHRlbnNpb24gPSBtZXRhbWFza0Jyb3dzZXJFeHRlbnNpb247XG4gICAgaW5zdGFuY2UuX2luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgIHNob3VsZFJldHVybiA9IHRydWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHByZWZlckV4dGVuc2lvbixcbiAgICBzaG91bGRSZXR1cm4sXG4gICAgbWV0YW1hc2tCcm93c2VyRXh0ZW5zaW9uLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgQ29tbXVuaWNhdGlvbkxheWVyUHJlZmVyZW5jZSB9IGZyb20gJ0BtZXRhbWFzay9zZGstY29tbXVuaWNhdGlvbi1sYXllcic7XG5pbXBvcnQgeyBNZXRhTWFza0luc3RhbGxlciB9IGZyb20gJy4uLy4uLy4uL1BsYXRmb3JtL01ldGFNYXNrSW5zdGFsbGVyJztcbmltcG9ydCB7IFBsYXRmb3JtTWFuYWdlciB9IGZyb20gJy4uLy4uLy4uL1BsYXRmb3JtL1BsYXRmZm9ybU1hbmFnZXInO1xuaW1wb3J0IHsgTWV0YU1hc2tTREsgfSBmcm9tICcuLi8uLi8uLi9zZGsnO1xuaW1wb3J0IHsgQW5hbHl0aWNzIH0gZnJvbSAnLi4vLi4vQW5hbHl0aWNzJztcbmltcG9ydCB7IFJlbW90ZUNvbm5lY3Rpb24gfSBmcm9tICcuLi8uLi9SZW1vdGVDb25uZWN0aW9uJztcbmltcG9ydCB7IGNvbm5lY3RXaXRoRXh0ZW5zaW9uUHJvdmlkZXIgfSBmcm9tICcuLi9Qcm92aWRlck1hbmFnZXInO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuZCBzZXRzIHVwIGJvdGggdGhlIFJlbW90ZUNvbm5lY3Rpb24gYW5kIE1ldGFNYXNrSW5zdGFsbGVyIGZvciB0aGUgTWV0YU1hc2tTREsgaW5zdGFuY2UuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjb25zdHJ1Y3RzIGEgbmV3IFJlbW90ZUNvbm5lY3Rpb24gd2l0aCB2YXJpb3VzIHNldHRpbmdzLCBzdWNoIGFzIGNvbW11bmljYXRpb24gbGF5ZXIgcHJlZmVyZW5jZSxcbiAqIGFuYWx5dGljcywgYW5kIG1ldGFkYXRhIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zIHdpdGhpbiB0aGUgTWV0YU1hc2tTREsgaW5zdGFuY2UuIEl0IGFsc28gc2V0cyB1cFxuICogTWV0YU1hc2tJbnN0YWxsZXIgd2hpY2ggaXMgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIE1ldGFNYXNrIGluc3RhbGxhdGlvbnMuIFRoZSBpbml0aWFsaXplZCBSZW1vdGVDb25uZWN0aW9uXG4gKiBhbmQgTWV0YU1hc2tJbnN0YWxsZXIgYXJlIHN0b3JlZCBiYWNrIGludG8gdGhlIE1ldGFNYXNrU0RLIGluc3RhbmNlIGZvciBmdXJ0aGVyIHVzZS5cbiAqXG4gKiBAcGFyYW0gaW5zdGFuY2UgVGhlIGN1cnJlbnQgaW5zdGFuY2Ugb2YgdGhlIE1ldGFNYXNrU0RLLCB3aGljaCBjb250YWlucyB1c2VyLWRlZmluZWQgb3IgZGVmYXVsdCBvcHRpb25zLlxuICogQHBhcmFtIG1ldGFtYXNrQnJvd3NlckV4dGVuc2lvbiBBbiBvcHRpb25hbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIHRoZSBNZXRhTWFzayBicm93c2VyIGV4dGVuc2lvbiBpbnN0YW5jZSwgaWYgYXZhaWxhYmxlLlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gYm90aCB0aGUgUmVtb3RlQ29ubmVjdGlvbiBhbmQgTWV0YU1hc2tJbnN0YWxsZXIgaGF2ZSBiZWVuIHN1Y2Nlc3NmdWxseSBzZXQgdXAuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZXR1cFJlbW90ZUNvbm5lY3Rpb25BbmRJbnN0YWxsZXIoXG4gIGluc3RhbmNlOiBNZXRhTWFza1NESyxcbiAgbWV0YW1hc2tCcm93c2VyRXh0ZW5zaW9uOiBhbnksXG4pIHtcbiAgY29uc3QgeyBvcHRpb25zIH0gPSBpbnN0YW5jZTtcblxuICBjb25zdCBydW50aW1lTG9nZ2luZyA9IHsgLi4ub3B0aW9ucy5sb2dnaW5nIH07XG5cbiAgaW5zdGFuY2UucmVtb3RlQ29ubmVjdGlvbiA9IG5ldyBSZW1vdGVDb25uZWN0aW9uKHtcbiAgICBhbm9uSWQ6IGF3YWl0IGluc3RhbmNlLmdldEFub25JZCgpLFxuICAgIHByZWZlckRlc2t0b3A6IG9wdGlvbnMucHJlZmVyRGVza3RvcCA/PyBmYWxzZSxcbiAgICBjb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlOlxuICAgICAgb3B0aW9ucy5jb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlID8/XG4gICAgICBDb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlLlNPQ0tFVCxcbiAgICBhbmFseXRpY3M6IGluc3RhbmNlLmFuYWx5dGljcyBhcyBBbmFseXRpY3MsXG4gICAgZGFwcE1ldGFkYXRhOiBvcHRpb25zLmRhcHBNZXRhZGF0YSxcbiAgICBfc291cmNlOiBvcHRpb25zLl9zb3VyY2UsXG4gICAgZW5hYmxlQW5hbHl0aWNzOiBvcHRpb25zLmVuYWJsZUFuYWx5dGljcyA/PyB0cnVlLFxuICAgIHRpbWVyOiBvcHRpb25zLnRpbWVyLFxuICAgIHNkazogaW5zdGFuY2UsXG4gICAgcGxhdGZvcm1NYW5hZ2VyOiBpbnN0YW5jZS5wbGF0Zm9ybU1hbmFnZXIgYXMgUGxhdGZvcm1NYW5hZ2VyLFxuICAgIHRyYW5zcG9ydHM6IG9wdGlvbnMudHJhbnNwb3J0cyxcbiAgICBjb21tdW5pY2F0aW9uU2VydmVyVXJsOiBvcHRpb25zLmNvbW11bmljYXRpb25TZXJ2ZXJVcmwsXG4gICAgc3RvcmFnZTogb3B0aW9ucy5zdG9yYWdlID8/IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgfSxcbiAgICBnZXRNZXRhTWFza0luc3RhbGxlcjogKCkgPT4ge1xuICAgICAgLy8gdXNlZCB0byBwcmV2ZW50IGNpcmN1bGFyIGRlcGVuZGVuY2llc1xuICAgICAgaWYgKCFpbnN0YW5jZS5pbnN0YWxsZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFNESyBzdGF0dXMgLS0gaW5zdGFsbGVyIG5vdCBpbml0aWFsaXplZGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc3RhbmNlLmluc3RhbGxlcjtcbiAgICB9LFxuICAgIGxvZ2dpbmc6IHJ1bnRpbWVMb2dnaW5nLFxuICAgIGNvbm5lY3RXaXRoRXh0ZW5zaW9uUHJvdmlkZXI6XG4gICAgICBtZXRhbWFza0Jyb3dzZXJFeHRlbnNpb24gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6ICgpID0+IGNvbm5lY3RXaXRoRXh0ZW5zaW9uUHJvdmlkZXIoaW5zdGFuY2UpLFxuICAgIG1vZGFsczoge1xuICAgICAgLi4ub3B0aW9ucy5tb2RhbHMsXG4gICAgICBvblBlbmRpbmdNb2RhbERpc2Nvbm5lY3Q6IGluc3RhbmNlLnRlcm1pbmF0ZS5iaW5kKGluc3RhbmNlKSxcbiAgICB9LFxuICB9KTtcblxuICBhd2FpdCBpbnN0YW5jZS5yZW1vdGVDb25uZWN0aW9uLmluaXRSZW1vdGVDb21tdW5pY2F0aW9uKHtcbiAgICBzZGtJbnN0YW5jZTogaW5zdGFuY2UsXG4gIH0pO1xuXG4gIGluc3RhbmNlLmluc3RhbGxlciA9IG5ldyBNZXRhTWFza0luc3RhbGxlcih7XG4gICAgcmVtb3RlOiBpbnN0YW5jZS5yZW1vdGVDb25uZWN0aW9uLFxuICAgIHByZWZlckRlc2t0b3A6IG9wdGlvbnMucHJlZmVyRGVza3RvcCA/PyBmYWxzZSxcbiAgICBwbGF0Zm9ybU1hbmFnZXI6IGluc3RhbmNlLnBsYXRmb3JtTWFuYWdlciBhcyBQbGF0Zm9ybU1hbmFnZXIsXG4gICAgZGVidWc6IGluc3RhbmNlLmRlYnVnLFxuICB9KTtcbn1cbiIsImltcG9ydCB7IFRyYWNraW5nRXZlbnRzIH0gZnJvbSAnQG1ldGFtYXNrL3Nkay1jb21tdW5pY2F0aW9uLWxheWVyJztcbmltcG9ydCB7IFNUT1JBR0VfUFJPVklERVJfVFlQRSB9IGZyb20gJy4uLy4uLy4uL2NvbmZpZyc7XG5pbXBvcnQgeyBNZXRhTWFza1NESyB9IGZyb20gJy4uLy4uLy4uL3Nkayc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgY29ubmVjdFdpdGhFeHRlbnNpb25Qcm92aWRlciB9IGZyb20gJy4uL1Byb3ZpZGVyTWFuYWdlcic7XG5cbi8qKlxuICogSGFuZGxlcyBhdXRvbWF0aWMgYW5kIGV4dGVuc2lvbi1iYXNlZCBjb25uZWN0aW9ucyBmb3IgTWV0YU1hc2sgU0RLLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZGVjaWRlcyBiZXR3ZWVuIGNvbm5lY3RpbmcgdXNpbmcgTWV0YU1hc2sgZXh0ZW5zaW9uIG9yIGF1dG9tYXRpY2FsbHlcbiAqIGNvbm5lY3RpbmcgYmFzZWQgb24gdGhlIHBhc3NlZCBwYXJhbWV0ZXJzIGFuZCBwbGF0Zm9ybSBjb25kaXRpb25zLiBJZiAncHJlZmVyRXh0ZW5zaW9uJyBpcyB0cnVlLFxuICogaXQgYXR0ZW1wdHMgdG8gY29ubmVjdCB3aXRoIHRoZSBNZXRhTWFzayBleHRlbnNpb24gYW5kIGZhbGxzIGJhY2sgdG8gY2xlYW5pbmcgdGhlIHByZWZlcmVuY2VcbiAqIGlmIHRoZSBjb25uZWN0aW9uIGZhaWxzLiBJZiAnY2hlY2tJbnN0YWxsYXRpb25JbW1lZGlhdGVseScgaXMgc2V0IGluIG9wdGlvbnMsIGl0IGF0dGVtcHRzIHRvIGF1dG8tY29ubmVjdCxcbiAqIGJ1dCBvbmx5IGlmIHRoZSBwbGF0Zm9ybSBpcyBhIGRlc2t0b3Agd2ViIGVudmlyb25tZW50LlxuICpcbiAqIEBwYXJhbSBpbnN0YW5jZSBUaGUgTWV0YU1hc2tTREsgaW5zdGFuY2UgdG8gaGFuZGxlIHRoZSBjb25uZWN0aW9uIGZvci5cbiAqIEBwYXJhbSBwcmVmZXJFeHRlbnNpb24gQSBib29sZWFuIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRvIHByZWZlciBjb25uZWN0aW5nIHZpYSBNZXRhTWFzayBleHRlbnNpb24uXG4gKiBAcmV0dXJucyB2b2lkXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBoYW5kbGVBdXRvQW5kRXh0ZW5zaW9uQ29ubmVjdGlvbnMoXG4gIGluc3RhbmNlOiBNZXRhTWFza1NESyxcbiAgcHJlZmVyRXh0ZW5zaW9uOiBib29sZWFuLFxuKSB7XG4gIGNvbnN0IHsgb3B0aW9ucyB9ID0gaW5zdGFuY2U7XG5cbiAgaWYgKHByZWZlckV4dGVuc2lvbikge1xuICAgIGxvZ2dlcihcbiAgICAgIGBbTWV0YU1hc2tTREs6IGhhbmRsZUF1dG9BbmRFeHRlbnNpb25Db25uZWN0aW9ucygpXSBwcmVmZXJFeHRlbnNpb24gaXMgZGV0ZWN0ZWQgLS0gY29ubmVjdCB3aXRoIGl0LmAsXG4gICAgKTtcblxuICAgIGluc3RhbmNlLmFuYWx5dGljcz8uc2VuZCh7XG4gICAgICBldmVudDogVHJhY2tpbmdFdmVudHMuU0RLX0VYVEVOU0lPTl9VVElMSVpFRCxcbiAgICB9KTtcblxuICAgIGNvbm5lY3RXaXRoRXh0ZW5zaW9uUHJvdmlkZXIoaW5zdGFuY2UpLmNhdGNoKChfZXJyKSA9PiB7XG4gICAgICBjb25zb2xlLndhcm4oYENhbid0IGNvbm5lY3Qgd2l0aCBNZXRhTWFzayBleHRlbnNpb24uLi5gLCBfZXJyKTtcbiAgICAgIC8vIENsZWFuIHByZWZlcmVuY2VzXG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShTVE9SQUdFX1BST1ZJREVSX1RZUEUpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMuY2hlY2tJbnN0YWxsYXRpb25JbW1lZGlhdGVseSkge1xuICAgIGlmIChpbnN0YW5jZS5wbGF0Zm9ybU1hbmFnZXI/LmlzRGVza3RvcFdlYigpKSB7XG4gICAgICBsb2dnZXIoXG4gICAgICAgIGBbTWV0YU1hc2tTREs6IGhhbmRsZUF1dG9BbmRFeHRlbnNpb25Db25uZWN0aW9ucygpXSBjaGVja0luc3RhbGxhdGlvbkltbWVkaWF0ZWx5YCxcbiAgICAgICk7XG5cbiAgICAgIC8vIERvbid0IGJsb2NrIC9hd2FpdCBpbml0aWFsaXphdGlvbiBvbiBhdXRvY29ubmVjdFxuICAgICAgaW5zdGFuY2UuY29ubmVjdCgpLmNhdGNoKChfZXJyKSA9PiB7XG4gICAgICAgIC8vIGlnbm9yZSBlcnJvciBvbiBhdXRvY29ubmVjdFxuICAgICAgICBsb2dnZXIoXG4gICAgICAgICAgYFtNZXRhTWFza1NESzogaGFuZGxlQXV0b0FuZEV4dGVuc2lvbkNvbm5lY3Rpb25zKCldIGNoZWNrSW5zdGFsbGF0aW9uSW1tZWRpYXRlbHkgLS0tIElHTk9SRUQgLS0tIGVycm9yIG9uIGF1dG9jb25uZWN0IF9lcnI9JHtfZXJyfWAsXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW2hhbmRsZUF1dG9BbmRFeHRlbnNpb25Db25uZWN0aW9ucygpXSBjaGVja0luc3RhbGxhdGlvbkltbWVkaWF0ZWx5IC0tLSBJR05PUkVEIC0tLSBvbmx5IGZvciB3ZWIgZGVza3RvcGAsXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGluc3RhbmNlLl9pbml0aWFsaXplZCA9IHRydWU7XG59XG4iLCJpbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tICd1dWlkJztcbmltcG9ydCB7IE1ldGFNYXNrSW5wYWdlUHJvdmlkZXIgfSBmcm9tICdAbWV0YW1hc2svcHJvdmlkZXJzJztcbmltcG9ydCB7XG4gIENvbW11bmljYXRpb25MYXllclByZWZlcmVuY2UsXG4gIERhcHBNZXRhZGF0YSxcbiAgU3RvcmFnZU1hbmFnZXJQcm9wcyxcbn0gZnJvbSAnQG1ldGFtYXNrL3Nkay1jb21tdW5pY2F0aW9uLWxheWVyJztcbmltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5cbmltcG9ydCBFdmVudEVtaXR0ZXIyIGZyb20gJ2V2ZW50ZW1pdHRlcjInO1xuaW1wb3J0IHBhY2thZ2VKc29uIGZyb20gJy4uL3BhY2thZ2UuanNvbic7XG5pbXBvcnQgeyBNZXRhTWFza0luc3RhbGxlciB9IGZyb20gJy4vUGxhdGZvcm0vTWV0YU1hc2tJbnN0YWxsZXInO1xuaW1wb3J0IHsgUGxhdGZvcm1NYW5hZ2VyIH0gZnJvbSAnLi9QbGF0Zm9ybS9QbGF0ZmZvcm1NYW5hZ2VyJztcbmltcG9ydCB7IERFRkFVTFRfU0RLX1NPVVJDRSB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IFNES1Byb3ZpZGVyIH0gZnJvbSAnLi9wcm92aWRlci9TREtQcm92aWRlcic7XG5pbXBvcnQgeyBBbmFseXRpY3MgfSBmcm9tICcuL3NlcnZpY2VzL0FuYWx5dGljcyc7XG5pbXBvcnQge1xuICBjb25uZWN0LFxuICByZXN1bWUsXG4gIHRlcm1pbmF0ZSxcbn0gZnJvbSAnLi9zZXJ2aWNlcy9NZXRhTWFza1NESy9Db25uZWN0aW9uTWFuYWdlcic7XG5pbXBvcnQgeyBjb25uZWN0QW5kU2lnbiB9IGZyb20gJy4vc2VydmljZXMvTWV0YU1hc2tTREsvQ29ubmVjdGlvbk1hbmFnZXIvY29ubmVjdEFuZFNpZ24nO1xuaW1wb3J0IHsgY29ubmVjdFdpdGggfSBmcm9tICcuL3NlcnZpY2VzL01ldGFNYXNrU0RLL0Nvbm5lY3Rpb25NYW5hZ2VyL2Nvbm5lY3RXaXRoJztcbmltcG9ydCB7IGluaXRpYWxpemVNZXRhTWFza1NESyB9IGZyb20gJy4vc2VydmljZXMvTWV0YU1hc2tTREsvSW5pdGlhbGl6ZXJNYW5hZ2VyJztcbmltcG9ydCB7IFJQQ19VUkxTX01BUCB9IGZyb20gJy4vc2VydmljZXMvTWV0YU1hc2tTREsvSW5pdGlhbGl6ZXJNYW5hZ2VyL3NldHVwUmVhZE9ubHlSUENQcm92aWRlcnMnO1xuaW1wb3J0IHtcbiAgUmVtb3RlQ29ubmVjdGlvbixcbiAgUmVtb3RlQ29ubmVjdGlvblByb3BzLFxufSBmcm9tICcuL3NlcnZpY2VzL1JlbW90ZUNvbm5lY3Rpb24nO1xuaW1wb3J0IHtcbiAgTWV0YU1hc2tTREtFdmVudFBheWxvYWQsXG4gIE1ldGFNYXNrU0RLRXZlbnRUeXBlLFxufSBmcm9tICcuL3R5cGVzL01ldGFNYXNrU0RLRXZlbnRzJztcbmltcG9ydCB7IFNES0xvZ2dpbmdPcHRpb25zIH0gZnJvbSAnLi90eXBlcy9TREtMb2dnaW5nT3B0aW9ucyc7XG5pbXBvcnQgeyBTREtVSU9wdGlvbnMgfSBmcm9tICcuL3R5cGVzL1NES1VJT3B0aW9ucyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL3V0aWxzL2xvZ2dlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWV0YU1hc2tTREtPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBJbmZ1cmEgQVBJIGtleSB0byB1c2UgZm9yIFJQQyByZXF1ZXN0cy5cbiAgICovXG4gIGluZnVyYUFQSUtleT86IHN0cmluZztcblxuICAvKipcbiAgICogQSBtYXAgb2YgUlBDIFVSTHMgdG8gdXNlIGZvciByZWFkLW9ubHkgcmVxdWVzdHMuXG4gICAqL1xuICByZWFkb25seVJQQ01hcD86IFJQQ19VUkxTX01BUDtcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgdGhlIFNESyB3aWxsIGluamVjdCB0aGUgcHJvdmlkZXIgaW50byB0aGUgZ2xvYmFsIGB3aW5kb3dgIG9iamVjdC5cbiAgICovXG4gIGluamVjdFByb3ZpZGVyPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgdGhlIFNESyB3aWxsIGZvcmNlIGluamVjdCB0aGUgcHJvdmlkZXIgaW50byB0aGUgZ2xvYmFsIGB3aW5kb3dgIG9iamVjdC5cbiAgICovXG4gIGZvcmNlSW5qZWN0UHJvdmlkZXI/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCB0aGUgU0RLIHdpbGwgZm9yY2UgZGVsZXRlIHRoZSBwcm92aWRlciBmcm9tIHRoZSBnbG9iYWwgYHdpbmRvd2Agb2JqZWN0LlxuICAgKi9cbiAgZm9yY2VEZWxldGVQcm92aWRlcj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIHRoZSBTREsgd2lsbCBjaGVjayBpZiBNZXRhTWFzayBpcyBpbnN0YWxsZWQgb24gdGhlIHVzZXIncyBicm93c2VyIGFuZCBzZW5kIGEgY29ubmVjdGlvbiByZXF1ZXN0LiBJZiBub3QgaXQgd2lsbCBwcm9tcHQgdGhlIHVzZXIgdG8gaW5zdGFsbCBpdC4gSWYgZmFsc2UsIHRoZSBTREsgd2lsbCB3YWl0IGZvciB0aGUgY29ubmVjdCBtZXRob2QgdG8gYmUgY2FsbGVkIHRvIGNoZWNrIGlmIE1ldGFNYXNrIGlzIGluc3RhbGxlZC5cbiAgICovXG4gIGNoZWNrSW5zdGFsbGF0aW9uSW1tZWRpYXRlbHk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCB0aGUgU0RLIHdpbGwgY2hlY2sgaWYgTWV0YU1hc2sgaXMgaW5zdGFsbGVkIG9uIHRoZSB1c2VyJ3MgYnJvd3NlciBiZWZvcmUgZWFjaCBSUEMgY2FsbC4gSWYgbm90IGl0IHdpbGwgcHJvbXB0IHRoZSB1c2VyIHRvIGluc3RhbGwgaXQuXG4gICAqL1xuICBjaGVja0luc3RhbGxhdGlvbk9uQWxsQ2FsbHM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCB0aGUgU0RLIHdpbGwgcHJlZmVyIHRoZSBkZXNrdG9wIHZlcnNpb24gb2YgTWV0YU1hc2sgb3ZlciB0aGUgbW9iaWxlIHZlcnNpb24uXG4gICAqL1xuICBwcmVmZXJEZXNrdG9wPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgdGhlIFNESyB3aWxsIG5vdCBkaXNwbGF5IGFueSBtb2RhbHMgb3IgUVIgY29kZSBVSS5cbiAgICovXG4gIGhlYWRsZXNzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHRvIG9wZW4gYSBkZWVwbGluayB0byB0aGUgTWV0YU1hc2sgTW9iaWxlIGFwcC5cbiAgICovXG4gIG9wZW5EZWVwbGluaz86IChhcmc6IHN0cmluZykgPT4gdm9pZDtcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgdGhlIFNESyB3aWxsIHVzZSBkZWVwbGlua3MgdG8gY29ubmVjdCB3aXRoIE1ldGFNYXNrIE1vYmlsZS4gSWYgZmFsc2UsIHRoZSBTREsgd2lsbCB1c2UgdW5pdmVyc2FsIGxpbmtzIHRvIGNvbm5lY3Qgd2l0aCBNZXRhTWFzayBNb2JpbGUuXG4gICAqL1xuICB1c2VEZWVwbGluaz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIElmIHRydWUsIHRoZSBTREsgd2lsbCBzaGltIHRoZSB3aW5kb3cud2ViMyBvYmplY3Qgd2l0aCB0aGUgcHJvdmlkZXIgcmV0dXJuZWQgYnkgdGhlIFNESyAodXNlZnVsIGZvciBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgYnJvd3NlcikuXG4gICAqL1xuICBzaG91bGRTaGltV2ViMz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBwcmVmZXJyZWQgY29tbXVuaWNhdGlvbiBsYXllciB0byB1c2UgZm9yIHRoZSBTREsuXG4gICAqL1xuICBjb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlPzogQ29tbXVuaWNhdGlvbkxheWVyUHJlZmVyZW5jZTtcblxuICAvKipcbiAgICogQW4gYXJyYXkgb2YgdHJhbnNwb3J0IHByb3RvY29scyB0byB1c2UgZm9yIGNvbW11bmljYXRpb24gd2l0aCB0aGUgTWV0YU1hc2sgd2FsbGV0LlxuICAgKi9cbiAgdHJhbnNwb3J0cz86IHN0cmluZ1tdO1xuXG4gIC8qKlxuICAgKiBNZXRhZGF0YSBhYm91dCB0aGUgZGFwcCB1c2luZyB0aGUgU0RLLlxuICAgKi9cbiAgZGFwcE1ldGFkYXRhOiBEYXBwTWV0YWRhdGE7XG5cbiAgLyoqXG4gICAqIEEgdGltZXIgb2JqZWN0IHRvIHVzZSBmb3Igc2NoZWR1bGluZyB0YXNrcy5cbiAgICovXG4gIHRpbWVyPzogYW55O1xuXG4gIC8qKlxuICAgKiBTZW5kIGFub255bW91cyBhbmFseXRpY3MgdG8gTWV0YU1hc2sgdG8gaGVscCB1cyBpbXByb3ZlIHRoZSBTREsuXG4gICAqL1xuICBlbmFibGVBbmFseXRpY3M/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJZiBNZXRhTWFzayBicm93c2VyIGV4dGVuc2lvbiBpcyBkZXRlY3RlZCwgZGlyZWN0bHkgdXNlIGl0LlxuICAgKi9cbiAgZXh0ZW5zaW9uT25seT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aGUgJ2Rpc3BsYXlfdXJpJyBldmVudCBvbiB0aGUgcHJvdmlkZXIgaW5zdGVhZC5cbiAgICogTGlzdGVuIHRvIHRoaXMgZXZlbnQgdG8gZ2V0IHRoZSBRUiBjb2RlIFVSTCBhbmQgY3VzdG9taXplIHlvdXIgVUkuXG4gICAqIEV4YW1wbGU6XG4gICAqIHNkay5nZXRQcm92aWRlcigpLm9uKCdkaXNwbGF5X3VyaScsICh1cmk6IHN0cmluZykgPT4ge1xuICAgKiAgIC8vIFVzZSB0aGUgdXJpIHRvIGRpc3BsYXkgYSBRUiBjb2RlIG9yIGN1c3RvbWl6ZSB5b3VyIFVJXG4gICAqIH0pO1xuICAgKi9cbiAgdWk/OiBTREtVSU9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB0aGUgJ2Rpc3BsYXlfdXJpJyBldmVudCBvbiB0aGUgcHJvdmlkZXIgaW5zdGVhZC5cbiAgICogTGlzdGVuIHRvIHRoaXMgZXZlbnQgdG8gZ2V0IHRoZSBRUiBjb2RlIFVSTCBhbmQgY3VzdG9taXplIHlvdXIgVUkuXG4gICAqIEV4YW1wbGU6XG4gICAqIHNkay5nZXRQcm92aWRlcigpLm9uKCdkaXNwbGF5X3VyaScsICh1cmk6IHN0cmluZykgPT4ge1xuICAgKiAgIC8vIFVzZSB0aGUgdXJpIHRvIGRpc3BsYXkgYSBRUiBjb2RlIG9yIGN1c3RvbWl6ZSB5b3VyIFVJXG4gICAqIH0pO1xuICAgKi9cbiAgbW9kYWxzPzogUmVtb3RlQ29ubmVjdGlvblByb3BzWydtb2RhbHMnXTtcblxuICAvKipcbiAgICogVGhlIFVSTCBvZiB0aGUgY29tbXVuaWNhdGlvbiBzZXJ2ZXIgdG8gdXNlIGZvciB0aGUgU0RLLlxuICAgKi9cbiAgY29tbXVuaWNhdGlvblNlcnZlclVybD86IHN0cmluZztcblxuICAvKipcbiAgICogT3B0aW9ucyBmb3IgY3VzdG9taXppbmcgdGhlIHN0b3JhZ2UgbWFuYWdlciB1c2VkIGJ5IHRoZSBTREsuXG4gICAqL1xuICBzdG9yYWdlPzogU3RvcmFnZU1hbmFnZXJQcm9wcztcblxuICAvKipcbiAgICogT3B0aW9ucyBmb3IgY3VzdG9taXppbmcgdGhlIGxvZ2dpbmcgYmVoYXZpb3Igb2YgdGhlIFNESy5cbiAgICovXG4gIGxvZ2dpbmc/OiBTREtMb2dnaW5nT3B0aW9ucztcblxuICAvKipcbiAgICogQSBzdHJpbmcgdG8gdHJhY2sgZXh0ZXJuYWwgaW50ZWdyYXRpb25zIChlLmcuIHdhZ21pKS5cbiAgICovXG4gIF9zb3VyY2U/OiBzdHJpbmc7XG5cbiAgLypcbiAgICogT3B0aW9ucyBmb3IgZW5hYmxpbmcgaTE4biBtdWx0aS1sYW5ndWFnZSBzdXBwb3J0IG9uIHRoZSBTREsuXG4gICAqL1xuICBpMThuT3B0aW9ucz86IHtcbiAgICBkZWJ1Zz86IGJvb2xlYW47XG4gICAgZW5hYmxlZD86IGJvb2xlYW47XG4gIH07XG59XG5cbmV4cG9ydCBjbGFzcyBNZXRhTWFza1NESyBleHRlbmRzIEV2ZW50RW1pdHRlcjIge1xuICBwdWJsaWMgb3B0aW9uczogTWV0YU1hc2tTREtPcHRpb25zO1xuXG4gIHB1YmxpYyBhY3RpdmVQcm92aWRlcj86IFNES1Byb3ZpZGVyO1xuXG4gIHB1YmxpYyBzZGtQcm92aWRlcj86IFNES1Byb3ZpZGVyO1xuXG4gIHB1YmxpYyByZW1vdGVDb25uZWN0aW9uPzogUmVtb3RlQ29ubmVjdGlvbjtcblxuICBwdWJsaWMgaW5zdGFsbGVyPzogTWV0YU1hc2tJbnN0YWxsZXI7XG5cbiAgcHVibGljIHBsYXRmb3JtTWFuYWdlcj86IFBsYXRmb3JtTWFuYWdlcjtcblxuICBwdWJsaWMgZGFwcE1ldGFkYXRhPzogRGFwcE1ldGFkYXRhO1xuXG4gIHB1YmxpYyBleHRlbnNpb25BY3RpdmUgPSBmYWxzZTtcblxuICBwdWJsaWMgZXh0ZW5zaW9uOiBNZXRhTWFza0lucGFnZVByb3ZpZGVyIHwgdW5kZWZpbmVkO1xuXG4gIHB1YmxpYyBfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcblxuICBwdWJsaWMgc2RrSW5pdFByb21pc2U/OiBQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gIHB1YmxpYyBkZWJ1ZyA9IGZhbHNlO1xuXG4gIHB1YmxpYyBhbmFseXRpY3M/OiBBbmFseXRpY3M7XG5cbiAgcHJpdmF0ZSByZWFkb25seVJQQ0NhbGxzID0gZmFsc2U7XG5cbiAgcHVibGljIGF2YWlsYWJsZUxhbmd1YWdlczogc3RyaW5nW10gPSBbJ2VuJ107XG5cbiAgcHJpdmF0ZSBfYW5vbklkOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBBTk9OX0lEX1NUT1JBR0VfS0VZID0gJ21tLXNkay1hbm9uLWlkJztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBvcHRpb25zOiBNZXRhTWFza1NES09wdGlvbnMgPSB7XG4gICAgICBzdG9yYWdlOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICB9LFxuICAgICAgaW5qZWN0UHJvdmlkZXI6IHRydWUsXG4gICAgICBmb3JjZUluamVjdFByb3ZpZGVyOiBmYWxzZSxcbiAgICAgIGVuYWJsZUFuYWx5dGljczogdHJ1ZSxcbiAgICAgIHNob3VsZFNoaW1XZWIzOiB0cnVlLFxuICAgICAgdXNlRGVlcGxpbms6IHRydWUsXG4gICAgICBleHRlbnNpb25Pbmx5OiB0cnVlLFxuICAgICAgaGVhZGxlc3M6IGZhbHNlLFxuICAgICAgZGFwcE1ldGFkYXRhOiB7XG4gICAgICAgIG5hbWU6ICcnLFxuICAgICAgICB1cmw6ICcnLFxuICAgICAgICBpY29uVXJsOiAnJyxcbiAgICAgIH0sXG4gICAgICBfc291cmNlOiBERUZBVUxUX1NES19TT1VSQ0UsXG4gICAgICBpMThuT3B0aW9uczoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgfSxcbiAgKSB7XG4gICAgc3VwZXIoKTtcbiAgICBkZWJ1Zy5kaXNhYmxlKCk7IC8vIGluaXRpYWxseSBkaXNhYmxlZFxuXG4gICAgY29uc3QgZGV2ZWxvcGVyTW9kZSA9IG9wdGlvbnMubG9nZ2luZz8uZGV2ZWxvcGVyTW9kZSA9PT0gdHJ1ZTtcbiAgICBjb25zdCBkZWJ1Z0VuYWJsZWQgPSBvcHRpb25zLmxvZ2dpbmc/LnNkayB8fCBkZXZlbG9wZXJNb2RlO1xuXG4gICAgaWYgKGRlYnVnRW5hYmxlZCkge1xuICAgICAgZGVidWcuZW5hYmxlKCdNTV9TREsnKTtcbiAgICB9XG4gICAgbG9nZ2VyKGBbTWV0YU1hc2tTREs6IGNvbnN0cnVjdG9yKCldOiBiZWdpbi5gKTtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycyg1MCk7XG5cbiAgICBpZiAoIW9wdGlvbnMuZGFwcE1ldGFkYXRhPy51cmwpIHtcbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgc2V0IGRhcHBNZXRhZGF0YSBvbiB3ZWIgZW52LlxuICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgb3B0aW9ucy5kYXBwTWV0YWRhdGEgPSB7XG4gICAgICAgICAgLi4ub3B0aW9ucy5kYXBwTWV0YWRhdGEsXG4gICAgICAgICAgdXJsOiBgJHt3aW5kb3cubG9jYXRpb24ucHJvdG9jb2x9Ly8ke3dpbmRvdy5sb2NhdGlvbi5ob3N0fWAsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHByb3ZpZGUgZEFwcE1ldGFkYXRhIHVybGApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuX3NvdXJjZSkge1xuICAgICAgb3B0aW9ucy5fc291cmNlID0gREVGQVVMVF9TREtfU09VUkNFO1xuICAgIH1cblxuICAgIC8vIEF1dG9tYXRpY2FsbHkgaW5pdGlhbGl6ZSB0aGUgU0RLIHRvIGtlZXAgdGhlIHNhbWUgYmVoYXZpb3IgYXMgYmVmb3JlXG4gICAgdGhpcy5pbml0KClcbiAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgbG9nZ2VyKGBbTWV0YU1hc2tTREs6IGNvbnN0cnVjdG9yKCldOiBpbml0aWFsaXplZCBzdWNjZXNzZnVsbHkuYCk7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHdpbmRvdy5tbXNkayA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIGBbTWV0YU1hc2tTREs6IGNvbnN0cnVjdG9yKCldIGVycm9yIGR1cmluZyBpbml0aWFsaXphdGlvbmAsXG4gICAgICAgICAgZXJyLFxuICAgICAgICApO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogWW91IGNhbiBzdWJzY3JpYmUgdG8gdGhlICdpbml0aWFsaXplZCcgZXZlbnQgdG8ga25vdyB3aGVuIHRoZSBTREsgaXMgcmVhZHkgb3IgY2FsbCBjb25uZWN0KCkgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb24gcHJvY2Vzcy5cbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgU0RLIGlzIGluaXRpYWxpemVkLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGluaXQoKSB7XG4gICAgcmV0dXJuIGluaXRpYWxpemVNZXRhTWFza1NESyh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgYWN0aXZlIGNvbm5lY3Rpb24gaXMgZG9uZSB2aWEgdGhlIE1ldGFNYXNrIGJyb3dzZXIgZXh0ZW5zaW9uL1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSBNZXRhTWFzayBicm93c2VyIGV4dGVuc2lvbiBpcyB0aGUgYWN0aXZlIHByb3ZpZGVyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0V4dGVuc2lvbkFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5leHRlbnNpb25BY3RpdmU7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIE1ldGFNYXNrIGV4dGVuc2lvbiBpcyBwb3RlbnRpYWxseSBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICogVGhpcyBtZXRob2QgaXMgbm90IHRoZSBwcmVmZXJyZWQgd2F5IHRvIGRldGVjdCBNZXRhTWFzay4gVXNlIEVJUC02OTYzIGluc3RlYWQsXG4gICAqIGFzIG1hbnkgZXh0ZW5zaW9ucyBjYW4gZmFrZSB0aGUgaXNNZXRhTWFzayBwcm9wZXJ0eS4gRUlQLTY5NjMgcHJvdmlkZXMgbW9yZSBhY2N1cmF0ZSBwcm92aWRlciBkZXRlY3Rpb24uXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgTWV0YU1hc2sgaXMgcG90ZW50aWFsbHkgYXZhaWxhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBjaGVja0V4dGVuc2lvbkF2YWlsYWJpbGl0eSgpOiBib29sZWFuIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIEJvb2xlYW4od2luZG93LmV0aGVyZXVtPy5pc01ldGFNYXNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25uZWN0IHRvIE1ldGFNYXNrLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmdbXT59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2YgYWNjb3VudCBhZGRyZXNzZXMuXG4gICAqL1xuICBhc3luYyBjb25uZWN0KCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICByZXR1cm4gY29ubmVjdCh0aGlzKTtcbiAgfVxuXG4gIC8vIFdBUk5JTkc6IFRoaXMgbWV0aG9kIG9ubHkgd29ya3MgZm9yIE1ldGFNYXNrIE1vYmlsZSB2Ny4xMCsuIEl0IHdpbGwgdGhyb3cgYW4gZXJyb3Igb3RoZXJ3aXNlLlxuICAvLyBtc2cgY2FuIGJlIGEgc2ltcGxlIHN0cmluZyBvciBBQk5GIFJGQyA1MjM0IGNvbXBsaWFudCBzdHJpbmcuXG4gIGFzeW5jIGNvbm5lY3RBbmRTaWduKHsgbXNnIH06IHsgbXNnOiBzdHJpbmcgfSkge1xuICAgIHJldHVybiBjb25uZWN0QW5kU2lnbih7IGluc3RhbmNlOiB0aGlzLCBtc2cgfSk7XG4gIH1cblxuICBhc3luYyBjb25uZWN0V2l0aChycGM6IHsgbWV0aG9kOiBzdHJpbmc7IHBhcmFtczogYW55W10gfSkge1xuICAgIHJldHVybiBjb25uZWN0V2l0aCh7IGluc3RhbmNlOiB0aGlzLCBycGMgfSk7XG4gIH1cblxuICByZXN1bWUoKSB7XG4gICAgcmV0dXJuIHJlc3VtZSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBERVBSRUNBVEVEOiB1c2UgdGVybWluYXRlKCkgaW5zdGVhZC5cbiAgICovXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgY29uc29sZS53YXJuKGBNZXRhTWFza1NESy5kaXNjb25uZWN0KCkgaXMgZGVwcmVjYXRlZCwgdXNlIHRlcm1pbmF0ZSgpYCk7XG4gICAgcmV0dXJuIHRoaXMudGVybWluYXRlKCk7XG4gIH1cblxuICBpc0F1dGhvcml6ZWQoKSB7XG4gICAgdGhpcy5yZW1vdGVDb25uZWN0aW9uPy5pc0F1dGhvcml6ZWQoKTtcbiAgfVxuXG4gIHRlcm1pbmF0ZSgpIHtcbiAgICByZXR1cm4gdGVybWluYXRlKHRoaXMpO1xuICB9XG5cbiAgaXNJbml0aWFsaXplZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5pdGlhbGl6ZWQ7XG4gIH1cblxuICBzZXRSZWFkT25seVJQQ0NhbGxzKGFsbG93ZWQ6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnJlYWRvbmx5UlBDQ2FsbHMgPSBhbGxvd2VkO1xuICB9XG5cbiAgaGFzUmVhZE9ubHlSUENDYWxscygpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkb25seVJQQ0NhbGxzO1xuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBhY3RpdmUgZXRoZXJldW0gcHJvdmlkZXIgb2JqZWN0XG4gIGdldFByb3ZpZGVyKCk6IFNES1Byb3ZpZGVyIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoIXRoaXMuYWN0aXZlUHJvdmlkZXIpIHtcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2tTREs6IE5vIGFjdGl2ZSBwcm92aWRlciBmb3VuZGApO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hY3RpdmVQcm92aWRlcjtcbiAgfVxuXG4gIGdldE1vYmlsZVByb3ZpZGVyKCk6IFNES1Byb3ZpZGVyIHtcbiAgICBpZiAoIXRoaXMuc2RrUHJvdmlkZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgU0RLIHN0YXRlIGludmFsaWQgLS0gdW5kZWZpbmVkIG1vYmlsZSBwcm92aWRlcmApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNka1Byb3ZpZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSAnZGlzcGxheV91cmknIGV2ZW50IG9uIGZyb20gc2RrIGluc3RhbmNlIGluc3RlYWQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIFFSQ29kZSBMaW5rLlxuICAgKi9cbiAgZ2V0VW5pdmVyc2FsTGluaygpIHtcbiAgICBjb25zdCB1bml2ZXJzYWxMaW5rID0gdGhpcy5yZW1vdGVDb25uZWN0aW9uPy5nZXRVbml2ZXJzYWxMaW5rKCk7XG5cbiAgICBpZiAoIXVuaXZlcnNhbExpbmspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ05vIFVuaXZlcnNhbCBMaW5rIGF2YWlsYWJsZSwgcGxlYXNlIGNhbGwgZXRoX3JlcXVlc3RBY2NvdW50cyBmaXJzdC4nLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5pdmVyc2FsTGluaztcbiAgfVxuXG4gIGdldENoYW5uZWxJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdGVDb25uZWN0aW9uPy5nZXRDaGFubmVsQ29uZmlnKCk/LmNoYW5uZWxJZDtcbiAgfVxuXG4gIGdldFJQQ0hpc3RvcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3RlQ29ubmVjdGlvbj8uZ2V0Q29ubmVjdG9yKCk/LmdldFJQQ01ldGhvZFRyYWNrZXIoKTtcbiAgfVxuXG4gIGdldFZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHBhY2thZ2VKc29uLnZlcnNpb247XG4gIH1cblxuICBnZXREYXBwSWQoKSB7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAgIHR5cGVvZiB3aW5kb3cubG9jYXRpb24gPT09ICd1bmRlZmluZWQnXG4gICAgKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLm9wdGlvbnMuZGFwcE1ldGFkYXRhPy5uYW1lID8/XG4gICAgICAgIHRoaXMub3B0aW9ucy5kYXBwTWV0YWRhdGE/LnVybCA/P1xuICAgICAgICAnTi9BJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYW5vbnltb3VzIElEIGZvciB0aGUgU0RLLlxuICAgKiBUaGlzIElEIGlzIHVzZWQgdG8gdHJhY2sgdGhlIHVzZXIncyBhY3Rpdml0eSBhY3Jvc3MgZGlmZmVyZW50IHNlc3Npb25zIGFub255bW91c2x5LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBhbm9ueW1vdXMgSUQuXG4gICAqL1xuICBhc3luYyBnZXRBbm9uSWQoKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICBpZiAodGhpcy5fYW5vbklkKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYW5vbklkO1xuICAgIH1cblxuICAgIGxldCBhbm9uSWQ6IHN0cmluZztcbiAgICBpZiAodGhpcy5wbGF0Zm9ybU1hbmFnZXI/LmlzQnJvd3NlcigpKSB7XG4gICAgICBhbm9uSWQgPSB0aGlzLmdldEJyb3dzZXJBbm9uSWQoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucGxhdGZvcm1NYW5hZ2VyPy5pc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgIGFub25JZCA9IGF3YWl0IHRoaXMuZ2V0UmVhY3ROYXRpdmVBbm9uSWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5vbklkID0gdXVpZHY0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYW5vbklkID0gYW5vbklkO1xuICAgIHJldHVybiBhbm9uSWQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgb3IgZ2VuZXJhdGUgdGhlIGFub255bW91cyBJRCBmb3IgYnJvd3NlciBlbnZpcm9ubWVudHMgdXNpbmcgbG9jYWxTdG9yYWdlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBhbm9ueW1vdXMgSUQuXG4gICAqL1xuICBwcml2YXRlIGdldEJyb3dzZXJBbm9uSWQoKTogc3RyaW5nIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLkFOT05fSURfU1RPUkFHRV9LRVk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0b3JlZElkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgICAgIGlmIChzdG9yZWRJZCkge1xuICAgICAgICByZXR1cm4gc3RvcmVkSWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBuZXdJZCA9IHV1aWR2NCgpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBuZXdJZCk7XG4gICAgICByZXR1cm4gbmV3SWQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJ1tNZXRhTWFza1NESzogZ2V0QnJvd3NlckFub25JZCgpXSBMb2NhbFN0b3JhZ2UgYWNjZXNzIGVycm9yOicsXG4gICAgICAgIGUsXG4gICAgICApO1xuICAgICAgcmV0dXJuIHV1aWR2NCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSBvciBnZW5lcmF0ZSB0aGUgYW5vbnltb3VzIElEIGZvciBSZWFjdCBOYXRpdmUgZW52aXJvbm1lbnRzIHVzaW5nIEFzeW5jU3RvcmFnZS5cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgYW5vbnltb3VzIElELlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZXRSZWFjdE5hdGl2ZUFub25JZCgpOiBQcm9taXNlPHN0cmluZz4ge1xuICAgIGNvbnN0IGtleSA9IHRoaXMuQU5PTl9JRF9TVE9SQUdFX0tFWTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgQXN5bmNTdG9yYWdlID1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXMsIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHNcbiAgICAgICAgcmVxdWlyZSgnQHJlYWN0LW5hdGl2ZS1hc3luYy1zdG9yYWdlL2FzeW5jLXN0b3JhZ2UnKS5kZWZhdWx0O1xuICAgICAgY29uc3Qgc3RvcmVkSWQgPSBhd2FpdCBBc3luY1N0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgaWYgKHN0b3JlZElkKSB7XG4gICAgICAgIHJldHVybiBzdG9yZWRJZDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0lkID0gdXVpZHY0KCk7XG4gICAgICBhd2FpdCBBc3luY1N0b3JhZ2Uuc2V0SXRlbShrZXksIG5ld0lkKTtcbiAgICAgIHJldHVybiBuZXdJZDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnW01ldGFNYXNrU0RLOiBnZXRSZWFjdE5hdGl2ZUFub25JZCgpXSBFcnJvciBhY2Nlc3NpbmcgQXN5bmNTdG9yYWdlOicsXG4gICAgICAgIGUsXG4gICAgICApO1xuICAgICAgcmV0dXJuIHV1aWR2NCgpO1xuICAgIH1cbiAgfVxuXG4gIGdldFdhbGxldFN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdGVDb25uZWN0aW9uPy5nZXRDb25uZWN0b3IoKT8uZ2V0Q29ubmVjdGlvblN0YXR1cygpO1xuICB9XG5cbiAgLy8gVE9ETzogcmVtb3ZlIG9uY2UgcmVhY2hpbmcgc2RrIDEuMFxuICAvLyBOb3QgZXhwb3NlZC4gU2hvdWxkIG9ubHkgYmUgdXNlZCBkdXJpbmcgZGV2LlxuICBfZ2V0Q2hhbm5lbENvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdGVDb25uZWN0aW9uPy5nZXRDaGFubmVsQ29uZmlnKCk7XG4gIH1cblxuICBfcGluZygpIHtcbiAgICB0aGlzLnJlbW90ZUNvbm5lY3Rpb24/LmdldENvbm5lY3RvcigpPy5waW5nKCk7XG4gIH1cblxuICBfa2V5Q2hlY2soKSB7XG4gICAgdGhpcy5yZW1vdGVDb25uZWN0aW9uPy5nZXRDb25uZWN0b3IoKT8ua2V5Q2hlY2soKTtcbiAgfVxuXG4gIF9nZXRTZXJ2aWNlU3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzLnJlbW90ZUNvbm5lY3Rpb24/LmdldENvbm5lY3RvcigpPy5nZXRTZXJ2aWNlU3RhdHVzKCk7XG4gIH1cblxuICBfZ2V0UmVtb3RlQ29ubmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdGVDb25uZWN0aW9uO1xuICB9XG5cbiAgX2dldERhcHBNZXRhZGF0YSgpOiBEYXBwTWV0YWRhdGEgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLmRhcHBNZXRhZGF0YTtcbiAgfVxuXG4gIF9nZXRLZXlJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLnJlbW90ZUNvbm5lY3Rpb24/LmdldEtleUluZm8oKTtcbiAgfVxuXG4gIF9yZXNldEtleXMoKSB7XG4gICAgdGhpcy5yZW1vdGVDb25uZWN0aW9uPy5nZXRDb25uZWN0b3IoKT8ucmVzZXRLZXlzKCk7XG4gIH1cblxuICBfZ2V0Q29ubmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZW1vdGVDb25uZWN0aW9uO1xuICB9XG5cbiAgcHVibGljIGVtaXQ8SyBleHRlbmRzIE1ldGFNYXNrU0RLRXZlbnRUeXBlPihcbiAgICBldmVudDogSyxcbiAgICBwYXlsb2FkOiBNZXRhTWFza1NES0V2ZW50UGF5bG9hZDxLPixcbiAgKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHN1cGVyLmVtaXQoZXZlbnQsIHBheWxvYWQpO1xuICB9XG5cbiAgcHVibGljIG9uPEsgZXh0ZW5kcyBNZXRhTWFza1NES0V2ZW50VHlwZT4oXG4gICAgZXZlbnQ6IEssXG4gICAgbGlzdGVuZXI6IChwYXlsb2FkOiBNZXRhTWFza1NES0V2ZW50UGF5bG9hZDxLPikgPT4gdm9pZCxcbiAgKTogdGhpcyB7XG4gICAgcmV0dXJuIHN1cGVyLm9uKGV2ZW50LCBsaXN0ZW5lcikgYXMgdGhpcztcbiAgfVxufVxuIiwiaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IE1ldGFNYXNrU0RLIH0gZnJvbSAnLi4vLi4vLi4vc2RrJztcbmltcG9ydCB7IHBlcmZvcm1TREtJbml0aWFsaXphdGlvbiB9IGZyb20gJy4vcGVyZm9ybVNES0luaXRpYWxpemF0aW9uJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgTWV0YU1hc2sgU0RLIGluc3RhbmNlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIHRoZSBTREsgaW5zdGFuY2UgaXMgYWxyZWFkeSBpbml0aWFsaXplZCBvciBpbiB0aGUgcHJvY2VzcyBvZiBpbml0aWFsaXppbmcuXG4gKiBJZiBub3QsIGl0IGNhbGxzICdwZXJmb3JtU0RLSW5pdGlhbGl6YXRpb24nIHRvIGNvbXBsZXRlIHRoZSBpbml0aWFsaXphdGlvbi4gVGhlIGluaXRpYWxpemF0aW9uIHByb21pc2VcbiAqIGlzIHN0b3JlZCBpbiAnaW5zdGFuY2Uuc2RrSW5pdFByb21pc2UnIHRvIHByZXZlbnQgbXVsdGlwbGUgc2ltdWx0YW5lb3VzIGluaXRpYWxpemF0aW9ucy5cbiAqXG4gKiBAcGFyYW0gaW5zdGFuY2UgVGhlIE1ldGFNYXNrU0RLIGluc3RhbmNlIHRvIGJlIGluaXRpYWxpemVkLlxuICogQHJldHVybnMgQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgU0RLIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBpbml0aWFsaXplZC5cbiAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGluaXRpYWxpemF0aW9uIHByb2Nlc3MgZW5jb3VudGVycyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGluaXRpYWxpemVNZXRhTWFza1NESyhpbnN0YW5jZTogTWV0YU1hc2tTREspIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5tbXNkaz8uaXNJbml0aWFsaXplZCgpKSB7XG4gICAgbG9nZ2VyKGBbTWV0YU1hc2tTREs6IGluaXRpYWxpemVNZXRhTWFza1NESygpXSBhbHJlYWR5IGluaXRpYWxpemVkYCk7XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHdpbmRvdy5tbXNkayk7XG4gIH1cblxuICBpZiAoaW5zdGFuY2UuX2luaXRpYWxpemVkKSB7XG4gICAgbG9nZ2VyKGBbTWV0YU1hc2tTREs6IGluaXRpYWxpemVNZXRhTWFza1NESygpXSBhbHJlYWR5IGluaXRpYWxpemVkYCk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2Uuc2RrSW5pdFByb21pc2U7XG4gIH0gZWxzZSBpZiAoaW5zdGFuY2Uuc2RrSW5pdFByb21pc2UpIHtcbiAgICBsb2dnZXIoYFtNZXRhTWFza1NESzogaW5pdGlhbGl6ZU1ldGFNYXNrU0RLKCldIGFscmVhZHkgaW5pdGlhbGl6aW5nYCk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2Uuc2RrSW5pdFByb21pc2U7XG4gIH1cblxuICAvLyBQcmV2ZW50IG11bHRpcGxlIGluc3RhbmNlcyBvZiB0aGUgU0RLIHRvIGJlIGluaXRpYWxpemVkIGF0IHRoZSBzYW1lIHRpbWVcbiAgdHJ5IHtcbiAgICBpbnN0YW5jZS5zZGtJbml0UHJvbWlzZSA9IHBlcmZvcm1TREtJbml0aWFsaXphdGlvbihpbnN0YW5jZSk7XG4gICAgYXdhaXQgaW5zdGFuY2Uuc2RrSW5pdFByb21pc2U7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2Uuc2RrSW5pdFByb21pc2U7XG59XG4iLCJpbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi8uLi8uLi91dGlscy9sb2dnZXInO1xuaW1wb3J0IHsgTWV0YU1hc2tTREsgfSBmcm9tICcuLi8uLi8uLi9zZGsnO1xuaW1wb3J0IHsgUlBDX01FVEhPRFMgfSBmcm9tICcuLi8uLi8uLi9jb25maWcnO1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IGNvbm5lY3RzIHRvIE1ldGFNYXNrIGFuZCByZXF1ZXN0cyBhY2NvdW50IGFjY2Vzcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGZpcnN0IGNoZWNrcyB3aGV0aGVyIHRoZSBNZXRhTWFza1NESyBpbnN0YW5jZSBpcyBpbml0aWFsaXplZC5cbiAqIElmIG5vdCwgaXQgaW5pdGlhbGl6ZXMgdGhlIGluc3RhbmNlLiBJdCB0aGVuIG1ha2VzIGEgcmVxdWVzdCB0byBhY2Nlc3MgYWNjb3VudHNcbiAqIHVzaW5nIHRoZSBhY3RpdmUgcHJvdmlkZXIuIFRocm93cyBhbiBlcnJvciBpZiB0aGUgcHJvdmlkZXIgaXMgdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSBpbnN0YW5jZSBUaGUgTWV0YU1hc2tTREsgaW5zdGFuY2UgdG8gY29ubmVjdCB0by5cbiAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSByZXN1bHQgb2YgdGhlICdldGhfcmVxdWVzdEFjY291bnRzJyByZXF1ZXN0LlxuICogQHRocm93cyBFcnJvciBpZiB0aGUgYWN0aXZlUHJvdmlkZXIgaXMgdW5kZWZpbmVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29ubmVjdChpbnN0YW5jZTogTWV0YU1hc2tTREspOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gIGlmICghaW5zdGFuY2UuX2luaXRpYWxpemVkKSB7XG4gICAgbG9nZ2VyKGBbTWV0YU1hc2tTREs6IGNvbm5lY3QoKV0gcHJvdmlkZXIgbm90IHJlYWR5IC0tIHdhaXQgZm9yIGluaXQoKWApO1xuXG4gICAgYXdhaXQgaW5zdGFuY2UuaW5pdCgpO1xuICB9XG5cbiAgbG9nZ2VyKFxuICAgIGBbTWV0YU1hc2tTREs6IGNvbm5lY3QoKV0gaXNFeHRlbnNpb25BY3RpdmU9JHtpbnN0YW5jZS5pc0V4dGVuc2lvbkFjdGl2ZSgpfSBhY3RpdmVQcm92aWRlcmAsXG4gICAgaW5zdGFuY2UuYWN0aXZlUHJvdmlkZXIsXG4gICk7XG5cbiAgaWYgKCFpbnN0YW5jZS5hY3RpdmVQcm92aWRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgU0RLIHN0YXRlIGludmFsaWQgLS0gdW5kZWZpbmVkIHByb3ZpZGVyYCk7XG4gIH1cblxuICBjb25zdCBzZWxlY3RlZEFkZHJlc3MgPSBpbnN0YW5jZS5hY3RpdmVQcm92aWRlci5nZXRTZWxlY3RlZEFkZHJlc3MoKTtcbiAgaWYgKHNlbGVjdGVkQWRkcmVzcykge1xuICAgIHJldHVybiBbc2VsZWN0ZWRBZGRyZXNzXTtcbiAgfVxuXG4gIC8vIFRPRE86IGVuYWJsZSBvbmNlIE1ldGFNYXNrIE1vYmlsZSB2Ny4yMSBpcyBvdXQgaW4gc3RvcmUuXG4gIC8vIEl0IHdvdWxkIHN0aWxsIHdvcmsgb24gb2xkZXIgd2FsbGV0IGJ1dCB0aGUgY29ubmVjdGlvbiBtb2RhbCBtYXkgYmUgdHJpZ2dlciB0d2ljZS5cbiAgLy8gcmV0dXJuIGluc3RhbmNlLmFjdGl2ZVByb3ZpZGVyLnJlcXVlc3Qoe1xuICAvLyAgIG1ldGhvZDogUlBDX01FVEhPRFMuV0FMTEVUX1JFUVVFU1RQRVJNSVNTSU9OUyxcbiAgLy8gICBwYXJhbXM6IFtcbiAgLy8gICAgIHtcbiAgLy8gICAgICAgZXRoX2FjY291bnRzOiB7fSxcbiAgLy8gICAgIH0sXG4gIC8vICAgXSxcbiAgLy8gfSk7XG4gIHJldHVybiBpbnN0YW5jZS5hY3RpdmVQcm92aWRlci5yZXF1ZXN0PHN0cmluZ1tdPih7XG4gICAgbWV0aG9kOiBSUENfTUVUSE9EUy5FVEhfUkVRVUVTVEFDQ09VTlRTLFxuICAgIHBhcmFtczogW10sXG4gIH0pIGFzIFByb21pc2U8c3RyaW5nW10+O1xufVxuIiwiaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi4vLi4vLi4vdXRpbHMvbG9nZ2VyJztcbmltcG9ydCB7IFJQQ19NRVRIT0RTIH0gZnJvbSAnLi4vLi4vLi4vY29uZmlnJztcbmltcG9ydCB7IE1ldGFNYXNrU0RLIH0gZnJvbSAnLi4vLi4vLi4vc2RrJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbm5lY3RXaXRoKHtcbiAgaW5zdGFuY2UsXG4gIHJwYyxcbn06IHtcbiAgaW5zdGFuY2U6IE1ldGFNYXNrU0RLO1xuICBycGM6IHsgbWV0aG9kOiBzdHJpbmc7IHBhcmFtczogYW55W10gfTtcbn0pIHtcbiAgaWYgKCFpbnN0YW5jZS5faW5pdGlhbGl6ZWQpIHtcbiAgICBsb2dnZXIoXG4gICAgICBgW01ldGFNYXNrU0RLOiBjb25uZWN0V2l0aCgpXSBwcm92aWRlciBub3QgcmVhZHkgLS0gd2FpdCBmb3IgaW5pdCgpYCxcbiAgICApO1xuXG4gICAgYXdhaXQgaW5zdGFuY2UuaW5pdCgpO1xuICB9XG5cbiAgbG9nZ2VyKGBbTWV0YU1hc2tTREs6IGNvbm5lY3RXaXRoKCldIG1ldGhvZDogJHtycGMubWV0aG9kfSBycGM9JHtycGN9YCk7XG5cbiAgaWYgKCFpbnN0YW5jZS5hY3RpdmVQcm92aWRlcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgU0RLIHN0YXRlIGludmFsaWQgLS0gdW5kZWZpbmVkIHByb3ZpZGVyYCk7XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2UuYWN0aXZlUHJvdmlkZXIucmVxdWVzdCh7XG4gICAgbWV0aG9kOiBSUENfTUVUSE9EUy5NRVRBTUFTS19DT05ORUNUV0lUSCxcbiAgICBwYXJhbXM6IFtycGNdLFxuICB9KTtcbn1cbiIsImltcG9ydCB7IGxvZ2dlciB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2xvZ2dlcic7XG5pbXBvcnQgeyBNZXRhTWFza1NESyB9IGZyb20gJy4uLy4uLy4uL3Nkayc7XG5cbi8qKlxuICogUmVzdW1lcyB0aGUgTWV0YU1hc2tTREsncyByZW1vdGUgY29ubmVjdGlvbiBpZiBpdCBpcyBub3QgYWxyZWFkeSByZWFkeS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNoZWNrcyBpZiB0aGUgcmVtb3RlIGNvbm5lY3Rpb24ncyBjb25uZWN0b3IgaXMgcmVhZHkgdG8gdHJhbnNtaXQgZGF0YS4gSWYgbm90LFxuICogaXQgaW5pdGlhdGVzIHRoZSBjb25uZWN0aW9uLiBUaGlzIGlzIHVzZWZ1bCBpbiBzY2VuYXJpb3Mgd2hlcmUgdGhlIFNESyBtaWdodCBoYXZlIGdvbmUgdG8gYVxuICogJ3NsZWVwJyBzdGF0ZSBhbmQgbmVlZHMgdG8gYmUgJ2F3YWtlbmVkJyB0byByZS1lc3RhYmxpc2ggdGhlIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIGluc3RhbmNlIFRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSBNZXRhTWFza1NESywgd2hpY2ggY29udGFpbnMgdXNlci1kZWZpbmVkIG9yIGRlZmF1bHQgb3B0aW9ucy5cbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjb25uZWN0aW9uIGhhcyBiZWVuIHN0YXJ0ZWQgb3IgaXMgYWxyZWFkeSByZWFkeS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc3VtZShpbnN0YW5jZTogTWV0YU1hc2tTREspIHtcbiAgaWYgKCFpbnN0YW5jZS5yZW1vdGVDb25uZWN0aW9uPy5nZXRDb25uZWN0b3IoKT8uaXNSZWFkeSgpKSB7XG4gICAgbG9nZ2VyKFxuICAgICAgYFtNZXRhTWFza1NESzogcmVzdW1lKCldIGNoYW5uZWwgaXMgbm90IHJlYWR5IC0tIHN0YXJ0aW5nIGNvbm5lY3Rpb25gLFxuICAgICk7XG5cbiAgICBpbnN0YW5jZS5yZW1vdGVDb25uZWN0aW9uPy5zdGFydENvbm5lY3Rpb24oKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBsb2dnZXIoYFtNZXRhTWFza1NESzogcmVzdW1lKCldIGNoYW5uZWwgaXMgcmVhZHlgKTtcbn1cbiIsImltcG9ydCB7XG4gIENoYW5uZWxDb25maWcsXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tc2hhZG93XG4gIFN0b3JhZ2VNYW5hZ2VyLFxuICBTdG9yYWdlTWFuYWdlclByb3BzLFxufSBmcm9tICdAbWV0YW1hc2svc2RrLWNvbW11bmljYXRpb24tbGF5ZXInO1xuaW1wb3J0IHtcbiAgU1RPUkFHRV9EQVBQX0NIQUlOSUQsXG4gIFNUT1JBR0VfREFQUF9TRUxFQ1RFRF9BRERSRVNTLFxuICBTVE9SQUdFX1BBVEgsXG59IGZyb20gJy4uL2NvbmZpZyc7XG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuLi91dGlscy9sb2dnZXInO1xuXG5leHBvcnQgY2xhc3MgU3RvcmFnZU1hbmFnZXJXZWIgaW1wbGVtZW50cyBTdG9yYWdlTWFuYWdlciB7XG4gIHByaXZhdGUgZW5hYmxlZCA9IGZhbHNlO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHsgZW5hYmxlZCB9OiBTdG9yYWdlTWFuYWdlclByb3BzIHwgdW5kZWZpbmVkID0ge1xuICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgfSxcbiAgKSB7XG4gICAgdGhpcy5lbmFibGVkID0gZW5hYmxlZDtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBwZXJzaXN0Q2hhbm5lbENvbmZpZyhjaGFubmVsQ29uZmlnOiBDaGFubmVsQ29uZmlnKSB7XG4gICAgY29uc3QgcGF5bG9hZCA9IEpTT04uc3RyaW5naWZ5KGNoYW5uZWxDb25maWcpO1xuXG4gICAgbG9nZ2VyKFxuICAgICAgYFtTdG9yYWdlTWFuYWdlcldlYjogcGVyc2lzdENoYW5uZWxDb25maWcoKV0gZW5hYmxlZD0ke3RoaXMuZW5hYmxlZH1gLFxuICAgICAgY2hhbm5lbENvbmZpZyxcbiAgICApO1xuXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9QQVRILCBwYXlsb2FkKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRQZXJzaXN0ZWRDaGFubmVsQ29uZmlnKCk6IFByb21pc2U8Q2hhbm5lbENvbmZpZyB8IHVuZGVmaW5lZD4ge1xuICAgIGxldCBwYXlsb2FkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGxvZ2dlcihcbiAgICAgICAgYFtTdG9yYWdlTWFuYWdlcldlYjogZ2V0UGVyc2lzdGVkQ2hhbm5lbENvbmZpZygpXSBlbmFibGVkPSR7dGhpcy5lbmFibGVkfWAsXG4gICAgICApO1xuXG4gICAgICBwYXlsb2FkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oU1RPUkFHRV9QQVRIKTtcblxuICAgICAgbG9nZ2VyKGBbU3RvcmFnZU1hbmFnZXJXZWI6IGdldFBlcnNpc3RlZENoYW5uZWxDb25maWcoKV1gLCBwYXlsb2FkKTtcblxuICAgICAgaWYgKCFwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoYW5uZWxDb25maWcgPSBKU09OLnBhcnNlKHBheWxvYWQpIGFzIENoYW5uZWxDb25maWc7XG4gICAgICBsb2dnZXIoXG4gICAgICAgIGBbU3RvcmFnZU1hbmFnZXJXZWI6IGdldFBlcnNpc3RlZENoYW5uZWxDb25maWcoKV0gY2hhbm5lbENvbmZpZ2AsXG4gICAgICAgIGNoYW5uZWxDb25maWcsXG4gICAgICApO1xuXG4gICAgICByZXR1cm4gY2hhbm5lbENvbmZpZztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgW1N0b3JhZ2VNYW5hZ2VyV2ViOiBnZXRQZXJzaXN0ZWRDaGFubmVsQ29uZmlnKCldIENhbid0IGZpbmQgZXhpc3RpbmcgY2hhbm5lbCBjb25maWdgLFxuICAgICAgICBlLFxuICAgICAgKTtcbiAgICAgIC8vIElnbm9yZSBlcnJvcnNcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIHBlcnNpc3RBY2NvdW50cyhhY2NvdW50czogc3RyaW5nW10pIHtcbiAgICBsb2dnZXIoXG4gICAgICBgW1N0b3JhZ2VNYW5hZ2VyV2ViOiBwZXJzaXN0QWNjb3VudHMoKV0gZW5hYmxlZD0ke3RoaXMuZW5hYmxlZH1gLFxuICAgICAgYWNjb3VudHMsXG4gICAgKTtcblxuICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShhY2NvdW50cyk7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9EQVBQX1NFTEVDVEVEX0FERFJFU1MsIHBheWxvYWQpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldENhY2hlZEFjY291bnRzKCk6IFByb21pc2U8c3RyaW5nW10+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmF3QWNjb3VudHMgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0RBUFBfU0VMRUNURURfQUREUkVTUyk7XG4gICAgICBpZiAoIXJhd0FjY291bnRzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBKU09OLnBhcnNlKHJhd0FjY291bnRzKSBhcyBzdHJpbmdbXTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYFtTdG9yYWdlTWFuYWdlcldlYjogZ2V0Q2FjaGVkQWNjb3VudHMoKV0gRXJyb3IgcmVhZGluZyBjYWNoZWQgYWNjb3VudHNgLFxuICAgICAgICBlcnJvcixcbiAgICAgICk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcGVyc2lzdENoYWluSWQoY2hhaW5JZDogc3RyaW5nKSB7XG4gICAgbG9nZ2VyKFxuICAgICAgYFtTdG9yYWdlTWFuYWdlcldlYjogcGVyc2lzdENoYWluSWQoKV0gZW5hYmxlZD0ke3RoaXMuZW5hYmxlZH1gLFxuICAgICAgY2hhaW5JZCxcbiAgICApO1xuXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9EQVBQX0NIQUlOSUQsIGNoYWluSWQpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGdldENhY2hlZENoYWluSWQoKTogUHJvbWlzZTxzdHJpbmcgfCB1bmRlZmluZWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2hhaW5JZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0VfREFQUF9DSEFJTklEKTtcbiAgICAgIHJldHVybiBjaGFpbklkID8/IHVuZGVmaW5lZDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYFtTdG9yYWdlTWFuYWdlcldlYjogZ2V0Q2FjaGVkQ2hhaW5JZCgpXSBFcnJvciByZWFkaW5nIGNhY2hlZCBjaGFpbklkYCxcbiAgICAgICAgZXJyb3IsXG4gICAgICApO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIHRlcm1pbmF0ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBsb2dnZXIoYFtTdG9yYWdlTWFuYWdlcldlYjogdGVybWluYXRlKCldIGVuYWJsZWQ9JHt0aGlzLmVuYWJsZWR9YCk7XG5cbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShTVE9SQUdFX1BBVEgpO1xuICB9XG59XG4iLCJjb25zdCBOQU1FU1BBQ0UgPSAnc2RrLWluc3RhbGwtbW9kYWwtd2ViJztcbmNvbnN0IEJVSUxEID0gLyogc2RrLWluc3RhbGwtbW9kYWwtd2ViICovIHsgYWxsUmVuZGVyRm46IHRydWUsIGFwcGVuZENoaWxkU2xvdEZpeDogZmFsc2UsIGFzeW5jTG9hZGluZzogdHJ1ZSwgYXN5bmNRdWV1ZTogZmFsc2UsIGF0dGFjaFN0eWxlczogdHJ1ZSwgY2xvbmVOb2RlRml4OiBmYWxzZSwgY21wRGlkTG9hZDogdHJ1ZSwgY21wRGlkUmVuZGVyOiBmYWxzZSwgY21wRGlkVW5sb2FkOiBmYWxzZSwgY21wRGlkVXBkYXRlOiBmYWxzZSwgY21wU2hvdWxkVXBkYXRlOiBmYWxzZSwgY21wV2lsbExvYWQ6IGZhbHNlLCBjbXBXaWxsUmVuZGVyOiBmYWxzZSwgY21wV2lsbFVwZGF0ZTogZmFsc2UsIGNvbm5lY3RlZENhbGxiYWNrOiB0cnVlLCBjb25zdHJ1Y3RhYmxlQ1NTOiB0cnVlLCBjc3NBbm5vdGF0aW9uczogdHJ1ZSwgZGV2VG9vbHM6IGZhbHNlLCBkaXNjb25uZWN0ZWRDYWxsYmFjazogdHJ1ZSwgZWxlbWVudDogZmFsc2UsIGV2ZW50OiB0cnVlLCBleHBlcmltZW50YWxTY29wZWRTbG90Q2hhbmdlczogZmFsc2UsIGV4cGVyaW1lbnRhbFNsb3RGaXhlczogZmFsc2UsIGZvcm1Bc3NvY2lhdGVkOiBmYWxzZSwgaGFzUmVuZGVyRm46IHRydWUsIGhvc3RMaXN0ZW5lcjogZmFsc2UsIGhvc3RMaXN0ZW5lclRhcmdldDogZmFsc2UsIGhvc3RMaXN0ZW5lclRhcmdldEJvZHk6IGZhbHNlLCBob3N0TGlzdGVuZXJUYXJnZXREb2N1bWVudDogZmFsc2UsIGhvc3RMaXN0ZW5lclRhcmdldFBhcmVudDogZmFsc2UsIGhvc3RMaXN0ZW5lclRhcmdldFdpbmRvdzogZmFsc2UsIGhvdE1vZHVsZVJlcGxhY2VtZW50OiBmYWxzZSwgaHlkcmF0ZUNsaWVudFNpZGU6IGZhbHNlLCBoeWRyYXRlU2VydmVyU2lkZTogZmFsc2UsIGh5ZHJhdGVkQXR0cmlidXRlOiBmYWxzZSwgaHlkcmF0ZWRDbGFzczogdHJ1ZSwgaHlkcmF0ZWRTZWxlY3Rvck5hbWU6IFwiaHlkcmF0ZWRcIiwgaW5pdGlhbGl6ZU5leHRUaWNrOiBmYWxzZSwgaW52aXNpYmxlUHJlaHlkcmF0aW9uOiB0cnVlLCBpc0RlYnVnOiBmYWxzZSwgaXNEZXY6IGZhbHNlLCBpc1Rlc3Rpbmc6IGZhbHNlLCBsYXp5TG9hZDogdHJ1ZSwgbGlmZWN5Y2xlOiB0cnVlLCBsaWZlY3ljbGVET01FdmVudHM6IGZhbHNlLCBtZW1iZXI6IHRydWUsIG1ldGhvZDogZmFsc2UsIG1vZGU6IGZhbHNlLCBvYnNlcnZlQXR0cmlidXRlOiB0cnVlLCBwcm9maWxlOiBmYWxzZSwgcHJvcDogdHJ1ZSwgcHJvcEJvb2xlYW46IHRydWUsIHByb3BNdXRhYmxlOiBmYWxzZSwgcHJvcE51bWJlcjogZmFsc2UsIHByb3BTdHJpbmc6IHRydWUsIHJlZmxlY3Q6IGZhbHNlLCBzY29wZWQ6IGZhbHNlLCBzY29wZWRTbG90VGV4dENvbnRlbnRGaXg6IGZhbHNlLCBzY3JpcHREYXRhT3B0czogZmFsc2UsIHNoYWRvd0RlbGVnYXRlc0ZvY3VzOiBmYWxzZSwgc2hhZG93RG9tOiB0cnVlLCBzbG90OiBmYWxzZSwgc2xvdENoaWxkTm9kZXNGaXg6IGZhbHNlLCBzbG90UmVsb2NhdGlvbjogZmFsc2UsIHN0YXRlOiB0cnVlLCBzdHlsZTogdHJ1ZSwgc3ZnOiB0cnVlLCB0YXNrUXVldWU6IHRydWUsIHRyYW5zZm9ybVRhZ05hbWU6IGZhbHNlLCB1cGRhdGFibGU6IHRydWUsIHZkb21BdHRyaWJ1dGU6IHRydWUsIHZkb21DbGFzczogdHJ1ZSwgdmRvbUZ1bmN0aW9uYWw6IHRydWUsIHZkb21LZXk6IGZhbHNlLCB2ZG9tTGlzdGVuZXI6IHRydWUsIHZkb21Qcm9wT3JBdHRyOiB0cnVlLCB2ZG9tUmVmOiBmYWxzZSwgdmRvbVJlbmRlcjogdHJ1ZSwgdmRvbVN0eWxlOiB0cnVlLCB2ZG9tVGV4dDogdHJ1ZSwgdmRvbVhsaW5rOiBmYWxzZSwgd2F0Y2hDYWxsYmFjazogdHJ1ZSB9O1xuXG4vKlxuIFN0ZW5jaWwgQ2xpZW50IFBsYXRmb3JtIHY0LjIyLjIgfCBNSVQgTGljZW5zZWQgfCBodHRwczovL3N0ZW5jaWxqcy5jb21cbiAqL1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lIGluIGFsbClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBuYW1lLCB7IGdldDogYWxsW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcbnZhciBob3N0UmVmcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIGdldEhvc3RSZWYgPSAocmVmKSA9PiBob3N0UmVmcy5nZXQocmVmKTtcbnZhciByZWdpc3Rlckluc3RhbmNlID0gKGxhenlJbnN0YW5jZSwgaG9zdFJlZikgPT4gaG9zdFJlZnMuc2V0KGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgPSBsYXp5SW5zdGFuY2UsIGhvc3RSZWYpO1xudmFyIHJlZ2lzdGVySG9zdCA9IChob3N0RWxlbWVudCwgY21wTWV0YSkgPT4ge1xuICBjb25zdCBob3N0UmVmID0ge1xuICAgICRmbGFncyQ6IDAsXG4gICAgJGhvc3RFbGVtZW50JDogaG9zdEVsZW1lbnQsXG4gICAgJGNtcE1ldGEkOiBjbXBNZXRhLFxuICAgICRpbnN0YW5jZVZhbHVlcyQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKClcbiAgfTtcbiAge1xuICAgIGhvc3RSZWYuJG9uUmVhZHlQcm9taXNlJCA9IG5ldyBQcm9taXNlKChyKSA9PiBob3N0UmVmLiRvblJlYWR5UmVzb2x2ZSQgPSByKTtcbiAgICBob3N0RWxlbWVudFtcInMtcFwiXSA9IFtdO1xuICAgIGhvc3RFbGVtZW50W1wicy1yY1wiXSA9IFtdO1xuICB9XG4gIHJldHVybiBob3N0UmVmcy5zZXQoaG9zdEVsZW1lbnQsIGhvc3RSZWYpO1xufTtcbnZhciBpc01lbWJlckluRWxlbWVudCA9IChlbG0sIG1lbWJlck5hbWUpID0+IG1lbWJlck5hbWUgaW4gZWxtO1xudmFyIGNvbnNvbGVFcnJvciA9IChlLCBlbCkgPT4gKDAsIGNvbnNvbGUuZXJyb3IpKGUsIGVsKTtcblxuLy8gc3JjL2NsaWVudC9jbGllbnQtbG9hZC1tb2R1bGUudHNcbnZhciBjbXBNb2R1bGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbnZhciBsb2FkTW9kdWxlID0gKGNtcE1ldGEsIGhvc3RSZWYsIGhtclZlcnNpb25JZCkgPT4ge1xuICBjb25zdCBleHBvcnROYW1lID0gY21wTWV0YS4kdGFnTmFtZSQucmVwbGFjZSgvLS9nLCBcIl9cIik7XG4gIGNvbnN0IGJ1bmRsZUlkID0gY21wTWV0YS4kbGF6eUJ1bmRsZUlkJDtcbiAgaWYgKCFidW5kbGVJZCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgbW9kdWxlID0gY21wTW9kdWxlcy5nZXQoYnVuZGxlSWQpIDtcbiAgaWYgKG1vZHVsZSkge1xuICAgIHJldHVybiBtb2R1bGVbZXhwb3J0TmFtZV07XG4gIH1cbiAgXG4gICAgICAgIGlmICghaG1yVmVyc2lvbklkIHx8ICFCVUlMRC5ob3RNb2R1bGVSZXBsYWNlbWVudCkge1xuICAgICAgICAgIGNvbnN0IHByb2Nlc3NNb2QgPSBpbXBvcnRlZE1vZHVsZSA9PiB7XG4gICAgICAgICAgICAgIGNtcE1vZHVsZXMuc2V0KGJ1bmRsZUlkLCBpbXBvcnRlZE1vZHVsZSk7XG4gICAgICAgICAgICAgIHJldHVybiBpbXBvcnRlZE1vZHVsZVtleHBvcnROYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoKGJ1bmRsZUlkKSB7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNhc2UgJ21tLWluc3RhbGwtbW9kYWxfMyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbXBvcnQoXG4gICAgICAgICAgICAgICAgICAgICAgLyogd2VicGFja01vZGU6IFwibGF6eVwiICovXG4gICAgICAgICAgICAgICAgICAgICAgJy4vbW0taW5zdGFsbC1tb2RhbF8zLmVudHJ5LmpzJykudGhlbihwcm9jZXNzTW9kLCBjb25zb2xlRXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgcmV0dXJuIGltcG9ydChcbiAgICAvKiBAdml0ZS1pZ25vcmUgKi9cbiAgICAvKiB3ZWJwYWNrSW5jbHVkZTogL1xcLmVudHJ5XFwuanMkLyAqL1xuICAgIC8qIHdlYnBhY2tFeGNsdWRlOiAvXFwuc3lzdGVtXFwuZW50cnlcXC5qcyQvICovXG4gICAgLyogd2VicGFja01vZGU6IFwibGF6eVwiICovXG4gICAgYC4vJHtidW5kbGVJZH0uZW50cnkuanMke1wiXCJ9YFxuICApLnRoZW4oKGltcG9ydGVkTW9kdWxlKSA9PiB7XG4gICAge1xuICAgICAgY21wTW9kdWxlcy5zZXQoYnVuZGxlSWQsIGltcG9ydGVkTW9kdWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIGltcG9ydGVkTW9kdWxlW2V4cG9ydE5hbWVdO1xuICB9LCBjb25zb2xlRXJyb3IpO1xufTtcblxuLy8gc3JjL2NsaWVudC9jbGllbnQtc3R5bGUudHNcbnZhciBzdHlsZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xudmFyIEhZRFJBVEVEX0NTUyA9IFwie3Zpc2liaWxpdHk6aGlkZGVufS5oeWRyYXRlZHt2aXNpYmlsaXR5OmluaGVyaXR9XCI7XG52YXIgU0xPVF9GQl9DU1MgPSBcInNsb3QtZmJ7ZGlzcGxheTpjb250ZW50c31zbG90LWZiW2hpZGRlbl17ZGlzcGxheTpub25lfVwiO1xudmFyIHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fTtcbnZhciBkb2MgPSB3aW4uZG9jdW1lbnQgfHwgeyBoZWFkOiB7fSB9O1xudmFyIHBsdCA9IHtcbiAgJGZsYWdzJDogMCxcbiAgJHJlc291cmNlc1VybCQ6IFwiXCIsXG4gIGptcDogKGgyKSA9PiBoMigpLFxuICByYWY6IChoMikgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGgyKSxcbiAgYWVsOiAoZWwsIGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdHMpID0+IGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0cyksXG4gIHJlbDogKGVsLCBldmVudE5hbWUsIGxpc3RlbmVyLCBvcHRzKSA9PiBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIsIG9wdHMpLFxuICBjZTogKGV2ZW50TmFtZSwgb3B0cykgPT4gbmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgb3B0cylcbn07XG52YXIgcHJvbWlzZVJlc29sdmUgPSAodikgPT4gUHJvbWlzZS5yZXNvbHZlKHYpO1xudmFyIHN1cHBvcnRzQ29uc3RydWN0YWJsZVN0eWxlc2hlZXRzID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gIHRyeSB7XG4gICAgbmV3IENTU1N0eWxlU2hlZXQoKTtcbiAgICByZXR1cm4gdHlwZW9mIG5ldyBDU1NTdHlsZVNoZWV0KCkucmVwbGFjZVN5bmMgPT09IFwiZnVuY3Rpb25cIjtcbiAgfSBjYXRjaCAoZSkge1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn0pKCkgO1xudmFyIHF1ZXVlUGVuZGluZyA9IGZhbHNlO1xudmFyIHF1ZXVlRG9tUmVhZHMgPSBbXTtcbnZhciBxdWV1ZURvbVdyaXRlcyA9IFtdO1xudmFyIHF1ZXVlVGFzayA9IChxdWV1ZSwgd3JpdGUpID0+IChjYikgPT4ge1xuICBxdWV1ZS5wdXNoKGNiKTtcbiAgaWYgKCFxdWV1ZVBlbmRpbmcpIHtcbiAgICBxdWV1ZVBlbmRpbmcgPSB0cnVlO1xuICAgIGlmICh3cml0ZSAmJiBwbHQuJGZsYWdzJCAmIDQgLyogcXVldWVTeW5jICovKSB7XG4gICAgICBuZXh0VGljayhmbHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBsdC5yYWYoZmx1c2gpO1xuICAgIH1cbiAgfVxufTtcbnZhciBjb25zdW1lID0gKHF1ZXVlKSA9PiB7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBxdWV1ZS5sZW5ndGg7IGkyKyspIHtcbiAgICB0cnkge1xuICAgICAgcXVldWVbaTJdKHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgfVxuICB9XG4gIHF1ZXVlLmxlbmd0aCA9IDA7XG59O1xudmFyIGZsdXNoID0gKCkgPT4ge1xuICBjb25zdW1lKHF1ZXVlRG9tUmVhZHMpO1xuICB7XG4gICAgY29uc3VtZShxdWV1ZURvbVdyaXRlcyk7XG4gICAgaWYgKHF1ZXVlUGVuZGluZyA9IHF1ZXVlRG9tUmVhZHMubGVuZ3RoID4gMCkge1xuICAgICAgcGx0LnJhZihmbHVzaCk7XG4gICAgfVxuICB9XG59O1xudmFyIG5leHRUaWNrID0gKGNiKSA9PiBwcm9taXNlUmVzb2x2ZSgpLnRoZW4oY2IpO1xudmFyIHdyaXRlVGFzayA9IC8qIEBfX1BVUkVfXyAqLyBxdWV1ZVRhc2socXVldWVEb21Xcml0ZXMsIHRydWUpO1xuXG4vLyBzcmMvdXRpbHMvY29uc3RhbnRzLnRzXG52YXIgRU1QVFlfT0JKID0ge307XG52YXIgU1ZHX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xudmFyIEhUTUxfTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIjtcblxuLy8gc3JjL3V0aWxzL2hlbHBlcnMudHNcbnZhciBpc0RlZiA9ICh2KSA9PiB2ICE9IG51bGw7XG52YXIgaXNDb21wbGV4VHlwZSA9IChvKSA9PiB7XG4gIG8gPSB0eXBlb2YgbztcbiAgcmV0dXJuIG8gPT09IFwib2JqZWN0XCIgfHwgbyA9PT0gXCJmdW5jdGlvblwiO1xufTtcblxuLy8gc3JjL3V0aWxzL3F1ZXJ5LW5vbmNlLW1ldGEtdGFnLWNvbnRlbnQudHNcbmZ1bmN0aW9uIHF1ZXJ5Tm9uY2VNZXRhVGFnQ29udGVudChkb2MyKSB7XG4gIHZhciBfYSwgX2IsIF9jO1xuICByZXR1cm4gKF9jID0gKF9iID0gKF9hID0gZG9jMi5oZWFkKSA9PSBudWxsID8gdm9pZCAwIDogX2EucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiY3NwLW5vbmNlXCJdJykpID09IG51bGwgPyB2b2lkIDAgOiBfYi5nZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIpKSAhPSBudWxsID8gX2MgOiB2b2lkIDA7XG59XG5cbi8vIHNyYy91dGlscy9yZXN1bHQudHNcbnZhciByZXN1bHRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQocmVzdWx0X2V4cG9ydHMsIHtcbiAgZXJyOiAoKSA9PiBlcnIsXG4gIG1hcDogKCkgPT4gbWFwLFxuICBvazogKCkgPT4gb2ssXG4gIHVud3JhcDogKCkgPT4gdW53cmFwLFxuICB1bndyYXBFcnI6ICgpID0+IHVud3JhcEVyclxufSk7XG52YXIgb2sgPSAodmFsdWUpID0+ICh7XG4gIGlzT2s6IHRydWUsXG4gIGlzRXJyOiBmYWxzZSxcbiAgdmFsdWVcbn0pO1xudmFyIGVyciA9ICh2YWx1ZSkgPT4gKHtcbiAgaXNPazogZmFsc2UsXG4gIGlzRXJyOiB0cnVlLFxuICB2YWx1ZVxufSk7XG5mdW5jdGlvbiBtYXAocmVzdWx0LCBmbikge1xuICBpZiAocmVzdWx0LmlzT2spIHtcbiAgICBjb25zdCB2YWwgPSBmbihyZXN1bHQudmFsdWUpO1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gdmFsLnRoZW4oKG5ld1ZhbCkgPT4gb2sobmV3VmFsKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvayh2YWwpO1xuICAgIH1cbiAgfVxuICBpZiAocmVzdWx0LmlzRXJyKSB7XG4gICAgY29uc3QgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgcmV0dXJuIGVycih2YWx1ZSk7XG4gIH1cbiAgdGhyb3cgXCJzaG91bGQgbmV2ZXIgZ2V0IGhlcmVcIjtcbn1cbnZhciB1bndyYXAgPSAocmVzdWx0KSA9PiB7XG4gIGlmIChyZXN1bHQuaXNPaykge1xuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgcmVzdWx0LnZhbHVlO1xuICB9XG59O1xudmFyIHVud3JhcEVyciA9IChyZXN1bHQpID0+IHtcbiAgaWYgKHJlc3VsdC5pc0Vycikge1xuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgcmVzdWx0LnZhbHVlO1xuICB9XG59O1xudmFyIGNyZWF0ZVRpbWUgPSAoZm5OYW1lLCB0YWdOYW1lID0gXCJcIikgPT4ge1xuICB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJldHVybjtcbiAgICB9O1xuICB9XG59O1xudmFyIHVuaXF1ZVRpbWUgPSAoa2V5LCBtZWFzdXJlVGV4dCkgPT4ge1xuICB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJldHVybjtcbiAgICB9O1xuICB9XG59O1xudmFyIGggPSAobm9kZU5hbWUsIHZub2RlRGF0YSwgLi4uY2hpbGRyZW4pID0+IHtcbiAgbGV0IGNoaWxkID0gbnVsbDtcbiAgbGV0IHNpbXBsZSA9IGZhbHNlO1xuICBsZXQgbGFzdFNpbXBsZSA9IGZhbHNlO1xuICBjb25zdCB2Tm9kZUNoaWxkcmVuID0gW107XG4gIGNvbnN0IHdhbGsgPSAoYykgPT4ge1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBjLmxlbmd0aDsgaTIrKykge1xuICAgICAgY2hpbGQgPSBjW2kyXTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkKSkge1xuICAgICAgICB3YWxrKGNoaWxkKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQgIT0gbnVsbCAmJiB0eXBlb2YgY2hpbGQgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIGlmIChzaW1wbGUgPSB0eXBlb2Ygbm9kZU5hbWUgIT09IFwiZnVuY3Rpb25cIiAmJiAhaXNDb21wbGV4VHlwZShjaGlsZCkpIHtcbiAgICAgICAgICBjaGlsZCA9IFN0cmluZyhjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpbXBsZSAmJiBsYXN0U2ltcGxlKSB7XG4gICAgICAgICAgdk5vZGVDaGlsZHJlblt2Tm9kZUNoaWxkcmVuLmxlbmd0aCAtIDFdLiR0ZXh0JCArPSBjaGlsZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2Tm9kZUNoaWxkcmVuLnB1c2goc2ltcGxlID8gbmV3Vk5vZGUobnVsbCwgY2hpbGQpIDogY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RTaW1wbGUgPSBzaW1wbGU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB3YWxrKGNoaWxkcmVuKTtcbiAgaWYgKHZub2RlRGF0YSkge1xuICAgIHtcbiAgICAgIGNvbnN0IGNsYXNzRGF0YSA9IHZub2RlRGF0YS5jbGFzc05hbWUgfHwgdm5vZGVEYXRhLmNsYXNzO1xuICAgICAgaWYgKGNsYXNzRGF0YSkge1xuICAgICAgICB2bm9kZURhdGEuY2xhc3MgPSB0eXBlb2YgY2xhc3NEYXRhICE9PSBcIm9iamVjdFwiID8gY2xhc3NEYXRhIDogT2JqZWN0LmtleXMoY2xhc3NEYXRhKS5maWx0ZXIoKGspID0+IGNsYXNzRGF0YVtrXSkuam9pbihcIiBcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygbm9kZU5hbWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBub2RlTmFtZShcbiAgICAgIHZub2RlRGF0YSA9PT0gbnVsbCA/IHt9IDogdm5vZGVEYXRhLFxuICAgICAgdk5vZGVDaGlsZHJlbixcbiAgICAgIHZkb21GblV0aWxzXG4gICAgKTtcbiAgfVxuICBjb25zdCB2bm9kZSA9IG5ld1ZOb2RlKG5vZGVOYW1lLCBudWxsKTtcbiAgdm5vZGUuJGF0dHJzJCA9IHZub2RlRGF0YTtcbiAgaWYgKHZOb2RlQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgIHZub2RlLiRjaGlsZHJlbiQgPSB2Tm9kZUNoaWxkcmVuO1xuICB9XG4gIHJldHVybiB2bm9kZTtcbn07XG52YXIgbmV3Vk5vZGUgPSAodGFnLCB0ZXh0KSA9PiB7XG4gIGNvbnN0IHZub2RlID0ge1xuICAgICRmbGFncyQ6IDAsXG4gICAgJHRhZyQ6IHRhZyxcbiAgICAkdGV4dCQ6IHRleHQsXG4gICAgJGVsbSQ6IG51bGwsXG4gICAgJGNoaWxkcmVuJDogbnVsbFxuICB9O1xuICB7XG4gICAgdm5vZGUuJGF0dHJzJCA9IG51bGw7XG4gIH1cbiAgcmV0dXJuIHZub2RlO1xufTtcbnZhciBIb3N0ID0ge307XG52YXIgaXNIb3N0ID0gKG5vZGUpID0+IG5vZGUgJiYgbm9kZS4kdGFnJCA9PT0gSG9zdDtcbnZhciB2ZG9tRm5VdGlscyA9IHtcbiAgZm9yRWFjaDogKGNoaWxkcmVuLCBjYikgPT4gY2hpbGRyZW4ubWFwKGNvbnZlcnRUb1B1YmxpYykuZm9yRWFjaChjYiksXG4gIG1hcDogKGNoaWxkcmVuLCBjYikgPT4gY2hpbGRyZW4ubWFwKGNvbnZlcnRUb1B1YmxpYykubWFwKGNiKS5tYXAoY29udmVydFRvUHJpdmF0ZSlcbn07XG52YXIgY29udmVydFRvUHVibGljID0gKG5vZGUpID0+ICh7XG4gIHZhdHRyczogbm9kZS4kYXR0cnMkLFxuICB2Y2hpbGRyZW46IG5vZGUuJGNoaWxkcmVuJCxcbiAgdmtleTogbm9kZS4ka2V5JCxcbiAgdm5hbWU6IG5vZGUuJG5hbWUkLFxuICB2dGFnOiBub2RlLiR0YWckLFxuICB2dGV4dDogbm9kZS4kdGV4dCRcbn0pO1xudmFyIGNvbnZlcnRUb1ByaXZhdGUgPSAobm9kZSkgPT4ge1xuICBpZiAodHlwZW9mIG5vZGUudnRhZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3Qgdm5vZGVEYXRhID0geyAuLi5ub2RlLnZhdHRycyB9O1xuICAgIGlmIChub2RlLnZrZXkpIHtcbiAgICAgIHZub2RlRGF0YS5rZXkgPSBub2RlLnZrZXk7XG4gICAgfVxuICAgIGlmIChub2RlLnZuYW1lKSB7XG4gICAgICB2bm9kZURhdGEubmFtZSA9IG5vZGUudm5hbWU7XG4gICAgfVxuICAgIHJldHVybiBoKG5vZGUudnRhZywgdm5vZGVEYXRhLCAuLi5ub2RlLnZjaGlsZHJlbiB8fCBbXSk7XG4gIH1cbiAgY29uc3Qgdm5vZGUgPSBuZXdWTm9kZShub2RlLnZ0YWcsIG5vZGUudnRleHQpO1xuICB2bm9kZS4kYXR0cnMkID0gbm9kZS52YXR0cnM7XG4gIHZub2RlLiRjaGlsZHJlbiQgPSBub2RlLnZjaGlsZHJlbjtcbiAgdm5vZGUuJGtleSQgPSBub2RlLnZrZXk7XG4gIHZub2RlLiRuYW1lJCA9IG5vZGUudm5hbWU7XG4gIHJldHVybiB2bm9kZTtcbn07XG52YXIgcGFyc2VQcm9wZXJ0eVZhbHVlID0gKHByb3BWYWx1ZSwgcHJvcFR5cGUpID0+IHtcbiAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmICFpc0NvbXBsZXhUeXBlKHByb3BWYWx1ZSkpIHtcbiAgICBpZiAocHJvcFR5cGUgJiA0IC8qIEJvb2xlYW4gKi8pIHtcbiAgICAgIHJldHVybiBwcm9wVmFsdWUgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDogcHJvcFZhbHVlID09PSBcIlwiIHx8ICEhcHJvcFZhbHVlO1xuICAgIH1cbiAgICBpZiAocHJvcFR5cGUgJiAxIC8qIFN0cmluZyAqLykge1xuICAgICAgcmV0dXJuIFN0cmluZyhwcm9wVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlO1xuICB9XG4gIHJldHVybiBwcm9wVmFsdWU7XG59O1xudmFyIGdldEVsZW1lbnQgPSAocmVmKSA9PiBnZXRIb3N0UmVmKHJlZikuJGhvc3RFbGVtZW50JCA7XG5cbi8vIHNyYy9ydW50aW1lL2V2ZW50LWVtaXR0ZXIudHNcbnZhciBjcmVhdGVFdmVudCA9IChyZWYsIG5hbWUsIGZsYWdzKSA9PiB7XG4gIGNvbnN0IGVsbSA9IGdldEVsZW1lbnQocmVmKTtcbiAgcmV0dXJuIHtcbiAgICBlbWl0OiAoZGV0YWlsKSA9PiB7XG4gICAgICByZXR1cm4gZW1pdEV2ZW50KGVsbSwgbmFtZSwge1xuICAgICAgICBidWJibGVzOiAhIShmbGFncyAmIDQgLyogQnViYmxlcyAqLyksXG4gICAgICAgIGNvbXBvc2VkOiAhIShmbGFncyAmIDIgLyogQ29tcG9zZWQgKi8pLFxuICAgICAgICBjYW5jZWxhYmxlOiAhIShmbGFncyAmIDEgLyogQ2FuY2VsbGFibGUgKi8pLFxuICAgICAgICBkZXRhaWxcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG52YXIgZW1pdEV2ZW50ID0gKGVsbSwgbmFtZSwgb3B0cykgPT4ge1xuICBjb25zdCBldiA9IHBsdC5jZShuYW1lLCBvcHRzKTtcbiAgZWxtLmRpc3BhdGNoRXZlbnQoZXYpO1xuICByZXR1cm4gZXY7XG59O1xudmFyIHJvb3RBcHBsaWVkU3R5bGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgcmVnaXN0ZXJTdHlsZSA9IChzY29wZUlkMiwgY3NzVGV4dCwgYWxsb3dDUykgPT4ge1xuICBsZXQgc3R5bGUgPSBzdHlsZXMuZ2V0KHNjb3BlSWQyKTtcbiAgaWYgKHN1cHBvcnRzQ29uc3RydWN0YWJsZVN0eWxlc2hlZXRzICYmIGFsbG93Q1MpIHtcbiAgICBzdHlsZSA9IHN0eWxlIHx8IG5ldyBDU1NTdHlsZVNoZWV0KCk7XG4gICAgaWYgKHR5cGVvZiBzdHlsZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgc3R5bGUgPSBjc3NUZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5yZXBsYWNlU3luYyhjc3NUZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3R5bGUgPSBjc3NUZXh0O1xuICB9XG4gIHN0eWxlcy5zZXQoc2NvcGVJZDIsIHN0eWxlKTtcbn07XG52YXIgYWRkU3R5bGUgPSAoc3R5bGVDb250YWluZXJOb2RlLCBjbXBNZXRhLCBtb2RlKSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3Qgc2NvcGVJZDIgPSBnZXRTY29wZUlkKGNtcE1ldGEpO1xuICBjb25zdCBzdHlsZSA9IHN0eWxlcy5nZXQoc2NvcGVJZDIpO1xuICBzdHlsZUNvbnRhaW5lck5vZGUgPSBzdHlsZUNvbnRhaW5lck5vZGUubm9kZVR5cGUgPT09IDExIC8qIERvY3VtZW50RnJhZ21lbnQgKi8gPyBzdHlsZUNvbnRhaW5lck5vZGUgOiBkb2M7XG4gIGlmIChzdHlsZSkge1xuICAgIGlmICh0eXBlb2Ygc3R5bGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHN0eWxlQ29udGFpbmVyTm9kZSA9IHN0eWxlQ29udGFpbmVyTm9kZS5oZWFkIHx8IHN0eWxlQ29udGFpbmVyTm9kZTtcbiAgICAgIGxldCBhcHBsaWVkU3R5bGVzID0gcm9vdEFwcGxpZWRTdHlsZXMuZ2V0KHN0eWxlQ29udGFpbmVyTm9kZSk7XG4gICAgICBsZXQgc3R5bGVFbG07XG4gICAgICBpZiAoIWFwcGxpZWRTdHlsZXMpIHtcbiAgICAgICAgcm9vdEFwcGxpZWRTdHlsZXMuc2V0KHN0eWxlQ29udGFpbmVyTm9kZSwgYXBwbGllZFN0eWxlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgICAgfVxuICAgICAgaWYgKCFhcHBsaWVkU3R5bGVzLmhhcyhzY29wZUlkMikpIHtcbiAgICAgICAge1xuICAgICAgICAgIHN0eWxlRWxtID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgICBzdHlsZUVsbS5pbm5lckhUTUwgPSBzdHlsZTtcbiAgICAgICAgICBjb25zdCBub25jZSA9IChfYSA9IHBsdC4kbm9uY2UkKSAhPSBudWxsID8gX2EgOiBxdWVyeU5vbmNlTWV0YVRhZ0NvbnRlbnQoZG9jKTtcbiAgICAgICAgICBpZiAobm9uY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3R5bGVFbG0uc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pKSB7XG4gICAgICAgICAgICBpZiAoc3R5bGVDb250YWluZXJOb2RlLm5vZGVOYW1lID09PSBcIkhFQURcIikge1xuICAgICAgICAgICAgICBjb25zdCBwcmVjb25uZWN0TGlua3MgPSBzdHlsZUNvbnRhaW5lck5vZGUucXVlcnlTZWxlY3RvckFsbChcImxpbmtbcmVsPXByZWNvbm5lY3RdXCIpO1xuICAgICAgICAgICAgICBjb25zdCByZWZlcmVuY2VOb2RlMiA9IHByZWNvbm5lY3RMaW5rcy5sZW5ndGggPiAwID8gcHJlY29ubmVjdExpbmtzW3ByZWNvbm5lY3RMaW5rcy5sZW5ndGggLSAxXS5uZXh0U2libGluZyA6IHN0eWxlQ29udGFpbmVyTm9kZS5xdWVyeVNlbGVjdG9yKFwic3R5bGVcIik7XG4gICAgICAgICAgICAgIHN0eWxlQ29udGFpbmVyTm9kZS5pbnNlcnRCZWZvcmUoc3R5bGVFbG0sIHJlZmVyZW5jZU5vZGUyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoXCJob3N0XCIgaW4gc3R5bGVDb250YWluZXJOb2RlKSB7XG4gICAgICAgICAgICAgIGlmIChzdXBwb3J0c0NvbnN0cnVjdGFibGVTdHlsZXNoZWV0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlc2hlZXQgPSBuZXcgQ1NTU3R5bGVTaGVldCgpO1xuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXQucmVwbGFjZVN5bmMoc3R5bGUpO1xuICAgICAgICAgICAgICAgIHN0eWxlQ29udGFpbmVyTm9kZS5hZG9wdGVkU3R5bGVTaGVldHMgPSBbc3R5bGVzaGVldCwgLi4uc3R5bGVDb250YWluZXJOb2RlLmFkb3B0ZWRTdHlsZVNoZWV0c107XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdTdHlsZUNvbnRhaW5lciA9IHN0eWxlQ29udGFpbmVyTm9kZS5xdWVyeVNlbGVjdG9yKFwic3R5bGVcIik7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nU3R5bGVDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nU3R5bGVDb250YWluZXIuaW5uZXJIVE1MID0gc3R5bGUgKyBleGlzdGluZ1N0eWxlQ29udGFpbmVyLmlubmVySFRNTDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc3R5bGVDb250YWluZXJOb2RlLnByZXBlbmQoc3R5bGVFbG0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3R5bGVDb250YWluZXJOb2RlLmFwcGVuZChzdHlsZUVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8gJiYgc3R5bGVDb250YWluZXJOb2RlLm5vZGVOYW1lICE9PSBcIkhFQURcIikge1xuICAgICAgICAgICAgc3R5bGVDb250YWluZXJOb2RlLmluc2VydEJlZm9yZShzdHlsZUVsbSwgbnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjbXBNZXRhLiRmbGFncyQgJiA0IC8qIGhhc1Nsb3RSZWxvY2F0aW9uICovKSB7XG4gICAgICAgICAgc3R5bGVFbG0uaW5uZXJIVE1MICs9IFNMT1RfRkJfQ1NTO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcHBsaWVkU3R5bGVzKSB7XG4gICAgICAgICAgYXBwbGllZFN0eWxlcy5hZGQoc2NvcGVJZDIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghc3R5bGVDb250YWluZXJOb2RlLmFkb3B0ZWRTdHlsZVNoZWV0cy5pbmNsdWRlcyhzdHlsZSkpIHtcbiAgICAgIHN0eWxlQ29udGFpbmVyTm9kZS5hZG9wdGVkU3R5bGVTaGVldHMgPSBbLi4uc3R5bGVDb250YWluZXJOb2RlLmFkb3B0ZWRTdHlsZVNoZWV0cywgc3R5bGVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2NvcGVJZDI7XG59O1xudmFyIGF0dGFjaFN0eWxlcyA9IChob3N0UmVmKSA9PiB7XG4gIGNvbnN0IGNtcE1ldGEgPSBob3N0UmVmLiRjbXBNZXRhJDtcbiAgY29uc3QgZWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICBjb25zdCBmbGFncyA9IGNtcE1ldGEuJGZsYWdzJDtcbiAgY29uc3QgZW5kQXR0YWNoU3R5bGVzID0gY3JlYXRlVGltZShcImF0dGFjaFN0eWxlc1wiLCBjbXBNZXRhLiR0YWdOYW1lJCk7XG4gIGNvbnN0IHNjb3BlSWQyID0gYWRkU3R5bGUoXG4gICAgZWxtLnNoYWRvd1Jvb3QgPyBlbG0uc2hhZG93Um9vdCA6IGVsbS5nZXRSb290Tm9kZSgpLFxuICAgIGNtcE1ldGEpO1xuICBpZiAoZmxhZ3MgJiAxMCAvKiBuZWVkc1Njb3BlZEVuY2Fwc3VsYXRpb24gKi8gJiYgZmxhZ3MgJiAyIC8qIHNjb3BlZENzc0VuY2Fwc3VsYXRpb24gKi8pIHtcbiAgICBlbG1bXCJzLXNjXCJdID0gc2NvcGVJZDI7XG4gICAgZWxtLmNsYXNzTGlzdC5hZGQoc2NvcGVJZDIgKyBcIi1oXCIpO1xuICB9XG4gIGVuZEF0dGFjaFN0eWxlcygpO1xufTtcbnZhciBnZXRTY29wZUlkID0gKGNtcCwgbW9kZSkgPT4gXCJzYy1cIiArIChjbXAuJHRhZ05hbWUkKTtcbnZhciBzZXRBY2Nlc3NvciA9IChlbG0sIG1lbWJlck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgaXNTdmcsIGZsYWdzKSA9PiB7XG4gIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICBsZXQgaXNQcm9wID0gaXNNZW1iZXJJbkVsZW1lbnQoZWxtLCBtZW1iZXJOYW1lKTtcbiAgICBsZXQgbG4gPSBtZW1iZXJOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG1lbWJlck5hbWUgPT09IFwiY2xhc3NcIikge1xuICAgICAgY29uc3QgY2xhc3NMaXN0ID0gZWxtLmNsYXNzTGlzdDtcbiAgICAgIGNvbnN0IG9sZENsYXNzZXMgPSBwYXJzZUNsYXNzTGlzdChvbGRWYWx1ZSk7XG4gICAgICBjb25zdCBuZXdDbGFzc2VzID0gcGFyc2VDbGFzc0xpc3QobmV3VmFsdWUpO1xuICAgICAgY2xhc3NMaXN0LnJlbW92ZSguLi5vbGRDbGFzc2VzLmZpbHRlcigoYykgPT4gYyAmJiAhbmV3Q2xhc3Nlcy5pbmNsdWRlcyhjKSkpO1xuICAgICAgY2xhc3NMaXN0LmFkZCguLi5uZXdDbGFzc2VzLmZpbHRlcigoYykgPT4gYyAmJiAhb2xkQ2xhc3Nlcy5pbmNsdWRlcyhjKSkpO1xuICAgIH0gZWxzZSBpZiAobWVtYmVyTmFtZSA9PT0gXCJzdHlsZVwiKSB7XG4gICAgICB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBvbGRWYWx1ZSkge1xuICAgICAgICAgIGlmICghbmV3VmFsdWUgfHwgbmV3VmFsdWVbcHJvcF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHByb3AuaW5jbHVkZXMoXCItXCIpKSB7XG4gICAgICAgICAgICAgIGVsbS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsbS5zdHlsZVtwcm9wXSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gbmV3VmFsdWUpIHtcbiAgICAgICAgaWYgKCFvbGRWYWx1ZSB8fCBuZXdWYWx1ZVtwcm9wXSAhPT0gb2xkVmFsdWVbcHJvcF0pIHtcbiAgICAgICAgICBpZiAocHJvcC5pbmNsdWRlcyhcIi1cIikpIHtcbiAgICAgICAgICAgIGVsbS5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wLCBuZXdWYWx1ZVtwcm9wXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsbS5zdHlsZVtwcm9wXSA9IG5ld1ZhbHVlW3Byb3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKCFpc1Byb3AgKSAmJiBtZW1iZXJOYW1lWzBdID09PSBcIm9cIiAmJiBtZW1iZXJOYW1lWzFdID09PSBcIm5cIikge1xuICAgICAgaWYgKG1lbWJlck5hbWVbMl0gPT09IFwiLVwiKSB7XG4gICAgICAgIG1lbWJlck5hbWUgPSBtZW1iZXJOYW1lLnNsaWNlKDMpO1xuICAgICAgfSBlbHNlIGlmIChpc01lbWJlckluRWxlbWVudCh3aW4sIGxuKSkge1xuICAgICAgICBtZW1iZXJOYW1lID0gbG4uc2xpY2UoMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZW1iZXJOYW1lID0gbG5bMl0gKyBtZW1iZXJOYW1lLnNsaWNlKDMpO1xuICAgICAgfVxuICAgICAgaWYgKG9sZFZhbHVlIHx8IG5ld1ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhcHR1cmUgPSBtZW1iZXJOYW1lLmVuZHNXaXRoKENBUFRVUkVfRVZFTlRfU1VGRklYKTtcbiAgICAgICAgbWVtYmVyTmFtZSA9IG1lbWJlck5hbWUucmVwbGFjZShDQVBUVVJFX0VWRU5UX1JFR0VYLCBcIlwiKTtcbiAgICAgICAgaWYgKG9sZFZhbHVlKSB7XG4gICAgICAgICAgcGx0LnJlbChlbG0sIG1lbWJlck5hbWUsIG9sZFZhbHVlLCBjYXB0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICBwbHQuYWVsKGVsbSwgbWVtYmVyTmFtZSwgbmV3VmFsdWUsIGNhcHR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlzQ29tcGxleCA9IGlzQ29tcGxleFR5cGUobmV3VmFsdWUpO1xuICAgICAgaWYgKChpc1Byb3AgfHwgaXNDb21wbGV4ICYmIG5ld1ZhbHVlICE9PSBudWxsKSAmJiAhaXNTdmcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIWVsbS50YWdOYW1lLmluY2x1ZGVzKFwiLVwiKSkge1xuICAgICAgICAgICAgY29uc3QgbiA9IG5ld1ZhbHVlID09IG51bGwgPyBcIlwiIDogbmV3VmFsdWU7XG4gICAgICAgICAgICBpZiAobWVtYmVyTmFtZSA9PT0gXCJsaXN0XCIpIHtcbiAgICAgICAgICAgICAgaXNQcm9wID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9sZFZhbHVlID09IG51bGwgfHwgZWxtW21lbWJlck5hbWVdICE9IG4pIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbG0uX19sb29rdXBTZXR0ZXJfXyhtZW1iZXJOYW1lKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgZWxtW21lbWJlck5hbWVdID0gbjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbG0uc2V0QXR0cmlidXRlKG1lbWJlck5hbWUsIG4pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsbVttZW1iZXJOYW1lXSA9IG5ld1ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobmV3VmFsdWUgPT0gbnVsbCB8fCBuZXdWYWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSBmYWxzZSB8fCBlbG0uZ2V0QXR0cmlidXRlKG1lbWJlck5hbWUpID09PSBcIlwiKSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShtZW1iZXJOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKCFpc1Byb3AgfHwgZmxhZ3MgJiA0IC8qIGlzSG9zdCAqLyB8fCBpc1N2ZykgJiYgIWlzQ29tcGxleCkge1xuICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlID09PSB0cnVlID8gXCJcIiA6IG5ld1ZhbHVlO1xuICAgICAgICB7XG4gICAgICAgICAgZWxtLnNldEF0dHJpYnV0ZShtZW1iZXJOYW1lLCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgcGFyc2VDbGFzc0xpc3RSZWdleCA9IC9cXHMvO1xudmFyIHBhcnNlQ2xhc3NMaXN0ID0gKHZhbHVlKSA9PiAhdmFsdWUgPyBbXSA6IHZhbHVlLnNwbGl0KHBhcnNlQ2xhc3NMaXN0UmVnZXgpO1xudmFyIENBUFRVUkVfRVZFTlRfU1VGRklYID0gXCJDYXB0dXJlXCI7XG52YXIgQ0FQVFVSRV9FVkVOVF9SRUdFWCA9IG5ldyBSZWdFeHAoQ0FQVFVSRV9FVkVOVF9TVUZGSVggKyBcIiRcIik7XG5cbi8vIHNyYy9ydW50aW1lL3Zkb20vdXBkYXRlLWVsZW1lbnQudHNcbnZhciB1cGRhdGVFbGVtZW50ID0gKG9sZFZub2RlLCBuZXdWbm9kZSwgaXNTdmdNb2RlMikgPT4ge1xuICBjb25zdCBlbG0gPSBuZXdWbm9kZS4kZWxtJC5ub2RlVHlwZSA9PT0gMTEgLyogRG9jdW1lbnRGcmFnbWVudCAqLyAmJiBuZXdWbm9kZS4kZWxtJC5ob3N0ID8gbmV3Vm5vZGUuJGVsbSQuaG9zdCA6IG5ld1Zub2RlLiRlbG0kO1xuICBjb25zdCBvbGRWbm9kZUF0dHJzID0gb2xkVm5vZGUgJiYgb2xkVm5vZGUuJGF0dHJzJCB8fCBFTVBUWV9PQko7XG4gIGNvbnN0IG5ld1Zub2RlQXR0cnMgPSBuZXdWbm9kZS4kYXR0cnMkIHx8IEVNUFRZX09CSjtcbiAge1xuICAgIGZvciAoY29uc3QgbWVtYmVyTmFtZSBvZiBzb3J0ZWRBdHRyTmFtZXMoT2JqZWN0LmtleXMob2xkVm5vZGVBdHRycykpKSB7XG4gICAgICBpZiAoIShtZW1iZXJOYW1lIGluIG5ld1Zub2RlQXR0cnMpKSB7XG4gICAgICAgIHNldEFjY2Vzc29yKGVsbSwgbWVtYmVyTmFtZSwgb2xkVm5vZGVBdHRyc1ttZW1iZXJOYW1lXSwgdm9pZCAwLCBpc1N2Z01vZGUyLCBuZXdWbm9kZS4kZmxhZ3MkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBtZW1iZXJOYW1lIG9mIHNvcnRlZEF0dHJOYW1lcyhPYmplY3Qua2V5cyhuZXdWbm9kZUF0dHJzKSkpIHtcbiAgICBzZXRBY2Nlc3NvcihlbG0sIG1lbWJlck5hbWUsIG9sZFZub2RlQXR0cnNbbWVtYmVyTmFtZV0sIG5ld1Zub2RlQXR0cnNbbWVtYmVyTmFtZV0sIGlzU3ZnTW9kZTIsIG5ld1Zub2RlLiRmbGFncyQpO1xuICB9XG59O1xuZnVuY3Rpb24gc29ydGVkQXR0ck5hbWVzKGF0dHJOYW1lcykge1xuICByZXR1cm4gYXR0ck5hbWVzLmluY2x1ZGVzKFwicmVmXCIpID8gKFxuICAgIC8vIHdlIG5lZWQgdG8gc29ydCB0aGVzZSB0byBlbnN1cmUgdGhhdCBgJ3JlZidgIGlzIHRoZSBsYXN0IGF0dHJcbiAgICBbLi4uYXR0ck5hbWVzLmZpbHRlcigoYXR0cikgPT4gYXR0ciAhPT0gXCJyZWZcIiksIFwicmVmXCJdXG4gICkgOiAoXG4gICAgLy8gbm8gbmVlZCB0byBzb3J0LCByZXR1cm4gdGhlIG9yaWdpbmFsIGFycmF5XG4gICAgYXR0ck5hbWVzXG4gICk7XG59XG5cbi8vIHNyYy9ydW50aW1lL3Zkb20vdmRvbS1yZW5kZXIudHNcbnZhciBzY29wZUlkO1xudmFyIGhvc3RUYWdOYW1lO1xudmFyIHVzZU5hdGl2ZVNoYWRvd0RvbSA9IGZhbHNlO1xudmFyIGlzU3ZnTW9kZSA9IGZhbHNlO1xudmFyIGNyZWF0ZUVsbSA9IChvbGRQYXJlbnRWTm9kZSwgbmV3UGFyZW50Vk5vZGUsIGNoaWxkSW5kZXgsIHBhcmVudEVsbSkgPT4ge1xuICBjb25zdCBuZXdWTm9kZTIgPSBuZXdQYXJlbnRWTm9kZS4kY2hpbGRyZW4kW2NoaWxkSW5kZXhdO1xuICBsZXQgaTIgPSAwO1xuICBsZXQgZWxtO1xuICBsZXQgY2hpbGROb2RlO1xuICBpZiAobmV3Vk5vZGUyLiR0ZXh0JCAhPT0gbnVsbCkge1xuICAgIGVsbSA9IG5ld1ZOb2RlMi4kZWxtJCA9IGRvYy5jcmVhdGVUZXh0Tm9kZShuZXdWTm9kZTIuJHRleHQkKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWlzU3ZnTW9kZSkge1xuICAgICAgaXNTdmdNb2RlID0gbmV3Vk5vZGUyLiR0YWckID09PSBcInN2Z1wiO1xuICAgIH1cbiAgICBlbG0gPSBuZXdWTm9kZTIuJGVsbSQgPSBkb2MuY3JlYXRlRWxlbWVudE5TKFxuICAgICAgaXNTdmdNb2RlID8gU1ZHX05TIDogSFRNTF9OUyxcbiAgICAgICF1c2VOYXRpdmVTaGFkb3dEb20gJiYgQlVJTEQuc2xvdFJlbG9jYXRpb24gJiYgbmV3Vk5vZGUyLiRmbGFncyQgJiAyIC8qIGlzU2xvdEZhbGxiYWNrICovID8gXCJzbG90LWZiXCIgOiBuZXdWTm9kZTIuJHRhZyRcbiAgICApIDtcbiAgICBpZiAoaXNTdmdNb2RlICYmIG5ld1ZOb2RlMi4kdGFnJCA9PT0gXCJmb3JlaWduT2JqZWN0XCIpIHtcbiAgICAgIGlzU3ZnTW9kZSA9IGZhbHNlO1xuICAgIH1cbiAgICB7XG4gICAgICB1cGRhdGVFbGVtZW50KG51bGwsIG5ld1ZOb2RlMiwgaXNTdmdNb2RlKTtcbiAgICB9XG4gICAgY29uc3Qgcm9vdE5vZGUgPSBlbG0uZ2V0Um9vdE5vZGUoKTtcbiAgICBjb25zdCBpc0VsZW1lbnRXaXRoaW5TaGFkb3dSb290ID0gIXJvb3ROb2RlLnF1ZXJ5U2VsZWN0b3IoXCJib2R5XCIpO1xuICAgIGlmICghaXNFbGVtZW50V2l0aGluU2hhZG93Um9vdCAmJiBCVUlMRC5zY29wZWQgJiYgaXNEZWYoc2NvcGVJZCkgJiYgZWxtW1wicy1zaVwiXSAhPT0gc2NvcGVJZCkge1xuICAgICAgZWxtLmNsYXNzTGlzdC5hZGQoZWxtW1wicy1zaVwiXSA9IHNjb3BlSWQpO1xuICAgIH1cbiAgICBpZiAobmV3Vk5vZGUyLiRjaGlsZHJlbiQpIHtcbiAgICAgIGZvciAoaTIgPSAwOyBpMiA8IG5ld1ZOb2RlMi4kY2hpbGRyZW4kLmxlbmd0aDsgKytpMikge1xuICAgICAgICBjaGlsZE5vZGUgPSBjcmVhdGVFbG0ob2xkUGFyZW50Vk5vZGUsIG5ld1ZOb2RlMiwgaTIpO1xuICAgICAgICBpZiAoY2hpbGROb2RlKSB7XG4gICAgICAgICAgZWxtLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAge1xuICAgICAgaWYgKG5ld1ZOb2RlMi4kdGFnJCA9PT0gXCJzdmdcIikge1xuICAgICAgICBpc1N2Z01vZGUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxtLnRhZ05hbWUgPT09IFwiZm9yZWlnbk9iamVjdFwiKSB7XG4gICAgICAgIGlzU3ZnTW9kZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsbVtcInMtaG5cIl0gPSBob3N0VGFnTmFtZTtcbiAgcmV0dXJuIGVsbTtcbn07XG52YXIgYWRkVm5vZGVzID0gKHBhcmVudEVsbSwgYmVmb3JlLCBwYXJlbnRWTm9kZSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4KSA9PiB7XG4gIGxldCBjb250YWluZXJFbG0gPSBwYXJlbnRFbG07XG4gIGxldCBjaGlsZE5vZGU7XG4gIGlmIChjb250YWluZXJFbG0uc2hhZG93Um9vdCAmJiBjb250YWluZXJFbG0udGFnTmFtZSA9PT0gaG9zdFRhZ05hbWUpIHtcbiAgICBjb250YWluZXJFbG0gPSBjb250YWluZXJFbG0uc2hhZG93Um9vdDtcbiAgfVxuICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgaWYgKHZub2Rlc1tzdGFydElkeF0pIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNyZWF0ZUVsbShudWxsLCBwYXJlbnRWTm9kZSwgc3RhcnRJZHgpO1xuICAgICAgaWYgKGNoaWxkTm9kZSkge1xuICAgICAgICB2bm9kZXNbc3RhcnRJZHhdLiRlbG0kID0gY2hpbGROb2RlO1xuICAgICAgICBpbnNlcnRCZWZvcmUoY29udGFpbmVyRWxtLCBjaGlsZE5vZGUsIGJlZm9yZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIHJlbW92ZVZub2RlcyA9ICh2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpID0+IHtcbiAgZm9yIChsZXQgaW5kZXggPSBzdGFydElkeDsgaW5kZXggPD0gZW5kSWR4OyArK2luZGV4KSB7XG4gICAgY29uc3Qgdm5vZGUgPSB2bm9kZXNbaW5kZXhdO1xuICAgIGlmICh2bm9kZSkge1xuICAgICAgY29uc3QgZWxtID0gdm5vZGUuJGVsbSQ7XG4gICAgICBpZiAoZWxtKSB7XG4gICAgICAgIGVsbS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG52YXIgdXBkYXRlQ2hpbGRyZW4gPSAocGFyZW50RWxtLCBvbGRDaCwgbmV3Vk5vZGUyLCBuZXdDaCwgaXNJbml0aWFsUmVuZGVyID0gZmFsc2UpID0+IHtcbiAgbGV0IG9sZFN0YXJ0SWR4ID0gMDtcbiAgbGV0IG5ld1N0YXJ0SWR4ID0gMDtcbiAgbGV0IG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gIGxldCBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gIGxldCBvbGRFbmRWbm9kZSA9IG9sZENoW29sZEVuZElkeF07XG4gIGxldCBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICBsZXQgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICBsZXQgbmV3RW5kVm5vZGUgPSBuZXdDaFtuZXdFbmRJZHhdO1xuICBsZXQgbm9kZTtcbiAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICBpZiAob2xkU3RhcnRWbm9kZSA9PSBudWxsKSB7XG4gICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgfSBlbHNlIGlmIChvbGRFbmRWbm9kZSA9PSBudWxsKSB7XG4gICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0Vm5vZGUgPT0gbnVsbCkge1xuICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgIH0gZWxzZSBpZiAobmV3RW5kVm5vZGUgPT0gbnVsbCkge1xuICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgfSBlbHNlIGlmIChpc1NhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpc0luaXRpYWxSZW5kZXIpKSB7XG4gICAgICBwYXRjaChvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlLCBpc0luaXRpYWxSZW5kZXIpO1xuICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgIH0gZWxzZSBpZiAoaXNTYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpc0luaXRpYWxSZW5kZXIpKSB7XG4gICAgICBwYXRjaChvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUsIGlzSW5pdGlhbFJlbmRlcik7XG4gICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgIH0gZWxzZSBpZiAoaXNTYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGlzSW5pdGlhbFJlbmRlcikpIHtcbiAgICAgIHBhdGNoKG9sZFN0YXJ0Vm5vZGUsIG5ld0VuZFZub2RlLCBpc0luaXRpYWxSZW5kZXIpO1xuICAgICAgaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS4kZWxtJCwgb2xkRW5kVm5vZGUuJGVsbSQubmV4dFNpYmxpbmcpO1xuICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgfSBlbHNlIGlmIChpc1NhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaXNJbml0aWFsUmVuZGVyKSkge1xuICAgICAgcGF0Y2gob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGlzSW5pdGlhbFJlbmRlcik7XG4gICAgICBpbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS4kZWxtJCwgb2xkU3RhcnRWbm9kZS4kZWxtJCk7XG4gICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICBub2RlID0gY3JlYXRlRWxtKG9sZENoICYmIG9sZENoW25ld1N0YXJ0SWR4XSwgbmV3Vk5vZGUyLCBuZXdTdGFydElkeCk7XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpbnNlcnRCZWZvcmUob2xkU3RhcnRWbm9kZS4kZWxtJC5wYXJlbnROb2RlLCBub2RlLCBvbGRTdGFydFZub2RlLiRlbG0kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAob2xkU3RhcnRJZHggPiBvbGRFbmRJZHgpIHtcbiAgICBhZGRWbm9kZXMoXG4gICAgICBwYXJlbnRFbG0sXG4gICAgICBuZXdDaFtuZXdFbmRJZHggKyAxXSA9PSBudWxsID8gbnVsbCA6IG5ld0NoW25ld0VuZElkeCArIDFdLiRlbG0kLFxuICAgICAgbmV3Vk5vZGUyLFxuICAgICAgbmV3Q2gsXG4gICAgICBuZXdTdGFydElkeCxcbiAgICAgIG5ld0VuZElkeFxuICAgICk7XG4gIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICByZW1vdmVWbm9kZXMob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICB9XG59O1xudmFyIGlzU2FtZVZub2RlID0gKGxlZnRWTm9kZSwgcmlnaHRWTm9kZSwgaXNJbml0aWFsUmVuZGVyID0gZmFsc2UpID0+IHtcbiAgaWYgKGxlZnRWTm9kZS4kdGFnJCA9PT0gcmlnaHRWTm9kZS4kdGFnJCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG52YXIgcGF0Y2ggPSAob2xkVk5vZGUsIG5ld1ZOb2RlMiwgaXNJbml0aWFsUmVuZGVyID0gZmFsc2UpID0+IHtcbiAgY29uc3QgZWxtID0gbmV3Vk5vZGUyLiRlbG0kID0gb2xkVk5vZGUuJGVsbSQ7XG4gIGNvbnN0IG9sZENoaWxkcmVuID0gb2xkVk5vZGUuJGNoaWxkcmVuJDtcbiAgY29uc3QgbmV3Q2hpbGRyZW4gPSBuZXdWTm9kZTIuJGNoaWxkcmVuJDtcbiAgY29uc3QgdGFnID0gbmV3Vk5vZGUyLiR0YWckO1xuICBjb25zdCB0ZXh0ID0gbmV3Vk5vZGUyLiR0ZXh0JDtcbiAgaWYgKHRleHQgPT09IG51bGwpIHtcbiAgICB7XG4gICAgICBpc1N2Z01vZGUgPSB0YWcgPT09IFwic3ZnXCIgPyB0cnVlIDogdGFnID09PSBcImZvcmVpZ25PYmplY3RcIiA/IGZhbHNlIDogaXNTdmdNb2RlO1xuICAgIH1cbiAgICB7XG4gICAgICB7XG4gICAgICAgIHVwZGF0ZUVsZW1lbnQob2xkVk5vZGUsIG5ld1ZOb2RlMiwgaXNTdmdNb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZENoaWxkcmVuICE9PSBudWxsICYmIG5ld0NoaWxkcmVuICE9PSBudWxsKSB7XG4gICAgICB1cGRhdGVDaGlsZHJlbihlbG0sIG9sZENoaWxkcmVuLCBuZXdWTm9kZTIsIG5ld0NoaWxkcmVuLCBpc0luaXRpYWxSZW5kZXIpO1xuICAgIH0gZWxzZSBpZiAobmV3Q2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgIGlmIChvbGRWTm9kZS4kdGV4dCQgIT09IG51bGwpIHtcbiAgICAgICAgZWxtLnRleHRDb250ZW50ID0gXCJcIjtcbiAgICAgIH1cbiAgICAgIGFkZFZub2RlcyhlbG0sIG51bGwsIG5ld1ZOb2RlMiwgbmV3Q2hpbGRyZW4sIDAsIG5ld0NoaWxkcmVuLmxlbmd0aCAtIDEpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyBkb24ndCBkbyB0aGlzIG9uIGluaXRpYWwgcmVuZGVyIGFzIGl0IGNhbiBjYXVzZSBub24taHlkcmF0ZWQgY29udGVudCB0byBiZSByZW1vdmVkXG4gICAgICAhaXNJbml0aWFsUmVuZGVyICYmIEJVSUxELnVwZGF0YWJsZSAmJiBvbGRDaGlsZHJlbiAhPT0gbnVsbFxuICAgICkge1xuICAgICAgcmVtb3ZlVm5vZGVzKG9sZENoaWxkcmVuLCAwLCBvbGRDaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgaWYgKGlzU3ZnTW9kZSAmJiB0YWcgPT09IFwic3ZnXCIpIHtcbiAgICAgIGlzU3ZnTW9kZSA9IGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChvbGRWTm9kZS4kdGV4dCQgIT09IHRleHQpIHtcbiAgICBlbG0uZGF0YSA9IHRleHQ7XG4gIH1cbn07XG52YXIgaW5zZXJ0QmVmb3JlID0gKHBhcmVudCwgbmV3Tm9kZSwgcmVmZXJlbmNlKSA9PiB7XG4gIGNvbnN0IGluc2VydGVkID0gcGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZSk7XG4gIHJldHVybiBpbnNlcnRlZDtcbn07XG52YXIgcmVuZGVyVmRvbSA9IChob3N0UmVmLCByZW5kZXJGblJlc3VsdHMsIGlzSW5pdGlhbExvYWQgPSBmYWxzZSkgPT4ge1xuICBjb25zdCBob3N0RWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICBjb25zdCBjbXBNZXRhID0gaG9zdFJlZi4kY21wTWV0YSQ7XG4gIGNvbnN0IG9sZFZOb2RlID0gaG9zdFJlZi4kdm5vZGUkIHx8IG5ld1ZOb2RlKG51bGwsIG51bGwpO1xuICBjb25zdCByb290Vm5vZGUgPSBpc0hvc3QocmVuZGVyRm5SZXN1bHRzKSA/IHJlbmRlckZuUmVzdWx0cyA6IGgobnVsbCwgbnVsbCwgcmVuZGVyRm5SZXN1bHRzKTtcbiAgaG9zdFRhZ05hbWUgPSBob3N0RWxtLnRhZ05hbWU7XG4gIGlmIChpc0luaXRpYWxMb2FkICYmIHJvb3RWbm9kZS4kYXR0cnMkKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocm9vdFZub2RlLiRhdHRycyQpKSB7XG4gICAgICBpZiAoaG9zdEVsbS5oYXNBdHRyaWJ1dGUoa2V5KSAmJiAhW1wia2V5XCIsIFwicmVmXCIsIFwic3R5bGVcIiwgXCJjbGFzc1wiXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgIHJvb3RWbm9kZS4kYXR0cnMkW2tleV0gPSBob3N0RWxtW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJvb3RWbm9kZS4kdGFnJCA9IG51bGw7XG4gIHJvb3RWbm9kZS4kZmxhZ3MkIHw9IDQgLyogaXNIb3N0ICovO1xuICBob3N0UmVmLiR2bm9kZSQgPSByb290Vm5vZGU7XG4gIHJvb3RWbm9kZS4kZWxtJCA9IG9sZFZOb2RlLiRlbG0kID0gaG9zdEVsbS5zaGFkb3dSb290IHx8IGhvc3RFbG0gO1xuICB7XG4gICAgc2NvcGVJZCA9IGhvc3RFbG1bXCJzLXNjXCJdO1xuICB9XG4gIHVzZU5hdGl2ZVNoYWRvd0RvbSA9IChjbXBNZXRhLiRmbGFncyQgJiAxIC8qIHNoYWRvd0RvbUVuY2Fwc3VsYXRpb24gKi8pICE9PSAwO1xuICBwYXRjaChvbGRWTm9kZSwgcm9vdFZub2RlLCBpc0luaXRpYWxMb2FkKTtcbn07XG5cbi8vIHNyYy9ydW50aW1lL3VwZGF0ZS1jb21wb25lbnQudHNcbnZhciBhdHRhY2hUb0FuY2VzdG9yID0gKGhvc3RSZWYsIGFuY2VzdG9yQ29tcG9uZW50KSA9PiB7XG4gIGlmIChhbmNlc3RvckNvbXBvbmVudCAmJiAhaG9zdFJlZi4kb25SZW5kZXJSZXNvbHZlJCAmJiBhbmNlc3RvckNvbXBvbmVudFtcInMtcFwiXSkge1xuICAgIGFuY2VzdG9yQ29tcG9uZW50W1wicy1wXCJdLnB1c2gobmV3IFByb21pc2UoKHIpID0+IGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQgPSByKSk7XG4gIH1cbn07XG52YXIgc2NoZWR1bGVVcGRhdGUgPSAoaG9zdFJlZiwgaXNJbml0aWFsTG9hZCkgPT4ge1xuICB7XG4gICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDE2IC8qIGlzUXVldWVkRm9yVXBkYXRlICovO1xuICB9XG4gIGlmIChob3N0UmVmLiRmbGFncyQgJiA0IC8qIGlzV2FpdGluZ0ZvckNoaWxkcmVuICovKSB7XG4gICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDUxMiAvKiBuZWVkc1JlcmVuZGVyICovO1xuICAgIHJldHVybjtcbiAgfVxuICBhdHRhY2hUb0FuY2VzdG9yKGhvc3RSZWYsIGhvc3RSZWYuJGFuY2VzdG9yQ29tcG9uZW50JCk7XG4gIGNvbnN0IGRpc3BhdGNoID0gKCkgPT4gZGlzcGF0Y2hIb29rcyhob3N0UmVmLCBpc0luaXRpYWxMb2FkKTtcbiAgcmV0dXJuIHdyaXRlVGFzayhkaXNwYXRjaCkgO1xufTtcbnZhciBkaXNwYXRjaEhvb2tzID0gKGhvc3RSZWYsIGlzSW5pdGlhbExvYWQpID0+IHtcbiAgY29uc3QgZWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICBjb25zdCBlbmRTY2hlZHVsZSA9IGNyZWF0ZVRpbWUoXCJzY2hlZHVsZVVwZGF0ZVwiLCBob3N0UmVmLiRjbXBNZXRhJC4kdGFnTmFtZSQpO1xuICBjb25zdCBpbnN0YW5jZSA9IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgO1xuICBpZiAoIWluc3RhbmNlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYENhbid0IHJlbmRlciBjb21wb25lbnQgPCR7ZWxtLnRhZ05hbWUudG9Mb3dlckNhc2UoKX0gLz4gd2l0aCBpbnZhbGlkIFN0ZW5jaWwgcnVudGltZSEgTWFrZSBzdXJlIHRoaXMgaW1wb3J0ZWQgY29tcG9uZW50IGlzIGNvbXBpbGVkIHdpdGggYSBcXGBleHRlcm5hbFJ1bnRpbWU6IHRydWVcXGAgZmxhZy4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHBsZWFzZSByZWZlciB0byBodHRwczovL3N0ZW5jaWxqcy5jb20vZG9jcy9jdXN0b20tZWxlbWVudHMjZXh0ZXJuYWxydW50aW1lYFxuICAgICk7XG4gIH1cbiAgbGV0IG1heWJlUHJvbWlzZTtcbiAgZW5kU2NoZWR1bGUoKTtcbiAgcmV0dXJuIGVucXVldWUobWF5YmVQcm9taXNlLCAoKSA9PiB1cGRhdGVDb21wb25lbnQoaG9zdFJlZiwgaW5zdGFuY2UsIGlzSW5pdGlhbExvYWQpKTtcbn07XG52YXIgZW5xdWV1ZSA9IChtYXliZVByb21pc2UsIGZuKSA9PiBpc1Byb21pc2V5KG1heWJlUHJvbWlzZSkgPyBtYXliZVByb21pc2UudGhlbihmbikuY2F0Y2goKGVycjIpID0+IHtcbiAgY29uc29sZS5lcnJvcihlcnIyKTtcbiAgZm4oKTtcbn0pIDogZm4oKTtcbnZhciBpc1Byb21pc2V5ID0gKG1heWJlUHJvbWlzZSkgPT4gbWF5YmVQcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSB8fCBtYXliZVByb21pc2UgJiYgbWF5YmVQcm9taXNlLnRoZW4gJiYgdHlwZW9mIG1heWJlUHJvbWlzZS50aGVuID09PSBcImZ1bmN0aW9uXCI7XG52YXIgdXBkYXRlQ29tcG9uZW50ID0gYXN5bmMgKGhvc3RSZWYsIGluc3RhbmNlLCBpc0luaXRpYWxMb2FkKSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgZWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICBjb25zdCBlbmRVcGRhdGUgPSBjcmVhdGVUaW1lKFwidXBkYXRlXCIsIGhvc3RSZWYuJGNtcE1ldGEkLiR0YWdOYW1lJCk7XG4gIGNvbnN0IHJjID0gZWxtW1wicy1yY1wiXTtcbiAgaWYgKGlzSW5pdGlhbExvYWQpIHtcbiAgICBhdHRhY2hTdHlsZXMoaG9zdFJlZik7XG4gIH1cbiAgY29uc3QgZW5kUmVuZGVyID0gY3JlYXRlVGltZShcInJlbmRlclwiLCBob3N0UmVmLiRjbXBNZXRhJC4kdGFnTmFtZSQpO1xuICB7XG4gICAgY2FsbFJlbmRlcihob3N0UmVmLCBpbnN0YW5jZSwgZWxtLCBpc0luaXRpYWxMb2FkKTtcbiAgfVxuICBpZiAocmMpIHtcbiAgICByYy5tYXAoKGNiKSA9PiBjYigpKTtcbiAgICBlbG1bXCJzLXJjXCJdID0gdm9pZCAwO1xuICB9XG4gIGVuZFJlbmRlcigpO1xuICBlbmRVcGRhdGUoKTtcbiAge1xuICAgIGNvbnN0IGNoaWxkcmVuUHJvbWlzZXMgPSAoX2EgPSBlbG1bXCJzLXBcIl0pICE9IG51bGwgPyBfYSA6IFtdO1xuICAgIGNvbnN0IHBvc3RVcGRhdGUgPSAoKSA9PiBwb3N0VXBkYXRlQ29tcG9uZW50KGhvc3RSZWYpO1xuICAgIGlmIChjaGlsZHJlblByb21pc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcG9zdFVwZGF0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBQcm9taXNlLmFsbChjaGlsZHJlblByb21pc2VzKS50aGVuKHBvc3RVcGRhdGUpO1xuICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDQgLyogaXNXYWl0aW5nRm9yQ2hpbGRyZW4gKi87XG4gICAgICBjaGlsZHJlblByb21pc2VzLmxlbmd0aCA9IDA7XG4gICAgfVxuICB9XG59O1xudmFyIGNhbGxSZW5kZXIgPSAoaG9zdFJlZiwgaW5zdGFuY2UsIGVsbSwgaXNJbml0aWFsTG9hZCkgPT4ge1xuICB0cnkge1xuICAgIGluc3RhbmNlID0gaW5zdGFuY2UucmVuZGVyKCkgO1xuICAgIHtcbiAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+MTYgLyogaXNRdWV1ZWRGb3JVcGRhdGUgKi87XG4gICAgfVxuICAgIHtcbiAgICAgIGhvc3RSZWYuJGZsYWdzJCB8PSAyIC8qIGhhc1JlbmRlcmVkICovO1xuICAgIH1cbiAgICB7XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICByZW5kZXJWZG9tKGhvc3RSZWYsIGluc3RhbmNlLCBpc0luaXRpYWxMb2FkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGVFcnJvcihlLCBob3N0UmVmLiRob3N0RWxlbWVudCQpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcbnZhciBwb3N0VXBkYXRlQ29tcG9uZW50ID0gKGhvc3RSZWYpID0+IHtcbiAgY29uc3QgdGFnTmFtZSA9IGhvc3RSZWYuJGNtcE1ldGEkLiR0YWdOYW1lJDtcbiAgY29uc3QgZWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkO1xuICBjb25zdCBlbmRQb3N0VXBkYXRlID0gY3JlYXRlVGltZShcInBvc3RVcGRhdGVcIiwgdGFnTmFtZSk7XG4gIGNvbnN0IGluc3RhbmNlID0gaG9zdFJlZi4kbGF6eUluc3RhbmNlJCA7XG4gIGNvbnN0IGFuY2VzdG9yQ29tcG9uZW50ID0gaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkO1xuICBpZiAoIShob3N0UmVmLiRmbGFncyQgJiA2NCAvKiBoYXNMb2FkZWRDb21wb25lbnQgKi8pKSB7XG4gICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDY0IC8qIGhhc0xvYWRlZENvbXBvbmVudCAqLztcbiAgICB7XG4gICAgICBhZGRIeWRyYXRlZEZsYWcoZWxtKTtcbiAgICB9XG4gICAge1xuICAgICAgc2FmZUNhbGwoaW5zdGFuY2UsIFwiY29tcG9uZW50RGlkTG9hZFwiKTtcbiAgICB9XG4gICAgZW5kUG9zdFVwZGF0ZSgpO1xuICAgIHtcbiAgICAgIGhvc3RSZWYuJG9uUmVhZHlSZXNvbHZlJChlbG0pO1xuICAgICAgaWYgKCFhbmNlc3RvckNvbXBvbmVudCkge1xuICAgICAgICBhcHBEaWRMb2FkKCk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGVuZFBvc3RVcGRhdGUoKTtcbiAgfVxuICB7XG4gICAgaWYgKGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQpIHtcbiAgICAgIGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQoKTtcbiAgICAgIGhvc3RSZWYuJG9uUmVuZGVyUmVzb2x2ZSQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChob3N0UmVmLiRmbGFncyQgJiA1MTIgLyogbmVlZHNSZXJlbmRlciAqLykge1xuICAgICAgbmV4dFRpY2soKCkgPT4gc2NoZWR1bGVVcGRhdGUoaG9zdFJlZiwgZmFsc2UpKTtcbiAgICB9XG4gICAgaG9zdFJlZi4kZmxhZ3MkICY9IH4oNCAvKiBpc1dhaXRpbmdGb3JDaGlsZHJlbiAqLyB8IDUxMiAvKiBuZWVkc1JlcmVuZGVyICovKTtcbiAgfVxufTtcbnZhciBhcHBEaWRMb2FkID0gKHdobykgPT4ge1xuICB7XG4gICAgYWRkSHlkcmF0ZWRGbGFnKGRvYy5kb2N1bWVudEVsZW1lbnQpO1xuICB9XG4gIG5leHRUaWNrKCgpID0+IGVtaXRFdmVudCh3aW4sIFwiYXBwbG9hZFwiLCB7IGRldGFpbDogeyBuYW1lc3BhY2U6IE5BTUVTUEFDRSB9IH0pKTtcbn07XG52YXIgc2FmZUNhbGwgPSAoaW5zdGFuY2UsIG1ldGhvZCwgYXJnKSA9PiB7XG4gIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZVttZXRob2RdKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBpbnN0YW5jZVttZXRob2RdKGFyZyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZUVycm9yKGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufTtcbnZhciBhZGRIeWRyYXRlZEZsYWcgPSAoZWxtKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIGVsbS5jbGFzc0xpc3QuYWRkKChfYSA9IEJVSUxELmh5ZHJhdGVkU2VsZWN0b3JOYW1lKSAhPSBudWxsID8gX2EgOiBcImh5ZHJhdGVkXCIpIDtcbn07XG5cbi8vIHNyYy9ydW50aW1lL3NldC12YWx1ZS50c1xudmFyIGdldFZhbHVlID0gKHJlZiwgcHJvcE5hbWUpID0+IGdldEhvc3RSZWYocmVmKS4kaW5zdGFuY2VWYWx1ZXMkLmdldChwcm9wTmFtZSk7XG52YXIgc2V0VmFsdWUgPSAocmVmLCBwcm9wTmFtZSwgbmV3VmFsLCBjbXBNZXRhKSA9PiB7XG4gIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKHJlZik7XG4gIGlmICghaG9zdFJlZikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDb3VsZG4ndCBmaW5kIGhvc3QgZWxlbWVudCBmb3IgXCIke2NtcE1ldGEuJHRhZ05hbWUkfVwiIGFzIGl0IGlzIHVua25vd24gdG8gdGhpcyBTdGVuY2lsIHJ1bnRpbWUuIFRoaXMgdXN1YWxseSBoYXBwZW5zIHdoZW4gaW50ZWdyYXRpbmcgYSAzcmQgcGFydHkgU3RlbmNpbCBjb21wb25lbnQgd2l0aCBhbm90aGVyIFN0ZW5jaWwgY29tcG9uZW50IG9yIGFwcGxpY2F0aW9uLiBQbGVhc2UgcmVhY2ggb3V0IHRvIHRoZSBtYWludGFpbmVycyBvZiB0aGUgM3JkIHBhcnR5IFN0ZW5jaWwgY29tcG9uZW50IG9yIHJlcG9ydCB0aGlzIG9uIHRoZSBTdGVuY2lsIERpc2NvcmQgc2VydmVyIChodHRwczovL2NoYXQuc3RlbmNpbGpzLmNvbSkgb3IgY29tbWVudCBvbiB0aGlzIHNpbWlsYXIgW0dpdEh1YiBpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL2lvbmljLXRlYW0vc3RlbmNpbC9pc3N1ZXMvNTQ1NykuYFxuICAgICk7XG4gIH1cbiAgY29uc3QgZWxtID0gaG9zdFJlZi4kaG9zdEVsZW1lbnQkIDtcbiAgY29uc3Qgb2xkVmFsID0gaG9zdFJlZi4kaW5zdGFuY2VWYWx1ZXMkLmdldChwcm9wTmFtZSk7XG4gIGNvbnN0IGZsYWdzID0gaG9zdFJlZi4kZmxhZ3MkO1xuICBjb25zdCBpbnN0YW5jZSA9IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgO1xuICBuZXdWYWwgPSBwYXJzZVByb3BlcnR5VmFsdWUobmV3VmFsLCBjbXBNZXRhLiRtZW1iZXJzJFtwcm9wTmFtZV1bMF0pO1xuICBjb25zdCBhcmVCb3RoTmFOID0gTnVtYmVyLmlzTmFOKG9sZFZhbCkgJiYgTnVtYmVyLmlzTmFOKG5ld1ZhbCk7XG4gIGNvbnN0IGRpZFZhbHVlQ2hhbmdlID0gbmV3VmFsICE9PSBvbGRWYWwgJiYgIWFyZUJvdGhOYU47XG4gIGlmICgoIShmbGFncyAmIDggLyogaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLykgfHwgb2xkVmFsID09PSB2b2lkIDApICYmIGRpZFZhbHVlQ2hhbmdlKSB7XG4gICAgaG9zdFJlZi4kaW5zdGFuY2VWYWx1ZXMkLnNldChwcm9wTmFtZSwgbmV3VmFsKTtcbiAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgIGlmIChjbXBNZXRhLiR3YXRjaGVycyQgJiYgZmxhZ3MgJiAxMjggLyogaXNXYXRjaFJlYWR5ICovKSB7XG4gICAgICAgIGNvbnN0IHdhdGNoTWV0aG9kcyA9IGNtcE1ldGEuJHdhdGNoZXJzJFtwcm9wTmFtZV07XG4gICAgICAgIGlmICh3YXRjaE1ldGhvZHMpIHtcbiAgICAgICAgICB3YXRjaE1ldGhvZHMubWFwKCh3YXRjaE1ldGhvZE5hbWUpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGluc3RhbmNlW3dhdGNoTWV0aG9kTmFtZV0obmV3VmFsLCBvbGRWYWwsIHByb3BOYW1lKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZUVycm9yKGUsIGVsbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgoZmxhZ3MgJiAoMiAvKiBoYXNSZW5kZXJlZCAqLyB8IDE2IC8qIGlzUXVldWVkRm9yVXBkYXRlICovKSkgPT09IDIgLyogaGFzUmVuZGVyZWQgKi8pIHtcbiAgICAgICAgc2NoZWR1bGVVcGRhdGUoaG9zdFJlZiwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3J1bnRpbWUvcHJveHktY29tcG9uZW50LnRzXG52YXIgcHJveHlDb21wb25lbnQgPSAoQ3N0ciwgY21wTWV0YSwgZmxhZ3MpID0+IHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgcHJvdG90eXBlID0gQ3N0ci5wcm90b3R5cGU7XG4gIGlmIChjbXBNZXRhLiRtZW1iZXJzJCB8fCAoY21wTWV0YS4kd2F0Y2hlcnMkIHx8IENzdHIud2F0Y2hlcnMpKSB7XG4gICAgaWYgKENzdHIud2F0Y2hlcnMgJiYgIWNtcE1ldGEuJHdhdGNoZXJzJCkge1xuICAgICAgY21wTWV0YS4kd2F0Y2hlcnMkID0gQ3N0ci53YXRjaGVycztcbiAgICB9XG4gICAgY29uc3QgbWVtYmVycyA9IE9iamVjdC5lbnRyaWVzKChfYSA9IGNtcE1ldGEuJG1lbWJlcnMkKSAhPSBudWxsID8gX2EgOiB7fSk7XG4gICAgbWVtYmVycy5tYXAoKFttZW1iZXJOYW1lLCBbbWVtYmVyRmxhZ3NdXSkgPT4ge1xuICAgICAgaWYgKChtZW1iZXJGbGFncyAmIDMxIC8qIFByb3AgKi8gfHwgKGZsYWdzICYgMiAvKiBwcm94eVN0YXRlICovKSAmJiBtZW1iZXJGbGFncyAmIDMyIC8qIFN0YXRlICovKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBtZW1iZXJOYW1lLCB7XG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFZhbHVlKHRoaXMsIG1lbWJlck5hbWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICBzZXRWYWx1ZSh0aGlzLCBtZW1iZXJOYW1lLCBuZXdWYWx1ZSwgY21wTWV0YSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoKGZsYWdzICYgMSAvKiBpc0VsZW1lbnRDb25zdHJ1Y3RvciAqLykpIHtcbiAgICAgIGNvbnN0IGF0dHJOYW1lVG9Qcm9wTmFtZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBwcm90b3R5cGUuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrID0gZnVuY3Rpb24oYXR0ck5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICBwbHQuam1wKCgpID0+IHtcbiAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gYXR0ck5hbWVUb1Byb3BOYW1lLmdldChhdHRyTmFtZSk7XG4gICAgICAgICAgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IHRoaXNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSAmJiB0eXBlb2YgdGhpc1twcm9wTmFtZV0gPT09IFwibnVtYmVyXCIgJiYgLy8gY2FzdCB0eXBlIHRvIG51bWJlciB0byBhdm9pZCBUUyBjb21waWxlciBpc3N1ZXNcbiAgICAgICAgICB0aGlzW3Byb3BOYW1lXSA9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAocHJvcE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgaG9zdFJlZiA9IGdldEhvc3RSZWYodGhpcyk7XG4gICAgICAgICAgICBjb25zdCBmbGFnczIgPSBob3N0UmVmID09IG51bGwgPyB2b2lkIDAgOiBob3N0UmVmLiRmbGFncyQ7XG4gICAgICAgICAgICBpZiAoZmxhZ3MyICYmICEoZmxhZ3MyICYgOCAvKiBpc0NvbnN0cnVjdGluZ0luc3RhbmNlICovKSAmJiBmbGFnczIgJiAxMjggLyogaXNXYXRjaFJlYWR5ICovICYmIG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgICBjb25zdCBpbnN0YW5jZSA9IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQgO1xuICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IChfYTIgPSBjbXBNZXRhLiR3YXRjaGVycyQpID09IG51bGwgPyB2b2lkIDAgOiBfYTJbYXR0ck5hbWVdO1xuICAgICAgICAgICAgICBlbnRyeSA9PSBudWxsID8gdm9pZCAwIDogZW50cnkuZm9yRWFjaCgoY2FsbGJhY2tOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlW2NhbGxiYWNrTmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgaW5zdGFuY2VbY2FsbGJhY2tOYW1lXS5jYWxsKGluc3RhbmNlLCBuZXdWYWx1ZSwgb2xkVmFsdWUsIGF0dHJOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG5ld1ZhbHVlID09PSBudWxsICYmIHR5cGVvZiB0aGlzW3Byb3BOYW1lXSA9PT0gXCJib29sZWFuXCIgPyBmYWxzZSA6IG5ld1ZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBDc3RyLm9ic2VydmVkQXR0cmlidXRlcyA9IEFycmF5LmZyb20oXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgICAgICAgICAuLi5PYmplY3Qua2V5cygoX2IgPSBjbXBNZXRhLiR3YXRjaGVycyQpICE9IG51bGwgPyBfYiA6IHt9KSxcbiAgICAgICAgICAuLi5tZW1iZXJzLmZpbHRlcigoW18sIG1dKSA9PiBtWzBdICYgMTUgLyogSGFzQXR0cmlidXRlICovKS5tYXAoKFtwcm9wTmFtZSwgbV0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJOYW1lID0gbVsxXSB8fCBwcm9wTmFtZTtcbiAgICAgICAgICAgIGF0dHJOYW1lVG9Qcm9wTmFtZS5zZXQoYXR0ck5hbWUsIHByb3BOYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBhdHRyTmFtZTtcbiAgICAgICAgICB9KVxuICAgICAgICBdKVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIENzdHI7XG59O1xuXG4vLyBzcmMvcnVudGltZS9pbml0aWFsaXplLWNvbXBvbmVudC50c1xudmFyIGluaXRpYWxpemVDb21wb25lbnQgPSBhc3luYyAoZWxtLCBob3N0UmVmLCBjbXBNZXRhLCBobXJWZXJzaW9uSWQpID0+IHtcbiAgbGV0IENzdHI7XG4gIGlmICgoaG9zdFJlZi4kZmxhZ3MkICYgMzIgLyogaGFzSW5pdGlhbGl6ZWRDb21wb25lbnQgKi8pID09PSAwKSB7XG4gICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDMyIC8qIGhhc0luaXRpYWxpemVkQ29tcG9uZW50ICovO1xuICAgIGNvbnN0IGJ1bmRsZUlkID0gY21wTWV0YS4kbGF6eUJ1bmRsZUlkJDtcbiAgICBpZiAoYnVuZGxlSWQpIHtcbiAgICAgIGNvbnN0IENzdHJJbXBvcnQgPSBsb2FkTW9kdWxlKGNtcE1ldGEpO1xuICAgICAgaWYgKENzdHJJbXBvcnQgJiYgXCJ0aGVuXCIgaW4gQ3N0ckltcG9ydCkge1xuICAgICAgICBjb25zdCBlbmRMb2FkID0gdW5pcXVlVGltZSgpO1xuICAgICAgICBDc3RyID0gYXdhaXQgQ3N0ckltcG9ydDtcbiAgICAgICAgZW5kTG9hZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQ3N0ciA9IENzdHJJbXBvcnQ7XG4gICAgICB9XG4gICAgICBpZiAoIUNzdHIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb25zdHJ1Y3RvciBmb3IgXCIke2NtcE1ldGEuJHRhZ05hbWUkfSMke2hvc3RSZWYuJG1vZGVOYW1lJH1cIiB3YXMgbm90IGZvdW5kYCk7XG4gICAgICB9XG4gICAgICBpZiAoIUNzdHIuaXNQcm94aWVkKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBjbXBNZXRhLiR3YXRjaGVycyQgPSBDc3RyLndhdGNoZXJzO1xuICAgICAgICB9XG4gICAgICAgIHByb3h5Q29tcG9uZW50KENzdHIsIGNtcE1ldGEsIDIgLyogcHJveHlTdGF0ZSAqLyk7XG4gICAgICAgIENzdHIuaXNQcm94aWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVuZE5ld0luc3RhbmNlID0gY3JlYXRlVGltZShcImNyZWF0ZUluc3RhbmNlXCIsIGNtcE1ldGEuJHRhZ05hbWUkKTtcbiAgICAgIHtcbiAgICAgICAgaG9zdFJlZi4kZmxhZ3MkIHw9IDggLyogaXNDb25zdHJ1Y3RpbmdJbnN0YW5jZSAqLztcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBDc3RyKGhvc3RSZWYpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlRXJyb3IoZSk7XG4gICAgICB9XG4gICAgICB7XG4gICAgICAgIGhvc3RSZWYuJGZsYWdzJCAmPSB+OCAvKiBpc0NvbnN0cnVjdGluZ0luc3RhbmNlICovO1xuICAgICAgfVxuICAgICAge1xuICAgICAgICBob3N0UmVmLiRmbGFncyQgfD0gMTI4IC8qIGlzV2F0Y2hSZWFkeSAqLztcbiAgICAgIH1cbiAgICAgIGVuZE5ld0luc3RhbmNlKCk7XG4gICAgICBmaXJlQ29ubmVjdGVkQ2FsbGJhY2soaG9zdFJlZi4kbGF6eUluc3RhbmNlJCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENzdHIgPSBlbG0uY29uc3RydWN0b3I7XG4gICAgICBjb25zdCBjbXBUYWcgPSBlbG0ubG9jYWxOYW1lO1xuICAgICAgY3VzdG9tRWxlbWVudHMud2hlbkRlZmluZWQoY21wVGFnKS50aGVuKCgpID0+IGhvc3RSZWYuJGZsYWdzJCB8PSAxMjggLyogaXNXYXRjaFJlYWR5ICovKTtcbiAgICB9XG4gICAgaWYgKENzdHIgJiYgQ3N0ci5zdHlsZSkge1xuICAgICAgbGV0IHN0eWxlO1xuICAgICAgaWYgKHR5cGVvZiBDc3RyLnN0eWxlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHN0eWxlID0gQ3N0ci5zdHlsZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjb3BlSWQyID0gZ2V0U2NvcGVJZChjbXBNZXRhKTtcbiAgICAgIGlmICghc3R5bGVzLmhhcyhzY29wZUlkMikpIHtcbiAgICAgICAgY29uc3QgZW5kUmVnaXN0ZXJTdHlsZXMgPSBjcmVhdGVUaW1lKFwicmVnaXN0ZXJTdHlsZXNcIiwgY21wTWV0YS4kdGFnTmFtZSQpO1xuICAgICAgICByZWdpc3RlclN0eWxlKHNjb3BlSWQyLCBzdHlsZSwgISEoY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSk7XG4gICAgICAgIGVuZFJlZ2lzdGVyU3R5bGVzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGFuY2VzdG9yQ29tcG9uZW50ID0gaG9zdFJlZi4kYW5jZXN0b3JDb21wb25lbnQkO1xuICBjb25zdCBzY2hlZHVsZSA9ICgpID0+IHNjaGVkdWxlVXBkYXRlKGhvc3RSZWYsIHRydWUpO1xuICBpZiAoYW5jZXN0b3JDb21wb25lbnQgJiYgYW5jZXN0b3JDb21wb25lbnRbXCJzLXJjXCJdKSB7XG4gICAgYW5jZXN0b3JDb21wb25lbnRbXCJzLXJjXCJdLnB1c2goc2NoZWR1bGUpO1xuICB9IGVsc2Uge1xuICAgIHNjaGVkdWxlKCk7XG4gIH1cbn07XG52YXIgZmlyZUNvbm5lY3RlZENhbGxiYWNrID0gKGluc3RhbmNlKSA9PiB7XG4gIHtcbiAgICBzYWZlQ2FsbChpbnN0YW5jZSwgXCJjb25uZWN0ZWRDYWxsYmFja1wiKTtcbiAgfVxufTtcblxuLy8gc3JjL3J1bnRpbWUvY29ubmVjdGVkLWNhbGxiYWNrLnRzXG52YXIgY29ubmVjdGVkQ2FsbGJhY2sgPSAoZWxtKSA9PiB7XG4gIGlmICgocGx0LiRmbGFncyQgJiAxIC8qIGlzVG1wRGlzY29ubmVjdGVkICovKSA9PT0gMCkge1xuICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKGVsbSk7XG4gICAgY29uc3QgY21wTWV0YSA9IGhvc3RSZWYuJGNtcE1ldGEkO1xuICAgIGNvbnN0IGVuZENvbm5lY3RlZCA9IGNyZWF0ZVRpbWUoXCJjb25uZWN0ZWRDYWxsYmFja1wiLCBjbXBNZXRhLiR0YWdOYW1lJCk7XG4gICAgaWYgKCEoaG9zdFJlZi4kZmxhZ3MkICYgMSAvKiBoYXNDb25uZWN0ZWQgKi8pKSB7XG4gICAgICBob3N0UmVmLiRmbGFncyQgfD0gMSAvKiBoYXNDb25uZWN0ZWQgKi87XG4gICAgICB7XG4gICAgICAgIGxldCBhbmNlc3RvckNvbXBvbmVudCA9IGVsbTtcbiAgICAgICAgd2hpbGUgKGFuY2VzdG9yQ29tcG9uZW50ID0gYW5jZXN0b3JDb21wb25lbnQucGFyZW50Tm9kZSB8fCBhbmNlc3RvckNvbXBvbmVudC5ob3N0KSB7XG4gICAgICAgICAgaWYgKGFuY2VzdG9yQ29tcG9uZW50W1wicy1wXCJdKSB7XG4gICAgICAgICAgICBhdHRhY2hUb0FuY2VzdG9yKGhvc3RSZWYsIGhvc3RSZWYuJGFuY2VzdG9yQ29tcG9uZW50JCA9IGFuY2VzdG9yQ29tcG9uZW50KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNtcE1ldGEuJG1lbWJlcnMkKSB7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGNtcE1ldGEuJG1lbWJlcnMkKS5tYXAoKFttZW1iZXJOYW1lLCBbbWVtYmVyRmxhZ3NdXSkgPT4ge1xuICAgICAgICAgIGlmIChtZW1iZXJGbGFncyAmIDMxIC8qIFByb3AgKi8gJiYgZWxtLmhhc093blByb3BlcnR5KG1lbWJlck5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGVsbVttZW1iZXJOYW1lXTtcbiAgICAgICAgICAgIGRlbGV0ZSBlbG1bbWVtYmVyTmFtZV07XG4gICAgICAgICAgICBlbG1bbWVtYmVyTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAge1xuICAgICAgICBpbml0aWFsaXplQ29tcG9uZW50KGVsbSwgaG9zdFJlZiwgY21wTWV0YSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChob3N0UmVmID09IG51bGwgPyB2b2lkIDAgOiBob3N0UmVmLiRsYXp5SW5zdGFuY2UkKSB7XG4gICAgICAgIGZpcmVDb25uZWN0ZWRDYWxsYmFjayhob3N0UmVmLiRsYXp5SW5zdGFuY2UkKTtcbiAgICAgIH0gZWxzZSBpZiAoaG9zdFJlZiA9PSBudWxsID8gdm9pZCAwIDogaG9zdFJlZi4kb25SZWFkeVByb21pc2UkKSB7XG4gICAgICAgIGhvc3RSZWYuJG9uUmVhZHlQcm9taXNlJC50aGVuKCgpID0+IGZpcmVDb25uZWN0ZWRDYWxsYmFjayhob3N0UmVmLiRsYXp5SW5zdGFuY2UkKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVuZENvbm5lY3RlZCgpO1xuICB9XG59O1xudmFyIGRpc2Nvbm5lY3RJbnN0YW5jZSA9IChpbnN0YW5jZSkgPT4ge1xuICB7XG4gICAgc2FmZUNhbGwoaW5zdGFuY2UsIFwiZGlzY29ubmVjdGVkQ2FsbGJhY2tcIik7XG4gIH1cbn07XG52YXIgZGlzY29ubmVjdGVkQ2FsbGJhY2sgPSBhc3luYyAoZWxtKSA9PiB7XG4gIGlmICgocGx0LiRmbGFncyQgJiAxIC8qIGlzVG1wRGlzY29ubmVjdGVkICovKSA9PT0gMCkge1xuICAgIGNvbnN0IGhvc3RSZWYgPSBnZXRIb3N0UmVmKGVsbSk7XG4gICAgaWYgKGhvc3RSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IGhvc3RSZWYuJGxhenlJbnN0YW5jZSQpIHtcbiAgICAgIGRpc2Nvbm5lY3RJbnN0YW5jZShob3N0UmVmLiRsYXp5SW5zdGFuY2UkKTtcbiAgICB9IGVsc2UgaWYgKGhvc3RSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IGhvc3RSZWYuJG9uUmVhZHlQcm9taXNlJCkge1xuICAgICAgaG9zdFJlZi4kb25SZWFkeVByb21pc2UkLnRoZW4oKCkgPT4gZGlzY29ubmVjdEluc3RhbmNlKGhvc3RSZWYuJGxhenlJbnN0YW5jZSQpKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9ydW50aW1lL2Jvb3RzdHJhcC1sYXp5LnRzXG52YXIgYm9vdHN0cmFwTGF6eSA9IChsYXp5QnVuZGxlcywgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgZW5kQm9vdHN0cmFwID0gY3JlYXRlVGltZSgpO1xuICBjb25zdCBjbXBUYWdzID0gW107XG4gIGNvbnN0IGV4Y2x1ZGUgPSBvcHRpb25zLmV4Y2x1ZGUgfHwgW107XG4gIGNvbnN0IGN1c3RvbUVsZW1lbnRzMiA9IHdpbi5jdXN0b21FbGVtZW50cztcbiAgY29uc3QgaGVhZCA9IGRvYy5oZWFkO1xuICBjb25zdCBtZXRhQ2hhcnNldCA9IC8qIEBfX1BVUkVfXyAqLyBoZWFkLnF1ZXJ5U2VsZWN0b3IoXCJtZXRhW2NoYXJzZXRdXCIpO1xuICBjb25zdCBkYXRhU3R5bGVzID0gLyogQF9fUFVSRV9fICovIGRvYy5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gIGNvbnN0IGRlZmVycmVkQ29ubmVjdGVkQ2FsbGJhY2tzID0gW107XG4gIGxldCBhcHBMb2FkRmFsbGJhY2s7XG4gIGxldCBpc0Jvb3RzdHJhcHBpbmcgPSB0cnVlO1xuICBPYmplY3QuYXNzaWduKHBsdCwgb3B0aW9ucyk7XG4gIHBsdC4kcmVzb3VyY2VzVXJsJCA9IG5ldyBVUkwob3B0aW9ucy5yZXNvdXJjZXNVcmwgfHwgXCIuL1wiLCBkb2MuYmFzZVVSSSkuaHJlZjtcbiAgbGV0IGhhc1Nsb3RSZWxvY2F0aW9uID0gZmFsc2U7XG4gIGxhenlCdW5kbGVzLm1hcCgobGF6eUJ1bmRsZSkgPT4ge1xuICAgIGxhenlCdW5kbGVbMV0ubWFwKChjb21wYWN0TWV0YSkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIGNvbnN0IGNtcE1ldGEgPSB7XG4gICAgICAgICRmbGFncyQ6IGNvbXBhY3RNZXRhWzBdLFxuICAgICAgICAkdGFnTmFtZSQ6IGNvbXBhY3RNZXRhWzFdLFxuICAgICAgICAkbWVtYmVycyQ6IGNvbXBhY3RNZXRhWzJdLFxuICAgICAgICAkbGlzdGVuZXJzJDogY29tcGFjdE1ldGFbM11cbiAgICAgIH07XG4gICAgICBpZiAoY21wTWV0YS4kZmxhZ3MkICYgNCAvKiBoYXNTbG90UmVsb2NhdGlvbiAqLykge1xuICAgICAgICBoYXNTbG90UmVsb2NhdGlvbiA9IHRydWU7XG4gICAgICB9XG4gICAgICB7XG4gICAgICAgIGNtcE1ldGEuJG1lbWJlcnMkID0gY29tcGFjdE1ldGFbMl07XG4gICAgICB9XG4gICAgICB7XG4gICAgICAgIGNtcE1ldGEuJHdhdGNoZXJzJCA9IChfYTIgPSBjb21wYWN0TWV0YVs0XSkgIT0gbnVsbCA/IF9hMiA6IHt9O1xuICAgICAgfVxuICAgICAgY29uc3QgdGFnTmFtZSA9IGNtcE1ldGEuJHRhZ05hbWUkO1xuICAgICAgY29uc3QgSG9zdEVsZW1lbnQgPSBjbGFzcyBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICAgICAgLy8gU3RlbmNpbExhenlIb3N0XG4gICAgICAgIGNvbnN0cnVjdG9yKHNlbGYpIHtcbiAgICAgICAgICBzdXBlcihzZWxmKTtcbiAgICAgICAgICB0aGlzLmhhc1JlZ2lzdGVyZWRFdmVudExpc3RlbmVycyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICAgIHJlZ2lzdGVySG9zdChzZWxmLCBjbXBNZXRhKTtcbiAgICAgICAgICBpZiAoY21wTWV0YS4kZmxhZ3MkICYgMSAvKiBzaGFkb3dEb21FbmNhcHN1bGF0aW9uICovKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICghc2VsZi5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hTaGFkb3coeyBtb2RlOiBcIm9wZW5cIiB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuc2hhZG93Um9vdC5tb2RlICE9PSBcIm9wZW5cIikge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICBgVW5hYmxlIHRvIHJlLXVzZSBleGlzdGluZyBzaGFkb3cgcm9vdCBmb3IgJHtjbXBNZXRhLiR0YWdOYW1lJH0hIE1vZGUgaXMgc2V0IHRvICR7c2VsZi5zaGFkb3dSb290Lm1vZGV9IGJ1dCBTdGVuY2lsIG9ubHkgc3VwcG9ydHMgb3BlbiBzaGFkb3cgcm9vdHMuYFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgICAgZ2V0SG9zdFJlZih0aGlzKTtcbiAgICAgICAgICBpZiAoIXRoaXMuaGFzUmVnaXN0ZXJlZEV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmhhc1JlZ2lzdGVyZWRFdmVudExpc3RlbmVycyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhcHBMb2FkRmFsbGJhY2spIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChhcHBMb2FkRmFsbGJhY2spO1xuICAgICAgICAgICAgYXBwTG9hZEZhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQm9vdHN0cmFwcGluZykge1xuICAgICAgICAgICAgZGVmZXJyZWRDb25uZWN0ZWRDYWxsYmFja3MucHVzaCh0aGlzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGx0LmptcCgoKSA9PiBjb25uZWN0ZWRDYWxsYmFjayh0aGlzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICAgIHBsdC5qbXAoKCkgPT4gZGlzY29ubmVjdGVkQ2FsbGJhY2sodGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbXBvbmVudE9uUmVhZHkoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldEhvc3RSZWYodGhpcykuJG9uUmVhZHlQcm9taXNlJDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNtcE1ldGEuJGxhenlCdW5kbGVJZCQgPSBsYXp5QnVuZGxlWzBdO1xuICAgICAgaWYgKCFleGNsdWRlLmluY2x1ZGVzKHRhZ05hbWUpICYmICFjdXN0b21FbGVtZW50czIuZ2V0KHRhZ05hbWUpKSB7XG4gICAgICAgIGNtcFRhZ3MucHVzaCh0YWdOYW1lKTtcbiAgICAgICAgY3VzdG9tRWxlbWVudHMyLmRlZmluZShcbiAgICAgICAgICB0YWdOYW1lLFxuICAgICAgICAgIHByb3h5Q29tcG9uZW50KEhvc3RFbGVtZW50LCBjbXBNZXRhLCAxIC8qIGlzRWxlbWVudENvbnN0cnVjdG9yICovKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgaWYgKGNtcFRhZ3MubGVuZ3RoID4gMCkge1xuICAgIGlmIChoYXNTbG90UmVsb2NhdGlvbikge1xuICAgICAgZGF0YVN0eWxlcy50ZXh0Q29udGVudCArPSBTTE9UX0ZCX0NTUztcbiAgICB9XG4gICAge1xuICAgICAgZGF0YVN0eWxlcy50ZXh0Q29udGVudCArPSBjbXBUYWdzLnNvcnQoKSArIEhZRFJBVEVEX0NTUztcbiAgICB9XG4gICAgaWYgKGRhdGFTdHlsZXMuaW5uZXJIVE1MLmxlbmd0aCkge1xuICAgICAgZGF0YVN0eWxlcy5zZXRBdHRyaWJ1dGUoXCJkYXRhLXN0eWxlc1wiLCBcIlwiKTtcbiAgICAgIGNvbnN0IG5vbmNlID0gKF9hID0gcGx0LiRub25jZSQpICE9IG51bGwgPyBfYSA6IHF1ZXJ5Tm9uY2VNZXRhVGFnQ29udGVudChkb2MpO1xuICAgICAgaWYgKG5vbmNlICE9IG51bGwpIHtcbiAgICAgICAgZGF0YVN0eWxlcy5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBub25jZSk7XG4gICAgICB9XG4gICAgICBoZWFkLmluc2VydEJlZm9yZShkYXRhU3R5bGVzLCBtZXRhQ2hhcnNldCA/IG1ldGFDaGFyc2V0Lm5leHRTaWJsaW5nIDogaGVhZC5maXJzdENoaWxkKTtcbiAgICB9XG4gIH1cbiAgaXNCb290c3RyYXBwaW5nID0gZmFsc2U7XG4gIGlmIChkZWZlcnJlZENvbm5lY3RlZENhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICBkZWZlcnJlZENvbm5lY3RlZENhbGxiYWNrcy5tYXAoKGhvc3QpID0+IGhvc3QuY29ubmVjdGVkQ2FsbGJhY2soKSk7XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgcGx0LmptcCgoKSA9PiBhcHBMb2FkRmFsbGJhY2sgPSBzZXRUaW1lb3V0KGFwcERpZExvYWQsIDMwKSk7XG4gICAgfVxuICB9XG4gIGVuZEJvb3RzdHJhcCgpO1xufTtcblxuLy8gc3JjL3J1bnRpbWUvbm9uY2UudHNcbnZhciBzZXROb25jZSA9IChub25jZSkgPT4gcGx0LiRub25jZSQgPSBub25jZTtcblxuZXhwb3J0IHsgYm9vdHN0cmFwTGF6eSBhcyBiLCBjcmVhdGVFdmVudCBhcyBjLCBnZXRFbGVtZW50IGFzIGcsIGgsIHByb21pc2VSZXNvbHZlIGFzIHAsIHJlZ2lzdGVySW5zdGFuY2UgYXMgciwgc2V0Tm9uY2UgYXMgcyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC00YjhhOTRjOS5qcy5tYXAiLCIoZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvdyYmdm9pZCAwIT09d2luZG93LlJlZmxlY3QmJnZvaWQgMCE9PXdpbmRvdy5jdXN0b21FbGVtZW50cyl7dmFyIGE9SFRNTEVsZW1lbnQ7d2luZG93LkhUTUxFbGVtZW50PWZ1bmN0aW9uKCl7cmV0dXJuIFJlZmxlY3QuY29uc3RydWN0KGEsW10sdGhpcy5jb25zdHJ1Y3Rvcil9O0hUTUxFbGVtZW50LnByb3RvdHlwZT1hLnByb3RvdHlwZTtIVE1MRWxlbWVudC5wcm90b3R5cGUuY29uc3RydWN0b3I9SFRNTEVsZW1lbnQ7T2JqZWN0LnNldFByb3RvdHlwZU9mKEhUTUxFbGVtZW50LGEpfX0pKCk7XG5leHBvcnQgKiBmcm9tICcuLi9lc20vbG9hZGVyLmpzJzsiLCJpbXBvcnQgeyBiIGFzIGJvb3RzdHJhcExhenkgfSBmcm9tICcuL2luZGV4LTRiOGE5NGM5LmpzJztcbmV4cG9ydCB7IHMgYXMgc2V0Tm9uY2UgfSBmcm9tICcuL2luZGV4LTRiOGE5NGM5LmpzJztcbmltcG9ydCB7IGcgYXMgZ2xvYmFsU2NyaXB0cyB9IGZyb20gJy4vYXBwLWdsb2JhbHMtMGY5OTNjZTUuanMnO1xuXG5jb25zdCBkZWZpbmVDdXN0b21FbGVtZW50cyA9IGFzeW5jICh3aW4sIG9wdGlvbnMpID0+IHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gdW5kZWZpbmVkO1xuICBhd2FpdCBnbG9iYWxTY3JpcHRzKCk7XG4gIHJldHVybiBib290c3RyYXBMYXp5KFtbXCJtbS1pbnN0YWxsLW1vZGFsXzNcIixbWzEsXCJtbS1pbnN0YWxsLW1vZGFsXCIse1wibGlua1wiOlsxXSxcInNka1ZlcnNpb25cIjpbMSxcInNkay12ZXJzaW9uXCJdLFwicHJlZmVyRGVza3RvcFwiOls0LFwicHJlZmVyLWRlc2t0b3BcIl0sXCJ0YWJcIjpbMzJdLFwiaXNEZWZhdWx0VGFiXCI6WzMyXSxcInRyYW5zbGF0aW9uc0xvYWRlZFwiOlszMl19LG51bGwse1wicHJlZmVyRGVza3RvcFwiOltcInVwZGF0ZVByZWZlckRlc2t0b3BcIl19XSxbMSxcIm1tLXBlbmRpbmctbW9kYWxcIix7XCJkaXNwbGF5T1RQXCI6WzQsXCJkaXNwbGF5LW8tdC1wXCJdLFwic2RrVmVyc2lvblwiOlsxLFwic2RrLXZlcnNpb25cIl0sXCJvdHBDb2RlXCI6WzEsXCJvdHAtY29kZVwiXSxcInRyYW5zbGF0aW9uc0xvYWRlZFwiOlszMl19XSxbMSxcIm1tLXNlbGVjdC1tb2RhbFwiLHtcImxpbmtcIjpbMV0sXCJzZGtWZXJzaW9uXCI6WzEsXCJzZGstdmVyc2lvblwiXSxcInByZWZlckRlc2t0b3BcIjpbNCxcInByZWZlci1kZXNrdG9wXCJdLFwidGFiXCI6WzMyXSxcImlzRGVmYXVsdFRhYlwiOlszMl0sXCJ0cmFuc2xhdGlvbnNMb2FkZWRcIjpbMzJdfSxudWxsLHtcInByZWZlckRlc2t0b3BcIjpbXCJ1cGRhdGVQcmVmZXJEZXNrdG9wXCJdfV1dXV0sIG9wdGlvbnMpO1xufTtcblxuZXhwb3J0IHsgZGVmaW5lQ3VzdG9tRWxlbWVudHMgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZGVyLmpzLm1hcCIsImltcG9ydCB7IGgsIHIgYXMgcmVnaXN0ZXJJbnN0YW5jZSwgYyBhcyBjcmVhdGVFdmVudCwgZyBhcyBnZXRFbGVtZW50IH0gZnJvbSAnLi9pbmRleC00YjhhOTRjOS5qcyc7XG5cbmNvbnN0IHdpZGdldFdyYXBwZXJTdHlsZSA9IHtcbiAgICBmb250RmFtaWx5OiAnUm9ib3RvLCBzYW5zLXNlcmlmJyxcbn07XG5jb25zdCBXaWRnZXRXcmFwcGVyID0gKHsgY2xhc3NOYW1lLCB9LCBjaGlsZHJlbikgPT4ge1xuICAgIHJldHVybiAoaChcImRpdlwiLCB7IHN0eWxlOiB3aWRnZXRXcmFwcGVyU3R5bGUsIGNsYXNzOiBjbGFzc05hbWUgfSwgY2hpbGRyZW4pKTtcbn07XG5cbmNvbnN0IEFkdmFudGFnZXNMaXN0SXRlbSA9ICh7IEljb24sIHRleHQgfSkgPT4gKGgoXCJkaXZcIiwgeyBjbGFzczogJ2ZsZXhDb250YWluZXInLCBzdHlsZTogeyBwYWRkaW5nOiAnNicsIGZsZXhEaXJlY3Rpb246ICdyb3cnIH0gfSxcbiAgICBoKFwiZGl2XCIsIHsgY2xhc3M6ICdmbGV4SXRlbTEnIH0sXG4gICAgICAgIGgoSWNvbiwgbnVsbCkpLFxuICAgIGgoXCJkaXZcIiwgeyBjbGFzczogJ2ZsZXhJdGVtMTEnIH0sXG4gICAgICAgIGgoXCJzcGFuXCIsIHsgc3R5bGU6IHsgbGluZUhlaWdodDogJzInLCBjb2xvcjogJ2JsYWNrJyB9IH0sIHRleHQpKSkpO1xuXG5jb25zdCBMb2NrSWNvbiA9ICgpID0+IChoKFwic3ZnXCIsIHsgd2lkdGg6IFwiMjBcIiwgaGVpZ2h0OiBcIjE4XCIsIHZpZXdCb3g6IFwiMCAwIDIwIDE4XCIsIGZpbGw6IFwibm9uZVwiLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIH0sXG4gICAgaChcInBhdGhcIiwgeyBkOiBcIk0yMC4wMDAyIDcuOTcwMlYxMC4wMzAyQzIwLjAwMDIgMTAuNTgwMiAxOS41NjAyIDExLjAzMDIgMTkuMDAwMiAxMS4wNTAySDE3LjA0MDJDMTUuOTYwMiAxMS4wNTAyIDE0Ljk3MDIgMTAuMjYwMiAxNC44ODAyIDkuMTgwMkMxNC44MjAyIDguNTUwMiAxNS4wNjAyIDcuOTYwMiAxNS40ODAyIDcuNTUwMkMxNS44NTAyIDcuMTcwMiAxNi4zNjAyIDYuOTUwMiAxNi45MjAyIDYuOTUwMkgxOS4wMDAyQzE5LjU2MDIgNi45NzAyIDIwLjAwMDIgNy40MjAyIDIwLjAwMDIgNy45NzAyWlwiLCBmaWxsOiBcIiMwMzdERDZcIiB9KSxcbiAgICBoKFwicGF0aFwiLCB7IGQ6IFwiTTE4LjQ3IDEyLjU1SDE3LjA0QzE1LjE0IDEyLjU1IDEzLjU0IDExLjEyIDEzLjM4IDkuM0MxMy4yOSA4LjI2IDEzLjY3IDcuMjIgMTQuNDMgNi40OEMxNS4wNyA1LjgyIDE1Ljk2IDUuNDUgMTYuOTIgNS40NUgxOC40N0MxOC43NiA1LjQ1IDE5IDUuMjEgMTguOTcgNC45MkMxOC43NSAyLjQ5IDE3LjE0IDAuODMgMTQuNzUgMC41NUMxNC41MSAwLjUxIDE0LjI2IDAuNSAxNCAwLjVINUM0LjcyIDAuNSA0LjQ1IDAuNTIgNC4xOSAwLjU2QzEuNjQgMC44OCAwIDIuNzggMCA1LjVWMTIuNUMwIDE1LjI2IDIuMjQgMTcuNSA1IDE3LjVIMTRDMTYuOCAxNy41IDE4LjczIDE1Ljc1IDE4Ljk3IDEzLjA4QzE5IDEyLjc5IDE4Ljc2IDEyLjU1IDE4LjQ3IDEyLjU1Wk0xMSA2Ljc1SDVDNC41OSA2Ljc1IDQuMjUgNi40MSA0LjI1IDZDNC4yNSA1LjU5IDQuNTkgNS4yNSA1IDUuMjVIMTFDMTEuNDEgNS4yNSAxMS43NSA1LjU5IDExLjc1IDZDMTEuNzUgNi40MSAxMS40MSA2Ljc1IDExIDYuNzVaXCIsIGZpbGw6IFwiIzAzN0RENlwiIH0pKSk7XG5cbmNvbnN0IEhlYXJ0SWNvbiA9ICgpID0+IChoKFwic3ZnXCIsIHsgd2lkdGg6IFwiMjBcIiwgaGVpZ2h0OiBcIjE4XCIsIHZpZXdCb3g6IFwiMCAwIDIwIDE4XCIsIGZpbGw6IFwibm9uZVwiLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIH0sXG4gICAgaChcInBhdGhcIiwgeyBkOiBcIk0xNC40NCAwLjA5OTk3NTZDMTIuNjMgMC4wOTk5NzU2IDExLjAxIDAuOTc5OTc2IDEwIDIuMzI5OThDOC45OSAwLjk3OTk3NiA3LjM3IDAuMDk5OTc1NiA1LjU2IDAuMDk5OTc1NkMyLjQ5IDAuMDk5OTc1NiAwIDIuNTk5OTggMCA1LjY4OTk4QzAgNi44Nzk5OCAwLjE5IDcuOTc5OTggMC41MiA4Ljk5OTk4QzIuMSAxNCA2Ljk3IDE2Ljk5IDkuMzggMTcuODFDOS43MiAxNy45MyAxMC4yOCAxNy45MyAxMC42MiAxNy44MUMxMy4wMyAxNi45OSAxNy45IDE0IDE5LjQ4IDguOTk5OThDMTkuODEgNy45Nzk5OCAyMCA2Ljg3OTk4IDIwIDUuNjg5OThDMjAgMi41OTk5OCAxNy41MSAwLjA5OTk3NTYgMTQuNDQgMC4wOTk5NzU2WlwiLCBmaWxsOiBcIiMwMzdERDZcIiB9KSkpO1xuXG5jb25zdCBXYWxsZXRJY29uID0gKCkgPT4gKGgoXCJzdmdcIiwgeyB3aWR0aDogXCIyMFwiLCBoZWlnaHQ6IFwiMjBcIiwgdmlld0JveDogXCIwIDAgMjAgMjBcIiwgZmlsbDogXCJub25lXCIsIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgfSxcbiAgICBoKFwicGF0aFwiLCB7IGQ6IFwiTTE2LjI4IDcuNTNWNi4yOEMxNi4yOCAzLjU4IDE1LjYzIDAgMTAgMEM0LjM3IDAgMy43MiAzLjU4IDMuNzIgNi4yOFY3LjUzQzAuOTIgNy44OCAwIDkuMyAwIDEyLjc5VjE0LjY1QzAgMTguNzUgMS4yNSAyMCA1LjM1IDIwSDE0LjY1QzE4Ljc1IDIwIDIwIDE4Ljc1IDIwIDE0LjY1VjEyLjc5QzIwIDkuMyAxOS4wOCA3Ljg4IDE2LjI4IDcuNTNaTTEwIDE2Ljc0QzguMzMgMTYuNzQgNi45OCAxNS4zOCA2Ljk4IDEzLjcyQzYuOTggMTIuMDUgOC4zNCAxMC43IDEwIDEwLjdDMTEuNjYgMTAuNyAxMy4wMiAxMi4wNiAxMy4wMiAxMy43MkMxMy4wMiAxNS4zOSAxMS42NyAxNi43NCAxMCAxNi43NFpNNS4zNSA3LjQ0QzUuMjcgNy40NCA1LjIgNy40NCA1LjEyIDcuNDRWNi4yOEM1LjEyIDMuMzUgNS45NSAxLjQgMTAgMS40QzE0LjA1IDEuNCAxNC44OCAzLjM1IDE0Ljg4IDYuMjhWNy40NUMxNC44IDcuNDUgMTQuNzMgNy40NSAxNC42NSA3LjQ1SDUuMzVWNy40NFpcIiwgZmlsbDogXCIjMDM3REQ2XCIgfSkpKTtcblxuY29uc3QgSW5zdGFsbEljb24gPSAoKSA9PiAoaChcInN2Z1wiLCB7IHdpZHRoOiBcIjIwXCIsIGhlaWdodDogXCIyMFwiLCB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBmaWxsOiBcIm5vbmVcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB9LFxuICAgIGgoXCJwYXRoXCIsIHsgZDogXCJNMTYuNDQwNSA4Ljg5OTlDMjAuMDQwNSA5LjIwOTkgMjEuNTEwNSAxMS4wNTk5IDIxLjUxMDUgMTUuMTA5OVYxNS4yMzk5QzIxLjUxMDUgMTkuNzA5OSAxOS43MjA1IDIxLjQ5OTkgMTUuMjUwNSAyMS40OTk5SDguNzQwNDdDNC4yNzA0NyAyMS40OTk5IDIuNDgwNDcgMTkuNzA5OSAyLjQ4MDQ3IDE1LjIzOTlWMTUuMTA5OUMyLjQ4MDQ3IDExLjA4OTkgMy45MzA0NyA5LjIzOTkgNy40NzA0NyA4LjkwOTlcIiwgc3Ryb2tlOiBcIndoaXRlXCIsIFwic3Ryb2tlLXdpZHRoXCI6IFwiMS41XCIsIFwic3Ryb2tlLWxpbmVjYXBcIjogXCJyb3VuZFwiLCBcInN0cm9rZS1saW5lam9pblwiOiBcInJvdW5kXCIgfSksXG4gICAgaChcInBhdGhcIiwgeyBkOiBcIk0xMiAyVjE0Ljg4XCIsIHN0cm9rZTogXCJ3aGl0ZVwiLCBcInN0cm9rZS13aWR0aFwiOiBcIjEuNVwiLCBcInN0cm9rZS1saW5lY2FwXCI6IFwicm91bmRcIiwgXCJzdHJva2UtbGluZWpvaW5cIjogXCJyb3VuZFwiIH0pLFxuICAgIGgoXCJwYXRoXCIsIHsgZDogXCJNMTUuMzUwNCAxMi42NDk5TDEyLjAwMDQgMTUuOTk5OUw4LjY1MDM5IDEyLjY0OTlcIiwgc3Ryb2tlOiBcIndoaXRlXCIsIFwic3Ryb2tlLXdpZHRoXCI6IFwiMS41XCIsIFwic3Ryb2tlLWxpbmVjYXBcIjogXCJyb3VuZFwiLCBcInN0cm9rZS1saW5lam9pblwiOiBcInJvdW5kXCIgfSkpKTtcblxuZnVuY3Rpb24gU0RLVmVyc2lvbih7IHZlcnNpb24gfSkge1xuICAgIHJldHVybiAoaChcImRpdlwiLCB7IHN0eWxlOiB7IHRleHRBbGlnbjogJ2NlbnRlcicsIGNvbG9yOiAnI0JCQzBDNScsIGZvbnRTaXplOiAnMTInIH0gfSxcbiAgICAgICAgXCJTREsgVmVyc2lvbiBcIixcbiAgICAgICAgdmVyc2lvbiA/IGB2JHt2ZXJzaW9ufWAgOiBgdW5rbm93bmApKTtcbn1cblxuY29uc3QgQ2xvc2VCdXR0b24gPSAoKSA9PiAoaChcInN2Z1wiLCB7IHdpZHRoOiBcIjE0XCIsIGhlaWdodDogXCIxNFwiLCB2aWV3Qm94OiBcIjAgMCAxNiAxNlwiLCBmaWxsOiBcIm5vbmVcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB9LFxuICAgIGgoXCJyZWN0XCIsIHsgd2lkdGg6IFwiMTZcIiwgaGVpZ2h0OiBcIjE2XCIsIGZpbGw6IFwid2hpdGVcIiB9KSxcbiAgICBoKFwicGF0aFwiLCB7IFwiZmlsbC1ydWxlXCI6IFwiZXZlbm9kZFwiLCBcImNsaXAtcnVsZVwiOiBcImV2ZW5vZGRcIiwgZDogXCJNMi40MDU1NCAyLjQwNTU0QzIuOTQ2MjcgMS44NjQ4MiAzLjgyMjk2IDEuODY0ODIgNC4zNjM2OSAyLjQwNTU0TDggNi4wNDE4NkwxMS42MzYzIDIuNDA1NTRDMTIuMTc3IDEuODY0ODIgMTMuMDUzNyAxLjg2NDgyIDEzLjU5NDUgMi40MDU1NEMxNC4xMzUyIDIuOTQ2MjcgMTQuMTM1MiAzLjgyMjk2IDEzLjU5NDUgNC4zNjM2OUw5Ljk1ODE0IDhMMTMuNTk0NSAxMS42MzYzQzE0LjEzNTIgMTIuMTc3IDE0LjEzNTIgMTMuMDUzNyAxMy41OTQ1IDEzLjU5NDVDMTMuMDUzNyAxNC4xMzUyIDEyLjE3NyAxNC4xMzUyIDExLjYzNjMgMTMuNTk0NUw4IDkuOTU4MTRMNC4zNjM2OSAxMy41OTQ1QzMuODIyOTYgMTQuMTM1MiAyLjk0NjI3IDE0LjEzNTIgMi40MDU1NCAxMy41OTQ1QzEuODY0ODIgMTMuMDUzNyAxLjg2NDgyIDEyLjE3NyAyLjQwNTU0IDExLjYzNjNMNi4wNDE4NiA4TDIuNDA1NTQgNC4zNjM2OUMxLjg2NDgyIDMuODIyOTYgMS44NjQ4MiAyLjk0NjI3IDIuNDA1NTQgMi40MDU1NFpcIiwgZmlsbDogXCIjQkJDMEM1XCIgfSkpKTtcblxuY29uc3QgTG9nbyA9ICgpID0+IChoKFwic3ZnXCIsIHsgd2lkdGg6IFwiMTIwXCIsIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIGZpbGw6IFwibm9uZVwiLCB2aWV3Qm94OiBcIjAgMCAxMjcgNjNcIiB9LFxuICAgIGgoXCJwYXRoXCIsIHsgZmlsbDogXCJjdXJyZW50Q29sb3JcIiwgZDogXCJNNzEuNTU0IDQ4LjYwN3YxMy44MWgtNy4wNzJ2LTkuNTY4bC04LjA1OS45NDVjLTEuNzcuMjA1LTIuNTQ4Ljc5LTIuNTQ4IDEuODY0IDAgMS41NzUgMS40NzggMi4yMzkgNC42NDggMi4yMzkgMS45MzIgMCA0LjA3My0uMjkgNS45NjMtLjc5bC0zLjY2IDUuMjI1Yy0xLjQ3OS4zMzItMi45Mi40OTYtNC40NC40OTYtNi40MTQgMC0xMC4wNzQtMi41Ny0xMC4wNzQtNy4xMzIgMC00LjAyMyAyLjg3Ny02LjEzNiA5LjQxNi02Ljg4NGw4LjYzOC0xLjAxMmMtLjQ2Ny0yLjUzMi0yLjM2Mi0zLjYzMy02LjEzLTMuNjMzLTMuNTM3IDAtNy40NDMuOTEyLTEwLjkzNyAyLjYxM2wxLjExMS02LjE4YzMuMjQ4LTEuMzY5IDYuOTUtMi4wNzQgMTAuNjktMi4wNzQgOC4yMjYgMCAxMi40NjEgMy40NDQgMTIuNDYxIDEwLjA3NWwtLjAwOC4wMDVaTTcuOTM4IDMxLjMxNS4yMDggNjIuNDE2aDcuNzNsMy44MzYtMTUuNjI4IDYuNjUgOC4wMzloOC4wNmw2LjY1LTguMDM5IDMuODM2IDE1LjYyOGg3LjczbC03LjczLTMxLjEwNS0xNC41MTggMTcuMzg4TDcuOTM0IDMxLjMxMWwuMDA0LjAwNFpNMzYuOTcuMjEgMjIuNDUyIDE3LjU5OCA3LjkzOC4yMS4yMDggMzEuMzE1aDcuNzNsMy44MzYtMTUuNjI4IDYuNjUgOC4wMzloOC4wNmw2LjY1LTguMDM5IDMuODM2IDE1LjYyOGg3LjczTDM2Ljk3LjIxWm01My4xNyA0OC4xMDctNi4yNS0uOTEyYy0xLjU2Mi0uMjQ3LTIuMTc4LS43NDctMi4xNzgtMS42MTcgMC0xLjQxIDEuNTItMi4wMzIgNC42NDctMi4wMzIgMy42MiAwIDYuODY4Ljc0NyAxMC4yODMgMi4zNjRsLS44NjItNi4wOTRjLTIuNzU3LS45OTUtNS45MjItMS40OTEtOS4yMTItMS40OTEtNy42ODggMC0xMS44ODYgMi42OTYtMTEuODg2IDcuNTQ3IDAgMy43NzYgMi4zMDMgNS44ODkgNy4xOTYgNi42MzZsNi4zMzUuOTU0YzEuNjAzLjI0OCAyLjI2MS44NyAyLjI2MSAxLjg2NSAwIDEuNDEtMS40NzggMi4wNzQtNC40ODEgMi4wNzQtMy45NDggMC04LjIyNS0uOTUzLTExLjcyLTIuNjU0bC43IDYuMDk0YzMuMDAzIDEuMTIyIDYuOTEgMS43ODUgMTAuNTcgMS43ODUgNy44OTYgMCAxMi4wMDctMi43OCAxMi4wMDctNy43MTUgMC0zLjk0LTIuMzAzLTYuMDU3LTcuNC02LjhsLS4wMS0uMDA0Wk0xMDAuMyAzNC4wOXYyOC4zMjVoNy4wNzFWMzQuMDkxSDEwMC4zWm0xNS4zMzQgMTUuNTk1IDkuODMzLTEwLjc0NGgtOC44bC05LjI5NiAxMS4xMTQgOS45MTIgMTIuMzU2aDguOTI1bC0xMC41NzQtMTIuNzN2LjAwNFptLTE2LjMyMS0yNS4wOWMwIDQuNTYgMy42NiA3LjEzIDEwLjA3NCA3LjEzIDEuNTIgMCAyLjk2MS0uMTY3IDQuNDQtLjQ5NWwzLjY2LTUuMjI1Yy0xLjg5LjQ5Ni00LjAzMS43OS01Ljk2My43OS0zLjE2NiAwLTQuNjQ4LS42NjQtNC42NDgtMi4yMzkgMC0xLjA3OS43ODMtMS42NTkgMi41NDktMS44NjRsOC4wNTgtLjk0NXY5LjU2N2g3LjA3MnYtMTMuODFjMC02LjYzNS00LjIzNi0xMC4wNzUtMTIuNDYxLTEwLjA3NS0zLjc0NCAwLTcuNDQyLjcwNS0xMC42OTEgMi4wNzVsLTEuMTEyIDYuMTc4YzMuNDk1LTEuNzAxIDcuNDAxLTIuNjEzIDEwLjkzNy0yLjYxMyAzLjc2OSAwIDUuNjY0IDEuMSA2LjEzIDMuNjMzbC04LjYzNyAxLjAxM2MtNi41MzkuNzQ3LTkuNDE3IDIuODYtOS40MTcgNi44ODNsLjAwOS0uMDA0Wm0tMTkuNzc5LTEuNDkyYzAgNS43MjUgMy4yOSA4LjYyNyA5Ljc4NyA4LjYyNyAyLjU5IDAgNC43MzItLjQxNiA2Ljc4NS0xLjM3bC45MDMtNi4yNjFjLTEuOTc0IDEuMi0zLjk5IDEuODIyLTYuMDA1IDEuODIyLTMuMDQ0IDAtNC40MDItMS4yNDMtNC40MDItNC4wMjN2LTguMjk1aDEwLjczMlY3Ljg0SDg2LjYwMVYyLjk0OGwtMTMuNDQ4IDcuMTc0djMuNDgyaDYuMzcyVjIzLjFsLjAwOC4wMDRabS02Ljk1LTIuNjEydjEuNDExSDUzLjQ3Yy44NjIgMi44NzMgMy40MjMgNC4xODcgNy45NyA0LjE4NyAzLjYyIDAgNi45OTMtLjc0NyA5Ljk5Mi0yLjE5NmwtLjg2MiA2LjA1NmMtMi43NTcgMS4xNi02LjI1MSAxLjc4NS05LjgyOSAxLjc4NS05LjUgMC0xNC42OC00LjIzLTE0LjY4LTEyLjA2NiAwLTcuODM4IDUuMjY0LTEyLjIzNSAxMy40MDYtMTIuMjM1czEzLjExOSA0Ljc3MSAxMy4xMTkgMTMuMDYybC0uMDA1LS4wMDRaTTUzLjM3OCAxNy4wOWgxMi4wODZjLS42MzctMi43NTEtMi43MzItNC4xODgtNi4wOC00LjE4OC0zLjM0OSAwLTUuMzM1IDEuMzk5LTYuMDA2IDQuMTg4WlwiIH0pKSk7XG5cbi8qIVxuQ29weXJpZ2h0IChjKSAyMDIzIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKVxuVGhlIGxpYnJhcnkgQHBhdWxtaWxsci9xciBpcyBkdWFsLWxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgMi4wIE9SIE1JVCBsaWNlbnNlLlxuWW91IGNhbiBzZWxlY3QgYSBsaWNlbnNlIG9mIHlvdXIgY2hvaWNlLlxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxubGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuZnVuY3Rpb24gYXNzZXJ0TnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFdyb25nIGludGVnZXI6ICR7bn1gKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVmVyc2lvbih2ZXIpIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHZlcikgfHwgdmVyIDwgMSB8fCB2ZXIgPiA0MClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZlcnNpb249JHt2ZXJ9LiBFeHBlY3RlZCBudW1iZXIgWzEuLjQwXWApO1xufVxuZnVuY3Rpb24gYmluKGRlYywgcGFkKSB7XG4gICAgcmV0dXJuIGRlYy50b1N0cmluZygyKS5wYWRTdGFydChwYWQsICcwJyk7XG59XG5mdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gMCA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaWxsQXJyKGxlbmd0aCwgdmFsKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheShsZW5ndGgpLmZpbGwodmFsKTtcbn1cbi8qKlxuICogSW50ZXJsZWF2ZXMgYnl0ZSBibG9ja3MuXG4gKiBAcGFyYW0gYmxvY2tzIFtbMSwgMiwgM10sIFs0LCA1LCA2XV1cbiAqIEByZXR1cm5zIFsxLCA0LCAyLCA1LCAzLCA2XVxuICovXG5mdW5jdGlvbiBpbnRlcmxlYXZlQnl0ZXMoLi4uYmxvY2tzKSB7XG4gICAgbGV0IGxlbiA9IDA7XG4gICAgZm9yIChjb25zdCBiIG9mIGJsb2NrcylcbiAgICAgICAgbGVuID0gTWF0aC5tYXgobGVuLCBiLmxlbmd0aCk7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmb3IgKGNvbnN0IGIgb2YgYmxvY2tzKSB7XG4gICAgICAgICAgICBpZiAoaSA+PSBiLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gb3V0c2lkZSBvZiBibG9jaywgc2tpcFxuICAgICAgICAgICAgcmVzLnB1c2goYltpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcyk7XG59XG5mdW5jdGlvbiBpbmNsdWRlc0F0KGxzdCwgcGF0dGVybiwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ICsgcGF0dGVybi5sZW5ndGggPiBsc3QubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAocGF0dGVybltpXSAhPT0gbHN0W2luZGV4ICsgaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBPcHRpbWl6ZSBmb3IgbWluaW1hbCBzY29yZS9wZW5hbHR5XG5mdW5jdGlvbiBiZXN0KCkge1xuICAgIGxldCBiZXN0O1xuICAgIGxldCBiZXN0U2NvcmUgPSBJbmZpbml0eTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGQoc2NvcmUsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoc2NvcmUgPj0gYmVzdFNjb3JlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGJlc3QgPSB2YWx1ZTtcbiAgICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6ICgpID0+IGJlc3QsXG4gICAgICAgIHNjb3JlOiAoKSA9PiBiZXN0U2NvcmUsXG4gICAgfTtcbn1cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvc2N1cmUtYmFzZS9ibG9iL21haW4vaW5kZXgudHNcbmZ1bmN0aW9uIGFscGhhYmV0KGFscGhhYmV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzOiAoY2hhcikgPT4gYWxwaGFiZXQuaW5jbHVkZXMoY2hhciksXG4gICAgICAgIGRlY29kZTogKGlucHV0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpIHx8IChpbnB1dC5sZW5ndGggJiYgdHlwZW9mIGlucHV0WzBdICE9PSAnc3RyaW5nJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5kZWNvZGUgaW5wdXQgc2hvdWxkIGJlIGFycmF5IG9mIHN0cmluZ3MnKTtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5tYXAoKGxldHRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGV0dGVyICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhbHBoYWJldC5kZWNvZGU6IG5vdCBzdHJpbmcgZWxlbWVudD0ke2xldHRlcn1gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGFscGhhYmV0LmluZGV4T2YobGV0dGVyKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbGV0dGVyOiBcIiR7bGV0dGVyfVwiLiBBbGxvd2VkOiAke2FscGhhYmV0fWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBlbmNvZGU6IChkaWdpdHMpID0+IHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkaWdpdHMpIHx8IChkaWdpdHMubGVuZ3RoICYmIHR5cGVvZiBkaWdpdHNbMF0gIT09ICdudW1iZXInKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FscGhhYmV0LmVuY29kZSBpbnB1dCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgbnVtYmVycycpO1xuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cy5tYXAoKGkpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnROdW1iZXIoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAwIHx8IGkgPj0gYWxwaGFiZXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpZ2l0IGluZGV4IG91dHNpZGUgYWxwaGFiZXQ6ICR7aX0gKGFscGhhYmV0OiAke2FscGhhYmV0Lmxlbmd0aH0pYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFscGhhYmV0W2ldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmNsYXNzIEJpdG1hcCB7XG4gICAgc3RhdGljIHNpemUoc2l6ZSwgbGltaXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzaXplID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHNpemUgPSB7IGhlaWdodDogc2l6ZSwgd2lkdGg6IHNpemUgfTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihzaXplLmhlaWdodCkgJiYgc2l6ZS5oZWlnaHQgIT09IEluZmluaXR5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXRtYXA6IHdyb25nIGhlaWdodD0ke3NpemUuaGVpZ2h0fSAoJHt0eXBlb2Ygc2l6ZS5oZWlnaHR9KWApO1xuICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHNpemUud2lkdGgpICYmIHNpemUud2lkdGggIT09IEluZmluaXR5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXRtYXA6IHdyb25nIHdpZHRoPSR7c2l6ZS53aWR0aH0gKCR7dHlwZW9mIHNpemUud2lkdGh9KWApO1xuICAgICAgICBpZiAobGltaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gQ2xhbXAgbGVuZ3RoLCBzbyBpdCB3b24ndCBvdmVyZmxvdywgYWxzbyBhbGxvd3MgdG8gdXNlIEluZmluaXR5LCBzbyB3ZSBkcmF3IHVudGlsIGVuZFxuICAgICAgICAgICAgc2l6ZSA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogTWF0aC5taW4oc2l6ZS53aWR0aCwgbGltaXQud2lkdGgpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5taW4oc2l6ZS5oZWlnaHQsIGxpbWl0LmhlaWdodCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhzKSB7XG4gICAgICAgIC8vIFJlbW92ZSBsaW5lYnJlYWtzIG9uIHN0YXJ0IGFuZCBlbmQsIHNvIHdlIGRyYXcgaW4gYGAgc2VjdGlvblxuICAgICAgICBzID0gcy5yZXBsYWNlKC9eXFxuKy9nLCAnJykucmVwbGFjZSgvXFxuKyQvZywgJycpO1xuICAgICAgICBjb25zdCBsaW5lcyA9IHMuc3BsaXQoJ1xcbicpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgQXJyYXkoaGVpZ2h0KTtcbiAgICAgICAgbGV0IHdpZHRoO1xuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IGxpbmUuc3BsaXQoJycpLm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAnWCcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAnICcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gJz8nKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQml0bWFwLmZyb21TdHJpbmc6IHVua25vd24gc3ltYm9sPSR7aX1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHdpZHRoICYmIHJvdy5sZW5ndGggIT09IHdpZHRoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQml0bWFwLmZyb21TdHJpbmcgZGlmZmVyZW50IHJvdyBzaXplczogd2lkdGg9JHt3aWR0aH0gY3VyPSR7cm93Lmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHdpZHRoID0gcm93Lmxlbmd0aDtcbiAgICAgICAgICAgIGRhdGEucHVzaChyb3cpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghd2lkdGgpXG4gICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgIHJldHVybiBuZXcgQml0bWFwKHsgaGVpZ2h0LCB3aWR0aCB9LCBkYXRhKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgZGF0YSkge1xuICAgICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGggfSA9IEJpdG1hcC5zaXplKHNpemUpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhIHx8IEFycmF5LmZyb20oeyBsZW5ndGg6IGhlaWdodCB9LCAoKSA9PiBmaWxsQXJyKHdpZHRoLCB1bmRlZmluZWQpKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB9XG4gICAgcG9pbnQocCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3AueV1bcC54XTtcbiAgICB9XG4gICAgaXNJbnNpZGUocCkge1xuICAgICAgICByZXR1cm4gMCA8PSBwLnggJiYgcC54IDwgdGhpcy53aWR0aCAmJiAwIDw9IHAueSAmJiBwLnkgPCB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgc2l6ZShvZmZzZXQpIHtcbiAgICAgICAgaWYgKCFvZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4geyBoZWlnaHQ6IHRoaXMuaGVpZ2h0LCB3aWR0aDogdGhpcy53aWR0aCB9O1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMueHkob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHsgaGVpZ2h0OiB0aGlzLmhlaWdodCAtIHksIHdpZHRoOiB0aGlzLndpZHRoIC0geCB9O1xuICAgIH1cbiAgICB4eShjKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYyA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICBjID0geyB4OiBjLCB5OiBjIH07XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYy54KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQml0bWFwOiB3cm9uZyB4PSR7Yy54fWApO1xuICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGMueSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJpdG1hcDogd3JvbmcgeT0ke2MueX1gKTtcbiAgICAgICAgLy8gRG8gbW9kdWxvLCBzbyB3ZSBjYW4gdXNlIG5lZ2F0aXZlIHBvc2l0aW9uc1xuICAgICAgICBjLnggPSBtb2QoYy54LCB0aGlzLndpZHRoKTtcbiAgICAgICAgYy55ID0gbW9kKGMueSwgdGhpcy5oZWlnaHQpO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9XG4gICAgLy8gQmFzaWNhbGx5IGV2ZXJ5IG9wZXJhdGlvbiBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgcmVjdFxuICAgIHJlY3QoYywgc2l6ZSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnh5KGMpO1xuICAgICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGggfSA9IEJpdG1hcC5zaXplKHNpemUsIHRoaXMuc2l6ZSh7IHgsIHkgfSkpO1xuICAgICAgICBmb3IgKGxldCB5UG9zID0gMDsgeVBvcyA8IGhlaWdodDsgeVBvcysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4UG9zID0gMDsgeFBvcyA8IHdpZHRoOyB4UG9zKyspIHtcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiB3ZSB1c2UgZ2l2ZSBmdW5jdGlvbiByZWxhdGl2ZSBjb29yZGluYXRlcyBpbnNpZGUgYm94XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW3kgKyB5UG9zXVt4ICsgeFBvc10gPVxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsdWUoeyB4OiB4UG9zLCB5OiB5UG9zIH0sIHRoaXMuZGF0YVt5ICsgeVBvc11beCArIHhQb3NdKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gcmV0dXJucyByZWN0YW5ndWxhciBwYXJ0IG9mIGJpdG1hcFxuICAgIHJlY3RSZWFkKGMsIHNpemUsIGZuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY3QoYywgc2l6ZSwgKGMsIGN1cikgPT4ge1xuICAgICAgICAgICAgZm4oYywgY3VyKTtcbiAgICAgICAgICAgIHJldHVybiBjdXI7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBIb3Jpem9udGFsICYgdmVydGljYWwgbGluZXNcbiAgICBoTGluZShjLCBsZW4sIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY3QoYywgeyB3aWR0aDogbGVuLCBoZWlnaHQ6IDEgfSwgdmFsdWUpO1xuICAgIH1cbiAgICB2TGluZShjLCBsZW4sIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY3QoYywgeyB3aWR0aDogMSwgaGVpZ2h0OiBsZW4gfSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBhZGQgYm9yZGVyXG4gICAgYm9yZGVyKGJvcmRlciA9IDIsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgMiAqIGJvcmRlcjtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLndpZHRoICsgMiAqIGJvcmRlcjtcbiAgICAgICAgY29uc3QgdiA9IGZpbGxBcnIoYm9yZGVyLCB2YWx1ZSk7XG4gICAgICAgIGNvbnN0IGggPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBib3JkZXIgfSwgKCkgPT4gZmlsbEFycih3aWR0aCwgdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCaXRtYXAoeyBoZWlnaHQsIHdpZHRoIH0sIFsuLi5oLCAuLi50aGlzLmRhdGEubWFwKChpKSA9PiBbLi4udiwgLi4uaSwgLi4udl0pLCAuLi5oXSk7XG4gICAgfVxuICAgIC8vIEVtYmVkIGFub3RoZXIgYml0bWFwIG9uIGNvb3JkaW5hdGVzXG4gICAgZW1iZWQoYywgYm0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjdChjLCBibS5zaXplKCksICh7IHgsIHkgfSkgPT4gYm0uZGF0YVt5XVt4XSk7XG4gICAgfVxuICAgIC8vIHJldHVybnMgcmVjdGFuZ3VsYXIgcGFydCBvZiBiaXRtYXBcbiAgICByZWN0U2xpY2UoYywgc2l6ZSA9IHRoaXMuc2l6ZSgpKSB7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBuZXcgQml0bWFwKEJpdG1hcC5zaXplKHNpemUsIHRoaXMuc2l6ZSh0aGlzLnh5KGMpKSkpO1xuICAgICAgICB0aGlzLnJlY3QoYywgc2l6ZSwgKHsgeCwgeSB9LCBjdXIpID0+IChyZWN0LmRhdGFbeV1beF0gPSBjdXIpKTtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICAgIC8vIENoYW5nZSBzaGFwZSwgcmVwbGFjZSByb3dzIHdpdGggY29sdW1ucyAoZGF0YVt5XVt4XSAtPiBkYXRhW3hdW3ldKVxuICAgIGludmVyc2UoKSB7XG4gICAgICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IEJpdG1hcCh7IGhlaWdodDogd2lkdGgsIHdpZHRoOiBoZWlnaHQgfSk7XG4gICAgICAgIHJldHVybiByZXMucmVjdCh7IHg6IDAsIHk6IDAgfSwgSW5maW5pdHksICh7IHgsIHkgfSkgPT4gdGhpcy5kYXRhW3hdW3ldKTtcbiAgICB9XG4gICAgLy8gRWFjaCBwaXhlbCBzaXplIGlzIG11bHRpcGxpZWQgYnkgZmFjdG9yXG4gICAgc2NhbGUoZmFjdG9yKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZmFjdG9yKSB8fCBmYWN0b3IgPiAxMDI0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBXcm9uZyBzY2FsZSBmYWN0b3I6ICR7ZmFjdG9yfWApO1xuICAgICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGggfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHJlcyA9IG5ldyBCaXRtYXAoeyBoZWlnaHQ6IGZhY3RvciAqIGhlaWdodCwgd2lkdGg6IGZhY3RvciAqIHdpZHRoIH0pO1xuICAgICAgICByZXR1cm4gcmVzLnJlY3QoeyB4OiAwLCB5OiAwIH0sIEluZmluaXR5LCAoeyB4LCB5IH0pID0+IHRoaXMuZGF0YVtNYXRoLmZsb29yKHkgLyBmYWN0b3IpXVtNYXRoLmZsb29yKHggLyBmYWN0b3IpXSk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgQml0bWFwKHRoaXMuc2l6ZSgpKTtcbiAgICAgICAgcmV0dXJuIHJlcy5yZWN0KHsgeDogMCwgeTogMCB9LCB0aGlzLnNpemUoKSwgKHsgeCwgeSB9KSA9PiB0aGlzLmRhdGFbeV1beF0pO1xuICAgIH1cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGVyZSBpcyBubyB1bmRlZmluZWQgdmFsdWVzIGxlZnRcbiAgICBhc3NlcnREcmF3bigpIHtcbiAgICAgICAgdGhpcy5yZWN0UmVhZCgwLCBJbmZpbml0eSwgKF8sIGN1cikgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXIgIT09ICdib29sZWFuJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgY29sb3IgdHlwZT0ke3R5cGVvZiBjdXJ9YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBTaW1wbGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciBkZWJ1Z2dpbmdcbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVxuICAgICAgICAgICAgLm1hcCgoaSkgPT4gaS5tYXAoKGopID0+IChqID09PSB1bmRlZmluZWQgPyAnPycgOiBqID8gJ1gnIDogJyAnKSkuam9pbignJykpXG4gICAgICAgICAgICAuam9pbignXFxuJyk7XG4gICAgfVxuICAgIHRvQVNDSUkoKSB7XG4gICAgICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCwgZGF0YSB9ID0gdGhpcztcbiAgICAgICAgbGV0IG91dCA9ICcnO1xuICAgICAgICAvLyBUZXJtaW5hbCBjaGFyYWN0ZXIgaGVpZ2h0IGlzIHgyIG9mIGNoYXJhY3RlciB3aWR0aCwgc28gd2UgcHJvY2VzcyB0d28gcm93cyBvZiBiaXRtYXBcbiAgICAgICAgLy8gdG8gcHJvZHVjZSBvbmUgcm93IG9mIEFTQ0lJXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5ICs9IDIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgd2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0ID0gZGF0YVt5XVt4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWNvbmQgPSB5ICsgMSA+PSBoZWlnaHQgPyB0cnVlIDogZGF0YVt5ICsgMV1beF07IC8vIGlmIGxhc3Qgcm93IG91dHNpZGUgYml0bWFwLCBtYWtlIGl0IGJsYWNrXG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdCAmJiAhc2Vjb25kKVxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJ+KWiCc7IC8vIGJvdGggcm93cyB3aGl0ZSAoZW1wdHkpXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWZpcnN0ICYmIHNlY29uZClcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICfiloAnOyAvLyB0b3Agcm93IHdoaXRlXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3QgJiYgIXNlY29uZClcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICfiloQnOyAvLyBkb3duIHJvdyB3aGl0ZVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0ICYmIHNlY29uZClcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgJzsgLy8gYm90aCByb3dzIGJsYWNrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgdG9UZXJtKCkge1xuICAgICAgICBjb25zdCByZXNldCA9ICdcXHgxYlswbSc7XG4gICAgICAgIGNvbnN0IHdoaXRlQkcgPSBgXFx4MWJbMTs0N20gICR7cmVzZXR9YDtcbiAgICAgICAgY29uc3QgZGFya0JHID0gYFxceDFiWzQwbSAgJHtyZXNldH1gO1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhLm1hcCgoaSkgPT4gaS5tYXAoKGopID0+IChqID8gZGFya0JHIDogd2hpdGVCRykpLmpvaW4oJycpKS5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgdG9TVkcoKSB7XG4gICAgICAgIGxldCBvdXQgPSBgPHN2ZyB4bWxuczpzdmc9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgJHt0aGlzLndpZHRofSAke3RoaXMuaGVpZ2h0fVwiIHZlcnNpb249XCIxLjFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+YDtcbiAgICAgICAgdGhpcy5yZWN0UmVhZCgwLCBJbmZpbml0eSwgKHsgeCwgeSB9LCB2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWwpXG4gICAgICAgICAgICAgICAgb3V0ICs9IGA8cmVjdCB4PVwiJHt4fVwiIHk9XCIke3l9XCIgd2lkdGg9XCIxXCIgaGVpZ2h0PVwiMVwiIC8+YDtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dCArPSAnPC9zdmc+JztcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgdG9HSUYoKSB7XG4gICAgICAgIC8vIE5PVEU6IFNtYWxsLCBidXQgaW5lZmZpY2llbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgIC8vIFVzZXMgMSBieXRlIHBlciBwaXhlbCwgYnV0IHN0aWxsIGxlc3MgYmxvYXRlZCB0aGFuIFNWRy5cbiAgICAgICAgY29uc3QgdTE2bGUgPSAoaSkgPT4gW2kgJiAweGZmLCAoaSA+Pj4gOCkgJiAweGZmXTtcbiAgICAgICAgY29uc3QgZGltcyA9IFsuLi51MTZsZSh0aGlzLndpZHRoKSwgLi4udTE2bGUodGhpcy5oZWlnaHQpXTtcbiAgICAgICAgY29uc3QgZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLnJlY3RSZWFkKDAsIEluZmluaXR5LCAoXywgY3VyKSA9PiBkYXRhLnB1c2goKyhjdXIgPT09IHRydWUpKSk7XG4gICAgICAgIGNvbnN0IE4gPSAxMjY7IC8vIEJsb2NrIHNpemVcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGNvbnN0IGJ5dGVzID0gW1xuICAgICAgICAgICAgMHg0NywgMHg0OSwgMHg0NiwgMHgzOCwgMHgzNywgMHg2MSwgLi4uZGltcywgMHhmNiwgMHgwMCwgMHgwMCwgMHhmZiwgMHhmZiwgMHhmZixcbiAgICAgICAgICAgIC4uLmZpbGxBcnIoMyAqIDEyNywgMHgwMCksIDB4MmMsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIC4uLmRpbXMsIDB4MDAsIDB4MDdcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgZnVsbENodW5rcyA9IE1hdGguZmxvb3IoZGF0YS5sZW5ndGggLyBOKTtcbiAgICAgICAgLy8gRnVsbCBibG9ja3NcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmdWxsQ2h1bmtzOyBpKyspXG4gICAgICAgICAgICBieXRlcy5wdXNoKE4gKyAxLCAweDgwLCAuLi5kYXRhLnNsaWNlKE4gKiBpLCBOICogKGkgKyAxKSkubWFwKChpKSA9PiAraSkpO1xuICAgICAgICAvLyBSZW1haW5pbmcgYnl0ZXNcbiAgICAgICAgYnl0ZXMucHVzaCgoZGF0YS5sZW5ndGggJSBOKSArIDEsIDB4ODAsIC4uLmRhdGEuc2xpY2UoZnVsbENodW5rcyAqIE4pLm1hcCgoaSkgPT4gK2kpKTtcbiAgICAgICAgYnl0ZXMucHVzaCgweDAxLCAweDgxLCAweDAwLCAweDNiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICB9XG4gICAgdG9JbWFnZShpc1JHQiA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gdGhpcy5zaXplKCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShoZWlnaHQgKiB3aWR0aCAqIChpc1JHQiA/IDMgOiA0KSk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSAhIXRoaXMuZGF0YVt5XVt4XSA/IDAgOiAyNTU7XG4gICAgICAgICAgICAgICAgZGF0YVtpKytdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZGF0YVtpKytdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZGF0YVtpKytdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1JHQilcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdID0gMjU1OyAvLyBhbHBoYSBjaGFubmVsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaGVpZ2h0LCB3aWR0aCwgZGF0YSB9O1xuICAgIH1cbn1cbi8vIEVuZCBvZiB1dGlsc1xuLy8gUnVudGltZSB0eXBlLWNoZWNraW5nXG4vLyBMb3c6IDclLCBtZWRpdW06IDE1JSwgcXVhcnRpbGU6IDI1JSwgaGlnaDogMzAlXG5jb25zdCBFQ01vZGUgPSBbJ2xvdycsICdtZWRpdW0nLCAncXVhcnRpbGUnLCAnaGlnaCddO1xuY29uc3QgRW5jb2RpbmcgPSBbJ251bWVyaWMnLCAnYWxwaGFudW1lcmljJywgJ2J5dGUnLCAna2FuamknLCAnZWNpJ107XG4vLyBWYXJpb3VzIGNvbnN0YW50cyAmIHRhYmxlc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBCWVRFUyA9IFtcbiAgICAvLyAxLCAgMiwgIDMsICAgNCwgICA1LCAgIDYsICAgNywgICA4LCAgIDksICAxMCwgIDExLCAgMTIsICAxMywgIDE0LCAgMTUsICAxNiwgIDE3LCAgMTgsICAxOSwgICAyMCxcbiAgICAyNiwgNDQsIDcwLCAxMDAsIDEzNCwgMTcyLCAxOTYsIDI0MiwgMjkyLCAzNDYsIDQwNCwgNDY2LCA1MzIsIDU4MSwgNjU1LCA3MzMsIDgxNSwgOTAxLCA5OTEsIDEwODUsXG4gICAgLy8gIDIxLCAgIDIyLCAgIDIzLCAgIDI0LCAgIDI1LCAgIDI2LCAgIDI3LCAgIDI4LCAgIDI5LCAgIDMwLCAgIDMxLCAgIDMyLCAgIDMzLCAgIDM0LCAgIDM1LCAgIDM2LCAgIDM3LCAgIDM4LCAgIDM5LCAgIDQwXG4gICAgMTE1NiwgMTI1OCwgMTM2NCwgMTQ3NCwgMTU4OCwgMTcwNiwgMTgyOCwgMTkyMSwgMjA1MSwgMjE4NSwgMjMyMywgMjQ2NSwgMjYxMSwgMjc2MSwgMjg3NiwgMzAzNCwgMzE5NiwgMzM2MiwgMzUzMiwgMzcwNixcbl07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFdPUkRTX1BFUl9CTE9DSyA9IHtcbiAgICAvLyBWZXJzaW9uIDEsICAyLCAgMywgIDQsICA1LCAgNiwgIDcsICA4LCAgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LCAzOSwgNDBcbiAgICBsb3c6IFs3LCAxMCwgMTUsIDIwLCAyNiwgMTgsIDIwLCAyNCwgMzAsIDE4LCAyMCwgMjQsIDI2LCAzMCwgMjIsIDI0LCAyOCwgMzAsIDI4LCAyOCwgMjgsIDI4LCAzMCwgMzAsIDI2LCAyOCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXSxcbiAgICBtZWRpdW06IFsxMCwgMTYsIDI2LCAxOCwgMjQsIDE2LCAxOCwgMjIsIDIyLCAyNiwgMzAsIDIyLCAyMiwgMjQsIDI0LCAyOCwgMjgsIDI2LCAyNiwgMjYsIDI2LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOF0sXG4gICAgcXVhcnRpbGU6IFsxMywgMjIsIDE4LCAyNiwgMTgsIDI0LCAxOCwgMjIsIDIwLCAyNCwgMjgsIDI2LCAyNCwgMjAsIDMwLCAyNCwgMjgsIDI4LCAyNiwgMzAsIDI4LCAzMCwgMzAsIDMwLCAzMCwgMjgsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMF0sXG4gICAgaGlnaDogWzE3LCAyOCwgMjIsIDE2LCAyMiwgMjgsIDI2LCAyNiwgMjQsIDI4LCAyNCwgMjgsIDIyLCAyNCwgMjQsIDMwLCAyOCwgMjgsIDI2LCAyOCwgMzAsIDI0LCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXSxcbn07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEVDQ19CTE9DS1MgPSB7XG4gICAgLy8gVmVyc2lvbiAgIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LCAzOSwgNDBcbiAgICBsb3c6IFsxLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLCA0LCA0LCA0LCA0LCA0LCA2LCA2LCA2LCA2LCA3LCA4LCA4LCA5LCA5LCAxMCwgMTIsIDEyLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDE5LCAyMCwgMjEsIDIyLCAyNCwgMjVdLFxuICAgIG1lZGl1bTogWzEsIDEsIDEsIDIsIDIsIDQsIDQsIDQsIDUsIDUsIDUsIDgsIDksIDksIDEwLCAxMCwgMTEsIDEzLCAxNCwgMTYsIDE3LCAxNywgMTgsIDIwLCAyMSwgMjMsIDI1LCAyNiwgMjgsIDI5LCAzMSwgMzMsIDM1LCAzNywgMzgsIDQwLCA0MywgNDUsIDQ3LCA0OV0sXG4gICAgcXVhcnRpbGU6IFsxLCAxLCAyLCAyLCA0LCA0LCA2LCA2LCA4LCA4LCA4LCAxMCwgMTIsIDE2LCAxMiwgMTcsIDE2LCAxOCwgMjEsIDIwLCAyMywgMjMsIDI1LCAyNywgMjksIDM0LCAzNCwgMzUsIDM4LCA0MCwgNDMsIDQ1LCA0OCwgNTEsIDUzLCA1NiwgNTksIDYyLCA2NSwgNjhdLFxuICAgIGhpZ2g6IFsxLCAxLCAyLCA0LCA0LCA0LCA1LCA2LCA4LCA4LCAxMSwgMTEsIDE2LCAxNiwgMTgsIDE2LCAxOSwgMjEsIDI1LCAyNSwgMjUsIDM0LCAzMCwgMzIsIDM1LCAzNywgNDAsIDQyLCA0NSwgNDgsIDUxLCA1NCwgNTcsIDYwLCA2MywgNjYsIDcwLCA3NCwgNzcsIDgxXSxcbn07XG5jb25zdCBpbmZvID0ge1xuICAgIHNpemU6IHtcbiAgICAgICAgZW5jb2RlOiAodmVyKSA9PiAyMSArIDQgKiAodmVyIC0gMSksIC8vIHZlcjEgPSAyMSwgdmVyNDA9MTc3IGJsb2Nrc1xuICAgICAgICBkZWNvZGU6IChzaXplKSA9PiAoc2l6ZSAtIDE3KSAvIDQsXG4gICAgfSxcbiAgICBzaXplVHlwZTogKHZlcikgPT4gTWF0aC5mbG9vcigodmVyICsgNykgLyAxNyksXG4gICAgLy8gQmFzZWQgb24gaHR0cHM6Ly9jb2RlcmV2aWV3LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy83NDkyNS9hbGdvcml0aG0tdG8tZ2VuZXJhdGUtdGhpcy1hbGlnbm1lbnQtcGF0dGVybi1sb2NhdGlvbnMtdGFibGUtZm9yLXFyLWNvZGVzXG4gICAgYWxpZ25tZW50UGF0dGVybnModmVyKSB7XG4gICAgICAgIGlmICh2ZXIgPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gNjtcbiAgICAgICAgY29uc3QgbGFzdCA9IGluZm8uc2l6ZS5lbmNvZGUodmVyKSAtIGZpcnN0IC0gMTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBsYXN0IC0gZmlyc3Q7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gTWF0aC5jZWlsKGRpc3RhbmNlIC8gMjgpO1xuICAgICAgICBsZXQgaW50ZXJ2YWwgPSBNYXRoLmZsb29yKGRpc3RhbmNlIC8gY291bnQpO1xuICAgICAgICBpZiAoaW50ZXJ2YWwgJSAyKVxuICAgICAgICAgICAgaW50ZXJ2YWwgKz0gMTtcbiAgICAgICAgZWxzZSBpZiAoKGRpc3RhbmNlICUgY291bnQpICogMiA+PSBjb3VudClcbiAgICAgICAgICAgIGludGVydmFsICs9IDI7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtmaXJzdF07XG4gICAgICAgIGZvciAobGV0IG0gPSAxOyBtIDwgY291bnQ7IG0rKylcbiAgICAgICAgICAgIHJlcy5wdXNoKGxhc3QgLSAoY291bnQgLSBtKSAqIGludGVydmFsKTtcbiAgICAgICAgcmVzLnB1c2gobGFzdCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBFQ0NvZGU6IHtcbiAgICAgICAgbG93OiAwYjAxLFxuICAgICAgICBtZWRpdW06IDBiMDAsXG4gICAgICAgIHF1YXJ0aWxlOiAwYjExLFxuICAgICAgICBoaWdoOiAwYjEwLFxuICAgIH0sXG4gICAgZm9ybWF0TWFzazogMGIxMDEwMTAwMDAwMTAwMTAsXG4gICAgZm9ybWF0Qml0cyhlY2MsIG1hc2tJZHgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IChpbmZvLkVDQ29kZVtlY2NdIDw8IDMpIHwgbWFza0lkeDtcbiAgICAgICAgbGV0IGQgPSBkYXRhO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspXG4gICAgICAgICAgICBkID0gKGQgPDwgMSkgXiAoKGQgPj4gOSkgKiAwYjEwMTAwMTEwMTExKTtcbiAgICAgICAgcmV0dXJuICgoZGF0YSA8PCAxMCkgfCBkKSBeIGluZm8uZm9ybWF0TWFzaztcbiAgICB9LFxuICAgIHZlcnNpb25CaXRzKHZlcikge1xuICAgICAgICBsZXQgZCA9IHZlcjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKVxuICAgICAgICAgICAgZCA9IChkIDw8IDEpIF4gKChkID4+IDExKSAqIDBiMTExMTEwMDEwMDEwMSk7XG4gICAgICAgIHJldHVybiAodmVyIDw8IDEyKSB8IGQ7XG4gICAgfSxcbiAgICBhbHBoYWJldDoge1xuICAgICAgICBudW1lcmljOiBhbHBoYWJldCgnMDEyMzQ1Njc4OScpLFxuICAgICAgICBhbHBoYW51bWVyYzogYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiAkJSorLS4vOicpLFxuICAgIH0sIC8vIGFzIFJlY29yZDxFbmNvZGluZ1R5cGUsIFJldHVyblR5cGU8dHlwZW9mIGFscGhhYmV0Pj4sXG4gICAgbGVuZ3RoQml0cyh2ZXIsIHR5cGUpIHtcbiAgICAgICAgY29uc3QgdGFibGUgPSB7XG4gICAgICAgICAgICBudW1lcmljOiBbMTAsIDEyLCAxNF0sXG4gICAgICAgICAgICBhbHBoYW51bWVyaWM6IFs5LCAxMSwgMTNdLFxuICAgICAgICAgICAgYnl0ZTogWzgsIDE2LCAxNl0sXG4gICAgICAgICAgICBrYW5qaTogWzgsIDEwLCAxMl0sXG4gICAgICAgICAgICBlY2k6IFswLCAwLCAwXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRhYmxlW3R5cGVdW2luZm8uc2l6ZVR5cGUodmVyKV07XG4gICAgfSxcbiAgICBtb2RlQml0czoge1xuICAgICAgICBudW1lcmljOiAnMDAwMScsXG4gICAgICAgIGFscGhhbnVtZXJpYzogJzAwMTAnLFxuICAgICAgICBieXRlOiAnMDEwMCcsXG4gICAgICAgIGthbmppOiAnMTAwMCcsXG4gICAgICAgIGVjaTogJzAxMTEnLFxuICAgIH0sXG4gICAgY2FwYWNpdHkodmVyLCBlY2MpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBCWVRFU1t2ZXIgLSAxXTtcbiAgICAgICAgY29uc3Qgd29yZHMgPSBXT1JEU19QRVJfQkxPQ0tbZWNjXVt2ZXIgLSAxXTtcbiAgICAgICAgY29uc3QgbnVtQmxvY2tzID0gRUNDX0JMT0NLU1tlY2NdW3ZlciAtIDFdO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IE1hdGguZmxvb3IoYnl0ZXMgLyBudW1CbG9ja3MpIC0gd29yZHM7XG4gICAgICAgIGNvbnN0IHNob3J0QmxvY2tzID0gbnVtQmxvY2tzIC0gKGJ5dGVzICUgbnVtQmxvY2tzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdvcmRzLFxuICAgICAgICAgICAgbnVtQmxvY2tzLFxuICAgICAgICAgICAgc2hvcnRCbG9ja3MsXG4gICAgICAgICAgICBibG9ja0xlbixcbiAgICAgICAgICAgIGNhcGFjaXR5OiAoYnl0ZXMgLSB3b3JkcyAqIG51bUJsb2NrcykgKiA4LFxuICAgICAgICAgICAgdG90YWw6ICh3b3JkcyArIGJsb2NrTGVuKSAqIG51bUJsb2NrcyArIG51bUJsb2NrcyAtIHNob3J0QmxvY2tzLFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuY29uc3QgUEFUVEVSTlMgPSBbXG4gICAgKHgsIHkpID0+ICh4ICsgeSkgJSAyID09IDAsXG4gICAgKF94LCB5KSA9PiB5ICUgMiA9PSAwLFxuICAgICh4LCBfeSkgPT4geCAlIDMgPT0gMCxcbiAgICAoeCwgeSkgPT4gKHggKyB5KSAlIDMgPT0gMCxcbiAgICAoeCwgeSkgPT4gKE1hdGguZmxvb3IoeSAvIDIpICsgTWF0aC5mbG9vcih4IC8gMykpICUgMiA9PSAwLFxuICAgICh4LCB5KSA9PiAoKHggKiB5KSAlIDIpICsgKCh4ICogeSkgJSAzKSA9PSAwLFxuICAgICh4LCB5KSA9PiAoKCh4ICogeSkgJSAyKSArICgoeCAqIHkpICUgMykpICUgMiA9PSAwLFxuICAgICh4LCB5KSA9PiAoKCh4ICsgeSkgJSAyKSArICgoeCAqIHkpICUgMykpICUgMiA9PSAwLFxuXTtcbi8vIEdhbG9pcyBmaWVsZCAmJiByZWVkLXNvbG9tb24gZW5jb2RpbmdcbmNvbnN0IEdGID0ge1xuICAgIHRhYmxlczogKChwX3BvbHkpID0+IHtcbiAgICAgICAgY29uc3QgZXhwID0gZmlsbEFycigyNTYsIDApO1xuICAgICAgICBjb25zdCBsb2cgPSBmaWxsQXJyKDI1NiwgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCB4ID0gMTsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgICAgICBleHBbaV0gPSB4O1xuICAgICAgICAgICAgbG9nW3hdID0gaTtcbiAgICAgICAgICAgIHggPDw9IDE7XG4gICAgICAgICAgICBpZiAoeCAmIDB4MTAwKVxuICAgICAgICAgICAgICAgIHggXj0gcF9wb2x5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGV4cCwgbG9nIH07XG4gICAgfSkoMHgxMWQpLFxuICAgIGV4cDogKHgpID0+IEdGLnRhYmxlcy5leHBbeF0sXG4gICAgbG9nKHgpIHtcbiAgICAgICAgaWYgKHggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdGLmxvZzogd3JvbmcgYXJnPSR7eH1gKTtcbiAgICAgICAgcmV0dXJuIEdGLnRhYmxlcy5sb2dbeF0gJSAyNTU7XG4gICAgfSxcbiAgICBtdWwoeCwgeSkge1xuICAgICAgICBpZiAoeCA9PT0gMCB8fCB5ID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHJldHVybiBHRi50YWJsZXMuZXhwWyhHRi50YWJsZXMubG9nW3hdICsgR0YudGFibGVzLmxvZ1t5XSkgJSAyNTVdO1xuICAgIH0sXG4gICAgYWRkOiAoeCwgeSkgPT4geCBeIHksXG4gICAgcG93OiAoeCwgZSkgPT4gR0YudGFibGVzLmV4cFsoR0YudGFibGVzLmxvZ1t4XSAqIGUpICUgMjU1XSxcbiAgICBpbnYoeCkge1xuICAgICAgICBpZiAoeCA9PT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR0YuaW52ZXJzZTogd3JvbmcgYXJnPSR7eH1gKTtcbiAgICAgICAgcmV0dXJuIEdGLnRhYmxlcy5leHBbMjU1IC0gR0YudGFibGVzLmxvZ1t4XV07XG4gICAgfSxcbiAgICBwb2x5bm9taWFsKHBvbHkpIHtcbiAgICAgICAgaWYgKHBvbHkubGVuZ3RoID09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dGLnBvbHltb21pYWw6IHdyb25nIGxlbmd0aCcpO1xuICAgICAgICBpZiAocG9seVswXSAhPT0gMClcbiAgICAgICAgICAgIHJldHVybiBwb2x5O1xuICAgICAgICAvLyBTdHJpcCBsZWFkaW5nIHplcm9zXG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBwb2x5Lmxlbmd0aCAtIDEgJiYgcG9seVtpXSA9PSAwOyBpKyspXG4gICAgICAgICAgICA7XG4gICAgICAgIHJldHVybiBwb2x5LnNsaWNlKGkpO1xuICAgIH0sXG4gICAgbW9ub21pYWwoZGVncmVlLCBjb2VmZmljaWVudCkge1xuICAgICAgICBpZiAoZGVncmVlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR0YubW9ub21pYWw6IHdyb25nIGRlZ3JlZT0ke2RlZ3JlZX1gKTtcbiAgICAgICAgaWYgKGNvZWZmaWNpZW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gWzBdO1xuICAgICAgICBsZXQgY29lZmZpY2llbnRzID0gZmlsbEFycihkZWdyZWUgKyAxLCAwKTtcbiAgICAgICAgY29lZmZpY2llbnRzWzBdID0gY29lZmZpY2llbnQ7XG4gICAgICAgIHJldHVybiBHRi5wb2x5bm9taWFsKGNvZWZmaWNpZW50cyk7XG4gICAgfSxcbiAgICBkZWdyZWU6IChhKSA9PiBhLmxlbmd0aCAtIDEsXG4gICAgY29lZmZpY2llbnQ6IChhLCBkZWdyZWUpID0+IGFbR0YuZGVncmVlKGEpIC0gZGVncmVlXSxcbiAgICBtdWxQb2x5KGEsIGIpIHtcbiAgICAgICAgaWYgKGFbMF0gPT09IDAgfHwgYlswXSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBbMF07XG4gICAgICAgIGNvbnN0IHJlcyA9IGZpbGxBcnIoYS5sZW5ndGggKyBiLmxlbmd0aCAtIDEsIDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHJlc1tpICsgal0gPSBHRi5hZGQocmVzW2kgKyBqXSwgR0YubXVsKGFbaV0sIGJbal0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gR0YucG9seW5vbWlhbChyZXMpO1xuICAgIH0sXG4gICAgbXVsUG9seVNjYWxhcihhLCBzY2FsYXIpIHtcbiAgICAgICAgaWYgKHNjYWxhciA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFswXTtcbiAgICAgICAgaWYgKHNjYWxhciA9PSAxKVxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIGNvbnN0IHJlcyA9IGZpbGxBcnIoYS5sZW5ndGgsIDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXNbaV0gPSBHRi5tdWwoYVtpXSwgc2NhbGFyKTtcbiAgICAgICAgcmV0dXJuIEdGLnBvbHlub21pYWwocmVzKTtcbiAgICB9LFxuICAgIG11bFBvbHlNb25vbWlhbChhLCBkZWdyZWUsIGNvZWZmaWNpZW50KSB7XG4gICAgICAgIGlmIChkZWdyZWUgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHRi5tdWxQb2x5TW9ub21pYWw6IHdyb25nIGRlZ3JlZScpO1xuICAgICAgICBpZiAoY29lZmZpY2llbnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBbMF07XG4gICAgICAgIGNvbnN0IHJlcyA9IGZpbGxBcnIoYS5sZW5ndGggKyBkZWdyZWUsIDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICByZXNbaV0gPSBHRi5tdWwoYVtpXSwgY29lZmZpY2llbnQpO1xuICAgICAgICByZXR1cm4gR0YucG9seW5vbWlhbChyZXMpO1xuICAgIH0sXG4gICAgYWRkUG9seShhLCBiKSB7XG4gICAgICAgIGlmIChhWzBdID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIGlmIChiWzBdID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIGxldCBzbWFsbGVyID0gYTtcbiAgICAgICAgbGV0IGxhcmdlciA9IGI7XG4gICAgICAgIGlmIChzbWFsbGVyLmxlbmd0aCA+IGxhcmdlci5sZW5ndGgpXG4gICAgICAgICAgICBbc21hbGxlciwgbGFyZ2VyXSA9IFtsYXJnZXIsIHNtYWxsZXJdO1xuICAgICAgICBsZXQgc3VtRGlmZiA9IGZpbGxBcnIobGFyZ2VyLmxlbmd0aCwgMCk7XG4gICAgICAgIGxldCBsZW5ndGhEaWZmID0gbGFyZ2VyLmxlbmd0aCAtIHNtYWxsZXIubGVuZ3RoO1xuICAgICAgICBsZXQgcyA9IGxhcmdlci5zbGljZSgwLCBsZW5ndGhEaWZmKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgc3VtRGlmZltpXSA9IHNbaV07XG4gICAgICAgIGZvciAobGV0IGkgPSBsZW5ndGhEaWZmOyBpIDwgbGFyZ2VyLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgc3VtRGlmZltpXSA9IEdGLmFkZChzbWFsbGVyW2kgLSBsZW5ndGhEaWZmXSwgbGFyZ2VyW2ldKTtcbiAgICAgICAgcmV0dXJuIEdGLnBvbHlub21pYWwoc3VtRGlmZik7XG4gICAgfSxcbiAgICByZW1haW5kZXJQb2x5KGRhdGEsIGRpdmlzb3IpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gQXJyYXkuZnJvbShkYXRhKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aCAtIGRpdmlzb3IubGVuZ3RoICsgMTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbG0gPSBvdXRbaV07XG4gICAgICAgICAgICBpZiAoZWxtID09PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDE7IGogPCBkaXZpc29yLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpdmlzb3Jbal0gIT09IDApXG4gICAgICAgICAgICAgICAgICAgIG91dFtpICsgal0gPSBHRi5hZGQob3V0W2kgKyBqXSwgR0YubXVsKGRpdmlzb3Jbal0sIGVsbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQuc2xpY2UoZGF0YS5sZW5ndGggLSBkaXZpc29yLmxlbmd0aCArIDEsIG91dC5sZW5ndGgpO1xuICAgIH0sXG4gICAgZGl2aXNvclBvbHkoZGVncmVlKSB7XG4gICAgICAgIGxldCBnID0gWzFdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlZ3JlZTsgaSsrKVxuICAgICAgICAgICAgZyA9IEdGLm11bFBvbHkoZywgWzEsIEdGLnBvdygyLCBpKV0pO1xuICAgICAgICByZXR1cm4gZztcbiAgICB9LFxuICAgIGV2YWxQb2x5KHBvbHksIGEpIHtcbiAgICAgICAgaWYgKGEgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBHRi5jb2VmZmljaWVudChwb2x5LCAwKTsgLy8gSnVzdCByZXR1cm4gdGhlIHheMCBjb2VmZmljaWVudFxuICAgICAgICBsZXQgcmVzID0gcG9seVswXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBwb2x5Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcmVzID0gR0YuYWRkKEdGLm11bChhLCByZXMpLCBwb2x5W2ldKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIC8vIFRPRE86IGNsZWFudXBcbiAgICBldWNsaWRpYW4oYSwgYiwgUikge1xuICAgICAgICAvLyBGb3JjZSBkZWdyZWUoYSkgPj0gZGVncmVlKGIpXG4gICAgICAgIGlmIChHRi5kZWdyZWUoYSkgPCBHRi5kZWdyZWUoYikpXG4gICAgICAgICAgICBbYSwgYl0gPSBbYiwgYV07XG4gICAgICAgIGxldCByTGFzdCA9IGE7XG4gICAgICAgIGxldCByID0gYjtcbiAgICAgICAgbGV0IHRMYXN0ID0gWzBdO1xuICAgICAgICBsZXQgdCA9IFsxXTtcbiAgICAgICAgLy8gd2hpbGUgZGVncmVlIG9mIFJpIOKJpSB0LzJcbiAgICAgICAgd2hpbGUgKDIgKiBHRi5kZWdyZWUocikgPj0gUikge1xuICAgICAgICAgICAgbGV0IHJMYXN0TGFzdCA9IHJMYXN0O1xuICAgICAgICAgICAgbGV0IHRMYXN0TGFzdCA9IHRMYXN0O1xuICAgICAgICAgICAgckxhc3QgPSByO1xuICAgICAgICAgICAgdExhc3QgPSB0O1xuICAgICAgICAgICAgaWYgKHJMYXN0WzBdID09PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignckxhc3RbMF0gPT09IDAnKTtcbiAgICAgICAgICAgIHIgPSByTGFzdExhc3Q7XG4gICAgICAgICAgICBsZXQgcSA9IFswXTtcbiAgICAgICAgICAgIGNvbnN0IGRsdEludmVyc2UgPSBHRi5pbnYockxhc3RbMF0pO1xuICAgICAgICAgICAgd2hpbGUgKEdGLmRlZ3JlZShyKSA+PSBHRi5kZWdyZWUockxhc3QpICYmIHJbMF0gIT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWdyZWVEaWZmID0gR0YuZGVncmVlKHIpIC0gR0YuZGVncmVlKHJMYXN0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsZSA9IEdGLm11bChyWzBdLCBkbHRJbnZlcnNlKTtcbiAgICAgICAgICAgICAgICBxID0gR0YuYWRkUG9seShxLCBHRi5tb25vbWlhbChkZWdyZWVEaWZmLCBzY2FsZSkpO1xuICAgICAgICAgICAgICAgIHIgPSBHRi5hZGRQb2x5KHIsIEdGLm11bFBvbHlNb25vbWlhbChyTGFzdCwgZGVncmVlRGlmZiwgc2NhbGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHEgPSBHRi5tdWxQb2x5KHEsIHRMYXN0KTtcbiAgICAgICAgICAgIHQgPSBHRi5hZGRQb2x5KHEsIHRMYXN0TGFzdCk7XG4gICAgICAgICAgICBpZiAoR0YuZGVncmVlKHIpID49IEdGLmRlZ3JlZShyTGFzdCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaXZpc2lvbiBmYWlsZWQgcjogJHtyfSwgckxhc3Q6ICR7ckxhc3R9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbWFUaWxkZUF0WmVybyA9IEdGLmNvZWZmaWNpZW50KHQsIDApO1xuICAgICAgICBpZiAoc2lnbWFUaWxkZUF0WmVybyA9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWdtYVRpbGRlKDApIHdhcyB6ZXJvJyk7XG4gICAgICAgIGNvbnN0IGludmVyc2UgPSBHRi5pbnYoc2lnbWFUaWxkZUF0WmVybyk7XG4gICAgICAgIHJldHVybiBbR0YubXVsUG9seVNjYWxhcih0LCBpbnZlcnNlKSwgR0YubXVsUG9seVNjYWxhcihyLCBpbnZlcnNlKV07XG4gICAgfSxcbn07XG5mdW5jdGlvbiBSUyhlY2NXb3Jkcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShmcm9tKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gR0YuZGl2aXNvclBvbHkoZWNjV29yZHMpO1xuICAgICAgICAgICAgY29uc3QgcG9sID0gQXJyYXkuZnJvbShmcm9tKTtcbiAgICAgICAgICAgIHBvbC5wdXNoKC4uLmQuc2xpY2UoMCwgLTEpLmZpbGwoMCkpO1xuICAgICAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShHRi5yZW1haW5kZXJQb2x5KHBvbCwgZCkpO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUodG8pIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRvLnNsaWNlKCk7XG4gICAgICAgICAgICBjb25zdCBwb2x5ID0gR0YucG9seW5vbWlhbChBcnJheS5mcm9tKHRvKSk7XG4gICAgICAgICAgICAvLyBGaW5kIGVycm9yc1xuICAgICAgICAgICAgbGV0IHN5bmRyb21lID0gZmlsbEFycihlY2NXb3JkcywgMCk7XG4gICAgICAgICAgICBsZXQgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWNjV29yZHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2bCA9IEdGLmV2YWxQb2x5KHBvbHksIEdGLmV4cChpKSk7XG4gICAgICAgICAgICAgICAgc3luZHJvbWVbc3luZHJvbWUubGVuZ3RoIC0gMSAtIGldID0gZXZsO1xuICAgICAgICAgICAgICAgIGlmIChldmwgIT09IDApXG4gICAgICAgICAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzRXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIHN5bmRyb21lID0gR0YucG9seW5vbWlhbChzeW5kcm9tZSk7XG4gICAgICAgICAgICBjb25zdCBtb25vbWlhbCA9IEdGLm1vbm9taWFsKGVjY1dvcmRzLCAxKTtcbiAgICAgICAgICAgIGNvbnN0IFtlcnJvckxvY2F0b3IsIGVycm9yRXZhbHVhdG9yXSA9IEdGLmV1Y2xpZGlhbihtb25vbWlhbCwgc3luZHJvbWUsIGVjY1dvcmRzKTtcbiAgICAgICAgICAgIC8vIEVycm9yIGxvY2F0aW9uc1xuICAgICAgICAgICAgY29uc3QgbG9jYXRpb25zID0gZmlsbEFycihHRi5kZWdyZWUoZXJyb3JMb2NhdG9yKSwgMCk7XG4gICAgICAgICAgICBsZXQgZSA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IDI1NiAmJiBlIDwgbG9jYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEdGLmV2YWxQb2x5KGVycm9yTG9jYXRvciwgaSkgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uc1tlKytdID0gR0YuaW52KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUgIT09IGxvY2F0aW9ucy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSUy5kZWNvZGU6IHdyb25nIGVycm9ycyBudW1iZXInKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zID0gcmVzLmxlbmd0aCAtIDEgLSBHRi5sb2cobG9jYXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zIDwgMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSUy5kZWNvZGU6IHdyb25nIGVycm9yIGxvY2F0aW9uJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeGlJbnZlcnNlID0gR0YuaW52KGxvY2F0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgbGV0IGRlbm9taW5hdG9yID0gMTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxvY2F0aW9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gailcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBkZW5vbWluYXRvciA9IEdGLm11bChkZW5vbWluYXRvciwgR0YuYWRkKDEsIEdGLm11bChsb2NhdGlvbnNbal0sIHhpSW52ZXJzZSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzW3Bvc10gPSBHRi5hZGQocmVzW3Bvc10sIEdGLm11bChHRi5ldmFsUG9seShlcnJvckV2YWx1YXRvciwgeGlJbnZlcnNlKSwgR0YuaW52KGRlbm9taW5hdG9yKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8gSW50ZXJsZWF2ZXMgYmxvY2tzXG5mdW5jdGlvbiBpbnRlcmxlYXZlKHZlciwgZWNjKSB7XG4gICAgY29uc3QgeyB3b3Jkcywgc2hvcnRCbG9ja3MsIG51bUJsb2NrcywgYmxvY2tMZW4sIHRvdGFsIH0gPSBpbmZvLmNhcGFjaXR5KHZlciwgZWNjKTtcbiAgICBjb25zdCBycyA9IFJTKHdvcmRzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoYnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIEFkZCBlcnJvciBjb3JyZWN0aW9uIHRvIGJ5dGVzXG4gICAgICAgICAgICBjb25zdCBibG9ja3MgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGVjY0Jsb2NrcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1CbG9ja3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzU2hvcnQgPSBpIDwgc2hvcnRCbG9ja3M7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuID0gYmxvY2tMZW4gKyAoaXNTaG9ydCA/IDAgOiAxKTtcbiAgICAgICAgICAgICAgICBibG9ja3MucHVzaChieXRlcy5zdWJhcnJheSgwLCBsZW4pKTtcbiAgICAgICAgICAgICAgICBlY2NCbG9ja3MucHVzaChycy5lbmNvZGUoYnl0ZXMuc3ViYXJyYXkoMCwgbGVuKSkpO1xuICAgICAgICAgICAgICAgIGJ5dGVzID0gYnl0ZXMuc3ViYXJyYXkobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc0Jsb2NrcyA9IGludGVybGVhdmVCeXRlcyguLi5ibG9ja3MpO1xuICAgICAgICAgICAgY29uc3QgcmVzRUNDID0gaW50ZXJsZWF2ZUJ5dGVzKC4uLmVjY0Jsb2Nrcyk7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShyZXNCbG9ja3MubGVuZ3RoICsgcmVzRUNDLmxlbmd0aCk7XG4gICAgICAgICAgICByZXMuc2V0KHJlc0Jsb2Nrcyk7XG4gICAgICAgICAgICByZXMuc2V0KHJlc0VDQywgcmVzQmxvY2tzLmxlbmd0aCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSB0b3RhbClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludGVybGVhdmUuZGVjb2RlOiBsZW4oZGF0YSk9JHtkYXRhLmxlbmd0aH0sIHRvdGFsPSR7dG90YWx9YCk7XG4gICAgICAgICAgICBjb25zdCBibG9ja3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQmxvY2tzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1Nob3J0ID0gaSA8IHNob3J0QmxvY2tzO1xuICAgICAgICAgICAgICAgIGJsb2Nrcy5wdXNoKG5ldyBVaW50OEFycmF5KHdvcmRzICsgYmxvY2tMZW4gKyAoaXNTaG9ydCA/IDAgOiAxKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2hvcnQgYmxvY2tzXG4gICAgICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tMZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbnVtQmxvY2tzOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tqXVtpXSA9IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTG9uZyBibG9ja3NcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBzaG9ydEJsb2NrczsgaiA8IG51bUJsb2NrczsgaisrKVxuICAgICAgICAgICAgICAgIGJsb2Nrc1tqXVtibG9ja0xlbl0gPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIC8vIEVDQ1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGJsb2NrTGVuOyBpIDwgYmxvY2tMZW4gKyB3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1CbG9ja3M7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc1Nob3J0ID0gaiA8IHNob3J0QmxvY2tzO1xuICAgICAgICAgICAgICAgICAgICBibG9ja3Nbal1baSArIChpc1Nob3J0ID8gMCA6IDEpXSA9IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlY29kZVxuICAgICAgICAgICAgLy8gRXJyb3ItY29ycmVjdCBhbmQgY29weSBkYXRhIGJsb2NrcyB0b2dldGhlciBpbnRvIGEgc3RyZWFtIG9mIGJ5dGVzXG4gICAgICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYmxvY2sgb2YgYmxvY2tzKVxuICAgICAgICAgICAgICAgIHJlcy5wdXNoKC4uLkFycmF5LmZyb20ocnMuZGVjb2RlKGJsb2NrKSkuc2xpY2UoMCwgLXdvcmRzKSk7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKHJlcyk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8vIERyYXdcbi8vIEdlbmVyaWMgdGVtcGxhdGUgcGVyIHZlcnNpb24rZWNjK21hc2suIENhbiBiZSBjYWNoZWQsIHRvIHNwZWVkdXAgY2FsY3VsYXRpb25zLlxuZnVuY3Rpb24gZHJhd1RlbXBsYXRlKHZlciwgZWNjLCBtYXNrSWR4LCB0ZXN0ID0gZmFsc2UpIHtcbiAgICBjb25zdCBzaXplID0gaW5mby5zaXplLmVuY29kZSh2ZXIpO1xuICAgIGxldCBiID0gbmV3IEJpdG1hcChzaXplICsgMik7XG4gICAgLy8gRmluZGVyIHBhdHRlcm5zXG4gICAgLy8gV2UgZHJhdyBmdWxsIHBhdHRlcm4gYW5kIGxhdGVyIHNsaWNlLCBzaW5jZSBiZWZvcmUgYWRkaXRpb24gb2YgYm9yZGVycyBmaW5kZXIgaXMgdHJ1bmNhdGVkIGJ5IG9uZSBwaXhlbCBvbiBzaWRlc1xuICAgIGNvbnN0IGZpbmRlciA9IG5ldyBCaXRtYXAoMykucmVjdCgwLCAzLCB0cnVlKS5ib3JkZXIoMSwgZmFsc2UpLmJvcmRlcigxLCB0cnVlKS5ib3JkZXIoMSwgZmFsc2UpO1xuICAgIGIgPSBiXG4gICAgICAgIC5lbWJlZCgwLCBmaW5kZXIpIC8vIHRvcCBsZWZ0XG4gICAgICAgIC5lbWJlZCh7IHg6IC1maW5kZXIud2lkdGgsIHk6IDAgfSwgZmluZGVyKSAvLyB0b3AgcmlnaHRcbiAgICAgICAgLmVtYmVkKHsgeDogMCwgeTogLWZpbmRlci5oZWlnaHQgfSwgZmluZGVyKTsgLy8gYm90dG9tIGxlZnRcbiAgICBiID0gYi5yZWN0U2xpY2UoMSwgc2l6ZSk7XG4gICAgLy8gQWxpZ25tZW50IHBhdHRlcm5zXG4gICAgY29uc3QgYWxpZ24gPSBuZXcgQml0bWFwKDEpLnJlY3QoMCwgMSwgdHJ1ZSkuYm9yZGVyKDEsIGZhbHNlKS5ib3JkZXIoMSwgdHJ1ZSk7XG4gICAgY29uc3QgYWxpZ25Qb3MgPSBpbmZvLmFsaWdubWVudFBhdHRlcm5zKHZlcik7XG4gICAgZm9yIChjb25zdCB5IG9mIGFsaWduUG9zKSB7XG4gICAgICAgIGZvciAoY29uc3QgeCBvZiBhbGlnblBvcykge1xuICAgICAgICAgICAgaWYgKGIuZGF0YVt5XVt4XSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgYi5lbWJlZCh7IHg6IHggLSAyLCB5OiB5IC0gMiB9LCBhbGlnbik7IC8vIGNlbnRlciBvZiBwYXR0ZXJuIHNob3VsZCBiZSBhdCBwb3NpdGlvblxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRpbWluZyBwYXR0ZXJuc1xuICAgIGIgPSBiXG4gICAgICAgIC5oTGluZSh7IHg6IDAsIHk6IDYgfSwgSW5maW5pdHksICh7IHggfSwgY3VyKSA9PiAoY3VyID09PSB1bmRlZmluZWQgPyB4ICUgMiA9PSAwIDogY3VyKSlcbiAgICAgICAgLnZMaW5lKHsgeDogNiwgeTogMCB9LCBJbmZpbml0eSwgKHsgeSB9LCBjdXIpID0+IChjdXIgPT09IHVuZGVmaW5lZCA/IHkgJSAyID09IDAgOiBjdXIpKTtcbiAgICAvLyBGb3JtYXQgaW5mb3JtYXRpb25cbiAgICB7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBpbmZvLmZvcm1hdEJpdHMoZWNjLCBtYXNrSWR4KTtcbiAgICAgICAgY29uc3QgZ2V0Qml0ID0gKGkpID0+ICF0ZXN0ICYmICgoYml0cyA+PiBpKSAmIDEpID09IDE7XG4gICAgICAgIC8vIHZlcnRpY2FsXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKVxuICAgICAgICAgICAgYi5kYXRhW2ldWzhdID0gZ2V0Qml0KGkpOyAvLyByaWdodCBvZiB0b3AtbGVmdCBmaW5kZXJcbiAgICAgICAgLy8gVE9ETzogcmUtd3JpdGUgYXMgbGluZXMsIGxpa2U6XG4gICAgICAgIC8vIGIudkxpbmUoeyB4OiA4LCB5OiAwIH0sIDYsICh7IHgsIHkgfSkgPT4gZ2V0Qml0KHkpKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDY7IGkgPCA4OyBpKyspXG4gICAgICAgICAgICBiLmRhdGFbaSArIDFdWzhdID0gZ2V0Qml0KGkpOyAvLyBhZnRlciB0aW1pbmcgcGF0dGVyblxuICAgICAgICBmb3IgKGxldCBpID0gODsgaSA8IDE1OyBpKyspXG4gICAgICAgICAgICBiLmRhdGFbc2l6ZSAtIDE1ICsgaV1bOF0gPSBnZXRCaXQoaSk7IC8vIHJpZ2h0IG9mIGJvdHRvbS1sZWZ0IGZpbmRlclxuICAgICAgICAvLyBob3Jpem9udGFsXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKVxuICAgICAgICAgICAgYi5kYXRhWzhdW3NpemUgLSBpIC0gMV0gPSBnZXRCaXQoaSk7IC8vIHVuZGVyIHRvcC1yaWdodCBmaW5kZXJcbiAgICAgICAgZm9yIChsZXQgaSA9IDg7IGkgPCA5OyBpKyspXG4gICAgICAgICAgICBiLmRhdGFbOF1bMTUgLSBpIC0gMSArIDFdID0gZ2V0Qml0KGkpOyAvLyBWVlYsIGFmdGVyIHRpbWluZ1xuICAgICAgICBmb3IgKGxldCBpID0gOTsgaSA8IDE1OyBpKyspXG4gICAgICAgICAgICBiLmRhdGFbOF1bMTUgLSBpIC0gMV0gPSBnZXRCaXQoaSk7IC8vIHVuZGVyIHRvcC1sZWZ0IGZpbmRlclxuICAgICAgICBiLmRhdGFbc2l6ZSAtIDhdWzhdID0gIXRlc3Q7IC8vIGJvdHRvbS1sZWZ0IGZpbmRlciwgcmlnaHRcbiAgICB9XG4gICAgLy8gVmVyc2lvbiBpbmZvcm1hdGlvblxuICAgIGlmICh2ZXIgPj0gNykge1xuICAgICAgICBjb25zdCBiaXRzID0gaW5mby52ZXJzaW9uQml0cyh2ZXIpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE4OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpdCA9ICF0ZXN0ICYmICgoYml0cyA+PiBpKSAmIDEpID09IDE7XG4gICAgICAgICAgICBjb25zdCB4ID0gTWF0aC5mbG9vcihpIC8gMyk7XG4gICAgICAgICAgICBjb25zdCB5ID0gKGkgJSAzKSArIHNpemUgLSA4IC0gMztcbiAgICAgICAgICAgIC8vIHR3byBjb3BpZXNcbiAgICAgICAgICAgIGIuZGF0YVt4XVt5XSA9IGJpdDtcbiAgICAgICAgICAgIGIuZGF0YVt5XVt4XSA9IGJpdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYjtcbn1cbi8vIHppZ3phZzogYm90dG9tLT50b3AgJiYgdG9wLT5ib3R0b21cbmZ1bmN0aW9uIHppZ3phZyh0cGwsIG1hc2tJZHgsIGZuKSB7XG4gICAgY29uc3Qgc2l6ZSA9IHRwbC5oZWlnaHQ7XG4gICAgY29uc3QgcGF0dGVybiA9IFBBVFRFUk5TW21hc2tJZHhdO1xuICAgIC8vIHppZy16YWcgcGF0dGVyblxuICAgIGxldCBkaXIgPSAtMTtcbiAgICBsZXQgeSA9IHNpemUgLSAxO1xuICAgIC8vIHR3byBjb2x1bW5zIGF0IHRpbWVcbiAgICBmb3IgKGxldCB4T2Zmc2V0ID0gc2l6ZSAtIDE7IHhPZmZzZXQgPiAwOyB4T2Zmc2V0IC09IDIpIHtcbiAgICAgICAgaWYgKHhPZmZzZXQgPT0gNilcbiAgICAgICAgICAgIHhPZmZzZXQgPSA1OyAvLyBza2lwIHZlcnRpY2FsIHRpbWluZyBwYXR0ZXJuXG4gICAgICAgIGZvciAoOzsgeSArPSBkaXIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgMjsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHhPZmZzZXQgLSBqO1xuICAgICAgICAgICAgICAgIGlmICh0cGwuZGF0YVt5XVt4XSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCBhbHJlYWR5IHdyaXR0ZW4gZWxlbWVudHNcbiAgICAgICAgICAgICAgICBmbih4LCB5LCBwYXR0ZXJuKHgsIHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5ICsgZGlyIDwgMCB8fCB5ICsgZGlyID49IHNpemUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGlyID0gLWRpcjsgLy8gY2hhbmdlIGRpcmVjdGlvblxuICAgIH1cbn1cbi8vIE5PVEU6IGJ5dGUgZW5jb2RpbmcgaXMganVzdCByZXByZXNlbnRhdGlvbiwgUVIgd29ya3Mgd2l0aCBzdHJpbmdzIG9ubHkuIE1vc3QgZGVjb2RlcnMgd2lsbCBmYWlsIG9uIHJhdyBieXRlIGFycmF5LFxuLy8gc2luY2UgdGhleSBleHBlY3QgdW5pY29kZSBvciBvdGhlciB0ZXh0IGVuY29kaW5nIGluc2lkZSBieXRlc1xuZnVuY3Rpb24gZGV0ZWN0VHlwZShzdHIpIHtcbiAgICBsZXQgdHlwZSA9ICdudW1lcmljJztcbiAgICBmb3IgKGxldCB4IG9mIHN0cikge1xuICAgICAgICBpZiAoaW5mby5hbHBoYWJldC5udW1lcmljLmhhcyh4KSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB0eXBlID0gJ2FscGhhbnVtZXJpYyc7XG4gICAgICAgIGlmICghaW5mby5hbHBoYWJldC5hbHBoYW51bWVyYy5oYXMoeCkpXG4gICAgICAgICAgICByZXR1cm4gJ2J5dGUnO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG5mdW5jdGlvbiBlbmNvZGUodmVyLCBlY2MsIGRhdGEsIHR5cGUpIHtcbiAgICBsZXQgZW5jb2RlZCA9ICcnO1xuICAgIGxldCBkYXRhTGVuID0gZGF0YS5sZW5ndGg7XG4gICAgaWYgKHR5cGUgPT09ICdudW1lcmljJykge1xuICAgICAgICBjb25zdCB0ID0gaW5mby5hbHBoYWJldC5udW1lcmljLmRlY29kZShkYXRhLnNwbGl0KCcnKSk7XG4gICAgICAgIGNvbnN0IG4gPSB0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuIC0gMjsgaSArPSAzKVxuICAgICAgICAgICAgZW5jb2RlZCArPSBiaW4odFtpXSAqIDEwMCArIHRbaSArIDFdICogMTAgKyB0W2kgKyAyXSwgMTApO1xuICAgICAgICBpZiAobiAlIDMgPT09IDEpIHtcbiAgICAgICAgICAgIGVuY29kZWQgKz0gYmluKHRbbiAtIDFdLCA0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuICUgMyA9PT0gMikge1xuICAgICAgICAgICAgZW5jb2RlZCArPSBiaW4odFtuIC0gMl0gKiAxMCArIHRbbiAtIDFdLCA3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnYWxwaGFudW1lcmljJykge1xuICAgICAgICBjb25zdCB0ID0gaW5mby5hbHBoYWJldC5hbHBoYW51bWVyYy5kZWNvZGUoZGF0YS5zcGxpdCgnJykpO1xuICAgICAgICBjb25zdCBuID0gdC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbiAtIDE7IGkgKz0gMilcbiAgICAgICAgICAgIGVuY29kZWQgKz0gYmluKHRbaV0gKiA0NSArIHRbaSArIDFdLCAxMSk7XG4gICAgICAgIGlmIChuICUgMiA9PSAxKVxuICAgICAgICAgICAgZW5jb2RlZCArPSBiaW4odFtuIC0gMV0sIDYpOyAvLyBwYWQgaWYgb2RkIG51bWJlciBvZiBjaGFyc1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlID09PSAnYnl0ZScpIHtcbiAgICAgICAgY29uc3QgdXRmOCA9IHV0ZjhUb0J5dGVzKGRhdGEpO1xuICAgICAgICBkYXRhTGVuID0gdXRmOC5sZW5ndGg7XG4gICAgICAgIGVuY29kZWQgPSBBcnJheS5mcm9tKHV0ZjgpXG4gICAgICAgICAgICAubWFwKChpKSA9PiBiaW4oaSwgOCkpXG4gICAgICAgICAgICAuam9pbignJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuY29kZTogdW5zdXBwb3J0ZWQgdHlwZScpO1xuICAgIH1cbiAgICBjb25zdCB7IGNhcGFjaXR5IH0gPSBpbmZvLmNhcGFjaXR5KHZlciwgZWNjKTtcbiAgICBjb25zdCBsZW4gPSBiaW4oZGF0YUxlbiwgaW5mby5sZW5ndGhCaXRzKHZlciwgdHlwZSkpO1xuICAgIGxldCBiaXRzID0gaW5mby5tb2RlQml0c1t0eXBlXSArIGxlbiArIGVuY29kZWQ7XG4gICAgaWYgKGJpdHMubGVuZ3RoID4gY2FwYWNpdHkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FwYWNpdHkgb3ZlcmZsb3cnKTtcbiAgICAvLyBUZXJtaW5hdG9yXG4gICAgYml0cyArPSAnMCcucmVwZWF0KE1hdGgubWluKDQsIE1hdGgubWF4KDAsIGNhcGFjaXR5IC0gYml0cy5sZW5ndGgpKSk7XG4gICAgLy8gUGFkIGJpdHMgc3RyaW5nIHVudGlsbCBmdWxsIGJ5dGVcbiAgICBpZiAoYml0cy5sZW5ndGggJSA4KVxuICAgICAgICBiaXRzICs9ICcwJy5yZXBlYXQoOCAtIChiaXRzLmxlbmd0aCAlIDgpKTtcbiAgICAvLyBBZGQgcGFkZGluZyB1bnRpbCBjYXBhY2l0eSBpcyBmdWxsXG4gICAgY29uc3QgcGFkZGluZyA9ICcxMTEwMTEwMDAwMDEwMDAxJztcbiAgICBmb3IgKGxldCBpZHggPSAwOyBiaXRzLmxlbmd0aCAhPT0gY2FwYWNpdHk7IGlkeCsrKVxuICAgICAgICBiaXRzICs9IHBhZGRpbmdbaWR4ICUgcGFkZGluZy5sZW5ndGhdO1xuICAgIC8vIENvbnZlcnQgYSBiaXRzdHJpbmcgdG8gYXJyYXkgb2YgYnl0ZXNcbiAgICBjb25zdCBieXRlcyA9IFVpbnQ4QXJyYXkuZnJvbShiaXRzLm1hdGNoKC8oLns4fSkvZykubWFwKChpKSA9PiBOdW1iZXIoYDBiJHtpfWApKSk7XG4gICAgcmV0dXJuIGludGVybGVhdmUodmVyLCBlY2MpLmVuY29kZShieXRlcyk7XG59XG4vLyBEUkFXXG5mdW5jdGlvbiBkcmF3UVIodmVyLCBlY2MsIGRhdGEsIG1hc2tJZHgsIHRlc3QgPSBmYWxzZSkge1xuICAgIGNvbnN0IGIgPSBkcmF3VGVtcGxhdGUodmVyLCBlY2MsIG1hc2tJZHgsIHRlc3QpO1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBuZWVkID0gOCAqIGRhdGEubGVuZ3RoO1xuICAgIHppZ3phZyhiLCBtYXNrSWR4LCAoeCwgeSwgbWFzaykgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGkgPCBuZWVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICgoZGF0YVtpID4+PiAzXSA+PiAoKDcgLSBpKSAmIDcpKSAmIDEpICE9PSAwO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGIuZGF0YVt5XVt4XSA9IHZhbHVlICE9PSBtYXNrOyAvLyAhPT0gYXMgeG9yXG4gICAgfSk7XG4gICAgaWYgKGkgIT09IG5lZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUVI6IGJ5dGVzIGxlZnQgYWZ0ZXIgZHJhdycpO1xuICAgIHJldHVybiBiO1xufVxuZnVuY3Rpb24gcGVuYWx0eShibSkge1xuICAgIGNvbnN0IGludmVyc2UgPSBibS5pbnZlcnNlKCk7XG4gICAgLy8gQWRqYWNlbnQgbW9kdWxlcyBpbiByb3cvY29sdW1uIGluIHNhbWUgfCBOby4gb2YgbW9kdWxlcyA9ICg1ICsgaSkgY29sb3JcbiAgICBjb25zdCBzYW1lQ29sb3IgPSAocm93KSA9PiB7XG4gICAgICAgIGxldCByZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgc2FtZSA9IDEsIGxhc3QgPSB1bmRlZmluZWQ7IGkgPCByb3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChsYXN0ID09PSByb3dbaV0pIHtcbiAgICAgICAgICAgICAgICBzYW1lKys7XG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IHJvdy5sZW5ndGggLSAxKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gaGFuZGxlIGxhc3QgZWxlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNhbWUgPj0gNSlcbiAgICAgICAgICAgICAgICByZXMgKz0gMyArIChzYW1lIC0gNSk7XG4gICAgICAgICAgICBsYXN0ID0gcm93W2ldO1xuICAgICAgICAgICAgc2FtZSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIGxldCBhZGphY2VudCA9IDA7XG4gICAgYm0uZGF0YS5mb3JFYWNoKChyb3cpID0+IChhZGphY2VudCArPSBzYW1lQ29sb3Iocm93KSkpO1xuICAgIGludmVyc2UuZGF0YS5mb3JFYWNoKChjb2x1bW4pID0+IChhZGphY2VudCArPSBzYW1lQ29sb3IoY29sdW1uKSkpO1xuICAgIC8vIEJsb2NrIG9mIG1vZHVsZXMgaW4gc2FtZSBjb2xvciAoQmxvY2sgc2l6ZSA9IDJ4MilcbiAgICBsZXQgYm94ID0gMDtcbiAgICBsZXQgYiA9IGJtLmRhdGE7XG4gICAgY29uc3QgbGFzdFcgPSBibS53aWR0aCAtIDE7XG4gICAgY29uc3QgbGFzdEggPSBibS5oZWlnaHQgLSAxO1xuICAgIGZvciAobGV0IHggPSAwOyB4IDwgbGFzdFc7IHgrKykge1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGxhc3RIOyB5KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHgxID0geCArIDE7XG4gICAgICAgICAgICBjb25zdCB5MSA9IHkgKyAxO1xuICAgICAgICAgICAgaWYgKGJbeF1beV0gPT09IGJbeDFdW3ldICYmIGJbeDFdW3ldID09PSBiW3hdW3kxXSAmJiBiW3gxXVt5XSA9PT0gYlt4MV1beTFdKSB7XG4gICAgICAgICAgICAgICAgYm94ICs9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gMToxOjM6MToxIHJhdGlvIChkYXJrOmxpZ2h0OmRhcms6bGlnaHQ6ZGFyaykgcGF0dGVybiBpbiByb3cvY29sdW1uLCBwcmVjZWRlZCBvciBmb2xsb3dlZCBieSBsaWdodCBhcmVhIDQgbW9kdWxlcyB3aWRlXG4gICAgY29uc3QgZmluZGVyUGF0dGVybiA9IChyb3cpID0+IHtcbiAgICAgICAgY29uc3QgZmluZGVyUGF0dGVybiA9IFt0cnVlLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIHRydWVdOyAvLyBkYXJrOmxpZ2h0OmRhcms6bGlnaHQ6ZGFya1xuICAgICAgICBjb25zdCBsaWdodFBhdHRlcm4gPSBbZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2VdOyAvLyBsaWdodCBhcmVhIDQgbW9kdWxlcyB3aWRlXG4gICAgICAgIGNvbnN0IHAxID0gWy4uLmZpbmRlclBhdHRlcm4sIC4uLmxpZ2h0UGF0dGVybl07XG4gICAgICAgIGNvbnN0IHAyID0gWy4uLmxpZ2h0UGF0dGVybiwgLi4uZmluZGVyUGF0dGVybl07XG4gICAgICAgIGxldCByZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVzQXQocm93LCBwMSwgaSkpXG4gICAgICAgICAgICAgICAgcmVzICs9IDQwO1xuICAgICAgICAgICAgaWYgKGluY2x1ZGVzQXQocm93LCBwMiwgaSkpXG4gICAgICAgICAgICAgICAgcmVzICs9IDQwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBsZXQgZmluZGVyID0gMDtcbiAgICBmb3IgKGNvbnN0IHJvdyBvZiBibS5kYXRhKVxuICAgICAgICBmaW5kZXIgKz0gZmluZGVyUGF0dGVybihyb3cpO1xuICAgIGZvciAoY29uc3QgY29sdW1uIG9mIGludmVyc2UuZGF0YSlcbiAgICAgICAgZmluZGVyICs9IGZpbmRlclBhdHRlcm4oY29sdW1uKTtcbiAgICAvLyBQcm9wb3J0aW9uIG9mIGRhcmsgbW9kdWxlcyBpbiBlbnRpcmUgc3ltYm9sXG4gICAgLy8gQWRkIDEwIHBvaW50cyB0byBhIGRldmlhdGlvbiBvZiA1JSBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGluIHRoZSBwcm9wb3J0aW9uXG4gICAgLy8gcmF0aW8gb2YgZGFyayBtb2R1bGUgZnJvbSB0aGUgcmVmZXJlbnRpYWwgNTAlXG4gICAgbGV0IGRhcmtQaXhlbHMgPSAwO1xuICAgIGJtLnJlY3RSZWFkKDAsIEluZmluaXR5LCAoX2MsIHZhbCkgPT4gKGRhcmtQaXhlbHMgKz0gdmFsID8gMSA6IDApKTtcbiAgICBjb25zdCBkYXJrUGVyY2VudCA9IChkYXJrUGl4ZWxzIC8gKGJtLmhlaWdodCAqIGJtLndpZHRoKSkgKiAxMDA7XG4gICAgY29uc3QgZGFyayA9IDEwICogTWF0aC5mbG9vcihNYXRoLmFicyhkYXJrUGVyY2VudCAtIDUwKSAvIDUpO1xuICAgIHJldHVybiBhZGphY2VudCArIGJveCArIGZpbmRlciArIGRhcms7XG59XG4vLyBTZWxlY3RzIGJlc3QgbWFzayBhY2NvcmRpbmcgdG8gcGVuYWx0eSwgaWYgbm8gbWFzayBpcyBwcm92aWRlZFxuZnVuY3Rpb24gZHJhd1FSQmVzdCh2ZXIsIGVjYywgZGF0YSwgbWFza0lkeCkge1xuICAgIGlmIChtYXNrSWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgYmVzdE1hc2sgPSBiZXN0KCk7XG4gICAgICAgIGZvciAobGV0IG1hc2sgPSAwOyBtYXNrIDwgUEFUVEVSTlMubGVuZ3RoOyBtYXNrKyspXG4gICAgICAgICAgICBiZXN0TWFzay5hZGQocGVuYWx0eShkcmF3UVIodmVyLCBlY2MsIGRhdGEsIG1hc2ssIHRydWUpKSwgbWFzayk7XG4gICAgICAgIG1hc2tJZHggPSBiZXN0TWFzay5nZXQoKTtcbiAgICB9XG4gICAgaWYgKG1hc2tJZHggPT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBtYXNrJyk7IC8vIFNob3VsZCBuZXZlciBoYXBwZW5cbiAgICByZXR1cm4gZHJhd1FSKHZlciwgZWNjLCBkYXRhLCBtYXNrSWR4KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRUNDKGVjKSB7XG4gICAgaWYgKCFFQ01vZGUuaW5jbHVkZXMoZWMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZXJyb3IgY29ycmVjdGlvbiBtb2RlPSR7ZWN9LiBFeHBlY3RlZDogJHtFQ01vZGV9YCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUVuY29kaW5nKGVuYykge1xuICAgIGlmICghRW5jb2RpbmcuaW5jbHVkZXMoZW5jKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbmNvZGluZzogaW52YWxpZCBtb2RlPSR7ZW5jfS4gRXhwZWN0ZWQ6ICR7RW5jb2Rpbmd9YCk7XG4gICAgaWYgKGVuYyA9PT0gJ2thbmppJyB8fCBlbmMgPT09ICdlY2knKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVuY29kaW5nOiAke2VuY30gaXMgbm90IHN1cHBvcnRlZCAoeWV0PykuYCk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1hc2sobWFzaykge1xuICAgIGlmICghWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDddLmluY2x1ZGVzKG1hc2spIHx8ICFQQVRURVJOU1ttYXNrXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1hc2s9JHttYXNrfS4gRXhwZWN0ZWQgbnVtYmVyIFswLi43XWApO1xufVxuZnVuY3Rpb24gZW5jb2RlUVIodGV4dCwgb3V0cHV0ID0gJ3JhdycsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGVjYyA9IG9wdHMuZWNjICE9PSB1bmRlZmluZWQgPyBvcHRzLmVjYyA6ICdtZWRpdW0nO1xuICAgIHZhbGlkYXRlRUNDKGVjYyk7XG4gICAgY29uc3QgZW5jb2RpbmcgPSBvcHRzLmVuY29kaW5nICE9PSB1bmRlZmluZWQgPyBvcHRzLmVuY29kaW5nIDogZGV0ZWN0VHlwZSh0ZXh0KTtcbiAgICB2YWxpZGF0ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgICBpZiAob3B0cy5tYXNrICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHZhbGlkYXRlTWFzayhvcHRzLm1hc2spO1xuICAgIGxldCB2ZXIgPSBvcHRzLnZlcnNpb247XG4gICAgbGV0IGRhdGEsIGVyciA9IG5ldyBFcnJvcignVW5rbm93biBlcnJvcicpO1xuICAgIGlmICh2ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWxpZGF0ZVZlcnNpb24odmVyKTtcbiAgICAgICAgZGF0YSA9IGVuY29kZSh2ZXIsIGVjYywgdGV4dCwgZW5jb2RpbmcpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSWYgbm8gdmVyc2lvbiBpcyBwcm92aWRlZCwgdHJ5IHRvIGZpbmQgc21hbGxlc3Qgb25lIHdoaWNoIGZpdHNcbiAgICAgICAgLy8gQ3VycmVudGx5IGp1c3Qgc2NhbnMgYWxsIHZlcnNpb24sIGNhbiBiZSBzaWduaWZpY2FudGx5IHNwZWVkdXAgaWYgbmVlZGVkXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IDQwOyBpKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGVuY29kZShpLCBlY2MsIHRleHQsIGVuY29kaW5nKTtcbiAgICAgICAgICAgICAgICB2ZXIgPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghdmVyIHx8ICFkYXRhKVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgbGV0IHJlcyA9IGRyYXdRUkJlc3QodmVyLCBlY2MsIGRhdGEsIG9wdHMubWFzayk7XG4gICAgcmVzLmFzc2VydERyYXduKCk7XG4gICAgY29uc3QgYm9yZGVyID0gb3B0cy5ib3JkZXIgPT09IHVuZGVmaW5lZCA/IDIgOiBvcHRzLmJvcmRlcjtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGJvcmRlcikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgYm9yZGVyIHR5cGU9JHt0eXBlb2YgYm9yZGVyfWApO1xuICAgIHJlcyA9IHJlcy5ib3JkZXIoYm9yZGVyLCBmYWxzZSk7IC8vIEFkZCBib3JkZXJcbiAgICBpZiAob3B0cy5zY2FsZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICByZXMgPSByZXMuc2NhbGUob3B0cy5zY2FsZSk7IC8vIFNjYWxlIGltYWdlXG4gICAgaWYgKG91dHB1dCA9PT0gJ3JhdycpXG4gICAgICAgIHJldHVybiByZXMuZGF0YTtcbiAgICBlbHNlIGlmIChvdXRwdXQgPT09ICdhc2NpaScpXG4gICAgICAgIHJldHVybiByZXMudG9BU0NJSSgpO1xuICAgIGVsc2UgaWYgKG91dHB1dCA9PT0gJ3N2ZycpXG4gICAgICAgIHJldHVybiByZXMudG9TVkcoKTtcbiAgICBlbHNlIGlmIChvdXRwdXQgPT09ICdnaWYnKVxuICAgICAgICByZXR1cm4gcmVzLnRvR0lGKCk7XG4gICAgZWxzZSBpZiAob3V0cHV0ID09PSAndGVybScpXG4gICAgICAgIHJldHVybiByZXMudG9UZXJtKCk7XG4gICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb3V0cHV0OiAke291dHB1dH1gKTtcbn1cbi8vIFR5cGUgdGVzdHNcbi8vIGNvbnN0IG8xID0gcXIoJ3Rlc3QnLCAnYXNjaWknKTtcbi8vIGNvbnN0IG8yID0gcXIoJ3Rlc3QnLCAncmF3Jyk7XG4vLyBjb25zdCBvMyA9IHFyKCd0ZXN0JywgJ2dpZicpO1xuLy8gY29uc3QgbzQgPSBxcigndGVzdCcsICdzdmcnKTtcbi8vIGNvbnN0IG81ID0gcXIoJ3Rlc3QnLCAndGVybScpO1xuXG5jb25zdCBkZWZhdWx0VHJhbnNsYXRpb25zID0ge1xuICAgIFwiREVTS1RPUFwiOiBcIkRlc2t0b3BcIixcbiAgICBcIk1PQklMRVwiOiBcIk1vYmlsZVwiLFxuICAgIFwiTUVUQV9NQVNLX01PQklMRV9BUFBcIjogXCJNZXRhTWFzayBtb2JpbGUgYXBwXCIsXG4gICAgXCJTQ0FOX1RPX0NPTk5FQ1RcIjogXCJTY2FuIHRvIGNvbm5lY3QgYW5kIHNpZ24gd2l0aFwiLFxuICAgIFwiQ09OTkVDVF9XSVRIX0VYVEVOU0lPTlwiOiBcIkNvbm5lY3QgV2l0aCBNZXRhTWFzayBFeHRlbnNpb25cIixcbiAgICBcIklOU1RBTExfTU9EQUxcIjoge1xuICAgICAgICBcIlRSVVNURURfQllfVVNFUlNcIjogXCJUcnVzdGVkIGJ5IG92ZXIgMzAgbWlsbGlvbiB1c2VycyB0byBidXksIHN0b3JlLCBzZW5kIGFuZCBzd2FwIGNyeXB0byBzZWN1cmVseVwiLFxuICAgICAgICBcIkxFQURJTkdfQ1JZUFRPX1dBTExFVFwiOiBcIlRoZSBsZWFkaW5nIGNyeXB0byB3YWxsZXQgJiBnYXRld2F5IHRvIGJsb2NrY2hhaW4gYXBwcyBidWlsdCBvbiBFdGhlcmV1bSBNYWlubmV0LCBQb2x5Z29uLCBPcHRpbWlzbSwgYW5kIG1hbnkgb3RoZXIgbmV0d29ya3NcIixcbiAgICAgICAgXCJDT05UUk9MX0RJR0lUQUxfSU5URVJBQ1RJT05TXCI6IFwiUHV0cyB5b3UgaW4gY29udHJvbCBvZiB5b3VyIGRpZ2l0YWwgaW50ZXJhY3Rpb25zIGJ5IG1ha2luZyBwb3dlciBvZiBjcnlwdG9ncmFwaHkgbW9yZSBhY2Nlc3NpYmxlXCIsXG4gICAgICAgIFwiSU5TVEFMTF9NRVRBX01BU0tfRVhURU5TSU9OXCI6IFwiSW5zdGFsbCBNZXRhTWFzayBFeHRlbnNpb25cIlxuICAgIH0sXG4gICAgXCJQRU5ESU5HX01PREFMXCI6IHtcbiAgICAgICAgXCJPUEVOX01FVEFfTUFTS19TRUxFQ1RfQ09ERVwiOiBcIlBsZWFzZSBvcGVuIHRoZSBNZXRhTWFzayB3YWxsZXQgYXBwIGFuZCBzZWxlY3QgdGhlIGNvZGUgb24gdGhlIHNjcmVlbiBPUiBkaXNjb25uZWN0XCIsXG4gICAgICAgIFwiT1BFTl9NRVRBX01BU0tfQ09OVElOVUVcIjogXCJPcGVuIHRoZSBNZXRhTWFzayBhcHAgdG8gY29udGludWUgd2l0aCB5b3VyIHNlc3Npb24uXCIsXG4gICAgICAgIFwiTlVNQkVSX0FGVEVSX09QRU5fTk9USUNFXCI6IFwiSWYgYSBudW1iZXIgZG9lc24ndCBhcHBlYXIgYWZ0ZXIgb3BlbmluZyBNZXRhTWFzaywgcGxlYXNlIGNsaWNrIGRpc2Nvbm5lY3QgYW5kIHJlLXNjYW4gdGhlIFFSQ29kZS5cIixcbiAgICAgICAgXCJESVNDT05ORUNUXCI6IFwiRGlzY29ubmVjdFwiXG4gICAgfSxcbiAgICBcIlNFTEVDVF9NT0RBTFwiOiB7XG4gICAgICAgIFwiQ1JZUFRPX1RBS0VfQ09OVFJPTF9URVhUXCI6IFwiVGFrZSBjb250cm9sIG9mIHlvdXIgY3J5cHRvIGFuZCBleHBsb3JlIHRoZSBibG9ja2NoYWluIHdpdGggdGhlIHdhbGxldCB0cnVzdGVkIGJ5IG92ZXIgMzAgbWlsbGlvbiBwZW9wbGUgd29ybGR3aWRlXCJcbiAgICB9LFxuICAgIFwiTUVUQV9NQVNLX01PREFMXCI6IHtcbiAgICAgICAgXCJBRERSRVNTX0NPUElFRFwiOiBcIkFkZHJlc3MgY29waWVkIHRvIGNsaXBib2FyZCFcIixcbiAgICAgICAgXCJESVNDT05ORUNUXCI6IFwiRGlzY29ubmVjdFwiLFxuICAgICAgICBcIkFDVElWRV9ORVRXT1JLXCI6IFwiQWN0aXZlIE5ldHdvcmtcIlxuICAgIH1cbn07XG5jbGFzcyBTaW1wbGVJMThuIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLnRyYW5zbGF0aW9ucyA9IGRlZmF1bHRUcmFuc2xhdGlvbnM7XG4gICAgICAgIHRoaXMuc3VwcG9ydGVkTG9jYWxlcyA9IFsnZXMnLCAnZnInLCAnaGUnLCAnaXQnLCAncHQnLCAndHInXTtcbiAgICAgICAgdGhpcy5iYXNlVXJsID0gKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmJhc2VVcmwpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vTWV0YU1hc2svbWV0YW1hc2stc2RrL3JlZnMvaGVhZHMvZ2gtcGFnZXMvbG9jYWxlcyc7XG4gICAgfVxuICAgIGdldEJyb3dzZXJMYW5ndWFnZSgpIHtcbiAgICAgICAgLy8gR2V0IGFsbCBicm93c2VyIGxhbmd1YWdlcyBpbiBvcmRlciBvZiBwcmVmZXJlbmNlXG4gICAgICAgIGNvbnN0IGJyb3dzZXJMYW5ndWFnZXMgPSBuYXZpZ2F0b3IubGFuZ3VhZ2VzIHx8IFtuYXZpZ2F0b3IubGFuZ3VhZ2VdO1xuICAgICAgICAvLyBDaGVjayBpZiBFbmdsaXNoIGlzIG9uZSBvZiB0aGUgcHJlZmVycmVkIGxhbmd1YWdlc1xuICAgICAgICBjb25zdCBoYXNFbmdsaXNoID0gYnJvd3Nlckxhbmd1YWdlcy5zb21lKGxhbmcgPT4gbGFuZy50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2VuJykpO1xuICAgICAgICAvLyBJZiB1c2VyIHVuZGVyc3RhbmRzIEVuZ2xpc2gsIHVzZSBpdFxuICAgICAgICBpZiAoaGFzRW5nbGlzaCkge1xuICAgICAgICAgICAgcmV0dXJuICdlbic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBjaGVjayBmb3Igb3RoZXIgc3VwcG9ydGVkIGxhbmd1YWdlc1xuICAgICAgICBjb25zdCBwcmltYXJ5TGFuZyA9IG5hdmlnYXRvci5sYW5ndWFnZTtcbiAgICAgICAgY29uc3Qgc2hvcnRMYW5nID0gcHJpbWFyeUxhbmcudG9Mb3dlckNhc2UoKS5zcGxpdCgnLScpWzBdO1xuICAgICAgICBpZiAodGhpcy5zdXBwb3J0ZWRMb2NhbGVzLmluY2x1ZGVzKHNob3J0TGFuZykpIHtcbiAgICAgICAgICAgIHJldHVybiBzaG9ydExhbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICdlbic7XG4gICAgfVxuICAgIGFzeW5jIGluaXQoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGJyb3dzZXJMYW5nID0gdGhpcy5nZXRCcm93c2VyTGFuZ3VhZ2UoKTtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gYnJvd3NlckxhbmcgfHwgY29uZmlnLmZhbGxiYWNrTG5nO1xuICAgICAgICBhd2FpdCB0aGlzLmxvYWRUcmFuc2xhdGlvbnMobG9jYWxlKTtcbiAgICB9XG4gICAgYXN5bmMgbG9hZFRyYW5zbGF0aW9ucyhsb2NhbGUpIHtcbiAgICAgICAgY29uc3Qgc2hvcnRMb2NhbGUgPSBsb2NhbGUuc3BsaXQoJy0nKVswXTtcbiAgICAgICAgaWYgKHNob3J0TG9jYWxlID09PSAnZW4nIHx8ICF0aGlzLnN1cHBvcnRlZExvY2FsZXMuaW5jbHVkZXMoc2hvcnRMb2NhbGUpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zbGF0aW9ucyA9IGRlZmF1bHRUcmFuc2xhdGlvbnM7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYmFzZVVybH0vJHtzaG9ydExvY2FsZX0uanNvbmA7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNsYXRpb25zID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGDinYwgRmFpbGVkIHRvIGxvYWQgJHtzaG9ydExvY2FsZX0gdHJhbnNsYXRpb25zLCBmYWxsaW5nIGJhY2sgdG8gRW5nbGlzaDpgLCBlcnJvcik7XG4gICAgICAgICAgICB0aGlzLnRyYW5zbGF0aW9ucyA9IGRlZmF1bHRUcmFuc2xhdGlvbnM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmVzdGVkVHJhbnNsYXRpb24oa2V5LCB0aGlzLnRyYW5zbGF0aW9ucykgfHwga2V5O1xuICAgIH1cbiAgICBnZXROZXN0ZWRUcmFuc2xhdGlvbihrZXksIGRpY3QpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBkaWN0O1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycmVudCAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbcGFydF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjdXJyZW50ID09PSAnc3RyaW5nJyA/IGN1cnJlbnQgOiAnJztcbiAgICB9XG59XG5cbnZhciBUcmFja2luZ0V2ZW50cztcbihmdW5jdGlvbiAoVHJhY2tpbmdFdmVudHMpIHtcbiAgICBUcmFja2luZ0V2ZW50c1tcIlNES19NT0RBTF9WSUVXRURcIl0gPSBcInNka19tb2RhbF92aWV3ZWRcIjtcbiAgICBUcmFja2luZ0V2ZW50c1tcIlNES19NT0RBTF9CVVRUT05fQ0xJQ0tFRFwiXSA9IFwic2RrX21vZGFsX2J1dHRvbl9jbGlja2VkXCI7XG4gICAgVHJhY2tpbmdFdmVudHNbXCJTREtfTU9EQUxfVE9HR0xFX0NIQU5HRURcIl0gPSBcInNka19tb2RhbF90b2dnbGVfY2hhbmdlZFwiO1xufSkoVHJhY2tpbmdFdmVudHMgfHwgKFRyYWNraW5nRXZlbnRzID0ge30pKTtcblxuY29uc3Qgc3R5bGVDc3MkMiA9IFwiLmZsZXhDb250YWluZXIge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG59XFxuXFxuLmZsZXhJdGVtIHtcXG4gICAgZmxleDogMTtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5mbGV4SXRlbTExIHtcXG4gICAgZmxleDogMTE7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4uZmxleEl0ZW0xIHtcXG4gICAgZmxleDogMTtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi50YWIge1xcbiAgICBwYWRkaW5nOiA4cHg7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0YyRjRGNjtcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGNvbG9yOiAjMjQyOTJFO1xcbn1cXG5cXG4udGFiY29udGFpbmVyIHtcXG4gICAgcGFkZGluZzogNHB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjJGNEY2O1xcbiAgICBib3JkZXItcmFkaXVzOiA4cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDMwcHg7XFxuICAgIG1hcmdpbi10b3A6IDMwcHg7XFxufVxcblxcbi50YWJhY3RpdmUge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDMwMG1zIGxpbmVhcjtcXG4gICAgLW1zLXRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMzAwbXMgbGluZWFyO1xcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDMwMG1zIGxpbmVhcjtcXG4gICAgYm9yZGVyLXJhZGl1czogOHB4O1xcbn1cXG5cXG4uaXRlbSB7XFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMTZweDtcXG4gICAgYm9yZGVyLXJhZGl1czogOHB4O1xcbiAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICBib3JkZXI6IDJweCAjRjJGNEY2IHNvbGlkO1xcbiAgICBjb2xvcjogIzI0MjkyRTtcXG59XFxuXFxuLmV4dGVuc2lvbkxhYmVsIHtcXG4gICAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgICBmb250LXdlaWdodDogYm9sZDtcXG4gICAgZm9udC1zaXplOiAxNHB4O1xcbiAgICB0ZXh0LWFsaWduOiBjZXRuZXI7XFxuICAgIGNvbG9yOiAjMjQyNzJBO1xcbn1cXG5cXG4ubm90aWNlIHtcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICBtYXJnaW4tbGVmdDogMTBweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxMHB4O1xcbiAgICBjb2xvcjogZ3JleTtcXG59XFxuXFxuLmJ1dHRvbiB7XFxuICAgIG1hcmdpbi10b3A6IDQxLjVweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMjBweDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBwYWRkaW5nOiAxMnB4IDIwcHg7XFxuICAgIGJhY2tncm91bmQ6ICMwMzdERDY7XFxuICAgIGJvcmRlci1yYWRpdXM6IDMycHg7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG4gICAgYm9yZGVyOiAwO1xcbiAgICBmb250LXNpemU6IDE0cHg7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLmJhY2tkcm9wIHtcXG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBib3R0b206IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICB6LWluZGV4OiA5OTk5ODtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjg3KTtcXG4gICAgb3BhY2l0eTogMC4zO1xcbn1cXG5cXG4ubW9kYWwge1xcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGxlZnQ6IDUwJTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICAgIHotaW5kZXg6IDk5OTk5O1xcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG4gICAgcGFkZGluZzogMjBweDtcXG4gICAgYm9yZGVyLXJhZGl1czogOHB4O1xcbiAgICB0b3A6IDUwJTtcXG4gICAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgICB3aWR0aDogNDYwcHg7XFxuICAgIG1pbi13aWR0aDogMzAwcHg7XFxuICAgIGJveC1zaGFkb3c6IHJnYmEoMCwgMCwgMCwgMC4yKSAwcHggMTFweCAxNXB4IC03cHgsIHJnYmEoMCwgMCwgMCwgMC4xNCkgMHB4IDI0cHggMzhweCAzcHgsIHJnYmEoMCwgMCwgMCwgMC4xMikgMHB4IDlweCA0NnB4IDhweDtcXG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XFxufVxcblxcbi5jbG9zZUJ1dHRvbiB7XFxuICAgIGNvbG9yOiAjQkJDMEM1O1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5sb2dvQ29udGFpbmVyIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDI0cHg7XFxuICAgIG1hcmdpbi1yaWdodDogMjRweDtcXG4gICAgbWFyZ2luLXRvcDogMjRweDtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcblxcbi5jb25uZWN0TW9iaWxlVGV4dCB7XFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgY29sb3I6IGJsYWNrO1xcbiAgICBtYXJnaW4tdG9wOiAyOHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAyOHB4O1xcbiAgICBsaW5lLWhlaWdodDogMjtcXG59XFxuXFxuLmJsdWUge1xcbiAgICBjb2xvcjogIzAzN0RENjtcXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcXG59XFxuXFxuLmluc3RhbGxFeHRlbnNpb25UZXh0IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDEwcHg7XFxufVxcblxcbi5jZW50ZXIge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLnJpZ2h0IHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiByaWdodDtcXG59XFxuXFxuI3Nkay1tbS1xcmNvZGUge1xcbiAgICBzdmcge1xcbiAgICAgICAgd2lkdGg6IDUwJTtcXG4gICAgfVxcbn1cIjtcbmNvbnN0IE1tSW5zdGFsbE1vZGFsU3R5bGUwID0gc3R5bGVDc3MkMjtcblxuY29uc3QgSW5zdGFsbE1vZGFsID0gY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKGhvc3RSZWYpIHtcbiAgICAgICAgcmVnaXN0ZXJJbnN0YW5jZSh0aGlzLCBob3N0UmVmKTtcbiAgICAgICAgdGhpcy5jbG9zZSA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiY2xvc2VcIiwgNyk7XG4gICAgICAgIHRoaXMuc3RhcnREZXNrdG9wT25ib2FyZGluZyA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwic3RhcnREZXNrdG9wT25ib2FyZGluZ1wiLCA3KTtcbiAgICAgICAgdGhpcy50cmFja0FuYWx5dGljcyA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwidHJhY2tBbmFseXRpY3NcIiwgNyk7XG4gICAgICAgIHRoaXMubGluayA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zZGtWZXJzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnByZWZlckRlc2t0b3AgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudGFiID0gMTtcbiAgICAgICAgdGhpcy5pc0RlZmF1bHRUYWIgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyYW5zbGF0aW9uc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uQ2xvc2UgPSB0aGlzLm9uQ2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vblN0YXJ0RGVza3RvcE9uYm9hcmRpbmdIYW5kbGVyID0gdGhpcy5vblN0YXJ0RGVza3RvcE9uYm9hcmRpbmdIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2V0VGFiID0gdGhpcy5zZXRUYWIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZW5kZXIgPSB0aGlzLnJlbmRlci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNldFRhYih0aGlzLnByZWZlckRlc2t0b3AgPyAxIDogMik7XG4gICAgICAgIHRoaXMuaTE4bkluc3RhbmNlID0gbmV3IFNpbXBsZUkxOG4oKTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTG9hZCgpIHtcbiAgICAgICAgdGhpcy50cmFja0FuYWx5dGljcy5lbWl0KHtcbiAgICAgICAgICAgIGV2ZW50OiBUcmFja2luZ0V2ZW50cy5TREtfTU9EQUxfVklFV0VELFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uSW5zdGFsbGVkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0YWI6IHRoaXMudGFiID09PSAxID8gJ2Rlc2t0b3AnIDogJ21vYmlsZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaTE4bkluc3RhbmNlLmluaXQoe1xuICAgICAgICAgICAgZmFsbGJhY2tMbmc6ICdlbidcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNsYXRpb25zTG9hZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdXBkYXRlUHJlZmVyRGVza3RvcChuZXdWYWx1ZSkge1xuICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VGFiKDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRUYWIoMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25DbG9zZShzaG91bGRUZXJtaW5hdGUgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmNsb3NlLmVtaXQoeyBzaG91bGRUZXJtaW5hdGUgfSk7XG4gICAgfVxuICAgIG9uU3RhcnREZXNrdG9wT25ib2FyZGluZ0hhbmRsZXIoKSB7XG4gICAgICAgIHRoaXMudHJhY2tBbmFseXRpY3MuZW1pdCh7XG4gICAgICAgICAgICBldmVudDogVHJhY2tpbmdFdmVudHMuU0RLX01PREFMX0JVVFRPTl9DTElDS0VELFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgYnV0dG9uX3R5cGU6ICdpbnN0YWxsX2V4dGVuc2lvbicsXG4gICAgICAgICAgICAgICAgdGFiOiAnZGVza3RvcCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGFydERlc2t0b3BPbmJvYXJkaW5nLmVtaXQoKTtcbiAgICB9XG4gICAgc2V0VGFiKG5ld1RhYiwgaXNVc2VyQWN0aW9uID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGlzVXNlckFjdGlvbikge1xuICAgICAgICAgICAgdGhpcy50cmFja0FuYWx5dGljcy5lbWl0KHtcbiAgICAgICAgICAgICAgICBldmVudDogVHJhY2tpbmdFdmVudHMuU0RLX01PREFMX1RPR0dMRV9DSEFOR0VELFxuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICB0b2dnbGU6IHRoaXMudGFiID09PSAxID8gJ2Rlc2t0b3BfdG9fbW9iaWxlJyA6ICdtb2JpbGVfdG9fZGVza3RvcCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGFiID0gbmV3VGFiO1xuICAgICAgICB0aGlzLmlzRGVmYXVsdFRhYiA9IGZhbHNlO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy50cmFuc2xhdGlvbnNMb2FkZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBvciBhIGxvYWRpbmcgc3RhdGVcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ID0gKGtleSkgPT4gdGhpcy5pMThuSW5zdGFuY2UudChrZXkpO1xuICAgICAgICBjb25zdCBjdXJyZW50VGFiID0gdGhpcy5pc0RlZmF1bHRUYWIgPyB0aGlzLnByZWZlckRlc2t0b3AgPyAxIDogMiA6IHRoaXMudGFiO1xuICAgICAgICBjb25zdCBzdmdFbGVtZW50ID0gZW5jb2RlUVIodGhpcy5saW5rLCBcInN2Z1wiLCB7XG4gICAgICAgICAgICBlY2M6IFwibWVkaXVtXCIsXG4gICAgICAgICAgICBzY2FsZTogMlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChoKFdpZGdldFdyYXBwZXIsIHsgY2xhc3NOYW1lOiBcImluc3RhbGwtbW9kZWxcIiB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6ICdiYWNrZHJvcCcsIG9uQ2xpY2s6ICgpID0+IHRoaXMub25DbG9zZSh0cnVlKSB9KSwgaChcImRpdlwiLCB7IGNsYXNzOiAnbW9kYWwnIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogJ2Nsb3NlQnV0dG9uQ29udGFpbmVyJyB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6ICdyaWdodCcgfSwgaChcInNwYW5cIiwgeyBjbGFzczogJ2Nsb3NlQnV0dG9uJywgb25DbGljazogKCkgPT4gdGhpcy5vbkNsb3NlKHRydWUpIH0sIGgoQ2xvc2VCdXR0b24sIG51bGwpKSkpLCBoKFwiZGl2XCIsIHsgY2xhc3M6ICdsb2dvQ29udGFpbmVyJyB9LCBoKExvZ28sIG51bGwpKSwgaChcImRpdlwiLCBudWxsLCBoKFwiZGl2XCIsIHsgY2xhc3M6ICd0YWJjb250YWluZXInIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogJ2ZsZXhDb250YWluZXInIH0sIGgoXCJkaXZcIiwgeyBvbkNsaWNrOiAoKSA9PiB0aGlzLnNldFRhYigxLCB0cnVlKSwgY2xhc3M6IGB0YWIgZmxleEl0ZW0gJHtjdXJyZW50VGFiID09PSAxID8gJ3RhYmFjdGl2ZScgOiAnJ31gIH0sIHQoJ0RFU0tUT1AnKSksIGgoXCJkaXZcIiwgeyBvbkNsaWNrOiAoKSA9PiB0aGlzLnNldFRhYigyLCB0cnVlKSwgY2xhc3M6IGB0YWIgZmxleEl0ZW0gJHtjdXJyZW50VGFiID09PSAyID8gJ3RhYmFjdGl2ZScgOiAnJ31gIH0sIHQoJ01PQklMRScpKSkpLCBoKFwiZGl2XCIsIHsgc3R5bGU6IHsgZGlzcGxheTogY3VycmVudFRhYiA9PT0gMSA/ICdub25lJyA6ICdibG9jaycgfSB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6ICdmbGV4Q29udGFpbmVyJyB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6ICdmbGV4SXRlbScsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6ICc0JyxcbiAgICAgICAgICAgIH0gfSwgc3ZnRWxlbWVudCAmJiAoaChcImRpdlwiLCB7IGlkOiBcInNkay1tbS1xcmNvZGVcIiwgY2xhc3M6ICdjZW50ZXInLCBpbm5lckhUTUw6IHN2Z0VsZW1lbnQgfSkpLCBoKFwiZGl2XCIsIHsgY2xhc3M6ICdjb25uZWN0TW9iaWxlVGV4dCcgfSwgdCgnU0NBTl9UT19DT05ORUNUJyksIFwiIFwiLCBoKFwiYnJcIiwgbnVsbCksIGgoXCJzcGFuXCIsIHsgY2xhc3M6ICdibHVlJyB9LCBoKFwiYlwiLCBudWxsLCB0KCdNRVRBX01BU0tfTU9CSUxFX0FQUCcpKSkpKSkpLCBoKFwiZGl2XCIsIHsgc3R5bGU6IHsgZGlzcGxheTogY3VycmVudFRhYiA9PT0gMiA/ICdub25lJyA6ICdibG9jaycgfSB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6ICdpdGVtJyB9LCBoKEFkdmFudGFnZXNMaXN0SXRlbSwgeyBJY29uOiBIZWFydEljb24sIHRleHQ6IHQoJ0lOU1RBTExfTU9EQUwuVFJVU1RFRF9CWV9VU0VSUycpIH0pKSwgaChcImRpdlwiLCB7IGNsYXNzOiAnaXRlbScgfSwgaChBZHZhbnRhZ2VzTGlzdEl0ZW0sIHsgSWNvbjogTG9ja0ljb24sIHRleHQ6IHQoJ0lOU1RBTExfTU9EQUwuTEVBRElOR19DUllQVE9fV0FMTEVUJykgfSkpLCBoKFwiZGl2XCIsIHsgY2xhc3M6ICdpdGVtJyB9LCBoKEFkdmFudGFnZXNMaXN0SXRlbSwgeyBJY29uOiBXYWxsZXRJY29uLCB0ZXh0OiB0KCdJTlNUQUxMX01PREFMLkNPTlRST0xfRElHSVRBTF9JTlRFUkFDVElPTlMnKSB9KSksIGgoXCJidXR0b25cIiwgeyBjbGFzczogJ2J1dHRvbicsIG9uQ2xpY2s6ICgpID0+IHRoaXMub25TdGFydERlc2t0b3BPbmJvYXJkaW5nSGFuZGxlcigpIH0sIGgoSW5zdGFsbEljb24sIG51bGwpLCBoKFwic3BhblwiLCB7IGNsYXNzOiAnaW5zdGFsbEV4dGVuc2lvblRleHQnIH0sIHQoJ0lOU1RBTExfTU9EQUwuSU5TVEFMTF9NRVRBX01BU0tfRVhURU5TSU9OJykpKSkpLCBoKFNES1ZlcnNpb24sIHsgdmVyc2lvbjogdGhpcy5zZGtWZXJzaW9uIH0pKSkpO1xuICAgIH1cbiAgICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG4gICAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICAgICAgXCJwcmVmZXJEZXNrdG9wXCI6IFtcInVwZGF0ZVByZWZlckRlc2t0b3BcIl1cbiAgICB9OyB9XG59O1xuSW5zdGFsbE1vZGFsLnN0eWxlID0gTW1JbnN0YWxsTW9kYWxTdHlsZTA7XG5cbmNvbnN0IHN0eWxlQ3NzJDEgPSBcIi5mbGV4Q29udGFpbmVyIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxufVxcblxcbi5mbGV4SXRlbSB7XFxuICAgIGZsZXg6IDE7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4uZmxleEl0ZW0xMSB7XFxuICAgIGZsZXg6IDExO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLmZsZXhJdGVtMSB7XFxuICAgIGZsZXg6IDE7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4udGFiIHtcXG4gICAgcGFkZGluZzogOHB4O1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgIGJhY2tncm91bmQtY29sb3I6ICNGMkY0RjY7XFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgICBjb2xvcjogIzI0MjkyRTtcXG59XFxuXFxuLnRhYmNvbnRhaW5lciB7XFxuICAgIHBhZGRpbmc6IDRweDtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0YyRjRGNjtcXG4gICAgYm9yZGVyLXJhZGl1czogOHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAzMHB4O1xcbiAgICBtYXJnaW4tdG9wOiAzMHB4O1xcbn1cXG5cXG4udGFiYWN0aXZlIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxuICAgIC13ZWJraXQtdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAzMDBtcyBsaW5lYXI7XFxuICAgIC1tcy10cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDMwMG1zIGxpbmVhcjtcXG4gICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAzMDBtcyBsaW5lYXI7XFxuICAgIGJvcmRlci1yYWRpdXM6IDhweDtcXG59XFxuXFxuLml0ZW0ge1xcbiAgICBmb250LXNpemU6IDEycHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDhweDtcXG4gICAgcGFkZGluZzogMTBweDtcXG4gICAgYm9yZGVyOiAycHggI0YyRjRGNiBzb2xpZDtcXG4gICAgY29sb3I6ICMyNDI5MkU7XFxufVxcblxcbi5leHRlbnNpb25MYWJlbCB7XFxuICAgIGZvbnQtc3R5bGU6IG5vcm1hbDtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgdGV4dC1hbGlnbjogY2V0bmVyO1xcbiAgICBjb2xvcjogIzI0MjcyQTtcXG59XFxuXFxuLm5vdGljZSB7XFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgbWFyZ2luLWxlZnQ6IDEwcHg7XFxuICAgIG1hcmdpbi1yaWdodDogMTBweDtcXG4gICAgY29sb3I6IGdyZXk7XFxufVxcblxcbi5idXR0b24ge1xcbiAgICBtYXJnaW4tdG9wOiA0MS41cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDIwcHg7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgcGFkZGluZzogMTJweCAyMHB4O1xcbiAgICBiYWNrZ3JvdW5kOiAjMDM3REQ2O1xcbiAgICBib3JkZXItcmFkaXVzOiAzMnB4O1xcbiAgICBjb2xvcjogd2hpdGU7XFxuICAgIGJvcmRlcjogMDtcXG4gICAgZm9udC1zaXplOiAxNHB4O1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5iYWNrZHJvcCB7XFxuICAgIHZpc2liaWxpdHk6IHZpc2libGU7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgdG9wOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICByaWdodDogMDtcXG4gICAgYm90dG9tOiAwO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgei1pbmRleDogOTk5OTg7XFxuICAgIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC44Nyk7XFxuICAgIG9wYWNpdHk6IDAuMztcXG59XFxuXFxuLm1vZGFsIHtcXG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICBsZWZ0OiA1MCU7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbiAgICB6LWluZGV4OiA5OTk5OTtcXG4gICAgYmFja2dyb3VuZDogd2hpdGU7XFxuICAgIHBhZGRpbmc6IDIwcHg7XFxuICAgIGJvcmRlci1yYWRpdXM6IDhweDtcXG4gICAgdG9wOiA1MCU7XFxuICAgIG1heC13aWR0aDogMTAwJTtcXG4gICAgd2lkdGg6IDQ2MHB4O1xcbiAgICBtaW4td2lkdGg6IDMwMHB4O1xcbiAgICBib3gtc2hhZG93OiByZ2JhKDAsIDAsIDAsIDAuMikgMHB4IDExcHggMTVweCAtN3B4LCByZ2JhKDAsIDAsIDAsIDAuMTQpIDBweCAyNHB4IDM4cHggM3B4LCByZ2JhKDAsIDAsIDAsIDAuMTIpIDBweCA5cHggNDZweCA4cHg7XFxuICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xcbn1cXG5cXG4uY2xvc2VCdXR0b24ge1xcbiAgICBjb2xvcjogI0JCQzBDNTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4ubG9nb0NvbnRhaW5lciB7XFxuICAgIG1hcmdpbi1sZWZ0OiAyNHB4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IDI0cHg7XFxuICAgIG1hcmdpbi10b3A6IDI0cHg7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbn1cXG5cXG4uY29ubmVjdE1vYmlsZVRleHQge1xcbiAgICBmb250LXNpemU6IDE0cHg7XFxuICAgIGNvbG9yOiBibGFjaztcXG4gICAgbWFyZ2luLXRvcDogMjhweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMjhweDtcXG4gICAgbGluZS1oZWlnaHQ6IDI7XFxufVxcblxcbi5ibHVlIHtcXG4gICAgY29sb3I6ICMwMzdERDY7XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxufVxcblxcbi5pbnN0YWxsRXh0ZW5zaW9uVGV4dCB7XFxuICAgIG1hcmdpbi1sZWZ0OiAxMHB4O1xcbn1cXG5cXG4uY2VudGVyIHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5yaWdodCB7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogcmlnaHQ7XFxufVxcblxcbiNzZGstbW0tcXJjb2RlIHtcXG4gICAgc3ZnIHtcXG4gICAgICAgIHdpZHRoOiA1MCU7XFxuICAgIH1cXG59XCI7XG5jb25zdCBNbVBlbmRpbmdNb2RhbFN0eWxlMCA9IHN0eWxlQ3NzJDE7XG5cbmNvbnN0IFBlbmRpbmdNb2RhbCA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcihob3N0UmVmKSB7XG4gICAgICAgIHJlZ2lzdGVySW5zdGFuY2UodGhpcywgaG9zdFJlZik7XG4gICAgICAgIHRoaXMuY2xvc2UgPSBjcmVhdGVFdmVudCh0aGlzLCBcImNsb3NlXCIsIDcpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QgPSBjcmVhdGVFdmVudCh0aGlzLCBcImRpc2Nvbm5lY3RcIiwgNyk7XG4gICAgICAgIHRoaXMudXBkYXRlT1RQVmFsdWUgPSBjcmVhdGVFdmVudCh0aGlzLCBcInVwZGF0ZU9UUFZhbHVlXCIsIDcpO1xuICAgICAgICB0aGlzLmRpc3BsYXlPVFAgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc2RrVmVyc2lvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5vdHBDb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRyYW5zbGF0aW9uc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmkxOG5JbnN0YW5jZSA9IG5ldyBTaW1wbGVJMThuKCk7XG4gICAgfVxuICAgIGFzeW5jIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmkxOG5JbnN0YW5jZS5pbml0KHtcbiAgICAgICAgICAgIGZhbGxiYWNrTG5nOiAnZW4nXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyYW5zbGF0aW9uc0xvYWRlZCA9IHRydWU7XG4gICAgfVxuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2UuZW1pdCgpO1xuICAgIH1cbiAgICBvbkRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdC5lbWl0KCk7XG4gICAgfVxuICAgIG9uVXBkYXRlT1RQVmFsdWVIYW5kbGVyKG90cFZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlT1RQVmFsdWUuZW1pdCh7XG4gICAgICAgICAgICBvdHBWYWx1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy50cmFuc2xhdGlvbnNMb2FkZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc3BsYXlPVFAgPSAoX2EgPSB0aGlzLmRpc3BsYXlPVFApICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XG4gICAgICAgIGNvbnN0IHNka1ZlcnNpb24gPSB0aGlzLnNka1ZlcnNpb247XG4gICAgICAgIGNvbnN0IHQgPSAoa2V5KSA9PiB0aGlzLmkxOG5JbnN0YW5jZS50KGtleSk7XG4gICAgICAgIHJldHVybiAoaChXaWRnZXRXcmFwcGVyLCB7IGNsYXNzTmFtZTogXCJwZW5kaW5nLW1vZGFsXCIgfSwgaChcImRpdlwiLCB7IGNsYXNzOiAnYmFja2Ryb3AnLCBvbkNsaWNrOiAoKSA9PiB0aGlzLm9uQ2xvc2UoKSB9KSwgaChcImRpdlwiLCB7IGNsYXNzOiAnbW9kYWwnIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogJ2Nsb3NlQnV0dG9uQ29udGFpbmVyJyB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6ICdyaWdodCcgfSwgaChcInNwYW5cIiwgeyBjbGFzczogJ2Nsb3NlQnV0dG9uJywgb25DbGljazogKCkgPT4gdGhpcy5vbkNsb3NlKCkgfSwgaChDbG9zZUJ1dHRvbiwgbnVsbCkpKSksIGgoXCJkaXZcIiwgeyBjbGFzczogJ2xvZ29Db250YWluZXInIH0sIGgoTG9nbywgbnVsbCkpLCBoKFwiZGl2XCIsIG51bGwsIGgoXCJkaXZcIiwgeyBjbGFzczogJ2ZsZXhDb250YWluZXInLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAnYmxhY2snLFxuICAgICAgICAgICAgfSB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6ICdmbGV4SXRlbScsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6ICczMHB4JyxcbiAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b206ICczMHB4JyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzE2cHgnLFxuICAgICAgICAgICAgfSB9LCBkaXNwbGF5T1RQXG4gICAgICAgICAgICA/IHQoJ1BFTkRJTkdfTU9EQUwuT1BFTl9NRVRBX01BU0tfU0VMRUNUX0NPREUnKVxuICAgICAgICAgICAgOiB0KCdQRU5ESU5HX01PREFMLk9QRU5fTUVUQV9NQVNLX0NPTlRJTlVFJykpLCBoKFwiZGl2XCIsIHsgaWQ6IFwic2RrLW1tLW90cC12YWx1ZVwiLCBzdHlsZTogeyBwYWRkaW5nOiAnMTBweCcsIGZvbnRTaXplOiAnMzJweCcsIGRpc3BsYXk6IHRoaXMub3RwQ29kZSA/ICdibG9jaycgOiAnbm9uZScgfSB9LCB0aGlzLm90cENvZGUpLCBkaXNwbGF5T1RQICYmIChoKFwiZGl2XCIsIHsgY2xhc3M6ICdub3RpY2UnIH0sIFwiKiBcIiwgdCgnUEVORElOR19NT0RBTC5OVU1CRVJfQUZURVJfT1BFTl9OT1RJQ0UnKSkpKSwgaChcImRpdlwiLCB7IHN0eWxlOiB7IG1hcmdpblRvcDogJzIwcHgnIH0gfSwgaChcImJ1dHRvblwiLCB7IGNsYXNzOiAnYnV0dG9uIGJsdWUnLCBzdHlsZToge1xuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogJzVweCcsXG4gICAgICAgICAgICAgICAgY29sb3I6ICcjMDM3NkM5JyxcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJyMwMzc2QzknLFxuICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAnMXB4JyxcbiAgICAgICAgICAgICAgICBib3JkZXJTdHlsZTogJ3NvbGlkJyxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgICB9LCBvbkNsaWNrOiAoKSA9PiB0aGlzLm9uRGlzY29ubmVjdCgpIH0sIHQoJ1BFTkRJTkdfTU9EQUwuRElTQ09OTkVDVCcpKSkpLCBoKFNES1ZlcnNpb24sIHsgdmVyc2lvbjogc2RrVmVyc2lvbiB9KSkpKTtcbiAgICB9XG4gICAgZ2V0IGVsKCkgeyByZXR1cm4gZ2V0RWxlbWVudCh0aGlzKTsgfVxufTtcblBlbmRpbmdNb2RhbC5zdHlsZSA9IE1tUGVuZGluZ01vZGFsU3R5bGUwO1xuXG5jb25zdCBDb25uZWN0SWNvbiA9ICgpID0+IChoKFwic3ZnXCIsIHsgd2lkdGg6IFwiMjFcIiwgaGVpZ2h0OiBcIjE1XCIsIHZpZXdCb3g6IFwiMCAwIDIxIDE1XCIsIGZpbGw6IFwibm9uZVwiLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIH0sXG4gICAgaChcInBhdGhcIiwgeyBkOiBcIk0xNC4xMzY0IDE0Ljk4NTFDMTMuNTkwOSAxNC45ODUxIDEzLjIyNzMgMTQuNTg1MSAxMy4yMjczIDEzLjk4NTFDMTMuMjI3MyAxMy4zODUxIDEzLjU5MDkgMTIuOTg1MSAxNC4xMzY0IDEyLjk4NTFDMTYuNjgxOCAxMi45ODUxIDE4LjY4MTggMTAuNzg1MSAxOC42ODE4IDcuOTg1MDhDMTguNjgxOCA1LjE4NTA4IDE2LjY4MTggMi45ODUwOCAxNC4xMzY0IDIuOTg1MDhDMTEuNTkwOSAyLjk4NTA4IDkuNTkwOTEgNS4xODUwOCA5LjU5MDkxIDcuOTg1MDhDOS41OTA5MSA4LjU4NTA4IDkuMjI3MjcgOC45ODUwOCA4LjY4MTgyIDguOTg1MDhDOC4xMzYzNiA4Ljk4NTA4IDcuNzcyNzMgOC41ODUwOCA3Ljc3MjczIDcuOTg1MDhDNy43NzI3MyA0LjA4NTA4IDEwLjU5MDkgMC45ODUwNzcgMTQuMTM2NCAwLjk4NTA3N0MxNy42ODE4IDAuOTg1MDc3IDIwLjUgNC4wODUwOCAyMC41IDcuOTg1MDhDMjAuNSAxMS44ODUxIDE3LjY4MTggMTQuOTg1MSAxNC4xMzY0IDE0Ljk4NTFaTTYuNjgxODIgMTQuNzg1MUMzLjIyNzI3IDE0Ljc4NTEgMC41IDExLjY4NTEgMC41IDcuOTg1MDhDMC41IDQuMjg1MDggMy4yMjcyNyAxLjE4NTA4IDYuNjgxODIgMS4xODUwOEM3LjIyNzI3IDEuMTg1MDggNy41OTA5MSAxLjU4NTA4IDcuNTkwOTEgMi4xODUwOEM3LjU5MDkxIDIuNzg1MDggNy4yMjcyNyAzLjE4NTA4IDYuNjgxODIgMy4xODUwOEM0LjIyNzI3IDMuMTg1MDggMi4zMTgxOCA1LjM4NTA4IDIuMzE4MTggNy45ODUwOEMyLjMxODE4IDEwLjU4NTEgNC4yMjcyNyAxMi43ODUxIDYuNjgxODIgMTIuNzg1MUM5LjEzNjM2IDEyLjc4NTEgMTEuMDQ1NSAxMC42ODUxIDExLjA0NTUgNy45ODUwOEMxMS4wNDU1IDcuMzg1MDggMTEuNDA5MSA2Ljk4NTA4IDExLjk1NDUgNi45ODUwOEMxMi41IDYuOTg1MDggMTIuODYzNiA3LjM4NTA4IDEyLjg2MzYgNy45ODUwOEMxMi43NzI3IDExLjY4NTEgMTAuMDQ1NSAxNC43ODUxIDYuNjgxODIgMTQuNzg1MVpcIiwgZmlsbDogXCJ3aGl0ZVwiIH0pKSk7XG5cbmNvbnN0IE1ldGFtYXNrRXh0ZW5zaW9uSW1hZ2UgPSAoKSA9PiAoaChcInN2Z1wiLCB7IHdpZHRoOiBcIjQwMFwiLCBoZWlnaHQ6IFwiMzAwXCIsIHZpZXdCb3g6IFwiMCAwIDQwMCAzMDBcIiwgZmlsbDogXCJub25lXCIsIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgfSxcbiAgICBoKFwicmVjdFwiLCB7IHdpZHRoOiBcIjQwMFwiLCBoZWlnaHQ6IFwiMzAwXCIsIGZpbGw6IFwid2hpdGVcIiB9KSxcbiAgICBoKFwicGF0aFwiLCB7IGQ6IFwiTTMwMC4xMTYgMjQyLjQ2TDI1MC40ODUgMjI3LjY4MUwyMTMuMDU3IDI1MC4wNTVMMTg2Ljk0NCAyNTAuMDQ1TDE0OS40OTMgMjI3LjY4MUw5OS44ODQzIDI0Mi40Nkw4NC43OTM5IDE5MS41MThMOTkuODg0MyAxMzQuOTc5TDg0Ljc5MzkgODcuMTc3N0w5OS44ODQzIDI3LjkzMzZMMTc3LjQwMiA3NC4yNDY2SDIyMi41OThMMzAwLjExNiAyNy45MzM2TDMxNS4yMDYgODcuMTc3N0wzMDAuMTE2IDEzNC45NzlMMzE1LjIwNiAxOTEuNTE4TDMwMC4xMTYgMjQyLjQ2WlwiLCBmaWxsOiBcIiNGRjVDMTZcIiB9KSxcbiAgICBoKFwicGF0aFwiLCB7IGQ6IFwiTTk5Ljg5NTUgMjcuOTMzNkwxNzcuNDE0IDc0LjI3OTJMMTc0LjMzMSAxMDYuMDg1TDk5Ljg5NTUgMjcuOTMzNlpcIiwgZmlsbDogXCIjRkY1QzE2XCIgfSksXG4gICAgaChcInBhdGhcIiwgeyBkOiBcIk0xNDkuNTA1IDE5MS41MzlMMTgzLjYxMiAyMTcuNTIxTDE0OS41MDUgMjI3LjY4MVYxOTEuNTM5WlwiLCBmaWxsOiBcIiNGRjVDMTZcIiB9KSxcbiAgICBoKFwicGF0aFwiLCB7IGQ6IFwiTTE4MC44ODYgMTQ4LjU4NUwxNzQuMzMgMTA2LjEwN0wxMzIuMzY5IDEzNC45OTFMMTMyLjM0OCAxMzQuOThWMTM1LjAwMUwxMzIuNDc3IDE2NC43MzJMMTQ5LjQ5MyAxNDguNTg1SDE0OS41MDRIMTgwLjg4NlpcIiwgZmlsbDogXCIjRkY1QzE2XCIgfSksXG4gICAgaChcInBhdGhcIiwgeyBkOiBcIk0zMDAuMTE2IDI3LjkzMzZMMjIyLjU5OCA3NC4yNzkyTDIyNS42NyAxMDYuMDg1TDMwMC4xMTYgMjcuOTMzNlpcIiwgZmlsbDogXCIjRkY1QzE2XCIgfSksXG4gICAgaChcInBhdGhcIiwgeyBkOiBcIk0yNTAuNTA4IDE5MS41MzlMMjE2LjQgMjE3LjUyMUwyNTAuNTA4IDIyNy42ODFWMTkxLjUzOVpcIiwgZmlsbDogXCIjRkY1QzE2XCIgfSksXG4gICAgaChcInBhdGhcIiwgeyBkOiBcIk0yNjcuNjUyIDEzNS4wMDFIMjY3LjY2M0gyNjcuNjUyVjEzNC45OEwyNjcuNjQxIDEzNC45OTFMMjI1LjY4IDEwNi4xMDdMMjE5LjEyNSAxNDguNTg1SDI1MC41MDdMMjY3LjUzMyAxNjQuNzMyTDI2Ny42NTIgMTM1LjAwMVpcIiwgZmlsbDogXCIjRkY1QzE2XCIgfSksXG4gICAgaChcInBhdGhcIiwgeyBkOiBcIk0xNDkuNDkzIDIyNy42ODFMOTkuODg0MyAyNDIuNDZMODQuNzkzOSAxOTEuNTRIMTQ5LjQ5M1YyMjcuNjgxWlwiLCBmaWxsOiBcIiNFMzQ4MDdcIiB9KSxcbiAgICBoKFwicGF0aFwiLCB7IGQ6IFwiTTE4MC44NzUgMTQ4LjU3NEwxOTAuMzUxIDIwOS45OEwxNzcuMjE5IDE3NS44MzhMMTMyLjQ1NiAxNjQuNzMyTDE0OS40ODMgMTQ4LjU3NEgxODAuODY0SDE4MC44NzVaXCIsIGZpbGw6IFwiI0UzNDgwN1wiIH0pLFxuICAgIGgoXCJwYXRoXCIsIHsgZDogXCJNMjUwLjUwNyAyMjcuNjgxTDMwMC4xMTYgMjQyLjQ2TDMxNS4yMDYgMTkxLjU0SDI1MC41MDdWMjI3LjY4MVpcIiwgZmlsbDogXCIjRTM0ODA3XCIgfSksXG4gICAgaChcInBhdGhcIiwgeyBkOiBcIk0yMTkuMTI2IDE0OC41NzRMMjA5LjY0OSAyMDkuOThMMjIyLjc4MiAxNzUuODM4TDI2Ny41NDUgMTY0LjczMkwyNTAuNTA3IDE0OC41NzRIMjE5LjEyNlpcIiwgZmlsbDogXCIjRTM0ODA3XCIgfSksXG4gICAgaChcInBhdGhcIiwgeyBkOiBcIk04NC43OTM5IDE5MS41MTdMOTkuODg0MyAxMzQuOTc5SDEzMi4zMzdMMTMyLjQ1NiAxNjQuNzIxTDE3Ny4yMTkgMTc1LjgyNkwxOTAuMzUxIDIwOS45NjlMMTgzLjYwMSAyMTcuNDg4TDE0OS40OTMgMTkxLjUwNkg4NC43OTM5VjE5MS41MTdaXCIsIGZpbGw6IFwiI0ZGOEQ1RFwiIH0pLFxuICAgIGgoXCJwYXRoXCIsIHsgZDogXCJNMzE1LjIwNiAxOTEuNTE3TDMwMC4xMTYgMTM0Ljk3OUgyNjcuNjY0TDI2Ny41NDUgMTY0LjcyMUwyMjIuNzgyIDE3NS44MjZMMjA5LjY0OSAyMDkuOTY5TDIxNi40IDIxNy40ODhMMjUwLjUwNyAxOTEuNTA2SDMxNS4yMDZWMTkxLjUxN1pcIiwgZmlsbDogXCIjRkY4RDVEXCIgfSksXG4gICAgaChcInBhdGhcIiwgeyBkOiBcIk0yMjIuNTk4IDc0LjI0NjZIMjAwSDE3Ny40MDJMMTc0LjMzIDEwNi4wNTNMMTkwLjM1MSAyMDkuOTM2SDIwOS42NDlMMjI1LjY4MSAxMDYuMDUzTDIyMi41OTggNzQuMjQ2NlpcIiwgZmlsbDogXCIjRkY4RDVEXCIgfSksXG4gICAgaChcInBhdGhcIiwgeyBkOiBcIk05OS44ODQzIDI3LjkzMzZMODQuNzkzOSA4Ny4xNzc3TDk5Ljg4NDMgMTM0Ljk3OUgxMzIuMzM3TDE3NC4zMTkgMTA2LjA4NUw5OS44ODQzIDI3LjkzMzZaXCIsIGZpbGw6IFwiIzY2MTgwMFwiIH0pLFxuICAgIGgoXCJwYXRoXCIsIHsgZDogXCJNMTcxLjQ5NiAxNjAuOTA2SDE1Ni43OTVMMTQ4Ljc5IDE2OC43NTJMMTc3LjIyOSAxNzUuODA0TDE3MS40OTYgMTYwLjg5NlYxNjAuOTA2WlwiLCBmaWxsOiBcIiM2NjE4MDBcIiB9KSxcbiAgICBoKFwicGF0aFwiLCB7IGQ6IFwiTTMwMC4xMTYgMjcuOTMzNkwzMTUuMjA2IDg3LjE3NzdMMzAwLjExNiAxMzQuOTc5SDI2Ny42NjNMMjI1LjY4MSAxMDYuMDg1TDMwMC4xMTYgMjcuOTMzNlpcIiwgZmlsbDogXCIjNjYxODAwXCIgfSksXG4gICAgaChcInBhdGhcIiwgeyBkOiBcIk0yMjguNTI1IDE2MC45MDZIMjQzLjI0OEwyNTEuMjUzIDE2OC43NjNMMjIyLjc4MSAxNzUuODI2TDIyOC41MjUgMTYwLjg5NlYxNjAuOTA2WlwiLCBmaWxsOiBcIiM2NjE4MDBcIiB9KSxcbiAgICBoKFwicGF0aFwiLCB7IGQ6IFwiTTIxMy4wNDYgMjI5Ljc4OUwyMTYuMzk5IDIxNy41MUwyMDkuNjQ5IDIwOS45OTFIMTkwLjM0TDE4My41OSAyMTcuNTFMMTg2Ljk0MyAyMjkuNzg5XCIsIGZpbGw6IFwiIzY2MTgwMFwiIH0pLFxuICAgIGgoXCJwYXRoXCIsIHsgZDogXCJNMjEzLjA0NyAyMjkuNzg5VjI1MC4wNjZIMTg2Ljk0NFYyMjkuNzg5SDIxMy4wNDdaXCIsIGZpbGw6IFwiI0MwQzRDRFwiIH0pLFxuICAgIGgoXCJwYXRoXCIsIHsgZDogXCJNMTQ5LjUwNCAyMjcuNjZMMTg2Ljk2NSAyNTAuMDU2VjIyOS43NzlMMTgzLjYxMSAyMTcuNUwxNDkuNTA0IDIyNy42NlpcIiwgZmlsbDogXCIjRTdFQkY2XCIgfSksXG4gICAgaChcInBhdGhcIiwgeyBkOiBcIk0yNTAuNTA2IDIyNy42NkwyMTMuMDQ1IDI1MC4wNTZWMjI5Ljc3OUwyMTYuMzk4IDIxNy41TDI1MC41MDYgMjI3LjY2WlwiLCBmaWxsOiBcIiNFN0VCRjZcIiB9KSkpO1xuXG5jb25zdCBzdHlsZUNzcyA9IFwiLmZsZXhDb250YWluZXIge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgZmxleC1kaXJlY3Rpb246IHJvdztcXG59XFxuXFxuLmZsZXhJdGVtIHtcXG4gICAgZmxleDogMTtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi5mbGV4SXRlbTExIHtcXG4gICAgZmxleDogMTE7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbn1cXG5cXG4uZmxleEl0ZW0xIHtcXG4gICAgZmxleDogMTtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxufVxcblxcbi50YWIge1xcbiAgICBwYWRkaW5nOiA4cHg7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0YyRjRGNjtcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICAgIGNvbG9yOiAjMjQyOTJFO1xcbn1cXG5cXG4udGFiY29udGFpbmVyIHtcXG4gICAgcGFkZGluZzogNHB4O1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjRjJGNEY2O1xcbiAgICBib3JkZXItcmFkaXVzOiA4cHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDMwcHg7XFxuICAgIG1hcmdpbi10b3A6IDMwcHg7XFxufVxcblxcbi50YWJhY3RpdmUge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gICAgLXdlYmtpdC10cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDMwMG1zIGxpbmVhcjtcXG4gICAgLW1zLXRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMzAwbXMgbGluZWFyO1xcbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDMwMG1zIGxpbmVhcjtcXG4gICAgYm9yZGVyLXJhZGl1czogOHB4O1xcbn1cXG5cXG4uaXRlbSB7XFxuICAgIGZvbnQtc2l6ZTogMTJweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMTZweDtcXG4gICAgYm9yZGVyLXJhZGl1czogOHB4O1xcbiAgICBwYWRkaW5nOiAxMHB4O1xcbiAgICBib3JkZXI6IDJweCAjRjJGNEY2IHNvbGlkO1xcbiAgICBjb2xvcjogIzI0MjkyRTtcXG59XFxuXFxuLmV4dGVuc2lvbkxhYmVsIHtcXG4gICAgZm9udC1zdHlsZTogbm9ybWFsO1xcbiAgICBmb250LXdlaWdodDogYm9sZDtcXG4gICAgZm9udC1zaXplOiAxNHB4O1xcbiAgICB0ZXh0LWFsaWduOiBjZXRuZXI7XFxuICAgIGNvbG9yOiAjMjQyNzJBO1xcbn1cXG5cXG4ubm90aWNlIHtcXG4gICAgZm9udC1zaXplOiAxMnB4O1xcbiAgICBtYXJnaW4tbGVmdDogMTBweDtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxMHB4O1xcbiAgICBjb2xvcjogZ3JleTtcXG59XFxuXFxuLmJ1dHRvbiB7XFxuICAgIG1hcmdpbi10b3A6IDQxLjVweDtcXG4gICAgbWFyZ2luLWJvdHRvbTogMjBweDtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBwYWRkaW5nOiAxMnB4IDIwcHg7XFxuICAgIGJhY2tncm91bmQ6ICMwMzdERDY7XFxuICAgIGJvcmRlci1yYWRpdXM6IDMycHg7XFxuICAgIGNvbG9yOiB3aGl0ZTtcXG4gICAgYm9yZGVyOiAwO1xcbiAgICBmb250LXNpemU6IDE0cHg7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLmJhY2tkcm9wIHtcXG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICB0b3A6IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBib3R0b206IDA7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICB6LWluZGV4OiA5OTk5ODtcXG4gICAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjg3KTtcXG4gICAgb3BhY2l0eTogMC4zO1xcbn1cXG5cXG4ubW9kYWwge1xcbiAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIGxlZnQ6IDUwJTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICAgIHotaW5kZXg6IDk5OTk5O1xcbiAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcXG4gICAgcGFkZGluZzogMjBweDtcXG4gICAgYm9yZGVyLXJhZGl1czogOHB4O1xcbiAgICB0b3A6IDUwJTtcXG4gICAgbWF4LXdpZHRoOiAxMDAlO1xcbiAgICB3aWR0aDogNDYwcHg7XFxuICAgIG1pbi13aWR0aDogMzAwcHg7XFxuICAgIGJveC1zaGFkb3c6IHJnYmEoMCwgMCwgMCwgMC4yKSAwcHggMTFweCAxNXB4IC03cHgsIHJnYmEoMCwgMCwgMCwgMC4xNCkgMHB4IDI0cHggMzhweCAzcHgsIHJnYmEoMCwgMCwgMCwgMC4xMikgMHB4IDlweCA0NnB4IDhweDtcXG4gICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XFxufVxcblxcbi5jbG9zZUJ1dHRvbiB7XFxuICAgIGNvbG9yOiAjQkJDMEM1O1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5sb2dvQ29udGFpbmVyIHtcXG4gICAgbWFyZ2luLWxlZnQ6IDI0cHg7XFxuICAgIG1hcmdpbi1yaWdodDogMjRweDtcXG4gICAgbWFyZ2luLXRvcDogMjRweDtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxufVxcblxcbi5jb25uZWN0TW9iaWxlVGV4dCB7XFxuICAgIGZvbnQtc2l6ZTogMTRweDtcXG4gICAgY29sb3I6IGJsYWNrO1xcbiAgICBtYXJnaW4tdG9wOiAyOHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAyOHB4O1xcbiAgICBsaW5lLWhlaWdodDogMjtcXG59XFxuXFxuLmJsdWUge1xcbiAgICBjb2xvcjogIzAzN0RENjtcXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcXG59XFxuXFxuLmluc3RhbGxFeHRlbnNpb25UZXh0IHtcXG4gICAgbWFyZ2luLWxlZnQ6IDEwcHg7XFxufVxcblxcbi5jZW50ZXIge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG59XFxuXFxuLnJpZ2h0IHtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAganVzdGlmeS1jb250ZW50OiByaWdodDtcXG59XFxuXFxuI3Nkay1tbS1xcmNvZGUge1xcbiAgICBzdmcge1xcbiAgICAgICAgd2lkdGg6IDUwJTtcXG4gICAgfVxcbn1cIjtcbmNvbnN0IE1tU2VsZWN0TW9kYWxTdHlsZTAgPSBzdHlsZUNzcztcblxuY29uc3QgU2VsZWN0TW9kYWwgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoaG9zdFJlZikge1xuICAgICAgICByZWdpc3Rlckluc3RhbmNlKHRoaXMsIGhvc3RSZWYpO1xuICAgICAgICB0aGlzLmNsb3NlID0gY3JlYXRlRXZlbnQodGhpcywgXCJjbG9zZVwiLCA3KTtcbiAgICAgICAgdGhpcy5jb25uZWN0V2l0aEV4dGVuc2lvbiA9IGNyZWF0ZUV2ZW50KHRoaXMsIFwiY29ubmVjdFdpdGhFeHRlbnNpb25cIiwgNyk7XG4gICAgICAgIHRoaXMubGluayA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zZGtWZXJzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnByZWZlckRlc2t0b3AgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudGFiID0gMTtcbiAgICAgICAgdGhpcy5pc0RlZmF1bHRUYWIgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyYW5zbGF0aW9uc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmkxOG5JbnN0YW5jZSA9IG5ldyBTaW1wbGVJMThuKCk7XG4gICAgICAgIHRoaXMuc2V0VGFiKHRoaXMucHJlZmVyRGVza3RvcCA/IDEgOiAyKTtcbiAgICB9XG4gICAgYXN5bmMgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaTE4bkluc3RhbmNlLmluaXQoe1xuICAgICAgICAgICAgZmFsbGJhY2tMbmc6ICdlbidcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNsYXRpb25zTG9hZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgb25DbG9zZShzaG91bGRUZXJtaW5hdGUgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmNsb3NlLmVtaXQoeyBzaG91bGRUZXJtaW5hdGUgfSk7XG4gICAgfVxuICAgIGNvbm5lY3RXaXRoRXh0ZW5zaW9uSGFuZGxlcigpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0V2l0aEV4dGVuc2lvbi5lbWl0KCk7XG4gICAgfVxuICAgIHNldFRhYih0YWIpIHtcbiAgICAgICAgdGhpcy50YWIgPSB0YWI7XG4gICAgICAgIHRoaXMuaXNEZWZhdWx0VGFiID0gZmFsc2U7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICB9XG4gICAgdXBkYXRlUHJlZmVyRGVza3RvcChuZXdWYWx1ZSkge1xuICAgICAgICBpZiAobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VGFiKDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRUYWIoMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAoIXRoaXMudHJhbnNsYXRpb25zTG9hZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ID0gKGtleSkgPT4gdGhpcy5pMThuSW5zdGFuY2UudChrZXkpO1xuICAgICAgICBjb25zdCBzZGtWZXJzaW9uID0gdGhpcy5zZGtWZXJzaW9uO1xuICAgICAgICBjb25zdCBjdXJyZW50VGFiID0gdGhpcy5pc0RlZmF1bHRUYWIgPyB0aGlzLnByZWZlckRlc2t0b3AgPyAxIDogMiA6IHRoaXMudGFiO1xuICAgICAgICBjb25zdCBzdmdFbGVtZW50ID0gZW5jb2RlUVIodGhpcy5saW5rLCBcInN2Z1wiLCB7XG4gICAgICAgICAgICBlY2M6IFwibWVkaXVtXCIsXG4gICAgICAgICAgICBzY2FsZTogMlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChoKFdpZGdldFdyYXBwZXIsIHsgY2xhc3NOYW1lOiBcInNlbGVjdC1tb2RhbFwiIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogJ2JhY2tkcm9wJywgb25DbGljazogKCkgPT4gdGhpcy5vbkNsb3NlKHRydWUpIH0pLCBoKFwiZGl2XCIsIHsgY2xhc3M6ICdtb2RhbCcgfSwgaChcImRpdlwiLCB7IGNsYXNzOiAnY2xvc2VCdXR0b25Db250YWluZXInIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogJ3JpZ2h0JyB9LCBoKFwic3BhblwiLCB7IGNsYXNzOiAnY2xvc2VCdXR0b24nLCBvbkNsaWNrOiAoKSA9PiB0aGlzLm9uQ2xvc2UodHJ1ZSkgfSwgaChDbG9zZUJ1dHRvbiwgbnVsbCkpKSksIGgoXCJkaXZcIiwgeyBjbGFzczogJ2xvZ29Db250YWluZXInIH0sIGgoTG9nbywgbnVsbCkpLCBoKFwiZGl2XCIsIG51bGwsIGgoXCJkaXZcIiwgeyBjbGFzczogJ3RhYmNvbnRhaW5lcicgfSwgaChcImRpdlwiLCB7IGNsYXNzOiAnZmxleENvbnRhaW5lcicgfSwgaChcImRpdlwiLCB7IG9uQ2xpY2s6ICgpID0+IHRoaXMuc2V0VGFiKDEpLCBjbGFzczogYHRhYiBmbGV4SXRlbSAke2N1cnJlbnRUYWIgPT09IDEgPyAndGFiYWN0aXZlJyA6ICcnfWAgfSwgdCgnREVTS1RPUCcpKSwgaChcImRpdlwiLCB7IG9uQ2xpY2s6ICgpID0+IHRoaXMuc2V0VGFiKDIpLCBjbGFzczogYHRhYiBmbGV4SXRlbSAke2N1cnJlbnRUYWIgPT09IDIgPyAndGFiYWN0aXZlJyA6ICcnfWAgfSwgdCgnTU9CSUxFJykpKSksIGgoXCJkaXZcIiwgeyBzdHlsZTogeyBkaXNwbGF5OiBjdXJyZW50VGFiID09PSAxID8gJ25vbmUnIDogJ2Jsb2NrJyB9IH0sIGgoXCJkaXZcIiwgeyBjbGFzczogJ2ZsZXhDb250YWluZXInIH0sIGgoXCJkaXZcIiwgeyBjbGFzczogJ2ZsZXhJdGVtJywgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogJzQnLFxuICAgICAgICAgICAgfSB9LCBoKFwiZGl2XCIsIHsgY2xhc3M6ICdjZW50ZXInLCBpZDogXCJzZGstbW0tcXJjb2RlXCIsIGlubmVySFRNTDogc3ZnRWxlbWVudCB9KSwgaChcImRpdlwiLCB7IGNsYXNzOiAnY29ubmVjdE1vYmlsZVRleHQnIH0sIHQoJ1NDQU5fVE9fQ09OTkVDVCcpLCBoKFwiYnJcIiwgbnVsbCksIGgoXCJzcGFuXCIsIHsgY2xhc3M6ICdibHVlJyB9LCBoKFwiYlwiLCBudWxsLCB0KCdNRVRBX01BU0tfTU9CSUxFX0FQUCcpKSkpKSkpLCBoKFwiZGl2XCIsIHsgc3R5bGU6IHsgZGlzcGxheTogY3VycmVudFRhYiA9PT0gMiA/ICdub25lJyA6ICdibG9jaycgfSB9LCBoKFwiZGl2XCIsIHsgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIGhlaWdodDogJzMwMCcsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAnLTIwJyxcbiAgICAgICAgICAgIH0gfSwgaChNZXRhbWFza0V4dGVuc2lvbkltYWdlLCBudWxsKSksIGgoXCJkaXZcIiwgeyBjbGFzczogJ2V4dGVuc2lvbkxhYmVsJyB9LCB0KCdTRUxFQ1RfTU9EQUwuQ1JZUFRPX1RBS0VfQ09OVFJPTF9URVhUJykpLCBoKFwiYnV0dG9uXCIsIHsgY2xhc3M6ICdidXR0b24nLCBvbkNsaWNrOiAoKSA9PiB0aGlzLmNvbm5lY3RXaXRoRXh0ZW5zaW9uSGFuZGxlcigpIH0sIGgoQ29ubmVjdEljb24sIG51bGwpLCBoKFwic3BhblwiLCB7IGNsYXNzOiAnaW5zdGFsbEV4dGVuc2lvblRleHQnIH0sIHQoJ0NPTk5FQ1RfV0lUSF9FWFRFTlNJT04nKSkpKSksIGgoU0RLVmVyc2lvbiwgeyB2ZXJzaW9uOiBzZGtWZXJzaW9uIH0pKSkpO1xuICAgIH1cbiAgICBnZXQgZWwoKSB7IHJldHVybiBnZXRFbGVtZW50KHRoaXMpOyB9XG4gICAgc3RhdGljIGdldCB3YXRjaGVycygpIHsgcmV0dXJuIHtcbiAgICAgICAgXCJwcmVmZXJEZXNrdG9wXCI6IFtcInVwZGF0ZVByZWZlckRlc2t0b3BcIl1cbiAgICB9OyB9XG59O1xuU2VsZWN0TW9kYWwuc3R5bGUgPSBNbVNlbGVjdE1vZGFsU3R5bGUwO1xuXG5leHBvcnQgeyBJbnN0YWxsTW9kYWwgYXMgbW1faW5zdGFsbF9tb2RhbCwgUGVuZGluZ01vZGFsIGFzIG1tX3BlbmRpbmdfbW9kYWwsIFNlbGVjdE1vZGFsIGFzIG1tX3NlbGVjdF9tb2RhbCB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tbS1pbnN0YWxsLW1vZGFsXzMuZW50cnkuanMubWFwIl0sIm5hbWVzIjpbIm51bWJlciIsIm4iLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiRXJyb3IiLCJib29sIiwiYiIsImlzQnl0ZXMiLCJhIiwiVWludDhBcnJheSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImJ5dGVzIiwibGVuZ3RocyIsImxlbmd0aCIsImluY2x1ZGVzIiwiaGFzaCIsImNyZWF0ZSIsIm91dHB1dExlbiIsImJsb2NrTGVuIiwiZXhpc3RzIiwiaW5zdGFuY2UiLCJjaGVja0ZpbmlzaGVkIiwiZGVzdHJveWVkIiwiZmluaXNoZWQiLCJvdXRwdXQiLCJvdXQiLCJtaW4iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9hc3NlcnQiLCJ2YWx1ZSIsImFzc2VydCIsImRlZmF1bHQiLCJleHBvcnRzIiwid3JhcENpcGhlciIsIkhhc2giLCJpc0xFIiwiY3JlYXRlVmlldyIsInUxNiIsInU4IiwiYnl0ZXNUb0hleCIsImhleFRvQnl0ZXMiLCJoZXhUb051bWJlciIsImJ5dGVzVG9OdW1iZXJCRSIsIm51bWJlclRvQnl0ZXNCRSIsImxlbiIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJhc3luY0xvb3AiLCJhc3luYyIsIml0ZXJzIiwidGljayIsImNiIiwidHMiLCJEYXRlIiwibm93IiwiaSIsImRpZmYiLCJuZXh0VGljayIsInV0ZjhUb0J5dGVzIiwiYnl0ZXNUb1V0ZjgiLCJUZXh0RGVjb2RlciIsImRlY29kZSIsInRvQnl0ZXMiLCJkYXRhIiwiX2Fzc2VydF9qc18xIiwiY29weUJ5dGVzIiwiY29uY2F0Qnl0ZXMiLCJhcnJheXMiLCJzdW0iLCJyZXMiLCJwYWQiLCJzZXQiLCJjaGVja09wdHMiLCJkZWZhdWx0cyIsIm9wdHMiLCJhc3NpZ24iLCJlcXVhbEJ5dGVzIiwic2V0QmlnVWludDY0IiwidTY0TGVuZ3RocyIsImNpcGhlcnRleHQiLCJBQUQiLCJudW0iLCJ2aWV3IiwiQmlnSW50IiwiaXNBbGlnbmVkMzIiLCJieXRlT2Zmc2V0IiwiY2xlYW4iLCJmaWxsIiwicmVxdWlyZSQkMCIsImFyciIsImJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJVaW50MTZBcnJheSIsIk1hdGgiLCJmbG9vciIsInUzMiIsIlVpbnQzMkFycmF5IiwiRGF0YVZpZXciLCJoZXhlcyIsIkFycmF5IiwiZnJvbSIsIl8iLCJoZXgiLCJhc2NpaXMiLCJfMCIsIl85IiwiX0EiLCJfRiIsIl9hIiwiX2YiLCJhc2NpaVRvQmFzZTE2IiwiY2hhciIsImhsIiwiYWwiLCJhcnJheSIsImFpIiwiaGkiLCJuMSIsImNoYXJDb2RlQXQiLCJuMiIsInVuZGVmaW5lZCIsInN0ciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiXzMybiIsIl91MzJfbWF4Iiwid2giLCJ3bCIsImgiLCJsIiwic2V0VWludDMyIiwicGFyYW1zIiwiYyIsImNvbnN0cyIsIkFFQURfVEFHX0xFTkdUSCIsIlhDSEFDSEEyMF9OT05DRV9MRU5HVEgiLCJDVVJWRTI1NTE5X1BVQkxJQ19LRVlfU0laRSIsIkVUSF9QVUJMSUNfS0VZX1NJWkUiLCJVTkNPTVBSRVNTRURfUFVCTElDX0tFWV9TSVpFIiwiU0VDUkVUX0tFWV9MRU5HVEgiLCJDT01QUkVTU0VEX1BVQkxJQ19LRVlfU0laRSIsImVwaGVtZXJhbEtleVNpemUiLCJzeW1tZXRyaWNOb25jZUxlbmd0aCIsImlzSGtkZktleUNvbXByZXNzZWQiLCJpc0VwaGVtZXJhbEtleUNvbXByZXNzZWQiLCJFQ0lFU19DT05GSUciLCJjb25zdHNfMSIsIkNvbmZpZyIsInRoaXMiLCJlbGxpcHRpY0N1cnZlIiwic3ltbWV0cmljQWxnb3JpdGhtIiwibWFwcGluZyIsInNlY3AyNTZrMSIsIngyNTUxOSIsImVkMjU1MTkiLCJjcnlwdG8iLCJnbG9iYWxUaGlzIiwiZ2NtIiwiY3RyIiwiY2JjIiwidXRpbHMiLCJyYW5kb21CeXRlcyIsImdldFdlYmNyeXB0b1N1YnRsZSIsIm1hbmFnZWROb25jZSIsImZuIiwibm9uY2VMZW5ndGgiLCJrZXkiLCJhcmdzIiwiZW5jcnlwdCIsInBsYWludGV4dCIsImFyZ3NFbmMiLCJub25jZSIsInV0aWxzX2pzXzEiLCJkZWNyeXB0IiwiYXJnc0RlYyIsInN1YmFycmF5IiwiY3J5cHRvXzEiLCJyZXF1aXJlJCQxIiwicmVxdWlyZSQkMiIsImJ5dGVzTGVuZ3RoIiwiZ2V0UmFuZG9tVmFsdWVzIiwic3VidGxlIiwia2V5UGFyYW1zIiwiY3J5cHRQYXJhbXMiLCJjciIsImlLZXkiLCJpbXBvcnRLZXkiLCJtb2RlIiwiQ0JDIiwiQ1RSIiwiR0NNIiwiZ2VuZXJhdGUiLCJhbGdvIiwiaXYiLCJjb3VudGVyIiwiYWRkaXRpb25hbERhdGEiLCJnZXRDcnlwdFBhcmFtcyIsImJ5dGVTd2FwSWZCRSIsImJ5dGVTd2FwIiwicm90bCIsInJvdHIiLCJieXRlU3dhcDMyIiwidG9TdHIiLCJjYWxsIiwid3JhcENvbnN0cnVjdG9yIiwiaGFzaENvbnMiLCJoYXNoQyIsIm1zZyIsInVwZGF0ZSIsImRpZ2VzdCIsInRtcCIsIndyYXBDb25zdHJ1Y3RvcldpdGhPcHRzIiwid3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMiLCJ3b3JkIiwic2hpZnQiLCJjbG9uZSIsIl9jbG9uZUludG8iLCJfbWQiLCJIYXNoTUQiLCJNYWoiLCJDaGkiLCJwYWRPZmZzZXQiLCJzdXBlciIsInBvcyIsInRha2UiLCJwcm9jZXNzIiwiZGF0YVZpZXciLCJyb3VuZENsZWFuIiwiZGlnZXN0SW50byIsIm92aWV3Iiwib3V0TGVuIiwic3RhdGUiLCJnZXQiLCJzbGljZSIsImRlc3Ryb3kiLCJ0byIsIl91NjQiLCJhZGQ1TCIsImFkZDVIIiwiYWRkNEgiLCJhZGQzSCIsImFkZDNMIiwicm90bEJMIiwicm90bFNMIiwicm90bFNIIiwicm90cjMyTCIsInJvdHJCTCIsInJvdHJCSCIsInJvdHJTSCIsInNoclNMIiwic2hyU0giLCJmcm9tQmlnIiwic3BsaXQiLCJhZGQiLCJVMzJfTUFTSzY0IiwibGUiLCJsc3QiLCJBaCIsIkFsIiwidG9CaWciLCJfbCIsInMiLCJyb3RyU0wiLCJyb3RyMzJIIiwiX2giLCJyb3RsQkgiLCJCaCIsIkJsIiwiQ2wiLCJsb3ciLCJDaCIsImFkZDRMIiwiRGwiLCJEaCIsIkVsIiwiRWgiLCJ1NjQiLCJzaGE1MTIiLCJzaGEzODQiLCJzaGE1MTJfMjU2Iiwic2hhNTEyXzIyNCIsIlNIQTM4NCIsIlNIQTUxMl8yNTYiLCJTSEE1MTJfMjI0IiwiX21kX2pzXzEiLCJfdTY0X2pzXzEiLCJTSEE1MTJfS2giLCJTSEE1MTJfS2wiLCJtYXAiLCJTSEE1MTJfV19IIiwiU0hBNTEyX1dfTCIsIlNIQTUxMiIsIkZoIiwiRmwiLCJHaCIsIkdsIiwiSGgiLCJIbCIsIm9mZnNldCIsImdldFVpbnQzMiIsIlcxNWgiLCJXMTVsIiwiczBoIiwiczBsIiwiVzJoIiwiVzJsIiwiczFoIiwiczFsIiwiU1VNbCIsIlNVTWgiLCJzaWdtYTFoIiwic2lnbWExbCIsIkNISWgiLCJDSElsIiwiVDFsbCIsIlQxaCIsIlQxbCIsInNpZ21hMGgiLCJzaWdtYTBsIiwiTUFKaCIsIk1BSmwiLCJBbGwiLCJub3RJbXBsZW1lbnRlZCIsImJpdE1hc2siLCJhYnl0ZXMiLCJhYm9vbCIsInRpdGxlIiwibnVtYmVyVG9IZXhVbnBhZGRlZCIsImJ5dGVzVG9OdW1iZXJMRSIsInJldmVyc2UiLCJudW1iZXJUb0J5dGVzTEUiLCJudW1iZXJUb1ZhckJ5dGVzQkUiLCJlbnN1cmVCeXRlcyIsImV4cGVjdGVkTGVuZ3RoIiwiZSIsImluUmFuZ2UiLCJhSW5SYW5nZSIsIm1heCIsImJpdExlbiIsIl8wbiIsIl8xbiIsImJpdEdldCIsImJpdFNldCIsImNyZWF0ZUhtYWNEcmJnIiwiaGFzaExlbiIsInFCeXRlTGVuIiwiaG1hY0ZuIiwidiIsInU4biIsImsiLCJyZXNldCIsInJlc2VlZCIsInNlZWQiLCJ1OGZyIiwiZ2VuIiwic2wiLCJwdXNoIiwicHJlZCIsInZhbGlkYXRlT2JqZWN0Iiwib2JqZWN0IiwidmFsaWRhdG9ycyIsIm9wdFZhbGlkYXRvcnMiLCJjaGVja0ZpZWxkIiwiZmllbGROYW1lIiwidHlwZSIsImlzT3B0aW9uYWwiLCJjaGVja1ZhbCIsInZhbGlkYXRvckZucyIsInZhbCIsIlN0cmluZyIsImVudHJpZXMiLCJtZW1vaXplZCIsIldlYWtNYXAiLCJhcmciLCJjb21wdXRlZCIsIl8ybiIsIml0ZW0iLCJpc1Bvc0JpZyIsImJpZ2ludCIsImZ1bmN0aW9uIiwiYm9vbGVhbiIsInN0cmluZyIsInN0cmluZ09yVWludDhBcnJheSIsImlzQXJyYXkiLCJmaWVsZCIsIkZwIiwiaXNWYWxpZCIsIm1vZHVsYXIiLCJpc05lZ2F0aXZlTEUiLCJtb2QiLCJwb3ciLCJwb3cyIiwieCIsInBvd2VyIiwibW9kdWxvIiwiaW52ZXJ0IiwidG9uZWxsaVNoYW5rcyIsIkZwU3FydCIsInZhbGlkYXRlRmllbGQiLCJGSUVMRF9GSUVMRFMiLCJyZWR1Y2UiLCJPUkRFUiIsIk1BU0siLCJCWVRFUyIsIkJJVFMiLCJGcFBvdyIsIkZwSW52ZXJ0QmF0Y2giLCJGcERpdiIsImYiLCJsaHMiLCJyaHMiLCJtdWwiLCJpbnYiLCJGcExlZ2VuZHJlIiwiRnBJc1NxdWFyZSIsImxlZ2VuZHJlIiwicCIsImVxbCIsIlpFUk8iLCJPTkUiLCJuTGVuZ3RoIiwiRmllbGQiLCJyZWRlZiIsIm5CaXRMZW5ndGgiLCJuQnl0ZUxlbmd0aCIsInNxcnRQIiwiZnJlZXplIiwiaXMwIiwiaXNPZGQiLCJuZWciLCJzcXIiLCJzdWIiLCJkaXYiLCJzcXJOIiwiYWRkTiIsInN1Yk4iLCJtdWxOIiwic3FydCIsImludmVydEJhdGNoIiwiY21vdiIsImZyb21CeXRlcyIsIkZwU3FydE9kZCIsImVsbSIsInJvb3QiLCJGcFNxcnRFdmVuIiwiaGFzaFRvUHJpdmF0ZVNjYWxhciIsImdyb3VwT3JkZXIiLCJtaW5MZW4iLCJnZXRGaWVsZEJ5dGVzTGVuZ3RoIiwiZ2V0TWluSGFzaExlbmd0aCIsIm1hcEhhc2hUb0ZpZWxkIiwiZmllbGRPcmRlciIsImZpZWxkTGVuIiwicmVkdWNlZCIsIl8zbiIsIl80biIsIl81biIsIl84biIsInJlc3VsdCIsInUiLCJyIiwibSIsIlAiLCJsZWdlbmRyZUMiLCJRIiwiUyIsIloiLCJwMWRpdjQiLCJRMWRpdjIiLCJnIiwidDIiLCJnZSIsImMxIiwibnYiLCJkIiwibnVtcyIsImxhc3RNdWx0aXBsaWVkIiwiYWNjIiwiaW52ZXJ0ZWQiLCJyZWR1Y2VSaWdodCIsIm9yZGVyIiwibGVnZW5kcmVDb25zdCIsIl9uQml0TGVuZ3RoIiwiY2VpbCIsImJpdExlbmd0aCIsImN1cnZlIiwid05BRiIsImJpdHMiLCJjb25zdFRpbWVOZWdhdGUiLCJjb25kaXRpb24iLCJuZWdhdGUiLCJ2YWxpZGF0ZVciLCJXIiwid2luZG93cyIsIndpbmRvd1NpemUiLCJ1bnNhZmVMYWRkZXIiLCJkb3VibGUiLCJwcmVjb21wdXRlV2luZG93IiwicG9pbnRzIiwiYmFzZSIsIndpbmRvdyIsInByZWNvbXB1dGVzIiwiQkFTRSIsIm1hc2siLCJtYXhOdW1iZXIiLCJzaGlmdEJ5Iiwid2JpdHMiLCJvZmZzZXQxIiwib2Zmc2V0MiIsImFicyIsImNvbmQxIiwiY29uZDIiLCJ3TkFGQ2FjaGVkIiwidHJhbnNmb3JtIiwicG9pbnRXaW5kb3dTaXplcyIsImNvbXAiLCJwb2ludFByZWNvbXB1dGVzIiwic2V0V2luZG93U2l6ZSIsImRlbGV0ZSIsInBpcHBlbmdlciIsInNjYWxhcnMiLCJmb3JFYWNoIiwiYnVja2V0cyIsImxhc3RCaXRzIiwiaiIsInNjYWxhciIsInJlc0kiLCJzdW1JIiwidmFsaWRhdGVCYXNpYyIsIm1vZHVsYXJfanNfMSIsIkd4IiwiR3kiLCJlZHdhcmRzIiwidHdpc3RlZEVkd2FyZHMiLCJjdXJ2ZURlZiIsIkNVUlZFIiwiY3VydmVfanNfMSIsInV0IiwiYWRqdXN0U2NhbGFyQnl0ZXMiLCJkb21haW4iLCJ1dlJhdGlvIiwibWFwVG9DdXJ2ZSIsInZhbGlkYXRlT3B0cyIsIkNVUlZFX09SREVSIiwicHJlaGFzaCIsImNIYXNoIiwiY29mYWN0b3IiLCJtb2RQIiwiRm4iLCJjdHgiLCJwaGZsYWciLCJhQ29vcmRpbmF0ZSIsImFzc2VydFBvaW50Iiwib3RoZXIiLCJQb2ludCIsInRvQWZmaW5lTWVtbyIsIml6IiwiZXgiLCJleSIsInkiLCJleiIsInoiLCJheCIsImF5IiwienoiLCJhc3NlcnRWYWxpZE1lbW8iLCJYIiwiWSIsImV0IiwiVCIsIlgyIiwiWTIiLCJaMiIsIlo0IiwiYVgyIiwidG9BZmZpbmUiLCJmcm9tQWZmaW5lIiwibm9ybWFsaXplWiIsInRvSW52IiwibXNtIiwiX3NldFdpbmRvd1NpemUiLCJ3bmFmIiwiYXNzZXJ0VmFsaWRpdHkiLCJlcXVhbHMiLCJYMSIsIlkxIiwiWjEiLCJYMVoyIiwiWDJaMSIsIlkxWjIiLCJZMloxIiwiQSIsIkIiLCJDIiwiRCIsIngxeTEiLCJFIiwiRyIsIkYiLCJIIiwiWDMiLCJZMyIsIlQzIiwiWjMiLCJUMSIsIlQyIiwic3VidHJhY3QiLCJtdWx0aXBseSIsIm11bHRpcGx5VW5zYWZlIiwiSSIsImlzU21hbGxPcmRlciIsImlzVG9yc2lvbkZyZWUiLCJjbGVhckNvZmFjdG9yIiwiZnJvbUhleCIsInppcDIxNSIsIm5vcm1lZCIsImxhc3RCeXRlIiwieTIiLCJpc1hPZGQiLCJpc0xhc3RCeXRlT2RkIiwiZnJvbVByaXZhdGVLZXkiLCJwcml2S2V5IiwiZ2V0RXh0ZW5kZWRQdWJsaWNLZXkiLCJwb2ludCIsInRvUmF3Qnl0ZXMiLCJ0b0hleCIsIm1vZE4iLCJtb2ROX0xFIiwiaGFzaGVkIiwiaGVhZCIsInByZWZpeCIsInBvaW50Qnl0ZXMiLCJoYXNoRG9tYWluVG9TY2FsYXIiLCJjb250ZXh0IiwibXNncyIsInZlcmlmeU9wdHMiLCJWRVJJRllfREVGQVVMVCIsInJhbmRvbVByaXZhdGVLZXkiLCJwcmVjb21wdXRlIiwiZ2V0UHVibGljS2V5Iiwic2lnbiIsIm9wdGlvbnMiLCJSIiwidmVyaWZ5Iiwic2lnIiwicHVibGljS2V5IiwiU0IiLCJlcnJvciIsIkV4dGVuZGVkUG9pbnQiLCJoYXNoVG9DdXJ2ZSIsImV4cGFuZF9tZXNzYWdlX3htZCIsImV4cGFuZF9tZXNzYWdlX3hvZiIsImhhc2hfdG9fZmllbGQiLCJpc29nZW55TWFwIiwiQ09FRkYiLCJ4TnVtIiwieERlbiIsInlOdW0iLCJ5RGVuIiwiY3JlYXRlSGFzaGVyIiwiZGVmIiwiRFNUIiwidTAiLCJ1MSIsImVuY29kZVRvQ3VydmUiLCJlbmNvZGVEU1QiLCJvczJpcCIsImkyb3NwIiwiYW51bSIsInN0cnhvciIsImxlbkluQnl0ZXMiLCJiX2luX2J5dGVzIiwicl9pbl9ieXRlcyIsImVsbCIsIkRTVF9wcmltZSIsIlpfcGFkIiwibF9pX2Jfc3RyIiwiYl8wIiwiZGtMZW4iLCJjb3VudCIsImV4cGFuZCIsIl9EU1QiLCJsb2cycCIsIkwiLCJsZW5faW5fYnl0ZXMiLCJwcmIiLCJlbG1fb2Zmc2V0IiwidHYiLCJtb250Z29tZXJ5XzEiLCJtb250Z29tZXJ5IiwibW9udGdvbWVyeUJpdHMiLCJwb3dQbWludXMyIiwiR3UiLCJtb250Z29tZXJ5Qnl0ZXMiLCJjc3dhcCIsInN3YXAiLCJ4XzIiLCJ4XzMiLCJkdW1teSIsImEyNCIsImVuY29kZVVDb29yZGluYXRlIiwic2NhbGFyTXVsdCIsInBvaW50VSIsInVFbmMiLCJkZWNvZGVVQ29vcmRpbmF0ZSIsIl9zY2FsYXIiLCJkZWNvZGVTY2FsYXIiLCJwdSIsInhfMSIsInN3Iiwiel8yIiwiel8zIiwidCIsImtfdCIsIkFBIiwiQkIiLCJEQSIsIkNCIiwiZGFjYiIsImRhX2NiIiwiejIiLCJtb250Z29tZXJ5TGFkZGVyIiwiR3VCeXRlcyIsInNjYWxhck11bHRCYXNlIiwiZ2V0U2hhcmVkU2VjcmV0IiwicHJpdmF0ZUtleSIsImhhc2hfdG9fcmlzdHJldHRvMjU1IiwiaGFzaFRvUmlzdHJldHRvMjU1IiwiUmlzdHJldHRvUG9pbnQiLCJlZHdhcmRzVG9Nb250Z29tZXJ5IiwiZWQyNTUxOXBoIiwiZWQyNTUxOWN0eCIsIkVEMjU1MTlfVE9SU0lPTl9TVUJHUk9VUCIsImVkd2FyZHNUb01vbnRnb21lcnlQdWIiLCJlZHdhcmRzVG9Nb250Z29tZXJ5UHJpdiIsImVkd2FyZHNQcml2IiwiZWQyNTUxOURlZmF1bHRzIiwic2hhNTEyXzEiLCJ1dGlsc18xIiwiZWR3YXJkc19qc18xIiwiaGFzaF90b19jdXJ2ZV9qc18xIiwicmVxdWlyZSQkMyIsInJlcXVpcmUkJDQiLCJtb250Z29tZXJ5X2pzXzEiLCJyZXF1aXJlJCQ1IiwicmVxdWlyZSQkNiIsIkVEMjU1MTlfUCIsIkVEMjU1MTlfU1FSVF9NMSIsImVkMjU1MTlfcG93XzJfMjUyXzMiLCJfMTBuIiwiXzIwbiIsIl80MG4iLCJfODBuIiwiYjIiLCJiNCIsImI1IiwiYjEwIiwiYjIwIiwiYjQwIiwiYjgwIiwiYjE2MCIsImIyNDAiLCJiMjUwIiwicG93X3BfNV84IiwidjMiLCJ2eDIiLCJyb290MSIsInJvb3QyIiwidXNlUm9vdDEiLCJ1c2VSb290MiIsIm5vUm9vdCIsImVkMjU1MTlfZG9tYWluIiwiZWR3YXJkc1B1YiIsIkVMTDJfQzEiLCJFTEwyX0MyIiwiRUxMMl9DMyIsIkVMTDJfQzFfRURXQVJEUyIsIm1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2Vkd2FyZHMyNTUxOSIsInhNbiIsInhNZCIsInlNbiIsInlNZCIsIkVMTDJfQzQiLCJFTEwyX0oiLCJ0djEiLCJ4ZCIsIngxbiIsInR2MiIsImd4ZCIsImd4MSIsInR2MyIsInkxMSIsInkxMiIsImUxIiwieTEiLCJ4Mm4iLCJ5MjEiLCJ5MjIiLCJneDIiLCJlMiIsImUzIiwieG4iLCJlNCIsIm1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2N1cnZlMjU1MTkiLCJ5biIsInlkIiwiaHRmIiwiYXNzZXJ0UnN0UG9pbnQiLCJSaXN0UG9pbnQiLCJTUVJUX00xIiwiU1FSVF9BRF9NSU5VU19PTkUiLCJJTlZTUVJUX0FfTUlOVVNfRCIsIk9ORV9NSU5VU19EX1NRIiwiRF9NSU5VU19PTkVfU1EiLCJpbnZlcnRTcXJ0IiwiTUFYXzI1NUIiLCJieXRlczI1NVRvTnVtYmVyTEUiLCJjYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwIiwicjAiLCJOcyIsIk5zX0RfaXNfc3EiLCJzXyIsIk50IiwiczIiLCJXMCIsIlcxIiwiVzIiLCJXMyIsImVwIiwiYXAiLCJSMSIsIlIyIiwiZW1zZyIsInUyIiwidTFfMiIsInUyXzIiLCJEeCIsIkR5IiwidTJzcSIsImludnNxcnQiLCJEMSIsIkQyIiwiekludiIsIl94IiwiX3kiLCJvbmUiLCJ0d28iLCJ1bmlmb3JtX2J5dGVzIiwic2hhMjU2Iiwic2hhMjI0IiwiU0hBMjU2X0siLCJTSEEyNTZfSVYiLCJTSEEyNTZfVyIsIlNIQTI1NiIsIlcxNSIsInMwIiwiczEiLCJTSEEyMjQiLCJobWFjIiwiSE1BQyIsIl9rZXkiLCJpSGFzaCIsIm9IYXNoIiwiYnVmIiwiZ2V0UHJvdG90eXBlT2YiLCJtZXNzYWdlIiwiREVSIiwid2VpZXJzdHJhc3NQb2ludHMiLCJ3ZWllcnN0cmFzcyIsImJpdHMyaW50IiwiYml0czJpbnRfbW9kTiIsImxvd1MiLCJjb21wcmVzc2VkTGVuIiwidW5jb21wcmVzc2VkTGVuIiwiaW52TiIsIlByb2plY3RpdmVQb2ludCIsIm5vcm1Qcml2YXRlS2V5VG9TY2FsYXIiLCJ3ZWllcnN0cmFzc0VxdWF0aW9uIiwiaXNXaXRoaW5DdXJ2ZU9yZGVyIiwiX2MiLCJpc0NvbXByZXNzZWQiLCJjYXQiLCJoYXNFdmVuWSIsInRhaWwiLCJzcXJ0RXJyb3IiLCJzdWZmaXgiLCJudW1Ub05CeXRlU3RyIiwiaXNCaWdnZXJUaGFuSGFsZk9yZGVyIiwic2xjTnVtIiwiU2lnbmF0dXJlIiwicmVjb3ZlcnkiLCJmcm9tQ29tcGFjdCIsImZyb21ERVIiLCJ0b1NpZyIsImFkZFJlY292ZXJ5Qml0IiwicmVjb3ZlclB1YmxpY0tleSIsIm1zZ0hhc2giLCJyZWMiLCJyYWRqIiwiaXIiLCJtdWx0aXBseUFuZEFkZFVuc2FmZSIsImhhc0hpZ2hTIiwibm9ybWFsaXplUyIsInRvREVSUmF3Qnl0ZXMiLCJ0b0RFUkhleCIsImhleEZyb21TaWciLCJ0b0NvbXBhY3RSYXdCeXRlcyIsInRvQ29tcGFjdEhleCIsImlzVmFsaWRQcml2YXRlS2V5IiwiaXNQcm9iUHViIiwiZGVsdGEiLCJPUkRFUl9NQVNLIiwiaW50Mm9jdGV0cyIsInByZXBTaWciLCJkZWZhdWx0U2lnT3B0cyIsInNvbWUiLCJleHRyYUVudHJvcHkiLCJlbnQiLCJ2YWxpZGF0ZVNpZ1Zlck9wdHMiLCJoMWludCIsInNlZWRBcmdzIiwiazJzaWciLCJrQnl0ZXMiLCJpayIsInEiLCJub3JtUyIsImRlZmF1bHRWZXJPcHRzIiwicHJpdmF0ZUEiLCJwdWJsaWNCIiwiZHJiZyIsInNpZ25hdHVyZSIsInNnIiwiX3NpZyIsImRlckVycm9yIiwiRXJyIiwiaXMiLCJTV1VGcFNxcnRSYXRpbyIsIm1hcFRvQ3VydmVTaW1wbGVTV1UiLCJzcXJ0UmF0aW8iLCJ0djQiLCJ0djUiLCJ0djYiLCJiMm4iLCJoMmIiLCJfdGx2IiwidGFnIiwiZGF0YUxlbiIsImxlbkxlbiIsImZpcnN0IiwibGVuZ3RoQnl0ZXMiLCJfaW50IiwicGFyc2VJbnQiLCJpbnQiLCJ0bHYiLCJzZXFCeXRlcyIsInNlcUxlZnRCeXRlcyIsInJCeXRlcyIsInJMZWZ0Qnl0ZXMiLCJzQnl0ZXMiLCJzTGVmdEJ5dGVzIiwic2VxIiwiYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIiwid3JhcFByaXZhdGVLZXkiLCJhbGxvd0luZmluaXR5UG9pbnQiLCJlbmRvIiwiYmV0YSIsInNwbGl0U2NhbGFyIiwidmFsaWRhdGVQb2ludE9wdHMiLCJfaXNDb21wcmVzc2VkIiwieDIiLCJ4MyIsIk4iLCJhc3NlcnRQcmpQb2ludCIsInB4IiwicHkiLCJweiIsImxlZnQiLCJyaWdodCIsIlUxIiwiVTIiLCJiMyIsInQwIiwidDEiLCJ0MyIsInQ0IiwidDUiLCJzYyIsImsxbmVnIiwiazEiLCJrMm5lZyIsImsyIiwiazFwIiwiazJwIiwiZmFrZSIsImYxcCIsImYycCIsIl9iaXRzIiwibyIsIl8ybl9wb3dfYzFfMSIsIl8ybl9wb3dfYzEiLCJjMiIsImMzIiwiYzQiLCJjNSIsImM2IiwiYzciLCJpc1FSIiwidHZ2NSIsIl9zaG9ydHdfdXRpbHMiLCJnZXRIYXNoIiwiY3JlYXRlQ3VydmUiLCJkZWZIYXNoIiwid2VpZXJzdHJhc3NfanNfMSIsImhtYWNfMSIsInNjaG5vcnIiLCJzaGEyNTZfMSIsIl9zaG9ydHdfdXRpbHNfanNfMSIsInNlY3AyNTZrMVAiLCJzZWNwMjU2azFOIiwiZGl2TmVhcmVzdCIsInNxcnRNb2QiLCJfNm4iLCJfMTFuIiwiXzIybiIsIl8yM24iLCJfNDRuIiwiXzg4biIsImI2IiwiYjkiLCJiMTEiLCJiMjIiLCJiNDQiLCJiODgiLCJiMTc2IiwiYjIyMCIsImIyMjMiLCJhMSIsImIxIiwiYTIiLCJQT1dfMl8xMjgiLCJUQUdHRURfSEFTSF9QUkVGSVhFUyIsInRhZ2dlZEhhc2giLCJtZXNzYWdlcyIsInRhZ1AiLCJ0YWdIIiwicG9pbnRUb0J5dGVzIiwibnVtVG8zMmIiLCJHbXVsQWRkIiwic2Nobm9yckdldEV4dFB1YktleSIsInByaXYiLCJkXyIsImxpZnRfeCIsInh4IiwiY2hhbGxlbmdlIiwic2Nobm9yckdldFB1YmxpY0tleSIsInNjaG5vcnJTaWduIiwiYXV4UmFuZCIsInJhbmQiLCJrXyIsInJ4Iiwic2Nobm9yclZlcmlmeSIsInB1YiIsImlzb01hcCIsIm1hcFNXVSIsImRlY29kZUhleCIsInJlbW92ZTB4Iiwic3RhcnRzV2l0aCIsImhleFRvUHVibGljS2V5IiwiZ2V0U2hhcmVkUG9pbnQiLCJnZXRWYWxpZFNlY3JldCIsIndlYmNyeXB0b18xIiwiZWQyNTUxOV8xIiwic2VjcDI1NmsxXzEiLCJjb25maWdfMSIsImhleF8xIiwic2VjcmV0IiwiX2V4ZWMiLCJzayIsInBrIiwiY29tcHJlc3NlZCIsImdldFNoYXJlZFBvaW50T25FZDI1NTE5IiwiY29udmVydFB1YmxpY0tleUZvcm1hdCIsInNlY3AyNTZrMUNhbGxiYWNrIiwieDI1NTE5Q2FsbGJhY2siLCJlZDI1NTE5Q2FsbGJhY2siLCJkZWNvZGVkIiwiY29tcGF0RXRoUHVibGljS2V5IiwiZml4ZWQiLCJoa2RmXzEiLCJoa2RmIiwiZXh0cmFjdCIsImhtYWNfanNfMSIsImlrbSIsInNhbHQiLCJIS0RGX0NPVU5URVIiLCJFTVBUWV9CVUZGRVIiLCJwcmsiLCJpbmZvIiwiYmxvY2tzIiwib2ttIiwiSE1BQ1RtcCIsImdldFNoYXJlZEtleSIsImRlcml2ZUtleSIsIm1hc3RlciIsInBhcnRzIiwiX2kiLCJhcmd1bWVudHMiLCJhcHBseSIsIl9wb2x5dmFsIiwicG9seXZhbCIsImdoYXNoIiwiX3RvR0hBU0hLZXkiLCJCTE9DS19TSVpFIiwiWkVST1MxNiIsIlpFUk9TMzIiLCJzd2FwTEUiLCJoaUJpdCIsImNhcnJ5IiwiR0hBU0giLCJzMyIsImtWaWV3IiwiazAiLCJrMyIsImRvdWJsZXMiLCJlc3RpbWF0ZVdpbmRvdyIsIml0ZW1zIiwidyIsImJ5dGUiLCJkMCIsImQxIiwiZDIiLCJkMyIsIl91cGRhdGVCbG9jayIsIm8wIiwibzEiLCJvMiIsIm8zIiwiYnl0ZVBvcyIsImJpdFBvcyIsImJpdCIsImUwIiwiYjMyIiwibzMyIiwiUG9seXZhbCIsImdoS2V5Iiwid3JhcENvbnN0cnVjdG9yV2l0aEtleSIsImFlcyIsInVuc2FmZSIsImFlc2t3cCIsInNpdiIsImVjYiIsImV4cGFuZEtleUxFIiwiZXhwYW5kS2V5RGVjTEUiLCJfcG9seXZhbF9qc18xIiwiRU1QVFlfQkxPQ0siLCJQT0xZIiwibXVsMiIsInNib3giLCJib3giLCJpbnZTYm94IiwiaW5kZXhPZiIsInJvdHIzMl84Iiwicm90bDMyXzgiLCJnZW5UdGFibGUiLCJUMCIsIlQwMSIsIlQyMyIsInNib3gyIiwiaWR4IiwidGFibGVFbmNvZGluZyIsInRhYmxlRGVjb2RpbmciLCJ4UG93ZXJzIiwidG9DbGVhbiIsImszMiIsIk5rIiwic3ViQnl0ZSIsImFwcGx5U2JveCIsInhrIiwiZW5jS2V5IiwiYXBwbHkwMTIzIiwicm91bmRzIiwiZ2V0RHN0IiwiZHN0IiwiY3RyQ291bnRlciIsInNyYyIsInNyY0xlbiIsImMzMiIsInNyYzMyIiwiZHN0MzIiLCJzdGFydCIsImN0cjMyIiwiY3RyUG9zIiwiY3RyTnVtIiwidmFsaWRhdGVCbG9ja0RlY3J5cHQiLCJ2YWxpZGF0ZUJsb2NrRW5jcnlwdCIsInBja3M1IiwicmVtYWluaW5nIiwidmFsaWRhdGVQQ0tTIiwicGFkUENLUyIsInRtcDMyIiwicGFkZGluZ0J5dGUiLCJjb21wdXRlVGFnIiwiYWFkTGVuZ3RoIiwiYmxvY2tTaXplIiwicHJvY2Vzc0N0ciIsImRpc2FibGVQYWRkaW5nIiwiX291dCIsIl9pdiIsIm4zMiIsInBzMCIsInBzMSIsInBzMiIsInBzMyIsImNmYiIsInByb2Nlc3NDZmIiLCJpc0VuY3J5cHQiLCJuZXh0MzIiLCJ0YWdMZW5ndGgiLCJfY29tcHV0ZVRhZyIsImF1dGhLZXkiLCJ0YWdNYXNrIiwiZGVyaXZlS2V5cyIsIm5vbmNlTGVuIiwicGFzc2VkVGFnIiwibGltaXQiLCJpc0J5dGVzMzIiLCJlbmNyeXB0QmxvY2siLCJibG9jayIsImRlY3J5cHRCbG9jayIsIkFBRF9MSU1JVCIsIlBMQUlOX0xJTUlUIiwiTk9OQ0VfTElNSVQiLCJDSVBIRVJfTElNSVQiLCJfbm9uY2UiLCJkZXJpdmVkS2V5IiwiZDMyIiwidDMyIiwicHJvY2Vzc1NpdiIsImlucHV0IiwiZXhwZWN0ZWRUYWciLCJBRVNXIiwia2VrIiwiYTAiLCJjaHVua3MiLCJBRVNLV19JViIsImFlc2t3IiwiQUVTS1dQX0lWIiwicGFkZGVkIiwib3V0MzIiLCJub2JsZSIsImFlczI1NmNiYyIsImFlczI1NmdjbSIsImFlc18xIiwiX2FyeCIsInNpZ21hIiwiY3JlYXRlQ2lwaGVyIiwiY29yZSIsImFsbG93U2hvcnRLZXlzIiwiZXh0ZW5kTm9uY2VGbiIsImNvdW50ZXJMZW5ndGgiLCJjb3VudGVyUmlnaHQiLCJNQVhfQ09VTlRFUiIsInNpZ21hMzJfMzIiLCJzaWdtYTE2XzMyIiwibm9uY2VOY0xlbiIsIm5jIiwiQkxPQ0tfTEVOIiwiaXNBbGlnbmVkIiwiVTMyX0VNUFRZIiwicG9zMzIiLCJwb3NqIiwiQkxPQ0tfTEVOMzIiLCJydW5DaXBoZXIiLCJfdXRmOFRvQnl0ZXMiLCJzaWdtYTE2Iiwic2lnbWEzMiIsIl9wb2x5MTMwNSIsInBvbHkxMzA1IiwidTh0bzE2IiwiUG9seTEzMDUiLCJ0NiIsInQ3IiwiaXNMYXN0IiwiaGliaXQiLCJyMSIsInIyIiwicjMiLCJyNCIsInI1IiwicjYiLCJyNyIsInI4IiwicjkiLCJoMCIsImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiIsImg3IiwiaDgiLCJoOSIsImQ0IiwiZDUiLCJkNiIsImQ3IiwiZDgiLCJkOSIsImZpbmFsaXplIiwib3BvcyIsInhjaGFjaGEyMHBvbHkxMzA1IiwiY2hhY2hhMjBwb2x5MTMwNSIsImNoYWNoYTEyIiwiY2hhY2hhOCIsImNoYWNoYTIwIiwiY2hhY2hhMjBvcmlnIiwiaGNoYWNoYSIsIl9hcnhfanNfMSIsIl9wb2x5MTMwNV9qc18xIiwiY2hhY2hhQ29yZSIsImNudCIsInkwMCIsInkwMSIsInkwMiIsInkwMyIsInkwNCIsInkwNSIsInkwNiIsInkwNyIsInkwOCIsInkwOSIsInkxMCIsInkxMyIsInkxNCIsInkxNSIsIngwMCIsIngwMSIsIngwMiIsIngwMyIsIngwNCIsIngwNSIsIngwNiIsIngwNyIsIngwOCIsIngwOSIsIngxMCIsIngxMSIsIngxMiIsIngxMyIsIngxNCIsIngxNSIsIm9pIiwieGNoYWNoYTIwIiwidXBkYXRlUGFkZGVkIiwiX3BvbHkxMzA1X2FlYWQiLCJ4b3JTdHJlYW0iLCJwbGVuZ3RoIiwiY2xlbmd0aCIsIl9fY3JlYXRlQmluZGluZyIsIl9fZXhwb3J0U3RhciIsImNoYWNoYV8xIiwiYWVzRGVjcnlwdCIsImFlc0VuY3J5cHQiLCJzeW1EZWNyeXB0Iiwic3ltRW5jcnlwdCIsInBsYWluVGV4dCIsIl9lbmNyeXB0IiwiY2FsbGJhY2siLCJhbGdvcml0aG0iLCJmdW5jIiwiZW5jcnlwdGVkIiwiY2lwaGVyVGV4dExlbmd0aCIsImNpcGhlclRleHQiLCJfZGVjcnlwdCIsImNpcGhlciIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfX2VzTW9kdWxlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJQdWJsaWNLZXlfMSIsIlB1YmxpY0tleSIsInV0aWxzXzIiLCJCdWZmZXIiLCJ1bmNvbXByZXNzZWQiLCJkZWNhcHN1bGF0ZSIsInNlbmRlclBvaW50Iiwic2hhcmVkUG9pbnQiLCJQcml2YXRlS2V5XzEiLCJQcml2YXRlS2V5IiwiZW5jYXBzdWxhdGUiLCJyZWNlaXZlclJhd1BLIiwiZXBoZW1lcmFsU0siLCJrZXlzXzEiLCJyZWNlaXZlclBLIiwic2hhcmVkS2V5IiwiZXBoZW1lcmFsUEsiLCJyZWNlaXZlclJhd1NLIiwicmVjZWl2ZXJTSyIsImtleVNpemUiLCJjb25maWdfMiIsImtleXNfMiIsImNvbG9yIiwiS2V5RXhjaGFuZ2UiLCJTb2NrZXRTZXJ2aWNlIiwiRWNpZXMiLCJSZW1vdGVDb21tdW5pY2F0aW9uIiwiZW5kc1dpdGgiLCJKU09OIiwic3RyaW5naWZ5IiwibWV0aG9kIiwiaGVhZGVycyIsIkFjY2VwdCIsImJvZHkiLCJ0ZXh0IiwiY2F0Y2giLCJlbmFibGVkIiwiZGVidWciLCJlbmFibGUiLCJlY2llcyIsImdlbmVyYXRlRUNJRVMiLCJnZXRLZXlJbmZvIiwicHJpdmF0ZSIsInB1YmxpYyIsInZlcnNpb24iLCJkZXNjcmlwdGlvbiIsImhvbWVwYWdlIiwiYnVncyIsInVybCIsInJlcG9zaXRvcnkiLCJkaXJlY3RvcnkiLCJtYWluIiwidW5wa2ciLCJtb2R1bGUiLCJicm93c2VyIiwidHlwZXMiLCJmaWxlcyIsInNjcmlwdHMiLCJidWlsZCIsImRldiIsInNpemUiLCJsaW50IiwicHJlcGFjayIsInRlc3QiLCJ3YXRjaCIsImRlcGVuZGVuY2llcyIsImJ1ZmZlcnV0aWwiLCJ1dWlkIiwiZGV2RGVwZW5kZW5jaWVzIiwiY29uY3VycmVudGx5IiwiZWNpZXNqcyIsImVzbGludCIsImV2ZW50ZW1pdHRlcjIiLCJqZXN0IiwicHJldHRpZXIiLCJyaW1yYWYiLCJyb2xsdXAiLCJ0eXBlc2NyaXB0IiwicGVlckRlcGVuZGVuY2llcyIsInB1Ymxpc2hDb25maWciLCJhY2Nlc3MiLCJyZWdpc3RyeSIsImxhdmFtb2F0IiwiYWxsb3dTY3JpcHRzIiwiY2FudmFzIiwiSyIsIk1FVEFNQVNLX0dFVFBST1ZJREVSU1RBVEUiLCJNRVRBTUFTS19DT05ORUNUU0lHTiIsIk1FVEFNQVNLX0NPTk5FQ1RXSVRIIiwiTUVUQU1BU0tfT1BFTiIsIk1FVEFNQVNLX0JBVENIIiwiUEVSU09OQUxfU0lHTiIsIldBTExFVF9SRVFVRVNUUEVSTUlTU0lPTlMiLCJXQUxMRVRfUkVWT0tFUEVSTUlTU0lPTlMiLCJXQUxMRVRfR0VUUEVSTUlTU0lPTlMiLCJXQUxMRVRfV0FUQ0hBU1NFVCIsIldBTExFVF9TV0lUQ0hFVEhFUkVVTUNIQUlOIiwiV0FMTEVUX0FEREVUSEVSRVVNQ0hBSU4iLCJFVEhfUkVRVUVTVEFDQ09VTlRTIiwiRVRIX0FDQ09VTlRTIiwiRVRIX0NIQUlOSUQiLCJFVEhfU0VORFRSQU5TQUNUSU9OIiwiRVRIX1NJR05UWVBFRERBVEEiLCJFVEhfU0lHTlRZUEVEREFUQV9WMyIsIkVUSF9TSUdOVFlQRUREQVRBX1Y0IiwiRVRIX1NJR05UUkFOU0FDVElPTiIsIkVUSF9TSUdOIiwiUEVSU09OQUxfRUNfUkVDT1ZFUiIsImNoYW5uZWxDb25maWciLCJyZWFkeSIsIm9yaWdpbmF0b3JDb25uZWN0U3RhcnRlZCIsIk8iLCJESVNDT05ORUNURUQiLCJXQUlUSU5HIiwiVElNRU9VVCIsIkxJTktFRCIsIlBBVVNFRCIsIlRFUk1JTkFURUQiLCJLRVlfSU5GTyIsIlNFUlZJQ0VfU1RBVFVTIiwiUFJPVklERVJfVVBEQVRFIiwiUlBDX1VQREFURSIsIktFWVNfRVhDSEFOR0VEIiwiSk9JTl9DSEFOTkVMIiwiUFVCTElDX0tFWSIsIkNIQU5ORUxfQ1JFQVRFRCIsIkNMSUVOVFNfQ09OTkVDVEVEIiwiQ0xJRU5UU19ESVNDT05ORUNURUQiLCJDTElFTlRTX1dBSVRJTkciLCJDTElFTlRTX1JFQURZIiwiUkVKRUNURUQiLCJXQUxMRVRfSU5JVCIsIkNIQU5ORUxfUEVSU0lTVEVOQ0UiLCJDT05GSUciLCJNRVNTQUdFX0FDSyIsIlNPQ0tFVF9ESVNDT05ORUNURUQiLCJTT0NLRVRfUkVDT05ORUNUIiwiT1RQIiwiU0RLX1JQQ19DQUxMIiwiQVVUSE9SSVpFRCIsIkNPTk5FQ1RJT05fU1RBVFVTIiwiTUVTU0FHRSIsIlRFUk1JTkFURSIsIktFWV9FWENIQU5HRSIsIktFWV9IQU5EU0hBS0VfU1RBUlQiLCJLRVlfSEFORFNIQUtFX0NIRUNLIiwiS0VZX0hBTkRTSEFLRV9TWU4iLCJLRVlfSEFORFNIQUtFX1NZTkFDSyIsIktFWV9IQU5EU0hBS0VfQUNLIiwiS0VZX0hBTkRTSEFLRV9XQUxMRVQiLCJLRVlfSEFORFNIQUtFX05PTkUiLCIkIiwiY29tbXVuaWNhdGlvbkxheWVyIiwib3RoZXJQdWJsaWNLZXkiLCJsb2dnaW5nIiwia2V5c0V4Y2hhbmdlZCIsInN0ZXAiLCJteUVDSUVTIiwiZWNpZXNMYXllciIsImVjaWVzSW5zdGFuY2UiLCJteVB1YmxpY0tleSIsImtleUV4Y2hhbmdlTGF5ZXIiLCJzZXRPdGhlclB1YmxpY0tleSIsIm9uIiwib25LZXlFeGNoYW5nZU1lc3NhZ2UiLCJiaW5kIiwicmVsYXlQZXJzaXN0ZW5jZSIsInJlbW90ZSIsImVtaXQiLCJjaGVja1N0ZXAiLCJwdWJrZXkiLCJzZW5kTWVzc2FnZSIsInNldFN0ZXAiLCJyZXNldEtleXMiLCJpc09yaWdpbmF0b3IiLCJmb3JjZSIsInByb3RvY29sVmVyc2lvbiIsInNldFJlbGF5UGVyc2lzdGVuY2UiLCJsb2NhbEtleSIsIm90aGVyS2V5Iiwic2V0S2V5c0V4Y2hhbmdlZCIsImFyZUtleXNFeGNoYW5nZWQiLCJnZXRNeVB1YmxpY0tleSIsImdldE90aGVyUHVibGljS2V5IiwiZW5jcnlwdE1lc3NhZ2UiLCJkZWNyeXB0TWVzc2FnZSIsIm90aGVyUHViS2V5Iiwia2V5SW5mbyIsIkFOU1dFUiIsIk9GRkVSIiwiQ0FORElEQVRFIiwiSlNPTlJQQyIsIldBTExFVF9JTkZPIiwiT1JJR0lOQVRPUl9JTkZPIiwiUEFVU0UiLCJQSU5HIiwiUkVBRFkiLCJSRVFVRVNUIiwiUkVRVUVTVF9NT0JJTEUiLCJSRUNPTk5FQ1QiLCJDT05ORUNURUQiLCJDT05ORUNURURfTU9CSUxFIiwiU0RLX1VTRV9FWFRFTlNJT04iLCJTREtfUlBDX1JFUVVFU1QiLCJTREtfUlBDX1JFUVVFU1RfUkVDRUlWRUQiLCJTREtfUlBDX1JFUVVFU1RfRE9ORSIsIlNES19FWFRFTlNJT05fVVRJTElaRUQiLCJTREtfVVNFX0lOQVBQX0JST1dTRVIiLCJjaGFubmVsSWQiLCJwZXJzaXN0ZW5jZSIsIndhbGxldEtleSIsInJlamVjdGVkIiwiZGlzY29ubmVjdCIsInRlcm1pbmF0ZSIsImVtaXRTZXJ2aWNlU3RhdHVzRXZlbnQiLCJnZXRLZXlFeGNoYW5nZSIsImtleUV4Y2hhbmdlIiwiYXV0aG9yaXplZCIsInN0b3JhZ2VNYW5hZ2VyIiwidmFsaWRVbnRpbCIsInNvY2tldCIsImlkIiwiY2xpZW50VHlwZSIsInBlcnNpc3RDaGFubmVsQ29uZmlnIiwic2V0Q29ubmVjdGlvblN0YXR1cyIsImV2ZW50Iiwib3JpZ2luYXRvckluZm8iLCJzZGtWZXJzaW9uIiwiY29tbUxheWVyIiwiY29tbXVuaWNhdGlvbkxheWVyUHJlZmVyZW5jZSIsImNvbW1MYXllclZlcnNpb24iLCJ3YWxsZXRWZXJzaW9uIiwid2FsbGV0SW5mbyIsImNvbW11bmljYXRpb25TZXJ2ZXJVcmwiLCJNIiwiUHJvbWlzZSIsInNldFRpbWVvdXQiLCJlbGFwc2VkVGltZSIsImlzUmVjb25uZWN0aW5nIiwiY29ubmVjdGVkIiwicmVjb25uZWN0aW9uQXR0ZW1wdHMiLCJyZXN1bWVkIiwiY29ubmVjdCIsImhhc1BsYWludGV4dCIsIm1hbnVhbERpc2Nvbm5lY3QiLCJzdWNjZXNzIiwiVSIsIlJQQ19DSEVDSyIsIlNLSVBQRURfUlBDIiwidG9Mb3dlckNhc2UiLCJoYW5kbGVyIiwiY2xpZW50c1BhdXNlZCIsImNsaWVudHNDb25uZWN0ZWQiLCJhY2tJZCIsInBhcnNlIiwicnBjTWV0aG9kVHJhY2tlciIsInRpbWVzdGFtcCIsImFuYWx5dGljcyIsInRyYWNrIiwiY29kZSIsImFjdGlvbiIsInRyYW5zcG9ydF90eXBlIiwiaW8iLCJzZXR1cENoYW5uZWxMaXN0ZW5lcnMiLCJKIiwibGFzdFJwY0lkIiwiZm9jdXNMaXN0ZW5lckFkZGVkIiwicmVtb3ZlRm9jdXNMaXN0ZW5lciIsInJlY29ubmVjdCIsInNlcnZpY2VMYXllciIsImluaXRTb2NrZXQiLCJhdXRvQ29ubmVjdCIsInRyYW5zcG9ydHMiLCJ3aXRoQ3JlZGVudGlhbHMiLCJkb2N1bWVudCIsImhhc0ZvY3VzIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzZW5kUHVibGljS2V5IiwiY3JlYXRlQ2hhbm5lbCIsInB1YktleSIsImNvbm5lY3RUb0NoYW5uZWwiLCJ3aXRoS2V5RXhjaGFuZ2UiLCJrZXlDaGVjayIsInRoZW4iLCJycGNJZCIsInJhY2UiLCJqc29ucnBjIiwiViIsInBpbmciLCJwYXVzZSIsImlzQ29ubmVjdGVkIiwicmVzdW1lIiwiaGFzUmVsYXlQZXJzaXN0ZW5jZSIsImdldFJQQ01ldGhvZFRyYWNrZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJsb2NhbGVDb21wYXJlIiwicGxhdGZvcm1UeXBlIiwiTW9iaWxlV2ViIiwiUmVhY3ROYXRpdmUiLCJNZXRhTWFza01vYmlsZVdlYnZpZXciLCJlZSIsInJlY29ubmVjdGlvbiIsIm9yaWdpbmF0b3JJbmZvU2VudCIsInRlIiwibmUiLCJhdXRvQ29ubmVjdE9wdGlvbnMiLCJ0aW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiaWUiLCJsYXN0QWN0aXZlIiwiZ2V0VGltZSIsInBhdXNlZCIsIm9yaWdpbmF0b3IiLCJvZSIsImFjY291bnRzIiwiY2hhaW5JZCIsIkJvb2xlYW4iLCJkZWVwbGlua1Byb3RvY29sIiwiZGVlcGxpbmtQcm90b2NvbEF2YWlsYWJsZSIsInBlcnNpc3RBY2NvdW50cyIsInBlcnNpc3RDaGFpbklkIiwib3RwQW5zd2VyIiwiYWUiLCJjZSIsInNlIiwicmUiLCJTT0NLRVQiLCJVUkwiLCJkYXBwTWV0YWRhdGEiLCJsb2NhdGlvbiIsImhvc3RuYW1lIiwic291cmNlIiwiZGFwcElkIiwiYW5vbklkIiwiaWNvbiIsImljb25VcmwiLCJiYXNlNjRJY29uIiwicGxhdGZvcm0iLCJhcGlWZXJzaW9uIiwiY29ubmVjdG9yIiwidGVybWluYXRlZCIsIk5vbkJyb3dzZXIiLCJEZXNrdG9wV2ViIiwiZGUiLCJwZXJzaXN0Iiwic2Vzc2lvbkR1cmF0aW9uIiwiX2Nvbm5lY3Rpb25TdGF0dXMiLCJfb3B0aW9ucyIsInN0b3JhZ2UiLCJzZXRNYXhMaXN0ZW5lcnMiLCJkdXJhdGlvbiIsInN0b3JhZ2VPcHRpb25zIiwicmVtb3RlTGF5ZXIiLCJpbml0RnJvbURhcHBTdG9yYWdlIiwiZ2V0UGVyc2lzdGVkQ2hhbm5lbENvbmZpZyIsIm9yaWdpbmF0b3JTZXNzaW9uQ29ubmVjdCIsImdlbmVyYXRlQ2hhbm5lbElkQ29ubmVjdCIsIm9uY2UiLCJ0ZXN0U3RvcmFnZSIsImhhc0RlZXBsaW5rUHJvdG9jb2wiLCJnZXRDaGFubmVsQ29uZmlnIiwiaXNSZWFkeSIsImlzQXV0aG9yaXplZCIsImlzUGF1c2VkIiwiZ2V0Q29tbXVuaWNhdGlvbkxheWVyIiwidGVzdExvZ2dlciIsImdldFNlcnZpY2VTdGF0dXMiLCJnZXRDb25uZWN0aW9uU3RhdHVzIiwiY29ubmVjdGlvblN0YXR1cyIsImdldFZlcnNpb24iLCJnZXRDaGFubmVsSWQiLCJyZWplY3QiLCJyZXNwb25zZSIsIlJFTkVXIiwiTElOSyIsIkVSQzcyMSIsIkVSQzExNTUiLCJtZXNzYWdlc19kZWZhdWx0IiwiZXJyb3JzIiwiZGlzY29ubmVjdGVkIiwicGVybWFuZW50bHlEaXNjb25uZWN0ZWQiLCJzZW5kU2l0ZU1ldGFkYXRhIiwidW5zdXBwb3J0ZWRTeW5jIiwiaW52YWxpZER1cGxleFN0cmVhbSIsImludmFsaWROZXR3b3JrUGFyYW1zIiwiaW52YWxpZFJlcXVlc3RBcmdzIiwiaW52YWxpZFJlcXVlc3RNZXRob2QiLCJpbnZhbGlkUmVxdWVzdFBhcmFtcyIsImludmFsaWRMb2dnZXJPYmplY3QiLCJpbnZhbGlkTG9nZ2VyTWV0aG9kIiwid2FybmluZ3MiLCJjaGFpbklkRGVwcmVjYXRpb24iLCJuZXR3b3JrVmVyc2lvbkRlcHJlY2F0aW9uIiwic2VsZWN0ZWRBZGRyZXNzRGVwcmVjYXRpb24iLCJlbmFibGVEZXByZWNhdGlvbiIsInNlbmREZXByZWNhdGlvbiIsImV2ZW50cyIsImNsb3NlIiwibmV0d29ya0NoYW5nZWQiLCJub3RpZmljYXRpb24iLCJycGMiLCJldGhEZWNyeXB0RGVwcmVjYXRpb24iLCJldGhHZXRFbmNyeXB0aW9uUHVibGljS2V5RGVwcmVjYXRpb24iLCJ3YWxsZXRXYXRjaEFzc2V0TkZURXhwZXJpbWVudGFsIiwiZXhwZXJpbWVudGFsTWV0aG9kcyIsImNyZWF0ZVJwY1dhcm5pbmdNaWRkbGV3YXJlIiwibG9nIiwic2VudFdhcm5pbmdzIiwicmVxIiwiX3JlcyIsIm5leHQiLCJ3YXJuIiwiTUFYIiwiaWRDb3VudGVyIiwicmFuZG9tIiwiY3JlYXRlSWRSZW1hcE1pZGRsZXdhcmUiLCJyZXF1ZXN0IiwiX2VuZCIsIm9yaWdpbmFsSWQiLCJuZXdJZCIsImRvbmUiLCJfX2FjY2Vzc0NoZWNrIiwib2JqIiwibWVtYmVyIiwiaGFzIiwiVHlwZUVycm9yIiwiX19wcml2YXRlR2V0IiwiZ2V0dGVyIiwiX19wcml2YXRlQWRkIiwiV2Vha1NldCIsIl9fcHJpdmF0ZVNldCIsInNldHRlciIsIl9fcHJpdmF0ZU1ldGhvZCIsImVycm9yQ29kZXMiLCJpbnZhbGlkSW5wdXQiLCJyZXNvdXJjZU5vdEZvdW5kIiwicmVzb3VyY2VVbmF2YWlsYWJsZSIsInRyYW5zYWN0aW9uUmVqZWN0ZWQiLCJtZXRob2ROb3RTdXBwb3J0ZWQiLCJsaW1pdEV4Y2VlZGVkIiwiaW52YWxpZFJlcXVlc3QiLCJtZXRob2ROb3RGb3VuZCIsImludmFsaWRQYXJhbXMiLCJpbnRlcm5hbCIsImVycm9yVmFsdWVzIiwic3RhbmRhcmQiLCJpc09iamVjdCIsImhhc1Byb3BlcnR5Iiwib2JqZWN0VG9DaGVjayIsIlN0cnVjdEVycm9yIiwiZmFpbHVyZSIsImZhaWx1cmVzIiwiY2FjaGVkIiwiZXhwbGFuYXRpb24iLCJyZXN0IiwicGF0aCIsImpvaW4iLCJjYXVzZSIsInByaW50IiwidG9GYWlsdXJlIiwic3RydWN0IiwiYnJhbmNoIiwicmVmaW5lbWVudCIsInRvRmFpbHVyZXMiLCJTeW1ib2wiLCJpdGVyYXRvciIsImlzSXRlcmFibGUiLCJydW4iLCJjb2VyY2UiLCJjb2VyY2VyIiwic2NoZW1hIiwic3RhdHVzIiwidmFsaWRhdG9yIiwiTWFwIiwiU2V0IiwicmVmaW5lciIsIlN0cnVjdCIsInByb3BzIiwidmFsaWRhdGUiLCJ0dXBsZXMiLCJ0dXBsZSIsInNoaWZ0SXRlcmF0b3IiLCJkZWZpbmUiLCJsYXp5IiwiRWxlbWVudCIsImxpdGVyYWwiLCJjb25zdGFudCIsImlzTmFOIiwia25vd25zIiwia2V5cyIsIk5ldmVyIiwidW5rbm93bnMiLCJvcHRpb25hbCIsInJlY29yZCIsIktleSIsIlZhbHVlIiwidW5pb24iLCJTdHJ1Y3RzIiwiY29lcmNlZCIsImdldEVycm9yTWVzc2FnZVdpdGhvdXRUcmFpbGluZ1BlcmlvZCIsImlzRXJyb3JXaXRoTWVzc2FnZSIsImdldEVycm9yTWVzc2FnZSIsInJlcGxhY2UiLCJnZXRFcnJvciIsIkVycm9yV3JhcHBlciIsIkFzc2VydGlvbkVycm9yIiwic3VwZXJzdHJ1Y3RPYmplY3QiLCJoYXNPcHRpb25hbCIsImV4YWN0T3B0aW9uYWwiLCJVbnNhZmVKc29uU3RydWN0IiwiaXNGaW5pdGUiLCJKc29uU3RydWN0IiwiZXJyb3JQcmVmaXgiLCJhc3NlcnRTdXBlcnN0cnVjdCIsImFzc2VydFN0cnVjdCIsInByb3BLZXkiLCJwcm9wVmFsdWUiLCJpc1ZhbGlkSnNvbiIsImdldFNhZmVKc29uIiwiSnNvblJwY1ZlcnNpb25TdHJ1Y3QiLCJKc29uUnBjSWRTdHJ1Y3QiLCJudWxsYWJsZSIsIkpzb25ScGNFcnJvclN0cnVjdCIsImlzSW50ZWdlciIsInN0YWNrIiwiSnNvblJwY1BhcmFtc1N0cnVjdCIsIkpzb25ScGNSZXF1ZXN0U3RydWN0IiwiSnNvblJwY05vdGlmaWNhdGlvblN0cnVjdCIsImlzSnNvblJwY1JlcXVlc3QiLCJpc0pzb25ScGNFcnJvciIsIkZBTExCQUNLX0VSUk9SX0NPREUiLCJGQUxMQkFDS19NRVNTQUdFIiwiRkFMTEJBQ0tfRVJST1IiLCJnZXRNZXNzYWdlRnJvbUNvZGUiLCJKU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRSIsImZhbGxiYWNrTWVzc2FnZSIsImlzVmFsaWRDb2RlIiwiY29kZVN0cmluZyIsImlzSnNvblJwY1NlcnZlckVycm9yIiwic2VyaWFsaXplRXJyb3IiLCJmYWxsYmFja0Vycm9yIiwic2hvdWxkSW5jbHVkZVN0YWNrIiwic2VyaWFsaXplZCIsInNlcmlhbGl6ZSIsInNlcmlhbGl6ZUNhdXNlIiwiZmFsbGJhY2tXaXRoQ2F1c2UiLCJidWlsZEVycm9yIiwiZW50cnkiLCJzZXJpYWxpemVPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZmFzdFNhZmVTdHJpbmdpZnkiLCJzdGFibGUiLCJkZXRlcm1pbmlzdGljU3RyaW5naWZ5Iiwic3RhYmxlU3RyaW5naWZ5IiwiTElNSVRfUkVQTEFDRV9OT0RFIiwiQ0lSQ1VMQVJfUkVQTEFDRV9OT0RFIiwicmVwbGFjZXJTdGFjayIsImRlZmF1bHRPcHRpb25zIiwiZGVwdGhMaW1pdCIsIk1BWF9TQUZFX0lOVEVHRVIiLCJlZGdlc0xpbWl0IiwicmVwbGFjZXIiLCJzcGFjZXIiLCJkZWNpcmMiLCJyZXBsYWNlR2V0dGVyVmFsdWVzIiwicGFydCIsInBvcCIsInNldFJlcGxhY2UiLCJwYXJlbnQiLCJwcm9wZXJ0eURlc2NyaXB0b3IiLCJlZGdlSW5kZXgiLCJkZXB0aCIsImNvbXBhcmVGdW5jdGlvbiIsImRldGVybWluaXN0aWNEZWNpcmMiLCJ0b0pTT04iLCJzb3J0Iiwic3BsaWNlIiwiSnNvblJwY0Vycm9yIiwicHJvdG8iLCJpc1BsYWluT2JqZWN0Iiwic2FmZVN0cmluZ2lmeSIsInN0cmluZ2lmeVJlcGxhY2VyIiwicnBjRXJyb3JzIiwiZ2V0SnNvblJwY0Vycm9yIiwicGFyc2VPcHRzIiwic2FmZUV2ZW50RW1pdHRlciIsImV2ZW50c18xIiwic2FmZUFwcGx5IiwiUmVmbGVjdCIsImVyciIsIlNhZmVFdmVudEVtaXR0ZXIkMSIsIkV2ZW50RW1pdHRlciIsImRvRXJyb3IiLCJfZXZlbnRzIiwiZXIiLCJsaXN0ZW5lcnMiLCJjb3B5IiwiYXJyYXlDbG9uZSIsIl9pc0Rlc3Ryb3llZCIsIl9taWRkbGV3YXJlIiwiX25vdGlmaWNhdGlvbkhhbmRsZXIiLCJfYXNzZXJ0SXNOb3REZXN0cm95ZWQiLCJhc3NlcnRJc05vdERlc3Ryb3llZF9mbiIsIl9oYW5kbGVCYXRjaCIsImhhbmRsZUJhdGNoX2ZuIiwiX2hhbmRsZSIsImhhbmRsZV9mbiIsIl9wcm9jZXNzUmVxdWVzdCIsInByb2Nlc3NSZXF1ZXN0X2ZuIiwiX3J1bkFsbE1pZGRsZXdhcmUiLCJydW5BbGxNaWRkbGV3YXJlX2ZuIiwiX3J1bk1pZGRsZXdhcmUiLCJydW5NaWRkbGV3YXJlX2ZuIiwiX3J1blJldHVybkhhbmRsZXJzIiwicnVuUmV0dXJuSGFuZGxlcnNfZm4iLCJfY2hlY2tGb3JDb21wbGV0aW9uIiwiY2hlY2tGb3JDb21wbGV0aW9uX2ZuIiwiX2RlZmF1bHQiLCJTYWZlRXZlbnRFbWl0dGVyIiwiX0pzb25ScGNFbmdpbmUiLCJub3RpZmljYXRpb25IYW5kbGVyIiwibWlkZGxld2FyZSIsImhhbmRsZSIsIl9wcm9taXNlSGFuZGxlIiwiYXNNaWRkbGV3YXJlIiwiZW5kIiwiX2IiLCJtaWRkbGV3YXJlRXJyb3IiLCJpc0NvbXBsZXRlIiwicmV0dXJuSGFuZGxlcnMiLCJoYW5kbGVyQ2FsbGJhY2siLCJfYTIiLCJyZXNvbHZlIiwicmVxdWVzdHMiLCJyZXNwb25zZXMiLCJhbGwiLCJmaWx0ZXIiLCJjYWxsZXJSZXEiLCJlcnJvcjIiLCJfZXJyb3IiLCJtaWRkbGV3YXJlcyIsInBhcnNlZEVycm9yIiwicmV0dXJuSGFuZGxlciIsImpzb25pZnkiLCJoYW5kbGVycyIsIkpzb25ScGNFbmdpbmUiLCJFTUlUVEVEX05PVElGSUNBVElPTlMiLCJnZXREZWZhdWx0RXh0ZXJuYWxNaWRkbGV3YXJlIiwibG9nZ2VyIiwiY29uc29sZSIsImNyZWF0ZUVycm9yTWlkZGxld2FyZSIsImdldFJwY1Byb21pc2VDYWxsYmFjayIsInVud3JhcFJlc3VsdCIsImlzVmFsaWRDaGFpbklkIiwiTk9PUCIsImVuZ2luZSIsImRvbWFpbk1ldGFkYXRhIiwiZ2V0U2l0ZU5hbWUiLCJnZXRTaXRlSWNvbiIsImdldFNpdGVNZXRhZGF0YSIsIm9yaWdpbmFsRXJyb3IiLCJ3aW5kb3dPYmplY3QiLCJkb2N1bWVudDIiLCJzaXRlTmFtZSIsInF1ZXJ5U2VsZWN0b3IiLCJjb250ZW50IiwibWV0YVRpdGxlIiwiaWNvbnMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaW1nRXhpc3RzIiwiaHJlZiIsImltZyIsImNyZWF0ZUVsZW1lbnQiLCJvbmxvYWQiLCJvbmVycm9yIiwiX2NoYWluSWQiLCJfc2VsZWN0ZWRBZGRyZXNzIiwiZmFzdERlZXBFcXVhbCIsImVxdWFsIiwiUmVnRXhwIiwiZmxhZ3MiLCJ2YWx1ZU9mIiwiX0Jhc2VQcm92aWRlciIsIm1heEV2ZW50TGlzdGVuZXJzIiwicnBjTWlkZGxld2FyZSIsIl9sb2ciLCJfc3RhdGUiLCJfZGVmYXVsdFN0YXRlIiwiX2hhbmRsZUFjY291bnRzQ2hhbmdlZCIsIl9oYW5kbGVDb25uZWN0IiwiX2hhbmRsZUNoYWluQ2hhbmdlZCIsIl9oYW5kbGVEaXNjb25uZWN0IiwiX2hhbmRsZVVubG9ja1N0YXRlQ2hhbmdlZCIsIl9ycGNSZXF1ZXN0IiwicnBjRW5naW5lIiwiX3JwY0VuZ2luZSIsInNlbGVjdGVkQWRkcmVzcyIsInBheWxvYWQiLCJfaW5pdGlhbGl6ZVN0YXRlIiwiaW5pdGlhbFN0YXRlIiwiaW5pdGlhbGl6ZWQiLCJpc1VubG9ja2VkIiwibmV0d29ya1ZlcnNpb24iLCJjYWxsYmFja1dyYXBwZXIiLCJpc1JlY292ZXJhYmxlIiwiZXJyb3JNZXNzYWdlIiwiaXNQZXJtYW5lbnRseURpc2Nvbm5lY3RlZCIsImlzRXRoQWNjb3VudHMiLCJfYWNjb3VudHMiLCJhY2NvdW50IiwiZGVxdWFsIiwiX25leHRBY2NvdW50cyIsIkJhc2VQcm92aWRlciIsInN0cmVhbUJyb3dzZXIiLCJvd25LZXlzIiwiZW51bWVyYWJsZU9ubHkiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwic3ltIiwiX29iamVjdFNwcmVhZCIsInRhcmdldCIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiX3RvUHJvcGVydHlLZXkiLCJfY3JlYXRlQ2xhc3MiLCJDb25zdHJ1Y3RvciIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsImRlc2NyaXB0b3IiLCJfZGVmaW5lUHJvcGVydGllcyIsImhpbnQiLCJwcmltIiwidG9QcmltaXRpdmUiLCJfdG9QcmltaXRpdmUiLCJpbnNwZWN0IiwiY3VzdG9tIiwiYnVmZmVyX2xpc3QiLCJCdWZmZXJMaXN0IiwiX2NsYXNzQ2FsbENoZWNrIiwicmV0IiwiYWxsb2MiLCJhbGxvY1Vuc2FmZSIsImhhc1N0cmluZ3MiLCJfZ2V0U3RyaW5nIiwiX2dldEJ1ZmZlciIsIm5iIiwiY3VzdG9tSW5zcGVjdCIsImVtaXRFcnJvckFuZENsb3NlTlQiLCJzZWxmIiwiZW1pdEVycm9yTlQiLCJlbWl0Q2xvc2VOVCIsIl93cml0YWJsZVN0YXRlIiwiZW1pdENsb3NlIiwiX3JlYWRhYmxlU3RhdGUiLCJkZXN0cm95XzEiLCJfdGhpcyIsInJlYWRhYmxlRGVzdHJveWVkIiwid3JpdGFibGVEZXN0cm95ZWQiLCJlcnJvckVtaXR0ZWQiLCJfZGVzdHJveSIsInVuZGVzdHJveSIsInJlYWRpbmciLCJlbmRlZCIsImVuZEVtaXR0ZWQiLCJlbmRpbmciLCJmaW5hbENhbGxlZCIsInByZWZpbmlzaGVkIiwiZXJyb3JPckRlc3Ryb3kiLCJzdHJlYW0iLCJyU3RhdGUiLCJ3U3RhdGUiLCJhdXRvRGVzdHJveSIsImNvZGVzIiwiY3JlYXRlRXJyb3JUeXBlIiwiQmFzZSIsIk5vZGVFcnJvciIsIl9CYXNlIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiYXJnMSIsImFyZzIiLCJhcmczIiwiZ2V0TWVzc2FnZSIsIl9fcHJvdG9fXyIsIm9uZU9mIiwiZXhwZWN0ZWQiLCJ0aGluZyIsImNvbmNhdCIsImFjdHVhbCIsImRldGVybWluZXIiLCJzZWFyY2giLCJzdWJzdHIiLCJ0aGlzX2xlbiIsInN1YnN0cmluZyIsImVycm9yc0Jyb3dzZXIiLCJFUlJfSU5WQUxJRF9PUFRfVkFMVUUiLCJnZXRIaWdoV2F0ZXJNYXJrIiwiZHVwbGV4S2V5IiwiaXNEdXBsZXgiLCJod20iLCJoaWdoV2F0ZXJNYXJrIiwiaGlnaFdhdGVyTWFya0Zyb20iLCJvYmplY3RNb2RlIiwiY29uZmlnIiwid2FybmVkIiwidHJhY2UiLCJnbG9iYWwiLCJsb2NhbFN0b3JhZ2UiLCJDb3JrZWRSZXF1ZXN0IiwiZmluaXNoIiwiY29ya1JlcSIsInBlbmRpbmdjYiIsImNvcmtlZFJlcXVlc3RzRnJlZSIsIm9uQ29ya2VkRmluaXNoIiwiRHVwbGV4IiwiX3N0cmVhbV93cml0YWJsZSIsIldyaXRhYmxlIiwiV3JpdGFibGVTdGF0ZSIsImludGVybmFsVXRpbCIsImRlcHJlY2F0ZSIsIlN0cmVhbSIsIk91clVpbnQ4QXJyYXkiLCJyZWFsSGFzSW5zdGFuY2UiLCJkZXN0cm95SW1wbCIsIl9yZXF1aXJlJGNvZGVzIiwiRVJSX0lOVkFMSURfQVJHX1RZUEUiLCJFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCIsIkVSUl9NVUxUSVBMRV9DQUxMQkFDSyIsIkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUiLCJFUlJfU1RSRUFNX0RFU1RST1lFRCIsIkVSUl9TVFJFQU1fTlVMTF9WQUxVRVMiLCJFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCIsIkVSUl9VTktOT1dOX0VOQ09ESU5HIiwibm9wIiwicmVxdWlyZSQkNyIsIndyaXRhYmxlT2JqZWN0TW9kZSIsIm5lZWREcmFpbiIsIm5vRGVjb2RlIiwiZGVjb2RlU3RyaW5ncyIsImRlZmF1bHRFbmNvZGluZyIsIndyaXRpbmciLCJjb3JrZWQiLCJzeW5jIiwiYnVmZmVyUHJvY2Vzc2luZyIsIm9ud3JpdGUiLCJ3cml0ZWNiIiwid3JpdGVsZW4iLCJvbndyaXRlU3RhdGVVcGRhdGUiLCJmaW5pc2hNYXliZSIsIm9ud3JpdGVFcnJvciIsIm5lZWRGaW5pc2giLCJidWZmZXJlZFJlcXVlc3QiLCJjbGVhckJ1ZmZlciIsImFmdGVyV3JpdGUiLCJsYXN0QnVmZmVyZWRSZXF1ZXN0IiwiYnVmZmVyZWRSZXF1ZXN0Q291bnQiLCJ3cml0ZSIsIl93cml0ZSIsIndyaXRldiIsIl93cml0ZXYiLCJmaW5hbCIsIl9maW5hbCIsImRvV3JpdGUiLCJjaHVuayIsImVuY29kaW5nIiwib253cml0ZURyYWluIiwiaG9sZGVyIiwiYWxsQnVmZmVycyIsImlzQnVmIiwiY2FsbEZpbmFsIiwibmVlZCIsInByZWZpbmlzaCIsImdldEJ1ZmZlciIsImN1cnJlbnQiLCJoYXNJbnN0YW5jZSIsIkZ1bmN0aW9uIiwicGlwZSIsImlzQnVmZmVyIiwiX3VpbnQ4QXJyYXlUb0J1ZmZlciIsIndyaXRlQWZ0ZXJFbmQiLCJ2YWxpZENodW5rIiwibmV3Q2h1bmsiLCJkZWNvZGVDaHVuayIsImxhc3QiLCJ3cml0ZU9yQnVmZmVyIiwiY29yayIsInVuY29yayIsInNldERlZmF1bHRFbmNvZGluZyIsImVuZFdyaXRhYmxlIiwiX3VuZGVzdHJveSIsIm9iamVjdEtleXMiLCJfc3RyZWFtX2R1cGxleCIsIlJlYWRhYmxlIiwiYWxsb3dIYWxmT3BlbiIsInJlYWRhYmxlIiwib25lbmQiLCJvbkVuZE5UIiwiRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UiLCJub29wIiwiZW5kT2ZTdHJlYW0iLCJlb3MiLCJjYWxsZWQiLCJfbGVuIiwib25sZWdhY3lmaW5pc2giLCJvbmZpbmlzaCIsIndyaXRhYmxlRW5kZWQiLCJyZWFkYWJsZUVuZGVkIiwib25jbG9zZSIsIm9ucmVxdWVzdCIsInNldEhlYWRlciIsImFib3J0IiwiaXNSZXF1ZXN0IiwicmVtb3ZlTGlzdGVuZXIiLCJfT2JqZWN0JHNldFByb3RvdHlwZU8iLCJrTGFzdFJlc29sdmUiLCJrTGFzdFJlamVjdCIsImtFcnJvciIsImtFbmRlZCIsImtMYXN0UHJvbWlzZSIsImtIYW5kbGVQcm9taXNlIiwia1N0cmVhbSIsImNyZWF0ZUl0ZXJSZXN1bHQiLCJyZWFkQW5kUmVzb2x2ZSIsIml0ZXIiLCJyZWFkIiwib25SZWFkYWJsZSIsIkFzeW5jSXRlcmF0b3JQcm90b3R5cGUiLCJSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUiLCJzZXRQcm90b3R5cGVPZiIsInByb21pc2UiLCJsYXN0UHJvbWlzZSIsIndyYXBGb3JOZXh0IiwiYXN5bmNJdGVyYXRvciIsIl90aGlzMiIsImFzeW5jX2l0ZXJhdG9yIiwiX09iamVjdCRjcmVhdGUiLCJfc3RyZWFtX3JlYWRhYmxlIiwiUmVhZGFibGVTdGF0ZSIsIkVFbGlzdGVuZXJDb3VudCIsImVtaXR0ZXIiLCJkZWJ1Z1V0aWwiLCJkZWJ1Z2xvZyIsIlN0cmluZ0RlY29kZXIiLCJjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IiLCJFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GIiwiRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCIsInJlcXVpcmUkJDgiLCJrUHJveHlFdmVudHMiLCJyZXF1aXJlJCQ5IiwicmVhZGFibGVPYmplY3RNb2RlIiwicGlwZXMiLCJwaXBlc0NvdW50IiwiZmxvd2luZyIsIm5lZWRSZWFkYWJsZSIsImVtaXR0ZWRSZWFkYWJsZSIsInJlYWRhYmxlTGlzdGVuaW5nIiwicmVzdW1lU2NoZWR1bGVkIiwiYXdhaXREcmFpbiIsInJlYWRpbmdNb3JlIiwiZGVjb2RlciIsInJlcXVpcmUkJDEwIiwiX3JlYWQiLCJyZWFkYWJsZUFkZENodW5rIiwiYWRkVG9Gcm9udCIsInNraXBDaHVua0NoZWNrIiwiZW1pdFJlYWRhYmxlIiwiZW1pdFJlYWRhYmxlXyIsIm9uRW9mQ2h1bmsiLCJjaHVua0ludmFsaWQiLCJhZGRDaHVuayIsIm1heWJlUmVhZE1vcmUiLCJ1bnNoaWZ0Iiwic2V0RW5jb2RpbmciLCJlbmMiLCJjbGVhciIsIk1BWF9IV00iLCJob3dNdWNoVG9SZWFkIiwiY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsiLCJmbG93IiwibWF5YmVSZWFkTW9yZV8iLCJ1cGRhdGVSZWFkYWJsZUxpc3RlbmluZyIsImxpc3RlbmVyQ291bnQiLCJuUmVhZGluZ05leHRUaWNrIiwicmVzdW1lXyIsImZyb21MaXN0IiwiY29uc3VtZSIsImVuZFJlYWRhYmxlIiwiZW5kUmVhZGFibGVOVCIsInhzIiwibk9yaWciLCJkb1JlYWQiLCJkZXN0IiwicGlwZU9wdHMiLCJlbmRGbiIsInN0ZG91dCIsInN0ZGVyciIsInVucGlwZSIsIm9udW5waXBlIiwidW5waXBlSW5mbyIsImhhc1VucGlwZWQiLCJvbmRyYWluIiwib25kYXRhIiwiY2xlYW5lZFVwIiwicGlwZU9uRHJhaW4iLCJwcmVwZW5kTGlzdGVuZXIiLCJkZXN0cyIsImluZGV4IiwiZXYiLCJhZGRMaXN0ZW5lciIsIndyYXAiLCJyZXF1aXJlJCQxMSIsIl9mcm9tTGlzdCIsIml0ZXJhYmxlIiwiZnJvbUJyb3dzZXIiLCJfc3RyZWFtX3RyYW5zZm9ybSIsIlRyYW5zZm9ybSIsIkVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkciLCJFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAiLCJhZnRlclRyYW5zZm9ybSIsIl90cmFuc2Zvcm1TdGF0ZSIsInRyYW5zZm9ybWluZyIsIndyaXRlY2h1bmsiLCJycyIsIm5lZWRUcmFuc2Zvcm0iLCJ3cml0ZWVuY29kaW5nIiwiX3RyYW5zZm9ybSIsImZsdXNoIiwiX2ZsdXNoIiwiZXJyMiIsIl9zdHJlYW1fcGFzc3Rocm91Z2giLCJQYXNzVGhyb3VnaCIsIkVSUl9NSVNTSU5HX0FSR1MiLCJwaXBlbGluZV8xIiwic3RyZWFtcyIsInBvcENhbGxiYWNrIiwiZGVzdHJveXMiLCJjbG9zZWQiLCJkZXN0cm95ZXIiLCJwaXBlbGluZSIsImNyZWF0ZVN0cmVhbU1pZGRsZXdhcmUiLCJpZE1hcCIsIl9lbmNvZGluZyIsInN0cmVhbVdyaXRlQ2FsbGJhY2siLCJlcnJvck9iaiIsIm5vdGlmIiwicmV0cnlPbk1lc3NhZ2UiLCJ2YWx1ZXMiLCJyZXRyeUNvdW50IiwiaWRNYXBPYmplY3QiLCJzZW5kVG9TdHJlYW0iLCJwcm9jZXNzTm90aWZpY2F0aW9uIiwicmVzcG9uc2VJZCIsInByb2Nlc3NSZXNwb25zZSIsIl9lcnIiLCJ3cmFwcHlfMSIsIndyYXBweSIsIndyYXBwZXIiLCJvbmNlU3RyaWN0Iiwib25jZUVycm9yIiwib25jZU1vZHVsZSIsInN0cmljdCIsIlN1YnN0cmVhbV8xIiwiU3Vic3RyZWFtIiwicmVhZGFibGVfc3RyZWFtXzEiLCJfcGFyZW50IiwiX25hbWUiLCJfX2ltcG9ydERlZmF1bHQiLCJPYmplY3RNdWx0aXBsZXhfMSIsIk9iamVjdE11bHRpcGxleCIsIm9uY2VfMSIsIklHTk9SRV9TVUJTVFJFQU0iLCJPYmplY3RNdWx0aXBsZXgkMSIsIl9zdWJzdHJlYW1zIiwiY3JlYXRlU3RyZWFtIiwic3Vic3RyZWFtIiwiX2NiIiwiYW55U3RyZWFtRW5kIiwiaWdub3JlU3RyZWFtIiwiaXNTdHJlYW0iLCJkdXBsZXgiLCJfbmV0d29ya1ZlcnNpb24iLCJpc1N0cmVhbV8xIiwiQWJzdHJhY3RTdHJlYW1Qcm92aWRlciIsImNvbm5lY3Rpb25TdHJlYW0iLCJqc29uUnBjU3RyZWFtTmFtZSIsIl9oYW5kbGVTdHJlYW1EaXNjb25uZWN0IiwibXV4IiwiX2pzb25ScGNDb25uZWN0aW9uIiwiX2luaXRpYWxpemVTdGF0ZUFzeW5jIiwic3RyZWFtTmFtZSIsIndhcm5pbmdNc2ciLCJpc1ZhbGlkTmV0d29ya1ZlcnNpb24iLCJNZXRhTWFza0lucGFnZVByb3ZpZGVyIiwic2hvdWxkU2VuZE1ldGFkYXRhIiwiX3NlbnRXYXJuaW5ncyIsInNlbmQiLCJpc01ldGFNYXNrIiwiX3NlbmRTeW5jIiwic2VuZEFzeW5jIiwiX3dhcm5PZkRlcHJlY2F0aW9uIiwiX21ldGFtYXNrIiwiX2dldEV4cGVyaW1lbnRhbEFwaSIsInJlYWR5U3RhdGUiLCJkb21Db250ZW50TG9hZGVkSGFuZGxlciIsImV2ZW50TmFtZSIsImxpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsIm1ldGhvZE9yUGF5bG9hZCIsImNhbGxiYWNrT3JBcmdzIiwiUHJveHkiLCJyZXF1ZXN0QmF0Y2giLCJwcm9wIiwiX3ByZXZpb3VzQ2hhaW5JZCIsImNsYXNzZXMiLCJFdGhlcmV1bVByb3ZpZGVyRXJyb3IiLCJFdGhlcmV1bVJwY0Vycm9yIiwiZmFzdF9zYWZlX3N0cmluZ2lmeV8xIiwiaXNWYWxpZEV0aFByb3ZpZGVyQ29kZSIsImVycm9yQ29uc3RhbnRzIiwicHJvdmlkZXIiLCJ1c2VyUmVqZWN0ZWRSZXF1ZXN0IiwidW5hdXRob3JpemVkIiwidW5zdXBwb3J0ZWRNZXRob2QiLCJjaGFpbkRpc2Nvbm5lY3RlZCIsImVycm9yX2NvbnN0YW50c18xIiwiY2xhc3Nlc18xIiwiaGFzS2V5IiwiYXNzaWduT3JpZ2luYWxFcnJvciIsImV0aEVycm9ycyIsImdldEV0aEpzb25ScGNFcnJvciIsImdldEV0aFByb3ZpZGVyRXJyb3IiLCJzZXJ2ZXIiLCJlcnJvcnNfMSIsInRvU3RyaW5nVGFnIiwiZ2V0Rmlyc3RNYXRjaCIsIm1hdGNoIiwiZ2V0U2Vjb25kTWF0Y2giLCJtYXRjaEFuZFJldHVybkNvbnN0IiwiZ2V0V2luZG93c1ZlcnNpb25OYW1lIiwiZ2V0TWFjT1NWZXJzaW9uTmFtZSIsImdldEFuZHJvaWRWZXJzaW9uTmFtZSIsImdldFZlcnNpb25QcmVjaXNpb24iLCJjb21wYXJlVmVyc2lvbnMiLCJmaW5kIiwiZ2V0QnJvd3NlckFsaWFzIiwiQlJPV1NFUl9BTElBU0VTX01BUCIsImdldEJyb3dzZXJUeXBlQnlBbGlhcyIsIkJST1dTRVJfTUFQIiwiRU5HSU5FX01BUCIsIk9TX01BUCIsIlBMQVRGT1JNU19NQVAiLCJCYWRhIiwiQmxhY2tCZXJyeSIsIkNocm9tZSIsIkNocm9taXVtIiwiRWxlY3Ryb24iLCJFcGlwaGFueSIsIkZpcmVmb3giLCJGb2N1cyIsIkdlbmVyaWMiLCJHb29nbGVib3QiLCJNYXh0aG9uIiwiT3BlcmEiLCJQaGFudG9tSlMiLCJQdWZmaW4iLCJRdXBaaWxsYSIsIlFRIiwiUVFMaXRlIiwiU2FmYXJpIiwiU2FpbGZpc2giLCJTZWFNb25rZXkiLCJTbGVpcG5pciIsIlN3aW5nIiwiVGl6ZW4iLCJWaXZhbGRpIiwiV2VDaGF0IiwiUm9rdSIsImFtYXpvbl9zaWxrIiwiYW5kcm9pZCIsImJhZGEiLCJibGFja2JlcnJ5IiwiY2hyb21lIiwiY2hyb21pdW0iLCJlbGVjdHJvbiIsImVwaXBoYW55IiwiZmlyZWZveCIsImZvY3VzIiwiZ2VuZXJpYyIsImdvb2dsZWJvdCIsImdvb2dsZV9zZWFyY2giLCJrX21lbGVvbiIsIm1heHRob24iLCJlZGdlIiwibXoiLCJuYXZlciIsIm9wZXJhIiwib3BlcmFfY29hc3QiLCJwaGFudG9tanMiLCJwdWZmaW4iLCJxdXB6aWxsYSIsInFxIiwicXFsaXRlIiwic2FmYXJpIiwic2FpbGZpc2giLCJzYW1zdW5nX2ludGVybmV0Iiwic2VhbW9ua2V5Iiwic2xlaXBuaXIiLCJzd2luZyIsInRpemVuIiwidWMiLCJ2aXZhbGRpIiwid2Vib3MiLCJ3ZWNoYXQiLCJ5YW5kZXgiLCJ0YWJsZXQiLCJtb2JpbGUiLCJkZXNrdG9wIiwiV2luZG93c1Bob25lIiwiV2luZG93cyIsIk1hY09TIiwiaU9TIiwiQW5kcm9pZCIsIldlYk9TIiwiTGludXgiLCJDaHJvbWVPUyIsIlBsYXlTdGF0aW9uNCIsIkVkZ2VIVE1MIiwiQmxpbmsiLCJUcmlkZW50IiwiUHJlc3RvIiwiR2Vja28iLCJXZWJLaXQiLCJnZXRQYXJzZXIiLCJnZXRSZXN1bHQiLCJfdWEiLCJwYXJzZWRSZXN1bHQiLCJnZXRVQSIsInBhcnNlQnJvd3NlciIsImRlc2NyaWJlIiwiZ2V0QnJvd3NlciIsImdldEJyb3dzZXJOYW1lIiwiZ2V0QnJvd3NlclZlcnNpb24iLCJnZXRPUyIsIm9zIiwicGFyc2VPUyIsImdldE9TTmFtZSIsImdldE9TVmVyc2lvbiIsImdldFBsYXRmb3JtIiwicGFyc2VQbGF0Zm9ybSIsImdldFBsYXRmb3JtVHlwZSIsImdldEVuZ2luZSIsInBhcnNlRW5naW5lIiwiZ2V0RW5naW5lTmFtZSIsInNhdGlzZmllcyIsImlzT1MiLCJpc1BsYXRmb3JtIiwiaXNCcm93c2VyIiwiY29tcGFyZVZlcnNpb24iLCJpc0VuZ2luZSIsInZlcnNpb25OYW1lIiwidmVuZG9yIiwibW9kZWwiLCJNZXRhTWFza1NES0V2ZW50IiwiSW5pdGlhbGl6ZWQiLCJEaXNwbGF5VVJJIiwiUHJvdmlkZXJVcGRhdGUiLCJDb25uZWN0V2l0aFJlc3BvbnNlIiwiQ29ubmVjdGlvblN0YXR1cyIsIlNlcnZpY2VTdGF0dXMiLCJFdGhlcmV1bSIsInNob3VsZFNldE9uV2luZG93Iiwic2hvdWxkU2hpbVdlYjMiLCJzZGtJbnN0YW5jZSIsIlNES1Byb3ZpZGVyIiwiYXV0b1JlcXVlc3RBY2NvdW50cyIsInByb3hpZWRQcm92aWRlciIsImRlbGV0ZVByb3BlcnR5IiwicHJvdmlkZXJJbnN0YW5jZSIsImV0aGVyZXVtIiwiZGlzcGF0Y2hFdmVudCIsIkV2ZW50IiwibG9nZ2VkQ3VycmVudFByb3ZpZGVyIiwibG9nZ2VkTWlzc2luZ1Byb3BlcnR5Iiwid2ViMyIsIlNISU1fSURFTlRJRklFUiIsIndlYjNTaGltIiwiY3VycmVudFByb3ZpZGVyIiwicHJvcGVydHkiLCJzaGltV2ViMyIsInVyaSIsImdldENoYWluSWQiLCJnZXRTZWxlY3RlZEFkZHJlc3MiLCJnZXROZXR3b3JrVmVyc2lvbiIsImluaXQiLCJnZXRJbnN0YW5jZSIsImdldFByb3ZpZGVyIiwiUGxhdGZvcm1NYW5hZ2VyIiwidXNlRGVlcExpbmsiLCJwcmVmZXJyZWRPcGVuTGluayIsInVzZURlZXBsaW5rIiwib3BlbkRlZXBsaW5rIiwidW5pdmVyc2FsTGluayIsImRlZXBsaW5rIiwibGluayIsInJlbCIsImNsaWNrIiwiaXNSZWFjdE5hdGl2ZSIsImlzTm90QnJvd3NlciIsIm5hdmlnYXRvciIsInByb2R1Y3QiLCJpc01ldGFNYXNrSW5zdGFsbGVkIiwiZXRoIiwiaXNEZXNrdG9wV2ViIiwiaXNNb2JpbGVXZWIiLCJpc01vYmlsZSIsIkJvd3NlciIsInVzZXJBZ2VudCIsImlzU2VjdXJlIiwiaXNNZXRhTWFza01vYmlsZVdlYlZpZXciLCJSZWFjdE5hdGl2ZVdlYlZpZXciLCJQbGF0Zm9ybVR5cGUiLCJpc05vZGVKUyIsImlzVXNlRGVlcExpbmsiLCJnZXRTdG9yYWdlTWFuYWdlciIsIl9fYXdhaXRlciIsIlN0b3JhZ2VNYW5hZ2VyV2ViIiwibm9vcFN0b3JhZ2VNYW5hZ2VyIiwiZ2V0Q2FjaGVkQWNjb3VudHMiLCJnZXRDYWNoZWRDaGFpbklkIiwicHJvdmlkZXJTdGF0ZVJlcXVlc3RlZCIsImZvcmNlSW5pdGlhbGl6ZVN0YXRlIiwiX3NldENvbm5lY3RlZCIsImdldFN0YXRlIiwiZ2V0U0RLUHJvdmlkZXJTdGF0ZSIsInNldFNES1Byb3ZpZGVyU3RhdGUiLCJoYW5kbGVBY2NvdW50c0NoYW5nZWQiLCJoYW5kbGVEaXNjb25uZWN0IiwiY2FjaGVkQ2hhaW5JZCIsImNhY2hlZFNlbGVjdGVkQWRkcmVzcyIsInVzZUNhY2hlIiwiY2FjaGVkQWNjb3VudHMiLCJpbml0aWFsaXplU3RhdGVBc3luYyIsInN1cGVySW5pdGlhbGl6ZVN0YXRlIiwiaW5pdGlhbGl6ZVN0YXRlIiwic3VwZXJIYW5kbGVDaGFpbkNoYW5nZWQiLCJmb3JjZWROZXR3b3JrVmVyc2lvbiIsImNhaXBfY2hhaW5faWQiLCJoYW5kbGVDaGFpbkNoYW5nZWQiLCJQcm92aWRlckNvbnN0YW50cyIsIkRFRkFVTFRfU0RLX1NPVVJDRSIsIk1FVEFNQVNLX0NPTk5FQ1RfQkFTRV9VUkwiLCJNRVRBTUFTS19ERUVQTElOS19CQVNFIiwiTUVUQU1BU0tfRUlQXzYzNjlfUFJPVklERVJfSU5GTyIsIk5BTUUiLCJSRE5TIiwiVVVJRF9WNF9SRUdFWCIsIlJQQ19NRVRIT0RTIiwiV0FMTEVUX1NXSVRDSEVUSEVUSEVSRVVNQ0hBSU4iLCJNRVRIT0RTX1RPX1JFRElSRUNUIiwibGNBbmFseXRpY3NSUENzIiwicnBjV2l0aEFjY291bnRQYXJhbSIsIlNUT1JBR0VfUEFUSCIsIlNUT1JBR0VfUFJPVklERVJfVFlQRSIsIlNUT1JBR0VfREFQUF9TRUxFQ1RFRF9BRERSRVNTIiwiU1RPUkFHRV9EQVBQX0NIQUlOSUQiLCJFWFRFTlNJT05fRVZFTlRTIiwiQ0hBSU5fQ0hBTkdFRCIsIkFDQ09VTlRTX0NIQU5HRUQiLCJESVNDT05ORUNUIiwiQ09OTkVDVCIsIk1BWF9NRVNTQUdFX0xFTkdUSCIsIlBST1ZJREVSX1VQREFURV9UWVBFIiwiaGFzTG9jYWxTdG9hZ2UiLCJjb25uZWN0QW5kU2lnbiIsIl9pbml0aWFsaXplZCIsImFjdGl2ZVByb3ZpZGVyIiwiaGV4TXNnIiwiaGV4U3RyaW5nIiwidWludDhBcnJheSIsInN0cmluZ1RvSGV4IiwiY29ubmVjdFdpdGhFeHRlbnNpb25Qcm92aWRlciIsInNka1Byb3ZpZGVyIiwiZXh0ZW5zaW9uIiwic2V0SXRlbSIsImV4dGVuc2lvbkFjdGl2ZSIsIkVYVEVOU0lPTiIsImVuYWJsZUFuYWx5dGljcyIsIlRyYWNraW5nRXZlbnRzIiwiYmFzZTY0RW5jb2RlIiwiYmFzZTY0c3RyaW5nIiwiYnRvYSIsImVuY29kZVVSSUNvbXBvbmVudCIsIl9tYXRjaCIsInAxIiwiZnJvbUNoYXJDb2RlIiwiaXNSZW1vdGVSZWFkeSIsInNvY2tldENvbm5lY3RlZCIsIl9kIiwiX2UiLCJ0YXJnZXRNZXRob2QiLCJ0cmlnZ2VyZWRJbnN0YWxsZXIiLCJfaXNCdWZmZXIiLCJfX3RyaWdnZXJlZEluc3RhbGxlciIsIndyYXBwZWRQYXJhbXMiLCJleHRyYWN0TWV0aG9kIiwiX2ciLCJwbGF0Zm9ybU1hbmFnZXIiLCJtb2JpbGVXZWIiLCJfaiIsImFjdGl2ZURlZXBsaW5rUHJvdG9jb2wiLCJfayIsInN0cmluZ2lmaWVkRGF0YSIsIl9tIiwiX3EiLCJfbyIsIl9wIiwidXJsUGFyYW1zIiwiZW5jb2RlVVJJIiwiX3IiLCJfcyIsIl90IiwiX3UiLCJfdiIsIlJlbW90ZUNvbW11bmljYXRpb25Qb3N0TWVzc2FnZVN0cmVhbSIsIl9vbk1lc3NhZ2UiLCJFdmVudFR5cGUiLCJQUk9WSURFUiIsIm9uTWVzc2FnZSIsIndhaXQiLCJ0aW1lIiwiaW5pdGlhbGl6ZU1vYmlsZVByb3ZpZGVyIiwiY2hlY2tJbnN0YWxsYXRpb25PbkFsbENhbGxzIiwiaW5qZWN0UHJvdmlkZXIiLCJpbnN0YWxsZXIiLCJzZGsiLCJyZW1vdGVDb25uZWN0aW9uIiwibWV0YW1hc2tTdHJlYW0iLCJnZXRDb25uZWN0b3IiLCJnZXRQbGF0Zm9ybU1hbmFnZXIiLCJnZXRQb3N0TWVzc2FnZVN0cmVhbSIsIklOUEFHRSIsIkNPTlRFTlRfU0NSSVBUIiwiZGFwcEluZm8iLCJzZGtJbmZvIiwicGFja2FnZUpzb24iLCJjYWNoZWRBY2NvdW50QWRkcmVzcyIsImNhY2hlZEFkZHJlc3NlcyIsImNhY2hlZENoYWluIiwiaW5pdGlhbGl6YXRpb25PbmdvaW5nIiwic2V0SW5pdGlhbGl6aW5nIiwib25nb2luZyIsImdldEluaXRpYWxpemluZyIsInNlbmRSZXF1ZXN0IiwiZXhlY3V0ZVJlcXVlc3QiLCJkZWJ1Z1JlcXVlc3QiLCJxcmNvZGVMaW5rIiwic2hvd0FjdGl2ZU1vZGFsIiwibG9vcCIsImluaXRpYWxpemluZyIsImlzSW5zdGFsbGVkIiwiY29ubmVjdGVkQWNjb3VudHMiLCJBTExPV0VEX0NPTk5FQ1RfTUVUSE9EUyIsImlzUmVhZE9ubHlNZXRob2QiLCJycGNFbmRwb2ludCIsInJlYWRvbmx5UlBDTWFwIiwicmVhZE9ubHlSZXNwb25zZSIsImNyb3NzRmV0Y2giLCJvayIsImpzb24iLCJycGNSZXF1ZXN0SGFuZGxlciIsImlzQ29ubmVjdFdpdGgiLCJycGNJbnN0YWxsSWQiLCJjb25uZWN0V2l0aCIsImluc3RhbGxFcnJvciIsImlzRXh0ZW5zaW9uQWN0aXZlIiwiY29ubmVjdGVkUnBjIiwiZXh0ZW5zaW9uQ29ubmVjdFdpdGhPdmVyd3JpdGUiLCJjbG9zZU1vZGFsIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJtZXNzYWdlQ291bnQiLCJtYXhNZXNzYWdlcyIsIm9uUlBDVXBkYXRlIiwiTG9jYWx0cmFja2VyIiwicnBjVXBkYXRlSGFuZGxlciIsInRyYWNrZXIiLCJvZmYiLCJycGNSZXNwb25zZSIsImFjY291bnRzVG9QZXJzaXN0IiwicGVybWlzc2lvbiIsInBhcmVudENhcGFiaWxpdHkiLCJyZXN0cmljdGVkQWNjb3VudHMiLCJjYXZlYXRzIiwiY2F2ZWF0IiwiaW5pdGlhbGl6ZVByb3ZpZGVyQW5kRXZlbnRMaXN0ZW5lcnMiLCJwcm92aWRlck9wdGlvbnMiLCJDb21tdW5pY2F0aW9uTGF5ZXJQcmVmZXJlbmNlIiwiZXh0ZW5zaW9uT25seSIsInNlcnZpY2VTdGF0dXMiLCJpbml0RXZlbnRMaXN0ZW5lcnMiLCJBTkFMWVRJQ1NfQ09OU1RBTlRTIiwiQW5hbHl0aWNzIiwic2VydmVyVXJsIiwic2VydmVyVVJMIiwiREVGQVVMVF9TRVJWRVJfVVJMIiwiU2VuZEFuYWx5dGljcyIsImV4dHJhY3RGYXZpY29uIiwiZmF2aWNvbiIsIm5vZGVMaXN0IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJnZXRBdHRyaWJ1dGUiLCJCQVNFXzY0X0lDT05fTUFYX0xFTkdUSCIsImdldFBsYXRmb3JtRGV0YWlscyIsInJhd0lkZW50aWZpZXIiLCJlbmNvZGVkSWRlbnRpZmllciIsInN0b3JlZFV1aWQiLCJnZXRJdGVtIiwidXVpZHY0IiwiZ2V0T3JDcmVhdGVVdWlkRm9ySWRlbnRpZmllciIsInBsYXRGb3JtVHlwZSIsImlzRXh0ZW5zaW9uIiwiaXNJbkFwcEJyb3dzZXIiLCJ0cmFja1JwY091dGNvbWUiLCJyZXNwIiwiY2F1Z2h0RXJyb3IiLCJpc0FuYWx5dGljc1RyYWNrZWRScGNNZXRob2QiLCJ3cmFwRXh0ZW5zaW9uUHJvdmlkZXIiLCJ0cmFja0V2ZW50IiwiaW5kaXZpZHVhbFJlc3AiLCJoYW5kbGVCYXRjaE1ldGhvZCIsImhhbmRsZUNvbm5lY3RTaWduTWV0aG9kIiwiY3VycmVudFJwY01ldGhvZCIsImN1cnJlbnRScGNQYXJhbXMiLCJoYW5kbGVDb25uZWN0V2l0aE1ldGhvZCIsIkVJUDY5NjNFdmVudE5hbWVzIiwiZ2V0QnJvd3NlckV4dGVuc2lvbiIsIm11c3RCZU1ldGFNYXNrIiwiZXh0ZW5zaW9uUHJvdmlkZXIiLCJ0aW1lb3V0SWQiLCJBbm5vdW5jZSIsImVpcDY5NjNBbm5vdW5jZVByb3ZpZGVyRXZlbnQiLCJkZXRhaWwiLCJyZG5zIiwiUmVxdWVzdCIsInNldHVwSW5mdXJhUHJvdmlkZXIiLCJpbmZ1cmFBUElLZXkiLCJpbmZ1cmFScGNVcmxzIiwic2V0dXBSZWFkT25seVJQQ1Byb3ZpZGVycyIsInNldFJlYWRPbmx5UlBDQ2FsbHMiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsImdlbmVyYXRvciIsImZ1bGZpbGxlZCIsIl9fZ2VuZXJhdG9yIiwibGFiZWwiLCJzZW50IiwidHJ5cyIsIm9wcyIsInZlcmIiLCJ0aHJvdyIsInJldHVybiIsIm9wIiwiT05CT0FSRElOR19TVEFURSIsIkVYVEVOU0lPTl9ET1dOTE9BRF9VUkwiLCJDSFJPTUUiLCJGSVJFRk9YIiwiREVGQVVMVCIsIlJFR0lTVFJBVElPTl9JTl9QUk9HUkVTUyIsIkZPUldBUkRFUl9JRCIsIk9uYm9hcmRpbmciLCJmb3J3YXJkZXJPcmlnaW4iLCJmb3J3YXJkZXJNb2RlIiwiRk9SV0FSREVSX01PREUiLCJJTkpFQ1QiLCJfZGV0ZWN0QnJvd3NlciIsImRvd25sb2FkVXJsIiwiX29uTWVzc2FnZUZyb21Gb3J3YXJkZXIiLCJfb3BlbkZvcndhcmRlciIsIl9vcGVuRG93bmxvYWRQYWdlIiwic3RhcnRPbmJvYXJkaW5nIiwic3RvcE9uYm9hcmRpbmciLCJzZXNzaW9uU3RvcmFnZSIsIl9pbmplY3RGb3J3YXJkZXIiLCJvcmlnaW4iLCJfb25NZXNzYWdlVW5rbm93blN0YXRlRXJyb3IiLCJyZWxvYWQiLCJfcmVnaXN0ZXIiLCJwb3N0TWVzc2FnZSIsIl9yZW1vdmVGb3J3YXJkZXIiLCJPUEVOX1RBQiIsIm9wZW4iLCJjb250YWluZXIiLCJpZnJhbWUiLCJzZXRBdHRyaWJ1dGUiLCJpbnNlcnRCZWZvcmUiLCJjaGlsZHJlbiIsImdldEVsZW1lbnRCeUlkIiwicmVtb3ZlIiwiYnJvd3NlckluZm8iLCJzdGFydEluc3RhbGxlciIsIndhaXRQcm9taXNlIiwiY2hlY2tJbnN0YWxsYXRpb24iLCJNZXRhTWFza0luc3RhbGxlciIsInByZWZlckRlc2t0b3AiLCJpc0luc3RhbGxpbmciLCJoYXNJbnN0YWxsZWQiLCJyZXNlbmRSZXF1ZXN0Iiwic3RhcnREZXNrdG9wT25ib2FyZGluZyIsIk1ldGFNYXNrT25ib2FyZGluZyIsInJlZGlyZWN0VG9Qcm9wZXJJbnN0YWxsIiwic3RhcnRDb25uZWN0aW9uIiwiTW9kYWxMb2FkZXIiLCJjb250YWluZXJzIiwiaW5zdGFsbCIsInBlbmRpbmciLCJzZWxlY3QiLCJkZWZpbmVkIiwibG9hZENvbXBvbmVudCIsImxvYWRlciIsImRlZmluZUN1c3RvbUVsZW1lbnRzIiwicmVuZGVySW5zdGFsbE1vZGFsIiwicGFyZW50RWxlbWVudCIsIm1vZGFsIiwic2hvdWxkVGVybWluYXRlIiwib25DbG9zZSIsIm1ldGFNYXNrSW5zdGFsbGVyIiwib25BbmFseXRpY3NFdmVudCIsImFwcGVuZENoaWxkIiwicmVuZGVyU2VsZWN0TW9kYWwiLCJjb25uZWN0V2l0aEV4dGVuc2lvbiIsInVwZGF0ZVFSQ29kZSIsInJlbmRlclBlbmRpbmdNb2RhbCIsImRpc3BsYXlPVFAiLCJvdHBWYWx1ZSIsInVwZGF0ZU9UUFZhbHVlIiwib25EaXNjb25uZWN0IiwidHJ5VXBkYXRlIiwib3RwQ29kZSIsImluc3RhbGxNb2RhbCIsInNlbGVjdE1vZGFsIiwidW5tb3VudCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsInNka1dlYkluc3RhbGxNb2RhbCIsIm1vZGFsTG9hZGVyIiwibW91bnQiLCJzdHlsZSIsImRpc3BsYXkiLCJzZGtXZWJQZW5kaW5nTW9kYWwiLCJpbml0aWFsaXplQ29ubmVjdG9yIiwiX3NvdXJjZSIsInRpbWVyIiwic3RvcEJhY2tncm91bmRUaW1lciIsInJ1bkJhY2tncm91bmRUaW1lciIsImNsZWFudXBMaXN0ZW5lcnMiLCJjb25uZWN0V2l0aE1vZGFsSW5zdGFsbGVyIiwibGlua1BhcmFtcyIsImNvbm5lY3Rpb25UaW1lb3V0IiwiaW5zdGFsbExpbmsiLCJtb2RhbHMiLCJnZXRNZXRhTWFza0luc3RhbGxlciIsImRldmVsb3Blck1vZGUiLCJleHRlbmRlZCIsInNob3dJbnN0YWxsTW9kYWwiLCJzZXR1cExpc3RlbmVycyIsInBlbmRpbmdNb2RhbCIsImluaXRpYWxDaGVjayIsIm5ld0NoYW5uZWwiLCJERUZBVUxUX1NFU1NJT05fVElNRU9VVF9NUyIsInFyQ29kZU9yaWdpbiIsInNjaGVtZSIsImJhc2U2NE9yaWdpbmF0b3JJbmZvIiwiZW5jb2RlZExpbmtQYXJhbXMiLCJjb25uZWN0V2l0aERlZXBsaW5rIiwiUmVtb3RlQ29ubmVjdGlvbiIsIkluc3RhbGxNb2RhbCIsIm90cCIsIlBlbmRpbmdNb2RhbCIsImV4dHJhcyIsImluaXRSZW1vdGVDb21tdW5pY2F0aW9uIiwiZWNpZXNQcm9wcyIsImdldFVuaXZlcnNhbExpbmsiLCJjbGVhbnVwQ29ubmVjdG9yIiwicGVyZm9ybVNES0luaXRpYWxpemF0aW9uIiwiZW5hYmxlRGVidWciLCJoZWFkbGVzcyIsIl9tb2RhbHMiLCJfdWkiLCJ1aSIsInJ1bnRpbWVMb2dnaW5nIiwic2V0dXBQbGF0Zm9ybU1hbmFnZXIiLCJnZXREYXBwSWQiLCJzZXR1cEFuYWx5dGljcyIsImdldEFub25JZCIsImludGVncmF0aW9uVHlwZSIsInNldEdsb2JhbFByb3BlcnR5Iiwic2V0dXBBbmFseXRpY3NWMiIsInNldHVwU3RvcmFnZU1hbmFnZXIiLCJ1cmxQYXR0ZXJuIiwiZmF2aWNvblVybCIsInByb3RvY29sIiwiaG9zdCIsInNldHVwRGFwcE1ldGFkYXRhIiwibWV0YW1hc2tCcm93c2VyRXh0ZW5zaW9uIiwicHJlZmVyRXh0ZW5zaW9uIiwic2hvdWxkUmV0dXJuIiwiZ2V0TW9iaWxlUHJvdmlkZXIiLCJoYXNNb2JpbGVQcm92aWRlciIsInNldHVwRXh0ZW5zaW9uUHJlZmVyZW5jZXMiLCJvblBlbmRpbmdNb2RhbERpc2Nvbm5lY3QiLCJzZXR1cFJlbW90ZUNvbm5lY3Rpb25BbmRJbnN0YWxsZXIiLCJyZW1vdmVJdGVtIiwiY2hlY2tJbnN0YWxsYXRpb25JbW1lZGlhdGVseSIsImhhbmRsZUF1dG9BbmRFeHRlbnNpb25Db25uZWN0aW9ucyIsIklOSVRJQUxJWkVEIiwiTWV0YU1hc2tTREsiLCJFdmVudEVtaXR0ZXIyIiwiZm9yY2VJbmplY3RQcm92aWRlciIsImkxOG5PcHRpb25zIiwic2RrSW5pdFByb21pc2UiLCJyZWFkb25seVJQQ0NhbGxzIiwiYXZhaWxhYmxlTGFuZ3VhZ2VzIiwiQU5PTl9JRF9TVE9SQUdFX0tFWSIsImRpc2FibGUiLCJtbXNkayIsImlzSW5pdGlhbGl6ZWQiLCJpbml0aWFsaXplTWV0YU1hc2tTREsiLCJjaGVja0V4dGVuc2lvbkF2YWlsYWJpbGl0eSIsImV0aF9hY2NvdW50cyIsImFsbG93ZWQiLCJoYXNSZWFkT25seVJQQ0NhbGxzIiwiZ2V0UlBDSGlzdG9yeSIsIl9hbm9uSWQiLCJnZXRCcm93c2VyQW5vbklkIiwiZ2V0UmVhY3ROYXRpdmVBbm9uSWQiLCJzdG9yZWRJZCIsIkFzeW5jU3RvcmFnZSIsInJlcXVpcmUiLCJnZXRXYWxsZXRTdGF0dXMiLCJfZ2V0Q2hhbm5lbENvbmZpZyIsIl9waW5nIiwiX2tleUNoZWNrIiwiX2dldFNlcnZpY2VTdGF0dXMiLCJfZ2V0UmVtb3RlQ29ubmVjdGlvbiIsIl9nZXREYXBwTWV0YWRhdGEiLCJfZ2V0S2V5SW5mbyIsIl9yZXNldEtleXMiLCJfZ2V0Q29ubmVjdGlvbiIsInJhd0FjY291bnRzIiwiQlVJTEQiLCJfX2RlZlByb3AiLCJob3N0UmVmcyIsImdldEhvc3RSZWYiLCJyZWYiLCJyZWdpc3Rlckluc3RhbmNlIiwibGF6eUluc3RhbmNlIiwiaG9zdFJlZiIsIiRsYXp5SW5zdGFuY2UkIiwiaXNNZW1iZXJJbkVsZW1lbnQiLCJtZW1iZXJOYW1lIiwiY29uc29sZUVycm9yIiwiZWwiLCJjbXBNb2R1bGVzIiwic3R5bGVzIiwiU0xPVF9GQl9DU1MiLCJ3aW4iLCJkb2MiLCJwbHQiLCIkZmxhZ3MkIiwiJHJlc291cmNlc1VybCQiLCJqbXAiLCJyYWYiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhZWwiLCJDdXN0b21FdmVudCIsInN1cHBvcnRzQ29uc3RydWN0YWJsZVN0eWxlc2hlZXRzIiwiQ1NTU3R5bGVTaGVldCIsInJlcGxhY2VTeW5jIiwicXVldWVQZW5kaW5nIiwicXVldWVEb21SZWFkcyIsInF1ZXVlRG9tV3JpdGVzIiwicXVldWVUYXNrIiwicXVldWUiLCJpMiIsInBlcmZvcm1hbmNlIiwicHJvbWlzZVJlc29sdmUiLCJ3cml0ZVRhc2siLCJFTVBUWV9PQkoiLCJpc0NvbXBsZXhUeXBlIiwicXVlcnlOb25jZU1ldGFUYWdDb250ZW50IiwiZG9jMiIsIl9fZXhwb3J0IiwidW53cmFwIiwidW53cmFwRXJyIiwiaXNPayIsImlzRXJyIiwibmV3VmFsIiwic2NvcGVJZCIsImhvc3RUYWdOYW1lIiwibm9kZU5hbWUiLCJ2bm9kZURhdGEiLCJjaGlsZCIsInNpbXBsZSIsImxhc3RTaW1wbGUiLCJ2Tm9kZUNoaWxkcmVuIiwid2FsayIsIiR0ZXh0JCIsIm5ld1ZOb2RlIiwiY2xhc3NEYXRhIiwiY2xhc3NOYW1lIiwiY2xhc3MiLCJ2ZG9tRm5VdGlscyIsInZub2RlIiwiJGF0dHJzJCIsIiRjaGlsZHJlbiQiLCIkdGFnJCIsIiRlbG0kIiwiSG9zdCIsImNvbnZlcnRUb1B1YmxpYyIsImNvbnZlcnRUb1ByaXZhdGUiLCJub2RlIiwidmF0dHJzIiwidmNoaWxkcmVuIiwidmtleSIsIiRrZXkkIiwidm5hbWUiLCIkbmFtZSQiLCJ2dGFnIiwidnRleHQiLCJnZXRFbGVtZW50IiwiJGhvc3RFbGVtZW50JCIsImNyZWF0ZUV2ZW50IiwiZW1pdEV2ZW50IiwiYnViYmxlcyIsImNvbXBvc2VkIiwiY2FuY2VsYWJsZSIsInJvb3RBcHBsaWVkU3R5bGVzIiwiYXR0YWNoU3R5bGVzIiwiY21wTWV0YSIsIiRjbXBNZXRhJCIsImVuZEF0dGFjaFN0eWxlcyIsIiR0YWdOYW1lJCIsInNjb3BlSWQyIiwic3R5bGVDb250YWluZXJOb2RlIiwiZ2V0U2NvcGVJZCIsIm5vZGVUeXBlIiwic3R5bGVFbG0iLCJhcHBsaWVkU3R5bGVzIiwiaW5uZXJIVE1MIiwiJG5vbmNlJCIsInByZWNvbm5lY3RMaW5rcyIsInJlZmVyZW5jZU5vZGUyIiwibmV4dFNpYmxpbmciLCJzdHlsZXNoZWV0IiwiYWRvcHRlZFN0eWxlU2hlZXRzIiwiZXhpc3RpbmdTdHlsZUNvbnRhaW5lciIsInByZXBlbmQiLCJhcHBlbmQiLCJhZGRTdHlsZSIsInNoYWRvd1Jvb3QiLCJnZXRSb290Tm9kZSIsImNsYXNzTGlzdCIsImNtcCIsInNldEFjY2Vzc29yIiwib2xkVmFsdWUiLCJuZXdWYWx1ZSIsImlzU3ZnIiwiaXNQcm9wIiwibG4iLCJvbGRDbGFzc2VzIiwicGFyc2VDbGFzc0xpc3QiLCJuZXdDbGFzc2VzIiwicmVtb3ZlUHJvcGVydHkiLCJzZXRQcm9wZXJ0eSIsImlzQ29tcGxleCIsInRhZ05hbWUiLCJfX2xvb2t1cFNldHRlcl9fIiwicmVtb3ZlQXR0cmlidXRlIiwiY2FwdHVyZSIsIkNBUFRVUkVfRVZFTlRfU1VGRklYIiwiQ0FQVFVSRV9FVkVOVF9SRUdFWCIsInBhcnNlQ2xhc3NMaXN0UmVnZXgiLCJ1cGRhdGVFbGVtZW50Iiwib2xkVm5vZGUiLCJuZXdWbm9kZSIsImlzU3ZnTW9kZTIiLCJvbGRWbm9kZUF0dHJzIiwibmV3Vm5vZGVBdHRycyIsInNvcnRlZEF0dHJOYW1lcyIsImF0dHJOYW1lcyIsImF0dHIiLCJ1c2VOYXRpdmVTaGFkb3dEb20iLCJpc1N2Z01vZGUiLCJjcmVhdGVFbG0iLCJvbGRQYXJlbnRWTm9kZSIsIm5ld1BhcmVudFZOb2RlIiwiY2hpbGRJbmRleCIsInBhcmVudEVsbSIsIm5ld1ZOb2RlMiIsImNoaWxkTm9kZSIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlRWxlbWVudE5TIiwiaXNEZWYiLCJhZGRWbm9kZXMiLCJiZWZvcmUiLCJwYXJlbnRWTm9kZSIsInZub2RlcyIsInN0YXJ0SWR4IiwiZW5kSWR4IiwiY29udGFpbmVyRWxtIiwicmVtb3ZlVm5vZGVzIiwiaXNTYW1lVm5vZGUiLCJsZWZ0Vk5vZGUiLCJyaWdodFZOb2RlIiwiaXNJbml0aWFsUmVuZGVyIiwicGF0Y2giLCJvbGRWTm9kZSIsIm9sZENoaWxkcmVuIiwibmV3Q2hpbGRyZW4iLCJvbGRDaCIsIm5ld0NoIiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsInVwZGF0ZUNoaWxkcmVuIiwidGV4dENvbnRlbnQiLCJuZXdOb2RlIiwicmVmZXJlbmNlIiwicmVuZGVyVmRvbSIsInJlbmRlckZuUmVzdWx0cyIsImlzSW5pdGlhbExvYWQiLCJob3N0RWxtIiwiJHZub2RlJCIsInJvb3RWbm9kZSIsImhhc0F0dHJpYnV0ZSIsImF0dGFjaFRvQW5jZXN0b3IiLCJhbmNlc3RvckNvbXBvbmVudCIsIiRvblJlbmRlclJlc29sdmUkIiwic2NoZWR1bGVVcGRhdGUiLCIkYW5jZXN0b3JDb21wb25lbnQkIiwiZGlzcGF0Y2hIb29rcyIsImVuZFNjaGVkdWxlIiwiZW5xdWV1ZSIsIm1heWJlUHJvbWlzZSIsInVwZGF0ZUNvbXBvbmVudCIsImlzUHJvbWlzZXkiLCJlbmRVcGRhdGUiLCJyYyIsImVuZFJlbmRlciIsImNhbGxSZW5kZXIiLCJjaGlsZHJlblByb21pc2VzIiwicG9zdFVwZGF0ZSIsInBvc3RVcGRhdGVDb21wb25lbnQiLCJyZW5kZXIiLCJlbmRQb3N0VXBkYXRlIiwiYWRkSHlkcmF0ZWRGbGFnIiwic2FmZUNhbGwiLCIkb25SZWFkeVJlc29sdmUkIiwiYXBwRGlkTG9hZCIsIndobyIsImRvY3VtZW50RWxlbWVudCIsIm5hbWVzcGFjZSIsInNldFZhbHVlIiwicHJvcE5hbWUiLCJvbGRWYWwiLCIkaW5zdGFuY2VWYWx1ZXMkIiwicHJvcFR5cGUiLCIkbWVtYmVycyQiLCJhcmVCb3RoTmFOIiwiJHdhdGNoZXJzJCIsIndhdGNoTWV0aG9kcyIsIndhdGNoTWV0aG9kTmFtZSIsInByb3h5Q29tcG9uZW50IiwiQ3N0ciIsIndhdGNoZXJzIiwibWVtYmVycyIsIm1lbWJlckZsYWdzIiwiYXR0ck5hbWVUb1Byb3BOYW1lIiwiYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIiwiYXR0ck5hbWUiLCJmbGFnczIiLCJjYWxsYmFja05hbWUiLCJvYnNlcnZlZEF0dHJpYnV0ZXMiLCJpbml0aWFsaXplQ29tcG9uZW50IiwiaG1yVmVyc2lvbklkIiwiJGxhenlCdW5kbGVJZCQiLCJDc3RySW1wb3J0IiwiZXhwb3J0TmFtZSIsImJ1bmRsZUlkIiwicHJvY2Vzc01vZCIsImltcG9ydGVkTW9kdWxlIiwiaW1wb3J0IiwibG9hZE1vZHVsZSIsImVuZExvYWQiLCIkbW9kZU5hbWUkIiwiaXNQcm94aWVkIiwiZW5kTmV3SW5zdGFuY2UiLCJmaXJlQ29ubmVjdGVkQ2FsbGJhY2siLCJjbXBUYWciLCJsb2NhbE5hbWUiLCJjdXN0b21FbGVtZW50cyIsIndoZW5EZWZpbmVkIiwiZW5kUmVnaXN0ZXJTdHlsZXMiLCJjc3NUZXh0IiwiYWxsb3dDUyIsInJlZ2lzdGVyU3R5bGUiLCJzY2hlZHVsZSIsImRpc2Nvbm5lY3RJbnN0YW5jZSIsImJvb3RzdHJhcExhenkiLCJsYXp5QnVuZGxlcyIsImVuZEJvb3RzdHJhcCIsImNtcFRhZ3MiLCJleGNsdWRlIiwiY3VzdG9tRWxlbWVudHMyIiwibWV0YUNoYXJzZXQiLCJkYXRhU3R5bGVzIiwiZGVmZXJyZWRDb25uZWN0ZWRDYWxsYmFja3MiLCJhcHBMb2FkRmFsbGJhY2siLCJpc0Jvb3RzdHJhcHBpbmciLCJyZXNvdXJjZXNVcmwiLCJiYXNlVVJJIiwiaGFzU2xvdFJlbG9jYXRpb24iLCJsYXp5QnVuZGxlIiwiY29tcGFjdE1ldGEiLCIkbGlzdGVuZXJzJCIsIkhvc3RFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJoYXNSZWdpc3RlcmVkRXZlbnRMaXN0ZW5lcnMiLCJob3N0RWxlbWVudCIsIiRvblJlYWR5UHJvbWlzZSQiLCJyZWdpc3Rlckhvc3QiLCJhdHRhY2hTaGFkb3ciLCJjb25uZWN0ZWRDYWxsYmFjayIsImVuZENvbm5lY3RlZCIsImRpc2Nvbm5lY3RlZENhbGxiYWNrIiwiY29tcG9uZW50T25SZWFkeSIsImZpcnN0Q2hpbGQiLCJjb25zdHJ1Y3QiLCJnbG9iYWxTY3JpcHRzIiwidGFiIiwiaXNEZWZhdWx0VGFiIiwidHJhbnNsYXRpb25zTG9hZGVkIiwid2lkZ2V0V3JhcHBlclN0eWxlIiwiZm9udEZhbWlseSIsIldpZGdldFdyYXBwZXIiLCJBZHZhbnRhZ2VzTGlzdEl0ZW0iLCJJY29uIiwicGFkZGluZyIsImZsZXhEaXJlY3Rpb24iLCJsaW5lSGVpZ2h0IiwiTG9ja0ljb24iLCJ3aWR0aCIsImhlaWdodCIsInZpZXdCb3giLCJ4bWxucyIsIkhlYXJ0SWNvbiIsIldhbGxldEljb24iLCJJbnN0YWxsSWNvbiIsInN0cm9rZSIsIlNES1ZlcnNpb24iLCJ0ZXh0QWxpZ24iLCJmb250U2l6ZSIsIkNsb3NlQnV0dG9uIiwiTG9nbyIsImJpbiIsImRlYyIsImZpbGxBcnIiLCJpbnRlcmxlYXZlQnl0ZXMiLCJpbmNsdWRlc0F0IiwicGF0dGVybiIsImFscGhhYmV0IiwibGV0dGVyIiwiZGlnaXRzIiwiYXNzZXJ0TnVtYmVyIiwiQml0bWFwIiwiSW5maW5pdHkiLCJmcm9tU3RyaW5nIiwibGluZXMiLCJsaW5lIiwicm93IiwiaXNJbnNpZGUiLCJ4eSIsInJlY3QiLCJ5UG9zIiwieFBvcyIsInJlY3RSZWFkIiwiY3VyIiwiaExpbmUiLCJ2TGluZSIsImJvcmRlciIsImVtYmVkIiwiYm0iLCJyZWN0U2xpY2UiLCJpbnZlcnNlIiwic2NhbGUiLCJmYWN0b3IiLCJhc3NlcnREcmF3biIsInRvQVNDSUkiLCJzZWNvbmQiLCJ0b1Rlcm0iLCJ3aGl0ZUJHIiwiZGFya0JHIiwidG9TVkciLCJ0b0dJRiIsInUxNmxlIiwiZGltcyIsImZ1bGxDaHVua3MiLCJ0b0ltYWdlIiwiaXNSR0IiLCJFQ01vZGUiLCJFbmNvZGluZyIsIldPUkRTX1BFUl9CTE9DSyIsIm1lZGl1bSIsInF1YXJ0aWxlIiwiaGlnaCIsIkVDQ19CTE9DS1MiLCJ2ZXIiLCJzaXplVHlwZSIsImFsaWdubWVudFBhdHRlcm5zIiwiZGlzdGFuY2UiLCJFQ0NvZGUiLCJmb3JtYXRNYXNrIiwiZm9ybWF0Qml0cyIsImVjYyIsIm1hc2tJZHgiLCJ2ZXJzaW9uQml0cyIsIm51bWVyaWMiLCJhbHBoYW51bWVyYyIsImxlbmd0aEJpdHMiLCJhbHBoYW51bWVyaWMiLCJrYW5qaSIsImVjaSIsIm1vZGVCaXRzIiwiY2FwYWNpdHkiLCJ3b3JkcyIsIm51bUJsb2NrcyIsInNob3J0QmxvY2tzIiwidG90YWwiLCJQQVRURVJOUyIsIkdGIiwidGFibGVzIiwicF9wb2x5IiwiZXhwIiwicG9seW5vbWlhbCIsInBvbHkiLCJtb25vbWlhbCIsImRlZ3JlZSIsImNvZWZmaWNpZW50IiwiY29lZmZpY2llbnRzIiwibXVsUG9seSIsIm11bFBvbHlTY2FsYXIiLCJtdWxQb2x5TW9ub21pYWwiLCJhZGRQb2x5Iiwic21hbGxlciIsImxhcmdlciIsInN1bURpZmYiLCJsZW5ndGhEaWZmIiwicmVtYWluZGVyUG9seSIsImRpdmlzb3IiLCJkaXZpc29yUG9seSIsImV2YWxQb2x5IiwiZXVjbGlkaWFuIiwickxhc3QiLCJ0TGFzdCIsInJMYXN0TGFzdCIsInRMYXN0TGFzdCIsImRsdEludmVyc2UiLCJkZWdyZWVEaWZmIiwic2lnbWFUaWxkZUF0WmVybyIsImludGVybGVhdmUiLCJlY2NXb3JkcyIsInBvbCIsInN5bmRyb21lIiwiaGFzRXJyb3IiLCJldmwiLCJlcnJvckxvY2F0b3IiLCJlcnJvckV2YWx1YXRvciIsImxvY2F0aW9ucyIsInhpSW52ZXJzZSIsImRlbm9taW5hdG9yIiwiZWNjQmxvY2tzIiwicmVzQmxvY2tzIiwicmVzRUNDIiwiaXNTaG9ydCIsImVuY29kZWQiLCJ1dGY4IiwicmVwZWF0IiwiZHJhd1FSIiwiZmluZGVyIiwiYWxpZ24iLCJhbGlnblBvcyIsImdldEJpdCIsImRyYXdUZW1wbGF0ZSIsInRwbCIsImRpciIsInhPZmZzZXQiLCJ6aWd6YWciLCJwZW5hbHR5Iiwic2FtZUNvbG9yIiwic2FtZSIsImFkamFjZW50IiwiY29sdW1uIiwibGFzdFciLCJsYXN0SCIsIngxIiwiZmluZGVyUGF0dGVybiIsImxpZ2h0UGF0dGVybiIsInAyIiwiZGFya1BpeGVscyIsImRhcmtQZXJjZW50IiwiZGFyayIsImVuY29kZVFSIiwiZWMiLCJ2YWxpZGF0ZUVDQyIsImRldGVjdFR5cGUiLCJ2YWxpZGF0ZUVuY29kaW5nIiwidmFsaWRhdGVNYXNrIiwidmFsaWRhdGVWZXJzaW9uIiwiYmVzdE1hc2siLCJiZXN0IiwiYmVzdFNjb3JlIiwic2NvcmUiLCJkcmF3UVJCZXN0IiwiZGVmYXVsdFRyYW5zbGF0aW9ucyIsIkRFU0tUT1AiLCJNT0JJTEUiLCJNRVRBX01BU0tfTU9CSUxFX0FQUCIsIlNDQU5fVE9fQ09OTkVDVCIsIkNPTk5FQ1RfV0lUSF9FWFRFTlNJT04iLCJJTlNUQUxMX01PREFMIiwiVFJVU1RFRF9CWV9VU0VSUyIsIkxFQURJTkdfQ1JZUFRPX1dBTExFVCIsIkNPTlRST0xfRElHSVRBTF9JTlRFUkFDVElPTlMiLCJJTlNUQUxMX01FVEFfTUFTS19FWFRFTlNJT04iLCJQRU5ESU5HX01PREFMIiwiT1BFTl9NRVRBX01BU0tfU0VMRUNUX0NPREUiLCJPUEVOX01FVEFfTUFTS19DT05USU5VRSIsIk5VTUJFUl9BRlRFUl9PUEVOX05PVElDRSIsIlNFTEVDVF9NT0RBTCIsIkNSWVBUT19UQUtFX0NPTlRST0xfVEVYVCIsIk1FVEFfTUFTS19NT0RBTCIsIkFERFJFU1NfQ09QSUVEIiwiQUNUSVZFX05FVFdPUksiLCJTaW1wbGVJMThuIiwidHJhbnNsYXRpb25zIiwic3VwcG9ydGVkTG9jYWxlcyIsImJhc2VVcmwiLCJnZXRCcm93c2VyTGFuZ3VhZ2UiLCJsYW5ndWFnZXMiLCJsYW5ndWFnZSIsImxhbmciLCJzaG9ydExhbmciLCJsb2NhbGUiLCJmYWxsYmFja0xuZyIsImxvYWRUcmFuc2xhdGlvbnMiLCJzaG9ydExvY2FsZSIsImZldGNoIiwiZ2V0TmVzdGVkVHJhbnNsYXRpb24iLCJkaWN0IiwidHJhY2tBbmFseXRpY3MiLCJvblN0YXJ0RGVza3RvcE9uYm9hcmRpbmdIYW5kbGVyIiwic2V0VGFiIiwiaTE4bkluc3RhbmNlIiwiY29tcG9uZW50RGlkTG9hZCIsIlNES19NT0RBTF9WSUVXRUQiLCJleHRlbnNpb25JbnN0YWxsZWQiLCJ1cGRhdGVQcmVmZXJEZXNrdG9wIiwiU0RLX01PREFMX0JVVFRPTl9DTElDS0VEIiwiYnV0dG9uX3R5cGUiLCJuZXdUYWIiLCJpc1VzZXJBY3Rpb24iLCJTREtfTU9EQUxfVE9HR0xFX0NIQU5HRUQiLCJ0b2dnbGUiLCJjdXJyZW50VGFiIiwic3ZnRWxlbWVudCIsIm9uQ2xpY2siLCJtYXJnaW5Ub3AiLCJvblVwZGF0ZU9UUFZhbHVlSGFuZGxlciIsIm1hcmdpbkJvdHRvbSIsImJvcmRlckNvbG9yIiwiYm9yZGVyV2lkdGgiLCJib3JkZXJTdHlsZSIsImJhY2tncm91bmRDb2xvciIsIkNvbm5lY3RJY29uIiwiTWV0YW1hc2tFeHRlbnNpb25JbWFnZSIsIlNlbGVjdE1vZGFsIiwiY29ubmVjdFdpdGhFeHRlbnNpb25IYW5kbGVyIiwianVzdGlmeUNvbnRlbnQiXSwiaWdub3JlTGlzdCI6WzAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksMzAsMzEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzksNDAsNDIsNDMsNDQsNDUsNDYsNDcsNDgsNDksNTAsNTEsNTIsNTMsNTQsNTUsNTYsNTcsNTgsNTksNjAsNjEsNjIsNjMsNjQsNjUsNjYsNjcsNjgsNjksNzAsNzEsNzIsNzMsNzQsNzUsNzYsNzcsNzgsNzksODAsODEsODIsODMsODQsODUsODYsODcsODgsODksOTAsOTMsOTQsOTUsOTYsOTcsOTgsMTAxLDEwMiwxNDRdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@metamask/sdk/dist/browser/es/metamask-sdk.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@metamask/sdk/node_modules/debug/src/browser.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@metamask/sdk/node_modules/debug/src/browser.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/process/browser.js\");\n/* eslint-env browser */ /**\n * This is the web browser implementation of `debug()`.\n */ \nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (()=>{\n    let warned = false;\n    return ()=>{\n        if (!warned) {\n            warned = true;\n            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n        }\n    };\n})();\n/**\n * Colors.\n */ exports.colors = [\n    '#0000CC',\n    '#0000FF',\n    '#0033CC',\n    '#0033FF',\n    '#0066CC',\n    '#0066FF',\n    '#0099CC',\n    '#0099FF',\n    '#00CC00',\n    '#00CC33',\n    '#00CC66',\n    '#00CC99',\n    '#00CCCC',\n    '#00CCFF',\n    '#3300CC',\n    '#3300FF',\n    '#3333CC',\n    '#3333FF',\n    '#3366CC',\n    '#3366FF',\n    '#3399CC',\n    '#3399FF',\n    '#33CC00',\n    '#33CC33',\n    '#33CC66',\n    '#33CC99',\n    '#33CCCC',\n    '#33CCFF',\n    '#6600CC',\n    '#6600FF',\n    '#6633CC',\n    '#6633FF',\n    '#66CC00',\n    '#66CC33',\n    '#9900CC',\n    '#9900FF',\n    '#9933CC',\n    '#9933FF',\n    '#99CC00',\n    '#99CC33',\n    '#CC0000',\n    '#CC0033',\n    '#CC0066',\n    '#CC0099',\n    '#CC00CC',\n    '#CC00FF',\n    '#CC3300',\n    '#CC3333',\n    '#CC3366',\n    '#CC3399',\n    '#CC33CC',\n    '#CC33FF',\n    '#CC6600',\n    '#CC6633',\n    '#CC9900',\n    '#CC9933',\n    '#CCCC00',\n    '#CCCC33',\n    '#FF0000',\n    '#FF0033',\n    '#FF0066',\n    '#FF0099',\n    '#FF00CC',\n    '#FF00FF',\n    '#FF3300',\n    '#FF3333',\n    '#FF3366',\n    '#FF3399',\n    '#FF33CC',\n    '#FF33FF',\n    '#FF6600',\n    '#FF6633',\n    '#FF9900',\n    '#FF9933',\n    '#FFCC00',\n    '#FFCC33'\n];\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */ // eslint-disable-next-line complexity\nfunction useColors() {\n    // NB: In an Electron preload script, document will be defined but not fully\n    // initialized. Since we know we're in Chrome, we'll just detect this case\n    // explicitly\n    if ( true && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n        return true;\n    }\n    // Internet Explorer and Edge do not support colors.\n    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n        return false;\n    }\n    // Is webkit? http://stackoverflow.com/a/16459606/376773\n    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773\n     true && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker\n    typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/);\n}\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */ function formatArgs(args) {\n    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);\n    if (!this.useColors) {\n        return;\n    }\n    const c = 'color: ' + this.color;\n    args.splice(1, 0, c, 'color: inherit');\n    // The final \"%c\" is somewhat tricky, because there could be other\n    // arguments passed either before or after the %c, so we need to\n    // figure out the correct index to insert the CSS into\n    let index = 0;\n    let lastC = 0;\n    args[0].replace(/%[a-zA-Z%]/g, (match)=>{\n        if (match === '%%') {\n            return;\n        }\n        index++;\n        if (match === '%c') {\n            // We only are interested in the *last* %c\n            // (the user may have provided their own)\n            lastC = index;\n        }\n    });\n    args.splice(lastC, 0, c);\n}\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */ exports.log = console.debug || console.log || (()=>{});\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */ function save(namespaces) {\n    try {\n        if (namespaces) {\n            exports.storage.setItem('debug', namespaces);\n        } else {\n            exports.storage.removeItem('debug');\n        }\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */ function load() {\n    let r;\n    try {\n        r = exports.storage.getItem('debug');\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n    if (!r && typeof process !== 'undefined' && 'env' in process) {\n        r = process.env.DEBUG;\n    }\n    return r;\n}\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */ function localstorage() {\n    try {\n        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n        // The Browser also has localStorage in the global context.\n        return localStorage;\n    } catch (error) {\n    // Swallow\n    // XXX (@Qix-) should we be logging these?\n    }\n}\nmodule.exports = __webpack_require__(/*! ./common */ \"(pages-dir-browser)/./node_modules/@metamask/sdk/node_modules/debug/src/common.js\")(exports);\nconst { formatters } = module.exports;\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */ formatters.j = function(v) {\n    try {\n        return JSON.stringify(v);\n    } catch (error) {\n        return '[UnexpectedJSONParseError]: ' + error.message;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc2RrL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsc0JBQXNCLEdBRXRCOztDQUVDO0FBRURBLGtCQUFrQixHQUFHQztBQUNyQkQsWUFBWSxHQUFHRTtBQUNmRixZQUFZLEdBQUdHO0FBQ2ZILGlCQUFpQixHQUFHSTtBQUNwQkosZUFBZSxHQUFHTTtBQUNsQk4sZUFBZSxHQUFHLENBQUM7SUFDbEIsSUFBSVEsU0FBUztJQUViLE9BQU87UUFDTixJQUFJLENBQUNBLFFBQVE7WUFDWkEsU0FBUztZQUNUQyxRQUFRQyxJQUFJLENBQUM7UUFDZDtJQUNEO0FBQ0Q7QUFFQTs7Q0FFQyxHQUVEVixjQUFjLEdBQUc7SUFDaEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7Q0FDQTtBQUVEOzs7Ozs7Q0FNQyxHQUVELHNDQUFzQztBQUN0QyxTQUFTSTtJQUNSLDRFQUE0RTtJQUM1RSwwRUFBMEU7SUFDMUUsYUFBYTtJQUNiLElBQUksS0FBNkIsSUFBSVEsT0FBT0MsT0FBTyxJQUFLRCxDQUFBQSxPQUFPQyxPQUFPLENBQUND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QUN0RSxJQUFJLENBQUNDLEtBQUssT0FBT2xDLE9BQU9BLEtBQUssZUFBZSxTQUFTQSxPQUFPQSxFQUFFO1FBQzdEa0MsSUFBSWxDLE9BQU9BLENBQUNvQyxHQUFHLENBQUNDLEtBQUs7SUFDdEI7SUFFQSxPQUFPSDtBQUNSO0FBRUE7Ozs7Ozs7OztDQVNDLEdBRUQsU0FBU3pDO0lBQ1IsSUFBSTtRQUNILHVHQUF1RztRQUN2RywyREFBMkQ7UUFDM0QsT0FBTzZDO0lBQ1IsRUFBRSxPQUFPTCxPQUFPO0lBQ2YsVUFBVTtJQUNWLDBDQUEwQztJQUMzQztBQUNEO0FBRUFkLE9BQU9oQyxPQUFPLEdBQUdvRCxtQkFBT0EsQ0FBQyxtR0FBVSxFQUFFcEQ7QUFFckMsTUFBTSxFQUFDcUQsVUFBVSxFQUFDLEdBQUdyQixPQUFPaEMsT0FBTztBQUVuQzs7Q0FFQyxHQUVEcUQsV0FBV0MsQ0FBQyxHQUFHLFNBQVVDLENBQUM7SUFDekIsSUFBSTtRQUNILE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ0Y7SUFDdkIsRUFBRSxPQUFPVCxPQUFPO1FBQ2YsT0FBTyxpQ0FBaUNBLE1BQU1ZLE9BQU87SUFDdEQ7QUFDRCIsInNvdXJjZXMiOlsiQzpcXHNob3BfaGFyZGhhdFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQG1ldGFtYXNrXFxzZGtcXG5vZGVfbW9kdWxlc1xcZGVidWdcXHNyY1xcYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbmV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG5cdGxldCB3YXJuZWQgPSBmYWxzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJmb3JtYXRBcmdzIiwic2F2ZSIsImxvYWQiLCJ1c2VDb2xvcnMiLCJzdG9yYWdlIiwibG9jYWxzdG9yYWdlIiwiZGVzdHJveSIsIndhcm5lZCIsImNvbnNvbGUiLCJ3YXJuIiwiY29sb3JzIiwid2luZG93IiwicHJvY2VzcyIsInR5cGUiLCJfX253anMiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ0b0xvd2VyQ2FzZSIsIm1hdGNoIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZSIsIldlYmtpdEFwcGVhcmFuY2UiLCJmaXJlYnVnIiwiZXhjZXB0aW9uIiwidGFibGUiLCJwYXJzZUludCIsIlJlZ0V4cCIsIiQxIiwiYXJncyIsIm5hbWVzcGFjZSIsIm1vZHVsZSIsImh1bWFuaXplIiwiZGlmZiIsImMiLCJjb2xvciIsInNwbGljZSIsImluZGV4IiwibGFzdEMiLCJyZXBsYWNlIiwibG9nIiwiZGVidWciLCJuYW1lc3BhY2VzIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJlcnJvciIsInIiLCJnZXRJdGVtIiwiZW52IiwiREVCVUciLCJsb2NhbFN0b3JhZ2UiLCJyZXF1aXJlIiwiZm9ybWF0dGVycyIsImoiLCJ2IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1lc3NhZ2UiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@metamask/sdk/node_modules/debug/src/browser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@metamask/sdk/node_modules/debug/src/common.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@metamask/sdk/node_modules/debug/src/common.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */ \nfunction setup(env) {\n    var _s = $RefreshSig$();\n    createDebug.debug = createDebug;\n    createDebug.default = createDebug;\n    createDebug.coerce = coerce;\n    createDebug.disable = disable;\n    createDebug.enable = enable;\n    createDebug.enabled = enabled;\n    createDebug.humanize = __webpack_require__(/*! ms */ \"(pages-dir-browser)/./node_modules/@metamask/sdk/node_modules/ms/index.js\");\n    createDebug.destroy = destroy;\n    Object.keys(env).forEach((key)=>{\n        createDebug[key] = env[key];\n    });\n    /**\n\t* The currently active debug mode names, and names to skip.\n\t*/ createDebug.names = [];\n    createDebug.skips = [];\n    /**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/ createDebug.formatters = {};\n    /**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/ function selectColor(namespace) {\n        let hash = 0;\n        for(let i = 0; i < namespace.length; i++){\n            hash = (hash << 5) - hash + namespace.charCodeAt(i);\n            hash |= 0; // Convert to 32bit integer\n        }\n        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n    }\n    createDebug.selectColor = selectColor;\n    /**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/ function createDebug(namespace) {\n        _s();\n        let prevTime;\n        let enableOverride = null;\n        let namespacesCache;\n        let enabledCache;\n        function debug() {\n            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                args[_key] = arguments[_key];\n            }\n            // Disabled?\n            if (!debug.enabled) {\n                return;\n            }\n            const self = debug;\n            // Set `diff` timestamp\n            const curr = Number(new Date());\n            const ms = curr - (prevTime || curr);\n            self.diff = ms;\n            self.prev = prevTime;\n            self.curr = curr;\n            prevTime = curr;\n            args[0] = createDebug.coerce(args[0]);\n            if (typeof args[0] !== 'string') {\n                // Anything else let's inspect with %O\n                args.unshift('%O');\n            }\n            // Apply any `formatters` transformations\n            let index = 0;\n            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{\n                // If we encounter an escaped % then don't increase the array index\n                if (match === '%%') {\n                    return '%';\n                }\n                index++;\n                const formatter = createDebug.formatters[format];\n                if (typeof formatter === 'function') {\n                    const val = args[index];\n                    match = formatter.call(self, val);\n                    // Now we need to remove `args[index]` since it's inlined in the `format`\n                    args.splice(index, 1);\n                    index--;\n                }\n                return match;\n            });\n            // Apply env-specific formatting (colors, etc.)\n            createDebug.formatArgs.call(self, args);\n            const logFn = self.log || createDebug.log;\n            logFn.apply(self, args);\n        }\n        debug.namespace = namespace;\n        debug.useColors = createDebug.useColors();\n        debug.color = createDebug.selectColor(namespace);\n        debug.extend = extend;\n        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n        Object.defineProperty(debug, 'enabled', {\n            enumerable: true,\n            configurable: false,\n            get: ()=>{\n                if (enableOverride !== null) {\n                    return enableOverride;\n                }\n                if (namespacesCache !== createDebug.namespaces) {\n                    namespacesCache = createDebug.namespaces;\n                    enabledCache = createDebug.enabled(namespace);\n                }\n                return enabledCache;\n            },\n            set: (v)=>{\n                enableOverride = v;\n            }\n        });\n        // Env-specific initialization logic for debug instances\n        if (typeof createDebug.init === 'function') {\n            createDebug.init(debug);\n        }\n        return debug;\n    }\n    _s(createDebug, \"TNTxU29/W+VV3aq8ipnhK5Nx0g0=\", false, function() {\n        return [\n            createDebug.useColors\n        ];\n    });\n    function extend(namespace, delimiter) {\n        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n        newDebug.log = this.log;\n        return newDebug;\n    }\n    /**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/ function enable(namespaces) {\n        createDebug.save(namespaces);\n        createDebug.namespaces = namespaces;\n        createDebug.names = [];\n        createDebug.skips = [];\n        let i;\n        const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n        const len = split.length;\n        for(i = 0; i < len; i++){\n            if (!split[i]) {\n                continue;\n            }\n            namespaces = split[i].replace(/\\*/g, '.*?');\n            if (namespaces[0] === '-') {\n                createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));\n            } else {\n                createDebug.names.push(new RegExp('^' + namespaces + '$'));\n            }\n        }\n    }\n    /**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/ function disable() {\n        const namespaces = [\n            ...createDebug.names.map(toNamespace),\n            ...createDebug.skips.map(toNamespace).map((namespace)=>'-' + namespace)\n        ].join(',');\n        createDebug.enable('');\n        return namespaces;\n    }\n    /**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/ function enabled(name) {\n        if (name[name.length - 1] === '*') {\n            return true;\n        }\n        let i;\n        let len;\n        for(i = 0, len = createDebug.skips.length; i < len; i++){\n            if (createDebug.skips[i].test(name)) {\n                return false;\n            }\n        }\n        for(i = 0, len = createDebug.names.length; i < len; i++){\n            if (createDebug.names[i].test(name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/ function toNamespace(regexp) {\n        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\\.\\*\\?$/, '*');\n    }\n    /**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/ function coerce(val) {\n        if (val instanceof Error) {\n            return val.stack || val.message;\n        }\n        return val;\n    }\n    /**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/ function destroy() {\n        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n    }\n    createDebug.enable(createDebug.load());\n    return createDebug;\n}\nmodule.exports = setup;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc2RrL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUNBOzs7Q0FHQztBQUVELFNBQVNBLE1BQU1DLEdBQUc7O0lBQ2pCQyxZQUFZQyxLQUFLLEdBQUdEO0lBQ3BCQSxZQUFZRSxPQUFPLEdBQUdGO0lBQ3RCQSxZQUFZRyxNQUFNLEdBQUdBO0lBQ3JCSCxZQUFZSSxPQUFPLEdBQUdBO0lBQ3RCSixZQUFZSyxNQUFNLEdBQUdBO0lBQ3JCTCxZQUFZTSxPQUFPLEdBQUdBO0lBQ3RCTixZQUFZTyxRQUFRLEdBQUdDLG1CQUFPQSxDQUFDLHFGQUFJO0lBQ25DUixZQUFZUyxPQUFPLEdBQUdBO0lBRXRCQyxPQUFPQyxJQUFJLENBQUNaLEtBQUthLE9BQU8sQ0FBQ0MsQ0FBQUE7UUFDeEJiLFdBQVcsQ0FBQ2EsSUFBSSxHQUFHZCxHQUFHLENBQUNjLElBQUk7SUFDNUI7SUFFQTs7Q0FFQSxHQUVBYixZQUFZYyxLQUFLLEdBQUcsRUFBRTtJQUN0QmQsWUFBWWUsS0FBSyxHQUFHLEVBQUU7SUFFdEI7Ozs7Q0FJQSxHQUNBZixZQUFZZ0IsVUFBVSxHQUFHLENBQUM7SUFFMUI7Ozs7O0NBS0EsR0FDQSxTQUFTQyxZQUFZQyxTQUFTO1FBQzdCLElBQUlDLE9BQU87UUFFWCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsVUFBVUcsTUFBTSxFQUFFRCxJQUFLO1lBQzFDRCxPQUFPLENBQUVBLFFBQVEsS0FBS0EsT0FBUUQsVUFBVUksVUFBVSxDQUFDRjtZQUNuREQsUUFBUSxHQUFHLDJCQUEyQjtRQUN2QztRQUVBLE9BQU9uQixZQUFZdUIsTUFBTSxDQUFDQyxLQUFLQyxHQUFHLENBQUNOLFFBQVFuQixZQUFZdUIsTUFBTSxDQUFDRixNQUFNLENBQUM7SUFDdEU7SUFDQXJCLFlBQVlpQixXQUFXLEdBQUdBO0lBRTFCOzs7Ozs7Q0FNQSxHQUNBLFNBQVNqQixZ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T0FBTztRQUNSO1FBRUEsSUFBSUQ7UUFDSixJQUFJOEM7UUFFSixJQUFLOUMsSUFBSSxHQUFHOEMsTUFBTWxFLFlBQVllLEtBQUssQ0FBQ00sTUFBTSxFQUFFRCxJQUFJOEMsS0FBSzlDLElBQUs7WUFDekQsSUFBSXBCLFlBQVllLEtBQUssQ0FBQ0ssRUFBRSxDQUFDc0QsSUFBSSxDQUFDRCxPQUFPO2dCQUNwQyxPQUFPO1lBQ1I7UUFDRDtRQUVBLElBQUtyRCxJQUFJLEdBQUc4QyxNQUFNbEUsWUFBWWMsS0FBSyxDQUFDTyxNQUFNLEVBQUVELElBQUk4QyxLQUFLOUMsSUFBSztZQUN6RCxJQUFJcEIsWUFBWWMsS0FBSyxDQUFDTSxFQUFFLENBQUNzRCxJQUFJLENBQUNELE9BQU87Z0JBQ3BDLE9BQU87WUFDUjtRQUNEO1FBRUEsT0FBTztJQUNSO0lBRUE7Ozs7OztDQU1BLEdBQ0EsU0FBU0YsWUFBWUksTUFBTTtRQUMxQixPQUFPQSxPQUFPQyxRQUFRLEdBQ3BCQyxTQUFTLENBQUMsR0FBR0YsT0FBT0MsUUFBUSxHQUFHdkQsTUFBTSxHQUFHLEdBQ3hDbUIsT0FBTyxDQUFDLFdBQVc7SUFDdEI7SUFFQTs7Ozs7O0NBTUEsR0FDQSxTQUFTckMsT0FBT3lDLEdBQUc7UUFDbEIsSUFBSUEsZUFBZWtDLE9BQU87WUFDekIsT0FBT2xDLElBQUltQyxLQUFLLElBQUluQyxJQUFJb0MsT0FBTztRQUNoQztRQUNBLE9BQU9wQztJQUNSO0lBRUE7OztDQUdBLEdBQ0EsU0FBU25DO1FBQ1J3RSxRQUFRQyxJQUFJLENBQUM7SUFDZDtJQUVBbEYsWUFBWUssTUFBTSxDQUFDTCxZQUFZbUYsSUFBSTtJQUVuQyxPQUFPbkY7QUFDUjtBQUVBb0YsT0FBT0MsT0FBTyxHQUFHdkYiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXEBtZXRhbWFza1xcc2RrXFxub2RlX21vZHVsZXNcXGRlYnVnXFxzcmNcXGNvbW1vbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblx0XHRsZXQgbmFtZXNwYWNlc0NhY2hlO1xuXHRcdGxldCBlbmFibGVkQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5hYmxlT3ZlcnJpZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcykge1xuXHRcdFx0XHRcdG5hbWVzcGFjZXNDYWNoZSA9IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXM7XG5cdFx0XHRcdFx0ZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVuYWJsZWRDYWNoZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cdFx0Y3JlYXRlRGVidWcubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zbGljZSgxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIl0sIm5hbWVzIjpbInNldHVwIiwiZW52IiwiY3JlYXRlRGVidWciLCJkZWJ1ZyIsImRlZmF1bHQiLCJjb2VyY2UiLCJkaXNhYmxlIiwiZW5hYmxlIiwiZW5hYmxlZCIsImh1bWFuaXplIiwicmVxdWlyZSIsImRlc3Ryb3kiLCJPYmplY3QiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsIm5hbWVzIiwic2tpcHMiLCJmb3JtYXR0ZXJzIiwic2VsZWN0Q29sb3IiLCJuYW1lc3BhY2UiLCJoYXNoIiwiaSIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJjb2xvcnMiLCJNYXRoIiwiYWJzIiwicHJldlRpbWUiLCJlbmFibGVPdmVycmlkZSIsIm5hbWVzcGFjZXNDYWNoZSIsImVuYWJsZWRDYWNoZSIsImFyZ3MiLCJzZWxmIiwiY3VyciIsIk51bWJlciIsIkRhdGUiLCJtcyIsImRpZmYiLCJwcmV2IiwidW5zaGlmdCIsImluZGV4IiwicmVwbGFjZSIsIm1hdGNoIiwiZm9ybWF0IiwiZm9ybWF0dGVyIiwidmFsIiwiY2FsbCIsInNwbGljZSIsImZvcm1hdEFyZ3MiLCJsb2dGbiIsImxvZyIsImFwcGx5IiwidXNlQ29sb3JzIiwiY29sb3IiLCJleHRlbmQiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJnZXQiLCJuYW1lc3BhY2VzIiwic2V0IiwidiIsImluaXQiLCJkZWxpbWl0ZXIiLCJuZXdEZWJ1ZyIsInNhdmUiLCJzcGxpdCIsImxlbiIsInB1c2giLCJSZWdFeHAiLCJzbGljZSIsIm1hcCIsInRvTmFtZXNwYWNlIiwiam9pbiIsIm5hbWUiLCJ0ZXN0IiwicmVnZXhwIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJFcnJvciIsInN0YWNrIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwibG9hZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@metamask/sdk/node_modules/debug/src/common.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@metamask/sdk/node_modules/ms/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@metamask/sdk/node_modules/ms/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * Helpers.\n */ \nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */ module.exports = function(val, options) {\n    options = options || {};\n    var type = typeof val;\n    if (type === 'string' && val.length > 0) {\n        return parse(val);\n    } else if (type === 'number' && isFinite(val)) {\n        return options.long ? fmtLong(val) : fmtShort(val);\n    }\n    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));\n};\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */ function parse(str) {\n    str = String(str);\n    if (str.length > 100) {\n        return;\n    }\n    var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);\n    if (!match) {\n        return;\n    }\n    var n = parseFloat(match[1]);\n    var type = (match[2] || 'ms').toLowerCase();\n    switch(type){\n        case 'years':\n        case 'year':\n        case 'yrs':\n        case 'yr':\n        case 'y':\n            return n * y;\n        case 'weeks':\n        case 'week':\n        case 'w':\n            return n * w;\n        case 'days':\n        case 'day':\n        case 'd':\n            return n * d;\n        case 'hours':\n        case 'hour':\n        case 'hrs':\n        case 'hr':\n        case 'h':\n            return n * h;\n        case 'minutes':\n        case 'minute':\n        case 'mins':\n        case 'min':\n        case 'm':\n            return n * m;\n        case 'seconds':\n        case 'second':\n        case 'secs':\n        case 'sec':\n        case 's':\n            return n * s;\n        case 'milliseconds':\n        case 'millisecond':\n        case 'msecs':\n        case 'msec':\n        case 'ms':\n            return n;\n        default:\n            return undefined;\n    }\n}\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */ function fmtShort(ms) {\n    var msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return Math.round(ms / d) + 'd';\n    }\n    if (msAbs >= h) {\n        return Math.round(ms / h) + 'h';\n    }\n    if (msAbs >= m) {\n        return Math.round(ms / m) + 'm';\n    }\n    if (msAbs >= s) {\n        return Math.round(ms / s) + 's';\n    }\n    return ms + 'ms';\n}\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */ function fmtLong(ms) {\n    var msAbs = Math.abs(ms);\n    if (msAbs >= d) {\n        return plural(ms, msAbs, d, 'day');\n    }\n    if (msAbs >= h) {\n        return plural(ms, msAbs, h, 'hour');\n    }\n    if (msAbs >= m) {\n        return plural(ms, msAbs, m, 'minute');\n    }\n    if (msAbs >= s) {\n        return plural(ms, msAbs, s, 'second');\n    }\n    return ms + ' ms';\n}\n/**\n * Pluralization helper.\n */ function plural(ms, msAbs, n, name) {\n    var isPlural = msAbs >= n * 1.5;\n    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svc2RrL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQztBQUVELElBQUlBLElBQUk7QUFDUixJQUFJQyxJQUFJRCxJQUFJO0FBQ1osSUFBSUUsSUFBSUQsSUFBSTtBQUNaLElBQUlFLElBQUlELElBQUk7QUFDWixJQUFJRSxJQUFJRCxJQUFJO0FBQ1osSUFBSUUsSUFBSUYsSUFBSTtBQUVaOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUVERyxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsR0FBRyxFQUFFQyxPQUFPO0lBQ3BDQSxVQUFVQSxXQUFXLENBQUM7SUFDdEIsSUFBSUMsT0FBTyxPQUFPRjtJQUNsQixJQUFJRSxTQUFTLFlBQVlGLElBQUlHLE1BQU0sR0FBRyxHQUFHO1FBQ3ZDLE9BQU9DLE1BQU1KO0lBQ2YsT0FBTyxJQUFJRSxTQUFTLFlBQVlHLFNBQVNMLE1BQU07UUFDN0MsT0FBT0MsUUFBUUssSUFBSSxHQUFHQyxRQUFRUCxPQUFPUSxTQUFTUjtJQUNoRDtJQUNBLE1BQU0sSUFBSVMsTUFDUiwwREFDRUMsS0FBS0MsU0FBUyxDQUFDWDtBQUVyQjtBQUVBOzs7Ozs7Q0FNQyxHQUVELFNBQVNJLE1BQU1RLEdBQUc7SUFDaEJBLE1BQU1DLE9BQU9EO0lBQ2IsSUFBSUEsSUFBSVQsTUFBTSxHQUFHLEtBQUs7UUFDcEI7SUFDRjtJQUNBLElBQUlXLFFBQVEsbUlBQW1JQyxJQUFJLENBQ2pKSDtJQUVGLElBQUksQ0FBQ0UsT0FBTztRQUNWO0lBQ0Y7SUFDQSxJQUFJRSxJQUFJQyxXQUFXSCxLQUFLLENBQUMsRUFBRTtJQUMzQixJQUFJWixPQUFPLENBQUNZLEtBQUssQ0FBQyxFQUFFLElBQUksSUFBRyxFQUFHSSxXQUFXO0lBQ3pDLE9BQVFoQjtRQUNOLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT2MsSUFBSW5CO1FBQ2IsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT21CLElBQUlwQjtRQUNiLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU9vQixJQUFJckI7UUFDYixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU9xQixJQUFJdEI7UUFDYixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU9zQixJQUFJdkI7UUFDYixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU91QixJQUFJeEI7UUFDYixLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU93QjtRQUNUO1lBQ0UsT0FBT0c7SUFDWDtBQUNGO0FBRUE7Ozs7OztDQU1DLEdBRUQsU0FBU1gsU0FBU1ksRUFBRTtJQUNsQixJQUFJQyxRQUFRQyxLQUFLQyxHQUFHLENBQUNIO0lBQ3JCLElBQUlDLFNBQVMxQixHQUFHO1FBQ2QsT0FBTzJCLEtBQUtFLEtBQUssQ0FBQ0osS0FBS3pCLEtBQUs7SUFDOUI7SUFDQSxJQUFJMEIsU0FBUzNCLEdBQUc7UUFDZCxPQUFPNEIsS0FBS0UsS0FBSyxDQUFDSixLQUFLMUIsS0FBSztJQUM5QjtJQUNBLElBQUkyQixTQUFTNUIsR0FBRztRQUNkLE9BQU82QixLQUFLRSxLQUFLLENBQUNKLEtBQUszQixLQUFLO0lBQzlCO0lBQ0EsSUFBSTRCLFNBQVM3QixHQUFHO1FBQ2QsT0FBTzhCLEtBQUtFLEtBQUssQ0FBQ0osS0FBSzVCLEtBQUs7SUFDOUI7SUFDQSxPQUFPNEIsS0FBSztBQUNkO0FBRUE7Ozs7OztDQU1DLEdBRUQsU0FBU2IsUUFBUWEsRUFBRTtJQUNqQixJQUFJQyxRQUFRQyxLQUFLQyxHQUFHLENBQUNIO0lBQ3JCLElBQUlDLFNBQVMxQixHQUFHO1FBQ2QsT0FBTzhCLE9BQU9MLElBQUlDLE9BQU8xQixHQUFHO0lBQzlCO0lBQ0EsSUFBSTBCLFNBQVMzQixHQUFHO1FBQ2QsT0FBTytCLE9BQU9MLElBQUlDLE9BQU8zQixHQUFHO0lBQzlCO0lBQ0EsSUFBSTJCLFNBQVM1QixHQUFHO1FBQ2QsT0FBT2dDLE9BQU9MLElBQUlDLE9BQU81QixHQUFHO0lBQzlCO0lBQ0EsSUFBSTRCLFNBQVM3QixHQUFHO1FBQ2QsT0FBT2lDLE9BQU9MLElBQUlDLE9BQU83QixHQUFHO0lBQzlCO0lBQ0EsT0FBTzRCLEtBQUs7QUFDZDtBQUVBOztDQUVDLEdBRUQsU0FBU0ssT0FBT0wsRUFBRSxFQUFFQyxLQUFLLEVBQUVMLENBQUMsRUFBRVUsSUFBSTtJQUNoQyxJQUFJQyxXQUFXTixTQUFTTCxJQUFJO0lBQzVCLE9BQU9NLEtBQUtFLEtBQUssQ0FBQ0osS0FBS0osS0FBSyxNQUFNVSxPQUFRQyxDQUFBQSxXQUFXLE1BQU0sRUFBQztBQUM5RCIsInNvdXJjZXMiOlsiQzpcXHNob3BfaGFyZGhhdFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQG1ldGFtYXNrXFxzZGtcXG5vZGVfbW9kdWxlc1xcbXNcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIl0sIm5hbWVzIjpbInMiLCJtIiwiaCIsImQiLCJ3IiwieSIsIm1vZHVsZSIsImV4cG9ydHMiLCJ2YWwiLCJvcHRpb25zIiwidHlwZSIsImxlbmd0aCIsInBhcnNlIiwiaXNGaW5pdGUiLCJsb25nIiwiZm10TG9uZyIsImZtdFNob3J0IiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwic3RyIiwiU3RyaW5nIiwibWF0Y2giLCJleGVjIiwibiIsInBhcnNlRmxvYXQiLCJ0b0xvd2VyQ2FzZSIsInVuZGVmaW5lZCIsIm1zIiwibXNBYnMiLCJNYXRoIiwiYWJzIiwicm91bmQiLCJwbHVyYWwiLCJuYW1lIiwiaXNQbHVyYWwiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@metamask/sdk/node_modules/ms/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/@socket.io/component-emitter/lib/esm/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@socket.io/component-emitter/lib/esm/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Emitter: () => (/* binding */ Emitter)\n/* harmony export */ });\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks['$' + event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks['$' + event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n\n  // Remove event specific arrays for event types that no\n  // one is subscribed for to avoid memory leak.\n  if (callbacks.length === 0) {\n    delete this._callbacks['$' + event];\n  }\n\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n\n  var args = new Array(arguments.length - 1)\n    , callbacks = this._callbacks['$' + event];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args[i - 1] = arguments[i];\n  }\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n// alias used for reserved events (protected method)\nEmitter.prototype.emitReserved = Emitter.prototype.emit;\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks['$' + event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29ja2V0LmlvL2NvbXBvbmVudC1lbWl0dGVyL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLFNBQVM7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXHNob3BfaGFyZGhhdFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcQHNvY2tldC5pb1xcY29tcG9uZW50LWVtaXR0ZXJcXGxpYlxcZXNtXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufVxuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPVxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgdGhpcy5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBldmVudCBzcGVjaWZpYyBhcnJheXMgZm9yIGV2ZW50IHR5cGVzIHRoYXQgbm9cbiAgLy8gb25lIGlzIHN1YnNjcmliZWQgZm9yIHRvIGF2b2lkIG1lbW9yeSBsZWFrLlxuICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgfVxuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gYWxpYXMgdXNlZCBmb3IgcmVzZXJ2ZWQgZXZlbnRzIChwcm90ZWN0ZWQgbWV0aG9kKVxuRW1pdHRlci5wcm90b3R5cGUuZW1pdFJlc2VydmVkID0gRW1pdHRlci5wcm90b3R5cGUuZW1pdDtcblxuLyoqXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/@socket.io/component-emitter/lib/esm/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/cross-fetch/dist/browser-ponyfill.js":
/*!***********************************************************!*\
  !*** ./node_modules/cross-fetch/dist/browser-ponyfill.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("// Save global object in a variable\nvar __global__ =\n(typeof globalThis !== 'undefined' && globalThis) ||\n(typeof self !== 'undefined' && self) ||\n(typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g);\n// Create an object that extends from __global__ without the fetch function\nvar __globalThis__ = (function () {\nfunction F() {\nthis.fetch = false;\nthis.DOMException = __global__.DOMException\n}\nF.prototype = __global__; // Needed for feature detection on whatwg-fetch's code\nreturn new F();\n})();\n// Wraps whatwg-fetch with a function scope to hijack the global object\n// \"globalThis\" that's going to be patched\n(function(globalThis) {\n\nvar irrelevant = (function (exports) {\n\n  /* eslint-disable no-prototype-builtins */\n  var g =\n    (typeof globalThis !== 'undefined' && globalThis) ||\n    (typeof self !== 'undefined' && self) ||\n    // eslint-disable-next-line no-undef\n    (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g) ||\n    {};\n\n  var support = {\n    searchParams: 'URLSearchParams' in g,\n    iterable: 'Symbol' in g && 'iterator' in Symbol,\n    blob:\n      'FileReader' in g &&\n      'Blob' in g &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in g,\n    arrayBuffer: 'ArrayBuffer' in g\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {\n      throw new TypeError('Invalid character in header field name: \"' + name + '\"')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        if (header.length != 2) {\n          throw new TypeError('Headers constructor: expected name/value pair to be length 2, found' + header.length)\n        }\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body._noBody) return\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    var match = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);\n    var encoding = match ? match[1] : 'utf-8';\n    reader.readAsText(blob, encoding);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      /*\n        fetch-mock wraps the Response object in an ES6 Proxy to\n        provide useful test harness features such as flush. However, on\n        ES5 browsers without fetch or Proxy support pollyfills must be used;\n        the proxy-pollyfill is unable to proxy an attribute unless it exists\n        on the object before the Proxy is created. This change ensures\n        Response.bodyUsed exists on the instance, while maintaining the\n        semantic of setting Request.bodyUsed in the constructor before\n        _initBody is called.\n      */\n      // eslint-disable-next-line no-self-assign\n      this.bodyUsed = this.bodyUsed;\n      this._bodyInit = body;\n      if (!body) {\n        this._noBody = true;\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n    }\n\n    this.arrayBuffer = function() {\n      if (this._bodyArrayBuffer) {\n        var isConsumed = consumed(this);\n        if (isConsumed) {\n          return isConsumed\n        } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {\n          return Promise.resolve(\n            this._bodyArrayBuffer.buffer.slice(\n              this._bodyArrayBuffer.byteOffset,\n              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength\n            )\n          )\n        } else {\n          return Promise.resolve(this._bodyArrayBuffer)\n        }\n      } else if (support.blob) {\n        return this.blob().then(readBlobAsArrayBuffer)\n      } else {\n        throw new Error('could not read as ArrayBuffer')\n      }\n    };\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PATCH', 'POST', 'PUT', 'TRACE'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n    }\n\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal || (function () {\n      if ('AbortController' in g) {\n        var ctrl = new AbortController();\n        return ctrl.signal;\n      }\n    }());\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n\n    if (this.method === 'GET' || this.method === 'HEAD') {\n      if (options.cache === 'no-store' || options.cache === 'no-cache') {\n        // Search for a '_' parameter in the query string\n        var reParamSearch = /([?&])_=[^&]*/;\n        if (reParamSearch.test(this.url)) {\n          // If it already exists then set the value with the current time\n          this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());\n        } else {\n          // Otherwise add a new '_' parameter to the end with the current time\n          var reQueryString = /\\?/;\n          this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();\n        }\n      }\n    }\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill\n    // https://github.com/github/fetch/issues/748\n    // https://github.com/zloirock/core-js/issues/751\n    preProcessedHeaders\n      .split('\\r')\n      .map(function(header) {\n        return header.indexOf('\\n') === 0 ? header.substr(1, header.length) : header\n      })\n      .forEach(function(line) {\n        var parts = line.split(':');\n        var key = parts.shift().trim();\n        if (key) {\n          var value = parts.join(':').trim();\n          try {\n            headers.append(key, value);\n          } catch (error) {\n            console.warn('Response ' + error.message);\n          }\n        }\n      });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Please use the \"new\" operator, this DOM object constructor cannot be called as a function.')\n    }\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    if (this.status < 200 || this.status > 599) {\n      throw new RangeError(\"Failed to construct 'Response': The status provided (0) is outside the range [200, 599].\")\n    }\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = options.statusText === undefined ? '' : '' + options.statusText;\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 200, statusText: ''});\n    response.ok = false;\n    response.status = 0;\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = g.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        // This check if specifically for when a user fetches a file locally from the file system\n        // Only if the status is out of a normal range\n        if (request.url.indexOf('file://') === 0 && (xhr.status < 200 || xhr.status > 599)) {\n          options.status = 200;\n        } else {\n          options.status = xhr.status;\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        setTimeout(function() {\n          resolve(new Response(body, options));\n        }, 0);\n      };\n\n      xhr.onerror = function() {\n        setTimeout(function() {\n          reject(new TypeError('Network request failed'));\n        }, 0);\n      };\n\n      xhr.ontimeout = function() {\n        setTimeout(function() {\n          reject(new TypeError('Network request timed out'));\n        }, 0);\n      };\n\n      xhr.onabort = function() {\n        setTimeout(function() {\n          reject(new exports.DOMException('Aborted', 'AbortError'));\n        }, 0);\n      };\n\n      function fixUrl(url) {\n        try {\n          return url === '' && g.location.href ? g.location.href : url\n        } catch (e) {\n          return url\n        }\n      }\n\n      xhr.open(request.method, fixUrl(request.url), true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr) {\n        if (support.blob) {\n          xhr.responseType = 'blob';\n        } else if (\n          support.arrayBuffer\n        ) {\n          xhr.responseType = 'arraybuffer';\n        }\n      }\n\n      if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers || (g.Headers && init.headers instanceof g.Headers))) {\n        var names = [];\n        Object.getOwnPropertyNames(init.headers).forEach(function(name) {\n          names.push(normalizeName(name));\n          xhr.setRequestHeader(name, normalizeValue(init.headers[name]));\n        });\n        request.headers.forEach(function(value, name) {\n          if (names.indexOf(name) === -1) {\n            xhr.setRequestHeader(name, value);\n          }\n        });\n      } else {\n        request.headers.forEach(function(value, name) {\n          xhr.setRequestHeader(name, value);\n        });\n      }\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!g.fetch) {\n    g.fetch = fetch;\n    g.Headers = Headers;\n    g.Request = Request;\n    g.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  return exports;\n\n})({});\n})(__globalThis__);\n// This is a ponyfill, so...\n__globalThis__.fetch.ponyfill = true;\ndelete __globalThis__.fetch.polyfill;\n// Choose between native implementation (__global__) or custom implementation (__globalThis__)\nvar ctx = __global__.fetch ? __global__ : __globalThis__;\nexports = ctx.fetch // To enable: import fetch from 'cross-fetch'\nexports[\"default\"] = ctx.fetch // For TypeScript consumers without esModuleInterop.\nexports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'\nexports.Headers = ctx.Headers\nexports.Request = ctx.Request\nexports.Response = ctx.Response\nmodule.exports = exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9jcm9zcy1mZXRjaC9kaXN0L2Jyb3dzZXItcG9ueWZpbGwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFCQUFNLG9CQUFvQixxQkFBTTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFNLG9CQUFvQixxQkFBTTtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIscUJBQXFCO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHVDQUF1Qyw0QkFBNEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsMEJBQTBCLGVBQWU7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxJQUFJO0FBQ0wsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YsYUFBYSxtQ0FBbUMsT0FBTztBQUN2RCxlQUFlO0FBQ2YsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsiQzpcXHNob3BfaGFyZGhhdFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcY3Jvc3MtZmV0Y2hcXGRpc3RcXGJyb3dzZXItcG9ueWZpbGwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2F2ZSBnbG9iYWwgb2JqZWN0IGluIGEgdmFyaWFibGVcbnZhciBfX2dsb2JhbF9fID1cbih0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcykgfHxcbih0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZikgfHxcbih0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwpO1xuLy8gQ3JlYXRlIGFuIG9iamVjdCB0aGF0IGV4dGVuZHMgZnJvbSBfX2dsb2JhbF9fIHdpdGhvdXQgdGhlIGZldGNoIGZ1bmN0aW9uXG52YXIgX19nbG9iYWxUaGlzX18gPSAoZnVuY3Rpb24gKCkge1xuZnVuY3Rpb24gRigpIHtcbnRoaXMuZmV0Y2ggPSBmYWxzZTtcbnRoaXMuRE9NRXhjZXB0aW9uID0gX19nbG9iYWxfXy5ET01FeGNlcHRpb25cbn1cbkYucHJvdG90eXBlID0gX19nbG9iYWxfXzsgLy8gTmVlZGVkIGZvciBmZWF0dXJlIGRldGVjdGlvbiBvbiB3aGF0d2ctZmV0Y2gncyBjb2RlXG5yZXR1cm4gbmV3IEYoKTtcbn0pKCk7XG4vLyBXcmFwcyB3aGF0d2ctZmV0Y2ggd2l0aCBhIGZ1bmN0aW9uIHNjb3BlIHRvIGhpamFjayB0aGUgZ2xvYmFsIG9iamVjdFxuLy8gXCJnbG9iYWxUaGlzXCIgdGhhdCdzIGdvaW5nIHRvIGJlIHBhdGNoZWRcbihmdW5jdGlvbihnbG9iYWxUaGlzKSB7XG5cbnZhciBpcnJlbGV2YW50ID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zICovXG4gIHZhciBnID1cbiAgICAodHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbFRoaXMpIHx8XG4gICAgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmKSB8fFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwpIHx8XG4gICAge307XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBnLFxuICAgIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBnICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICAgIGJsb2I6XG4gICAgICAnRmlsZVJlYWRlcicgaW4gZyAmJlxuICAgICAgJ0Jsb2InIGluIGcgJiZcbiAgICAgIChmdW5jdGlvbigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXcgQmxvYigpO1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBnLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIGdcbiAgfTtcblxuICBmdW5jdGlvbiBpc0RhdGFWaWV3KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgICBdO1xuXG4gICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICAgIEFycmF5QnVmZmVyLmlzVmlldyB8fFxuICAgICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+IV0vaS50ZXN0KG5hbWUpIHx8IG5hbWUgPT09ICcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZTogXCInICsgbmFtZSArICdcIicpXG4gICAgfVxuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuICBmdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykge1xuICAgIHZhciBpdGVyYXRvciA9IHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4ge2RvbmU6IHZhbHVlID09PSB1bmRlZmluZWQsIHZhbHVlOiB2YWx1ZX1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBpdGVyYXRvclxuICB9XG5cbiAgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgdGhpcy5tYXAgPSB7fTtcblxuICAgIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICBpZiAoaGVhZGVyLmxlbmd0aCAhPSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGVhZGVycyBjb25zdHJ1Y3RvcjogZXhwZWN0ZWQgbmFtZS92YWx1ZSBwYWlyIHRvIGJlIGxlbmd0aCAyLCBmb3VuZCcgKyBoZWFkZXIubGVuZ3RoKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXTtcbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUgKyAnLCAnICsgdmFsdWUgOiB2YWx1ZTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMubWFwW25vcm1hbGl6ZU5hbWUobmFtZSldO1xuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLm1hcFtuYW1lXSA6IG51bGxcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmhhc093blByb3BlcnR5KG5vcm1hbGl6ZU5hbWUobmFtZSkpXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMubWFwKSB7XG4gICAgICBpZiAodGhpcy5tYXAuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzQXJnLCB0aGlzLm1hcFtuYW1lXSwgbmFtZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaXRlbXMucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgIGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm9yKGl0ZW1zKVxuICB9O1xuXG4gIGlmIChzdXBwb3J0Lml0ZXJhYmxlKSB7XG4gICAgSGVhZGVycy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IEhlYWRlcnMucHJvdG90eXBlLmVudHJpZXM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdW1lZChib2R5KSB7XG4gICAgaWYgKGJvZHkuX25vQm9keSkgcmV0dXJuXG4gICAgaWYgKGJvZHkuYm9keVVzZWQpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKSlcbiAgICB9XG4gICAgYm9keS5ib2R5VXNlZCA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgfTtcbiAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgICAgfTtcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc0FycmF5QnVmZmVyKGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEJsb2JBc1RleHQoYmxvYikge1xuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHZhciBwcm9taXNlID0gZmlsZVJlYWRlclJlYWR5KHJlYWRlcik7XG4gICAgdmFyIG1hdGNoID0gL2NoYXJzZXQ9KFtBLVphLXowLTlfLV0rKS8uZXhlYyhibG9iLnR5cGUpO1xuICAgIHZhciBlbmNvZGluZyA9IG1hdGNoID8gbWF0Y2hbMV0gOiAndXRmLTgnO1xuICAgIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IsIGVuY29kaW5nKTtcbiAgICByZXR1cm4gcHJvbWlzZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZEFycmF5QnVmZmVyQXNUZXh0KGJ1Zikge1xuICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcbiAgICB2YXIgY2hhcnMgPSBuZXcgQXJyYXkodmlldy5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGFyc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodmlld1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFycy5qb2luKCcnKVxuICB9XG5cbiAgZnVuY3Rpb24gYnVmZmVyQ2xvbmUoYnVmKSB7XG4gICAgaWYgKGJ1Zi5zbGljZSkge1xuICAgICAgcmV0dXJuIGJ1Zi5zbGljZSgwKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgIHZpZXcuc2V0KG5ldyBVaW50OEFycmF5KGJ1ZikpO1xuICAgICAgcmV0dXJuIHZpZXcuYnVmZmVyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gQm9keSgpIHtcbiAgICB0aGlzLmJvZHlVc2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9pbml0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcbiAgICAgIC8qXG4gICAgICAgIGZldGNoLW1vY2sgd3JhcHMgdGhlIFJlc3BvbnNlIG9iamVjdCBpbiBhbiBFUzYgUHJveHkgdG9cbiAgICAgICAgcHJvdmlkZSB1c2VmdWwgdGVzdCBoYXJuZXNzIGZlYXR1cmVzIHN1Y2ggYXMgZmx1c2guIEhvd2V2ZXIsIG9uXG4gICAgICAgIEVTNSBicm93c2VycyB3aXRob3V0IGZldGNoIG9yIFByb3h5IHN1cHBvcnQgcG9sbHlmaWxscyBtdXN0IGJlIHVzZWQ7XG4gICAgICAgIHRoZSBwcm94eS1wb2xseWZpbGwgaXMgdW5hYmxlIHRvIHByb3h5IGFuIGF0dHJpYnV0ZSB1bmxlc3MgaXQgZXhpc3RzXG4gICAgICAgIG9uIHRoZSBvYmplY3QgYmVmb3JlIHRoZSBQcm94eSBpcyBjcmVhdGVkLiBUaGlzIGNoYW5nZSBlbnN1cmVzXG4gICAgICAgIFJlc3BvbnNlLmJvZHlVc2VkIGV4aXN0cyBvbiB0aGUgaW5zdGFuY2UsIHdoaWxlIG1haW50YWluaW5nIHRoZVxuICAgICAgICBzZW1hbnRpYyBvZiBzZXR0aW5nIFJlcXVlc3QuYm9keVVzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIGJlZm9yZVxuICAgICAgICBfaW5pdEJvZHkgaXMgY2FsbGVkLlxuICAgICAgKi9cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWFzc2lnblxuICAgICAgdGhpcy5ib2R5VXNlZCA9IHRoaXMuYm9keVVzZWQ7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fbm9Cb2R5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcik7XG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICB2YXIgaXNDb25zdW1lZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgICBpZiAoaXNDb25zdW1lZCkge1xuICAgICAgICAgIHJldHVybiBpc0NvbnN1bWVkXG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFxuICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ1ZmZlci5zbGljZShcbiAgICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlT2Zmc2V0ICsgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ5dGVMZW5ndGhcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgYXMgQXJyYXlCdWZmZXInKVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydDT05ORUNUJywgJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BBVENIJywgJ1BPU1QnLCAnUFVUJywgJ1RSQUNFJ107XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIG1ldGhvZHMuaW5kZXhPZih1cGNhc2VkKSA+IC0xID8gdXBjYXNlZCA6IG1ldGhvZFxuICB9XG5cbiAgZnVuY3Rpb24gUmVxdWVzdChpbnB1dCwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXF1ZXN0KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGxlYXNlIHVzZSB0aGUgXCJuZXdcIiBvcGVyYXRvciwgdGhpcyBET00gb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi4nKVxuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBib2R5ID0gb3B0aW9ucy5ib2R5O1xuXG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgUmVxdWVzdCkge1xuICAgICAgaWYgKGlucHV0LmJvZHlVc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscmVhZHkgcmVhZCcpXG4gICAgICB9XG4gICAgICB0aGlzLnVybCA9IGlucHV0LnVybDtcbiAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBpbnB1dC5jcmVkZW50aWFscztcbiAgICAgIGlmICghb3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKGlucHV0LmhlYWRlcnMpO1xuICAgICAgfVxuICAgICAgdGhpcy5tZXRob2QgPSBpbnB1dC5tZXRob2Q7XG4gICAgICB0aGlzLm1vZGUgPSBpbnB1dC5tb2RlO1xuICAgICAgdGhpcy5zaWduYWwgPSBpbnB1dC5zaWduYWw7XG4gICAgICBpZiAoIWJvZHkgJiYgaW5wdXQuX2JvZHlJbml0ICE9IG51bGwpIHtcbiAgICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdDtcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dCk7XG4gICAgfVxuXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnc2FtZS1vcmlnaW4nO1xuICAgIGlmIChvcHRpb25zLmhlYWRlcnMgfHwgIXRoaXMuaGVhZGVycykge1xuICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICB9XG4gICAgdGhpcy5tZXRob2QgPSBub3JtYWxpemVNZXRob2Qob3B0aW9ucy5tZXRob2QgfHwgdGhpcy5tZXRob2QgfHwgJ0dFVCcpO1xuICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZSB8fCB0aGlzLm1vZGUgfHwgbnVsbDtcbiAgICB0aGlzLnNpZ25hbCA9IG9wdGlvbnMuc2lnbmFsIHx8IHRoaXMuc2lnbmFsIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoJ0Fib3J0Q29udHJvbGxlcicgaW4gZykge1xuICAgICAgICB2YXIgY3RybCA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgcmV0dXJuIGN0cmwuc2lnbmFsO1xuICAgICAgfVxuICAgIH0oKSk7XG4gICAgdGhpcy5yZWZlcnJlciA9IG51bGw7XG5cbiAgICBpZiAoKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSAmJiBib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb2R5IG5vdCBhbGxvd2VkIGZvciBHRVQgb3IgSEVBRCByZXF1ZXN0cycpXG4gICAgfVxuICAgIHRoaXMuX2luaXRCb2R5KGJvZHkpO1xuXG4gICAgaWYgKHRoaXMubWV0aG9kID09PSAnR0VUJyB8fCB0aGlzLm1ldGhvZCA9PT0gJ0hFQUQnKSB7XG4gICAgICBpZiAob3B0aW9ucy5jYWNoZSA9PT0gJ25vLXN0b3JlJyB8fCBvcHRpb25zLmNhY2hlID09PSAnbm8tY2FjaGUnKSB7XG4gICAgICAgIC8vIFNlYXJjaCBmb3IgYSAnXycgcGFyYW1ldGVyIGluIHRoZSBxdWVyeSBzdHJpbmdcbiAgICAgICAgdmFyIHJlUGFyYW1TZWFyY2ggPSAvKFs/Jl0pXz1bXiZdKi87XG4gICAgICAgIGlmIChyZVBhcmFtU2VhcmNoLnRlc3QodGhpcy51cmwpKSB7XG4gICAgICAgICAgLy8gSWYgaXQgYWxyZWFkeSBleGlzdHMgdGhlbiBzZXQgdGhlIHZhbHVlIHdpdGggdGhlIGN1cnJlbnQgdGltZVxuICAgICAgICAgIHRoaXMudXJsID0gdGhpcy51cmwucmVwbGFjZShyZVBhcmFtU2VhcmNoLCAnJDFfPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBhIG5ldyAnXycgcGFyYW1ldGVyIHRvIHRoZSBlbmQgd2l0aCB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgICAgdmFyIHJlUXVlcnlTdHJpbmcgPSAvXFw/LztcbiAgICAgICAgICB0aGlzLnVybCArPSAocmVRdWVyeVN0cmluZy50ZXN0KHRoaXMudXJsKSA/ICcmJyA6ICc/JykgKyAnXz0nICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBSZXF1ZXN0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh0aGlzLCB7Ym9keTogdGhpcy5fYm9keUluaXR9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRlY29kZShib2R5KSB7XG4gICAgdmFyIGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgICBib2R5XG4gICAgICAudHJpbSgpXG4gICAgICAuc3BsaXQoJyYnKVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgaWYgKGJ5dGVzKSB7XG4gICAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHNwbGl0LnNoaWZ0KCkucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc3BsaXQuam9pbignPScpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHJldHVybiBmb3JtXG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhlYWRlcnMocmF3SGVhZGVycykge1xuICAgIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICAvLyBSZXBsYWNlIGluc3RhbmNlcyBvZiBcXHJcXG4gYW5kIFxcbiBmb2xsb3dlZCBieSBhdCBsZWFzdCBvbmUgc3BhY2Ugb3IgaG9yaXpvbnRhbCB0YWIgd2l0aCBhIHNwYWNlXG4gICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzAjc2VjdGlvbi0zLjJcbiAgICB2YXIgcHJlUHJvY2Vzc2VkSGVhZGVycyA9IHJhd0hlYWRlcnMucmVwbGFjZSgvXFxyP1xcbltcXHQgXSsvZywgJyAnKTtcbiAgICAvLyBBdm9pZGluZyBzcGxpdCB2aWEgcmVnZXggdG8gd29yayBhcm91bmQgYSBjb21tb24gSUUxMSBidWcgd2l0aCB0aGUgY29yZS1qcyAzLjYuMCByZWdleCBwb2x5ZmlsbFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gvaXNzdWVzLzc0OFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy83NTFcbiAgICBwcmVQcm9jZXNzZWRIZWFkZXJzXG4gICAgICAuc3BsaXQoJ1xccicpXG4gICAgICAubWFwKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICByZXR1cm4gaGVhZGVyLmluZGV4T2YoJ1xcbicpID09PSAwID8gaGVhZGVyLnN1YnN0cigxLCBoZWFkZXIubGVuZ3RoKSA6IGhlYWRlclxuICAgICAgfSlcbiAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gbGluZS5zcGxpdCgnOicpO1xuICAgICAgICB2YXIga2V5ID0gcGFydHMuc2hpZnQoKS50cmltKCk7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJ0cy5qb2luKCc6JykudHJpbSgpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdSZXNwb25zZSAnICsgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICByZXR1cm4gaGVhZGVyc1xuICB9XG5cbiAgQm9keS5jYWxsKFJlcXVlc3QucHJvdG90eXBlKTtcblxuICBmdW5jdGlvbiBSZXNwb25zZShib2R5SW5pdCwgb3B0aW9ucykge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZXNwb25zZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIFwibmV3XCIgb3BlcmF0b3IsIHRoaXMgRE9NIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uJylcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdGhpcy50eXBlID0gJ2RlZmF1bHQnO1xuICAgIHRoaXMuc3RhdHVzID0gb3B0aW9ucy5zdGF0dXMgPT09IHVuZGVmaW5lZCA/IDIwMCA6IG9wdGlvbnMuc3RhdHVzO1xuICAgIGlmICh0aGlzLnN0YXR1cyA8IDIwMCB8fCB0aGlzLnN0YXR1cyA+IDU5OSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdSZXNwb25zZSc6IFRoZSBzdGF0dXMgcHJvdmlkZWQgKDApIGlzIG91dHNpZGUgdGhlIHJhbmdlIFsyMDAsIDU5OV0uXCIpXG4gICAgfVxuICAgIHRoaXMub2sgPSB0aGlzLnN0YXR1cyA+PSAyMDAgJiYgdGhpcy5zdGF0dXMgPCAzMDA7XG4gICAgdGhpcy5zdGF0dXNUZXh0ID0gb3B0aW9ucy5zdGF0dXNUZXh0ID09PSB1bmRlZmluZWQgPyAnJyA6ICcnICsgb3B0aW9ucy5zdGF0dXNUZXh0O1xuICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgdGhpcy51cmwgPSBvcHRpb25zLnVybCB8fCAnJztcbiAgICB0aGlzLl9pbml0Qm9keShib2R5SW5pdCk7XG4gIH1cblxuICBCb2R5LmNhbGwoUmVzcG9uc2UucHJvdG90eXBlKTtcblxuICBSZXNwb25zZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMuX2JvZHlJbml0LCB7XG4gICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnModGhpcy5oZWFkZXJzKSxcbiAgICAgIHVybDogdGhpcy51cmxcbiAgICB9KVxuICB9O1xuXG4gIFJlc3BvbnNlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IDIwMCwgc3RhdHVzVGV4dDogJyd9KTtcbiAgICByZXNwb25zZS5vayA9IGZhbHNlO1xuICAgIHJlc3BvbnNlLnN0YXR1cyA9IDA7XG4gICAgcmVzcG9uc2UudHlwZSA9ICdlcnJvcic7XG4gICAgcmV0dXJuIHJlc3BvbnNlXG4gIH07XG5cbiAgdmFyIHJlZGlyZWN0U3RhdHVzZXMgPSBbMzAxLCAzMDIsIDMwMywgMzA3LCAzMDhdO1xuXG4gIFJlc3BvbnNlLnJlZGlyZWN0ID0gZnVuY3Rpb24odXJsLCBzdGF0dXMpIHtcbiAgICBpZiAocmVkaXJlY3RTdGF0dXNlcy5pbmRleE9mKHN0YXR1cykgPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBzdGF0dXMgY29kZScpXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7c3RhdHVzOiBzdGF0dXMsIGhlYWRlcnM6IHtsb2NhdGlvbjogdXJsfX0pXG4gIH07XG5cbiAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBnLkRPTUV4Y2VwdGlvbjtcbiAgdHJ5IHtcbiAgICBuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24gPSBmdW5jdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgIHZhciBlcnJvciA9IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgdGhpcy5zdGFjayA9IGVycm9yLnN0YWNrO1xuICAgIH07XG4gICAgZXhwb3J0cy5ET01FeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGV4cG9ydHMuRE9NRXhjZXB0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZmV0Y2goaW5wdXQsIGluaXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IG5ldyBSZXF1ZXN0KGlucHV0LCBpbml0KTtcblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsICYmIHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKVxuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIGZ1bmN0aW9uIGFib3J0WGhyKCkge1xuICAgICAgICB4aHIuYWJvcnQoKTtcbiAgICAgIH1cblxuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpIHx8ICcnKVxuICAgICAgICB9O1xuICAgICAgICAvLyBUaGlzIGNoZWNrIGlmIHNwZWNpZmljYWxseSBmb3Igd2hlbiBhIHVzZXIgZmV0Y2hlcyBhIGZpbGUgbG9jYWxseSBmcm9tIHRoZSBmaWxlIHN5c3RlbVxuICAgICAgICAvLyBPbmx5IGlmIHRoZSBzdGF0dXMgaXMgb3V0IG9mIGEgbm9ybWFsIHJhbmdlXG4gICAgICAgIGlmIChyZXF1ZXN0LnVybC5pbmRleE9mKCdmaWxlOi8vJykgPT09IDAgJiYgKHhoci5zdGF0dXMgPCAyMDAgfHwgeGhyLnN0YXR1cyA+IDU5OSkpIHtcbiAgICAgICAgICBvcHRpb25zLnN0YXR1cyA9IDIwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLnN0YXR1cyA9IHhoci5zdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy51cmwgPSAncmVzcG9uc2VVUkwnIGluIHhociA/IHhoci5yZXNwb25zZVVSTCA6IG9wdGlvbnMuaGVhZGVycy5nZXQoJ1gtUmVxdWVzdC1VUkwnKTtcbiAgICAgICAgdmFyIGJvZHkgPSAncmVzcG9uc2UnIGluIHhociA/IHhoci5yZXNwb25zZSA6IHhoci5yZXNwb25zZVRleHQ7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVzb2x2ZShuZXcgUmVzcG9uc2UoYm9keSwgb3B0aW9ucykpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSk7XG4gICAgICAgIH0sIDApO1xuICAgICAgfTtcblxuICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgdGltZWQgb3V0JykpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBleHBvcnRzLkRPTUV4Y2VwdGlvbignQWJvcnRlZCcsICdBYm9ydEVycm9yJykpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGZpeFVybCh1cmwpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gdXJsID09PSAnJyAmJiBnLmxvY2F0aW9uLmhyZWYgPyBnLmxvY2F0aW9uLmhyZWYgOiB1cmxcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiB1cmxcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgZml4VXJsKHJlcXVlc3QudXJsKSwgdHJ1ZSk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnaW5jbHVkZScpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdvbWl0Jykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgc3VwcG9ydC5hcnJheUJ1ZmZlclxuICAgICAgICApIHtcbiAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaW5pdCAmJiB0eXBlb2YgaW5pdC5oZWFkZXJzID09PSAnb2JqZWN0JyAmJiAhKGluaXQuaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMgfHwgKGcuSGVhZGVycyAmJiBpbml0LmhlYWRlcnMgaW5zdGFuY2VvZiBnLkhlYWRlcnMpKSkge1xuICAgICAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaW5pdC5oZWFkZXJzKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICBuYW1lcy5wdXNoKG5vcm1hbGl6ZU5hbWUobmFtZSkpO1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIG5vcm1hbGl6ZVZhbHVlKGluaXQuaGVhZGVyc1tuYW1lXSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICBpZiAobmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdC5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVxdWVzdC5zaWduYWwpIHtcbiAgICAgICAgcmVxdWVzdC5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydFhocik7XG5cbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIC8vIERPTkUgKHN1Y2Nlc3Mgb3IgZmFpbHVyZSlcbiAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdCk7XG4gICAgfSlcbiAgfVxuXG4gIGZldGNoLnBvbHlmaWxsID0gdHJ1ZTtcblxuICBpZiAoIWcuZmV0Y2gpIHtcbiAgICBnLmZldGNoID0gZmV0Y2g7XG4gICAgZy5IZWFkZXJzID0gSGVhZGVycztcbiAgICBnLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICAgIGcuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgfVxuXG4gIGV4cG9ydHMuSGVhZGVycyA9IEhlYWRlcnM7XG4gIGV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG4gIGV4cG9ydHMuUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgZXhwb3J0cy5mZXRjaCA9IGZldGNoO1xuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KSh7fSk7XG59KShfX2dsb2JhbFRoaXNfXyk7XG4vLyBUaGlzIGlzIGEgcG9ueWZpbGwsIHNvLi4uXG5fX2dsb2JhbFRoaXNfXy5mZXRjaC5wb255ZmlsbCA9IHRydWU7XG5kZWxldGUgX19nbG9iYWxUaGlzX18uZmV0Y2gucG9seWZpbGw7XG4vLyBDaG9vc2UgYmV0d2VlbiBuYXRpdmUgaW1wbGVtZW50YXRpb24gKF9fZ2xvYmFsX18pIG9yIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiAoX19nbG9iYWxUaGlzX18pXG52YXIgY3R4ID0gX19nbG9iYWxfXy5mZXRjaCA/IF9fZ2xvYmFsX18gOiBfX2dsb2JhbFRoaXNfXztcbmV4cG9ydHMgPSBjdHguZmV0Y2ggLy8gVG8gZW5hYmxlOiBpbXBvcnQgZmV0Y2ggZnJvbSAnY3Jvc3MtZmV0Y2gnXG5leHBvcnRzLmRlZmF1bHQgPSBjdHguZmV0Y2ggLy8gRm9yIFR5cGVTY3JpcHQgY29uc3VtZXJzIHdpdGhvdXQgZXNNb2R1bGVJbnRlcm9wLlxuZXhwb3J0cy5mZXRjaCA9IGN0eC5mZXRjaCAvLyBUbyBlbmFibGU6IGltcG9ydCB7ZmV0Y2h9IGZyb20gJ2Nyb3NzLWZldGNoJ1xuZXhwb3J0cy5IZWFkZXJzID0gY3R4LkhlYWRlcnNcbmV4cG9ydHMuUmVxdWVzdCA9IGN0eC5SZXF1ZXN0XG5leHBvcnRzLlJlc3BvbnNlID0gY3R4LlJlc3BvbnNlXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/cross-fetch/dist/browser-ponyfill.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/engine.io-client/build/esm/contrib/has-cors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/engine.io-client/build/esm/contrib/has-cors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasCORS: () => (/* binding */ hasCORS)\n/* harmony export */ });\n// imported from https://github.com/component/has-cors\nlet value = false;\ntry {\n    value = typeof XMLHttpRequest !== 'undefined' &&\n        'withCredentials' in new XMLHttpRequest();\n}\ncatch (err) {\n    // if XMLHttp support is disabled in IE then it will throw\n    // when trying to create\n}\nconst hasCORS = value;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS9jb250cmliL2hhcy1jb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPIiwic291cmNlcyI6WyJDOlxcc2hvcF9oYXJkaGF0XFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxlbmdpbmUuaW8tY2xpZW50XFxidWlsZFxcZXNtXFxjb250cmliXFxoYXMtY29ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jb21wb25lbnQvaGFzLWNvcnNcbmxldCB2YWx1ZSA9IGZhbHNlO1xudHJ5IHtcbiAgICB2YWx1ZSA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG59XG5jYXRjaCAoZXJyKSB7XG4gICAgLy8gaWYgWE1MSHR0cCBzdXBwb3J0IGlzIGRpc2FibGVkIGluIElFIHRoZW4gaXQgd2lsbCB0aHJvd1xuICAgIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxufVxuZXhwb3J0IGNvbnN0IGhhc0NPUlMgPSB2YWx1ZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/engine.io-client/build/esm/contrib/has-cors.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/engine.io-client/build/esm/contrib/parseqs.js":
/*!********************************************************************!*\
  !*** ./node_modules/engine.io-client/build/esm/contrib/parseqs.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n// imported from https://github.com/galkn/querystring\n/**\n * Compiles a querystring\n * Returns string representation of the object\n *\n * @param {Object}\n * @api private\n */\nfunction encode(obj) {\n    let str = '';\n    for (let i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            if (str.length)\n                str += '&';\n            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n        }\n    }\n    return str;\n}\n/**\n * Parses a simple querystring into an object\n *\n * @param {String} qs\n * @api private\n */\nfunction decode(qs) {\n    let qry = {};\n    let pairs = qs.split('&');\n    for (let i = 0, l = pairs.length; i < l; i++) {\n        let pair = pairs[i].split('=');\n        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n    }\n    return qry;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS9jb250cmliL3BhcnNlcXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcc2hvcF9oYXJkaGF0XFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxlbmdpbmUuaW8tY2xpZW50XFxidWlsZFxcZXNtXFxjb250cmliXFxwYXJzZXFzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGltcG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2dhbGtuL3F1ZXJ5c3RyaW5nXG4vKipcbiAqIENvbXBpbGVzIGEgcXVlcnlzdHJpbmdcbiAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKG9iaikge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICBpZiAoc3RyLmxlbmd0aClcbiAgICAgICAgICAgICAgICBzdHIgKz0gJyYnO1xuICAgICAgICAgICAgc3RyICs9IGVuY29kZVVSSUNvbXBvbmVudChpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG4vKipcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGUocXMpIHtcbiAgICBsZXQgcXJ5ID0ge307XG4gICAgbGV0IHBhaXJzID0gcXMuc3BsaXQoJyYnKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBsZXQgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gcXJ5O1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/engine.io-client/build/esm/contrib/parseqs.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/engine.io-client/build/esm/contrib/parseuri.js":
/*!*********************************************************************!*\
  !*** ./node_modules/engine.io-client/build/esm/contrib/parseuri.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse: () => (/* binding */ parse)\n/* harmony export */ });\n// imported from https://github.com/galkn/parseuri\n/**\n * Parses a URI\n *\n * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.\n *\n * See:\n * - https://developer.mozilla.org/en-US/docs/Web/API/URL\n * - https://caniuse.com/url\n * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B\n *\n * History of the parse() method:\n * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c\n * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3\n * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\nconst re = /^(?:(?![^:@\\/?#]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@\\/?#]*)(?::([^:@\\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nconst parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\nfunction parse(str) {\n    if (str.length > 8000) {\n        throw \"URI too long\";\n    }\n    const src = str, b = str.indexOf('['), e = str.indexOf(']');\n    if (b != -1 && e != -1) {\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n    }\n    let m = re.exec(str || ''), uri = {}, i = 14;\n    while (i--) {\n        uri[parts[i]] = m[i] || '';\n    }\n    if (b != -1 && e != -1) {\n        uri.source = src;\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n        uri.ipv6uri = true;\n    }\n    uri.pathNames = pathNames(uri, uri['path']);\n    uri.queryKey = queryKey(uri, uri['query']);\n    return uri;\n}\nfunction pathNames(obj, path) {\n    const regx = /\\/{2,9}/g, names = path.replace(regx, \"/\").split(\"/\");\n    if (path.slice(0, 1) == '/' || path.length === 0) {\n        names.splice(0, 1);\n    }\n    if (path.slice(-1) == '/') {\n        names.splice(names.length - 1, 1);\n    }\n    return names;\n}\nfunction queryKey(uri, query) {\n    const data = {};\n    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {\n        if ($1) {\n            data[$1] = $2;\n        }\n    });\n    return data;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS9jb250cmliL3BhcnNldXJpLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SCxJQUFJLEdBQUcsSUFBSSxTQUFTLElBQUk7QUFDL0k7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEUsa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLElBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJDOlxcc2hvcF9oYXJkaGF0XFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxlbmdpbmUuaW8tY2xpZW50XFxidWlsZFxcZXNtXFxjb250cmliXFxwYXJzZXVyaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9nYWxrbi9wYXJzZXVyaVxuLyoqXG4gKiBQYXJzZXMgYSBVUklcbiAqXG4gKiBOb3RlOiB3ZSBjb3VsZCBhbHNvIGhhdmUgdXNlZCB0aGUgYnVpbHQtaW4gVVJMIG9iamVjdCwgYnV0IGl0IGlzbid0IHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLlxuICpcbiAqIFNlZTpcbiAqIC0gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1VSTFxuICogLSBodHRwczovL2Nhbml1c2UuY29tL3VybFxuICogLSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjMzk4NiNhcHBlbmRpeC1CXG4gKlxuICogSGlzdG9yeSBvZiB0aGUgcGFyc2UoKSBtZXRob2Q6XG4gKiAtIGZpcnN0IGNvbW1pdDogaHR0cHM6Ly9naXRodWIuY29tL3NvY2tldGlvL3NvY2tldC5pby1jbGllbnQvY29tbWl0LzRlZTFkNWQ5NGIzOTA2YTljMDUyYjQ1OWYxYTgxOGIxNWYzOGY5MWNcbiAqIC0gZXhwb3J0IGludG8gaXRzIG93biBtb2R1bGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NrZXRpby9lbmdpbmUuaW8tY2xpZW50L2NvbW1pdC9kZTJjNTYxZTQ1NjRlZmViNzhmMWJkYjFiYTM5ZWY4MWIyODIyY2IzXG4gKiAtIHJlaW1wb3J0OiBodHRwczovL2dpdGh1Yi5jb20vc29ja2V0aW8vZW5naW5lLmlvLWNsaWVudC9jb21taXQvZGYzMjI3N2MzZjZkNjIyZWVjNWVkMDlmNDkzY2FlM2YzMzkxZDI0MlxuICpcbiAqIEBhdXRob3IgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+IChNSVQgbGljZW5zZSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5jb25zdCByZSA9IC9eKD86KD8hW146QFxcLz8jXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QFxcLz8jXSopKD86OihbXjpAXFwvPyNdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xuY29uc3QgcGFydHMgPSBbXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXG5dO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICAgIGlmIChzdHIubGVuZ3RoID4gODAwMCkge1xuICAgICAgICB0aHJvdyBcIlVSSSB0b28gbG9uZ1wiO1xuICAgIH1cbiAgICBjb25zdCBzcmMgPSBzdHIsIGIgPSBzdHIuaW5kZXhPZignWycpLCBlID0gc3RyLmluZGV4T2YoJ10nKTtcbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgYikgKyBzdHIuc3Vic3RyaW5nKGIsIGUpLnJlcGxhY2UoLzovZywgJzsnKSArIHN0ci5zdWJzdHJpbmcoZSwgc3RyLmxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBtID0gcmUuZXhlYyhzdHIgfHwgJycpLCB1cmkgPSB7fSwgaSA9IDE0O1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdXJpW3BhcnRzW2ldXSA9IG1baV0gfHwgJyc7XG4gICAgfVxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgdXJpLnNvdXJjZSA9IHNyYztcbiAgICAgICAgdXJpLmhvc3QgPSB1cmkuaG9zdC5zdWJzdHJpbmcoMSwgdXJpLmhvc3QubGVuZ3RoIC0gMSkucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuaXB2NnVyaSA9IHRydWU7XG4gICAgfVxuICAgIHVyaS5wYXRoTmFtZXMgPSBwYXRoTmFtZXModXJpLCB1cmlbJ3BhdGgnXSk7XG4gICAgdXJpLnF1ZXJ5S2V5ID0gcXVlcnlLZXkodXJpLCB1cmlbJ3F1ZXJ5J10pO1xuICAgIHJldHVybiB1cmk7XG59XG5mdW5jdGlvbiBwYXRoTmFtZXMob2JqLCBwYXRoKSB7XG4gICAgY29uc3QgcmVneCA9IC9cXC97Miw5fS9nLCBuYW1lcyA9IHBhdGgucmVwbGFjZShyZWd4LCBcIi9cIikuc3BsaXQoXCIvXCIpO1xuICAgIGlmIChwYXRoLnNsaWNlKDAsIDEpID09ICcvJyB8fCBwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBuYW1lcy5zcGxpY2UoMCwgMSk7XG4gICAgfVxuICAgIGlmIChwYXRoLnNsaWNlKC0xKSA9PSAnLycpIHtcbiAgICAgICAgbmFtZXMuc3BsaWNlKG5hbWVzLmxlbmd0aCAtIDEsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXM7XG59XG5mdW5jdGlvbiBxdWVyeUtleSh1cmksIHF1ZXJ5KSB7XG4gICAgY29uc3QgZGF0YSA9IHt9O1xuICAgIHF1ZXJ5LnJlcGxhY2UoLyg/Ol58JikoW14mPV0qKT0/KFteJl0qKS9nLCBmdW5jdGlvbiAoJDAsICQxLCAkMikge1xuICAgICAgICBpZiAoJDEpIHtcbiAgICAgICAgICAgIGRhdGFbJDFdID0gJDI7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gZGF0YTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/engine.io-client/build/esm/contrib/parseuri.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/engine.io-client/build/esm/globals.js":
/*!************************************************************!*\
  !*** ./node_modules/engine.io-client/build/esm/globals.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCookieJar: () => (/* binding */ createCookieJar),\n/* harmony export */   defaultBinaryType: () => (/* binding */ defaultBinaryType),\n/* harmony export */   globalThisShim: () => (/* binding */ globalThisShim),\n/* harmony export */   nextTick: () => (/* binding */ nextTick)\n/* harmony export */ });\nconst nextTick = (() => {\n    const isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n    if (isPromiseAvailable) {\n        return (cb) => Promise.resolve().then(cb);\n    }\n    else {\n        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);\n    }\n})();\nconst globalThisShim = (() => {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    else if (typeof window !== \"undefined\") {\n        return window;\n    }\n    else {\n        return Function(\"return this\")();\n    }\n})();\nconst defaultBinaryType = \"arraybuffer\";\nfunction createCookieJar() { }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS9nbG9iYWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGVuZ2luZS5pby1jbGllbnRcXGJ1aWxkXFxlc21cXGdsb2JhbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gKCgpID0+IHtcbiAgICBjb25zdCBpc1Byb21pc2VBdmFpbGFibGUgPSB0eXBlb2YgUHJvbWlzZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBQcm9taXNlLnJlc29sdmUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICBpZiAoaXNQcm9taXNlQXZhaWxhYmxlKSB7XG4gICAgICAgIHJldHVybiAoY2IpID0+IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oY2IpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChjYiwgc2V0VGltZW91dEZuKSA9PiBzZXRUaW1lb3V0Rm4oY2IsIDApO1xuICAgIH1cbn0pKCk7XG5leHBvcnQgY29uc3QgZ2xvYmFsVGhpc1NoaW0gPSAoKCkgPT4ge1xuICAgIGlmICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbiAgICB9XG59KSgpO1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRCaW5hcnlUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvb2tpZUphcigpIHsgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/engine.io-client/build/esm/globals.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/engine.io-client/build/esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/engine.io-client/build/esm/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fetch: () => (/* reexport safe */ _transports_polling_fetch_js__WEBPACK_IMPORTED_MODULE_6__.Fetch),\n/* harmony export */   NodeWebSocket: () => (/* reexport safe */ _transports_websocket_node_js__WEBPACK_IMPORTED_MODULE_8__.WS),\n/* harmony export */   NodeXHR: () => (/* reexport safe */ _transports_polling_xhr_node_js__WEBPACK_IMPORTED_MODULE_7__.XHR),\n/* harmony export */   Socket: () => (/* reexport safe */ _socket_js__WEBPACK_IMPORTED_MODULE_0__.Socket),\n/* harmony export */   SocketWithUpgrade: () => (/* reexport safe */ _socket_js__WEBPACK_IMPORTED_MODULE_0__.SocketWithUpgrade),\n/* harmony export */   SocketWithoutUpgrade: () => (/* reexport safe */ _socket_js__WEBPACK_IMPORTED_MODULE_0__.SocketWithoutUpgrade),\n/* harmony export */   Transport: () => (/* reexport safe */ _transport_js__WEBPACK_IMPORTED_MODULE_1__.Transport),\n/* harmony export */   TransportError: () => (/* reexport safe */ _transport_js__WEBPACK_IMPORTED_MODULE_1__.TransportError),\n/* harmony export */   WebSocket: () => (/* reexport safe */ _transports_websocket_node_js__WEBPACK_IMPORTED_MODULE_8__.WS),\n/* harmony export */   WebTransport: () => (/* reexport safe */ _transports_webtransport_js__WEBPACK_IMPORTED_MODULE_9__.WT),\n/* harmony export */   XHR: () => (/* reexport safe */ _transports_polling_xhr_node_js__WEBPACK_IMPORTED_MODULE_7__.XHR),\n/* harmony export */   installTimerFunctions: () => (/* reexport safe */ _util_js__WEBPACK_IMPORTED_MODULE_3__.installTimerFunctions),\n/* harmony export */   nextTick: () => (/* reexport safe */ _globals_node_js__WEBPACK_IMPORTED_MODULE_5__.nextTick),\n/* harmony export */   parse: () => (/* reexport safe */ _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_4__.parse),\n/* harmony export */   protocol: () => (/* binding */ protocol),\n/* harmony export */   transports: () => (/* reexport safe */ _transports_index_js__WEBPACK_IMPORTED_MODULE_2__.transports)\n/* harmony export */ });\n/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./socket.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/socket.js\");\n/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transport.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transport.js\");\n/* harmony import */ var _transports_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transports/index.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/index.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/util.js\");\n/* harmony import */ var _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./contrib/parseuri.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/contrib/parseuri.js\");\n/* harmony import */ var _globals_node_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./globals.node.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/globals.js\");\n/* harmony import */ var _transports_polling_fetch_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transports/polling-fetch.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/polling-fetch.js\");\n/* harmony import */ var _transports_polling_xhr_node_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./transports/polling-xhr.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/polling-xhr.js\");\n/* harmony import */ var _transports_websocket_node_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./transports/websocket.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js\");\n/* harmony import */ var _transports_webtransport_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./transports/webtransport.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/webtransport.js\");\n\n\n\nconst protocol = _socket_js__WEBPACK_IMPORTED_MODULE_0__.Socket.protocol;\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFxQztBQUNuQjtBQUNxRDtBQUNoRSxpQkFBaUIsOENBQU07QUFDNkI7QUFDUjtBQUNEO0FBQ0o7QUFDRDtBQUNTO0FBQ1k7QUFDaEI7QUFDbUI7QUFDVDtBQUNNIiwic291cmNlcyI6WyJDOlxcc2hvcF9oYXJkaGF0XFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxlbmdpbmUuaW8tY2xpZW50XFxidWlsZFxcZXNtXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTb2NrZXQgfSBmcm9tIFwiLi9zb2NrZXQuanNcIjtcbmV4cG9ydCB7IFNvY2tldCB9O1xuZXhwb3J0IHsgU29ja2V0V2l0aG91dFVwZ3JhZGUsIFNvY2tldFdpdGhVcGdyYWRlLCB9IGZyb20gXCIuL3NvY2tldC5qc1wiO1xuZXhwb3J0IGNvbnN0IHByb3RvY29sID0gU29ja2V0LnByb3RvY29sO1xuZXhwb3J0IHsgVHJhbnNwb3J0LCBUcmFuc3BvcnRFcnJvciB9IGZyb20gXCIuL3RyYW5zcG9ydC5qc1wiO1xuZXhwb3J0IHsgdHJhbnNwb3J0cyB9IGZyb20gXCIuL3RyYW5zcG9ydHMvaW5kZXguanNcIjtcbmV4cG9ydCB7IGluc3RhbGxUaW1lckZ1bmN0aW9ucyB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmV4cG9ydCB7IHBhcnNlIH0gZnJvbSBcIi4vY29udHJpYi9wYXJzZXVyaS5qc1wiO1xuZXhwb3J0IHsgbmV4dFRpY2sgfSBmcm9tIFwiLi9nbG9iYWxzLm5vZGUuanNcIjtcbmV4cG9ydCB7IEZldGNoIH0gZnJvbSBcIi4vdHJhbnNwb3J0cy9wb2xsaW5nLWZldGNoLmpzXCI7XG5leHBvcnQgeyBYSFIgYXMgTm9kZVhIUiB9IGZyb20gXCIuL3RyYW5zcG9ydHMvcG9sbGluZy14aHIubm9kZS5qc1wiO1xuZXhwb3J0IHsgWEhSIH0gZnJvbSBcIi4vdHJhbnNwb3J0cy9wb2xsaW5nLXhoci5qc1wiO1xuZXhwb3J0IHsgV1MgYXMgTm9kZVdlYlNvY2tldCB9IGZyb20gXCIuL3RyYW5zcG9ydHMvd2Vic29ja2V0Lm5vZGUuanNcIjtcbmV4cG9ydCB7IFdTIGFzIFdlYlNvY2tldCB9IGZyb20gXCIuL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzXCI7XG5leHBvcnQgeyBXVCBhcyBXZWJUcmFuc3BvcnQgfSBmcm9tIFwiLi90cmFuc3BvcnRzL3dlYnRyYW5zcG9ydC5qc1wiO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/engine.io-client/build/esm/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/engine.io-client/build/esm/socket.js":
/*!***********************************************************!*\
  !*** ./node_modules/engine.io-client/build/esm/socket.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Socket: () => (/* binding */ Socket),\n/* harmony export */   SocketWithUpgrade: () => (/* binding */ SocketWithUpgrade),\n/* harmony export */   SocketWithoutUpgrade: () => (/* binding */ SocketWithoutUpgrade)\n/* harmony export */ });\n/* harmony import */ var _transports_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transports/index.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/index.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/util.js\");\n/* harmony import */ var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./contrib/parseqs.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/contrib/parseqs.js\");\n/* harmony import */ var _contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contrib/parseuri.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/contrib/parseuri.js\");\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @socket.io/component-emitter */ \"(pages-dir-browser)/./node_modules/@socket.io/component-emitter/lib/esm/index.js\");\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! engine.io-parser */ \"(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/index.js\");\n/* harmony import */ var _globals_node_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./globals.node.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/globals.js\");\n\n\n\n\n\n\n\nconst withEventListeners = typeof addEventListener === \"function\" &&\n    typeof removeEventListener === \"function\";\nconst OFFLINE_EVENT_LISTENERS = [];\nif (withEventListeners) {\n    // within a ServiceWorker, any event handler for the 'offline' event must be added on the initial evaluation of the\n    // script, so we create one single event listener here which will forward the event to the socket instances\n    addEventListener(\"offline\", () => {\n        OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());\n    }, false);\n}\n/**\n * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established\n * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.\n *\n * This class comes without upgrade mechanism, which means that it will keep the first low-level transport that\n * successfully establishes the connection.\n *\n * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.\n *\n * @example\n * import { SocketWithoutUpgrade, WebSocket } from \"engine.io-client\";\n *\n * const socket = new SocketWithoutUpgrade({\n *   transports: [WebSocket]\n * });\n *\n * socket.on(\"open\", () => {\n *   socket.send(\"hello\");\n * });\n *\n * @see SocketWithUpgrade\n * @see Socket\n */\nclass SocketWithoutUpgrade extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_4__.Emitter {\n    /**\n     * Socket constructor.\n     *\n     * @param {String|Object} uri - uri or options\n     * @param {Object} opts - options\n     */\n    constructor(uri, opts) {\n        super();\n        this.binaryType = _globals_node_js__WEBPACK_IMPORTED_MODULE_6__.defaultBinaryType;\n        this.writeBuffer = [];\n        this._prevBufferLen = 0;\n        this._pingInterval = -1;\n        this._pingTimeout = -1;\n        this._maxPayload = -1;\n        /**\n         * The expiration timestamp of the {@link _pingTimeoutTimer} object is tracked, in case the timer is throttled and the\n         * callback is not fired on time. This can happen for example when a laptop is suspended or when a phone is locked.\n         */\n        this._pingTimeoutTime = Infinity;\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = null;\n        }\n        if (uri) {\n            const parsedUri = (0,_contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__.parse)(uri);\n            opts.hostname = parsedUri.host;\n            opts.secure =\n                parsedUri.protocol === \"https\" || parsedUri.protocol === \"wss\";\n            opts.port = parsedUri.port;\n            if (parsedUri.query)\n                opts.query = parsedUri.query;\n        }\n        else if (opts.host) {\n            opts.hostname = (0,_contrib_parseuri_js__WEBPACK_IMPORTED_MODULE_3__.parse)(opts.host).host;\n        }\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.installTimerFunctions)(this, opts);\n        this.secure =\n            null != opts.secure\n                ? opts.secure\n                : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n        if (opts.hostname && !opts.port) {\n            // if no port is specified manually, use the protocol default\n            opts.port = this.secure ? \"443\" : \"80\";\n        }\n        this.hostname =\n            opts.hostname ||\n                (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n        this.port =\n            opts.port ||\n                (typeof location !== \"undefined\" && location.port\n                    ? location.port\n                    : this.secure\n                        ? \"443\"\n                        : \"80\");\n        this.transports = [];\n        this._transportsByName = {};\n        opts.transports.forEach((t) => {\n            const transportName = t.prototype.name;\n            this.transports.push(transportName);\n            this._transportsByName[transportName] = t;\n        });\n        this.opts = Object.assign({\n            path: \"/engine.io\",\n            agent: false,\n            withCredentials: false,\n            upgrade: true,\n            timestampParam: \"t\",\n            rememberUpgrade: false,\n            addTrailingSlash: true,\n            rejectUnauthorized: true,\n            perMessageDeflate: {\n                threshold: 1024,\n            },\n            transportOptions: {},\n            closeOnBeforeunload: false,\n        }, opts);\n        this.opts.path =\n            this.opts.path.replace(/\\/$/, \"\") +\n                (this.opts.addTrailingSlash ? \"/\" : \"\");\n        if (typeof this.opts.query === \"string\") {\n            this.opts.query = (0,_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_2__.decode)(this.opts.query);\n        }\n        if (withEventListeners) {\n            if (this.opts.closeOnBeforeunload) {\n                // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\n                // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\n                // closed/reloaded)\n                this._beforeunloadEventListener = () => {\n                    if (this.transport) {\n                        // silently close the transport\n                        this.transport.removeAllListeners();\n                        this.transport.close();\n                    }\n                };\n                addEventListener(\"beforeunload\", this._beforeunloadEventListener, false);\n            }\n            if (this.hostname !== \"localhost\") {\n                this._offlineEventListener = () => {\n                    this._onClose(\"transport close\", {\n                        description: \"network connection lost\",\n                    });\n                };\n                OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);\n            }\n        }\n        if (this.opts.withCredentials) {\n            this._cookieJar = (0,_globals_node_js__WEBPACK_IMPORTED_MODULE_6__.createCookieJar)();\n        }\n        this._open();\n    }\n    /**\n     * Creates transport of the given type.\n     *\n     * @param {String} name - transport name\n     * @return {Transport}\n     * @private\n     */\n    createTransport(name) {\n        const query = Object.assign({}, this.opts.query);\n        // append engine.io protocol identifier\n        query.EIO = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__.protocol;\n        // transport name\n        query.transport = name;\n        // session id if we already have one\n        if (this.id)\n            query.sid = this.id;\n        const opts = Object.assign({}, this.opts, {\n            query,\n            socket: this,\n            hostname: this.hostname,\n            secure: this.secure,\n            port: this.port,\n        }, this.opts.transportOptions[name]);\n        return new this._transportsByName[name](opts);\n    }\n    /**\n     * Initializes transport to use and starts probe.\n     *\n     * @private\n     */\n    _open() {\n        if (this.transports.length === 0) {\n            // Emit error on next tick so it can be listened to\n            this.setTimeoutFn(() => {\n                this.emitReserved(\"error\", \"No transports available\");\n            }, 0);\n            return;\n        }\n        const transportName = this.opts.rememberUpgrade &&\n            SocketWithoutUpgrade.priorWebsocketSuccess &&\n            this.transports.indexOf(\"websocket\") !== -1\n            ? \"websocket\"\n            : this.transports[0];\n        this.readyState = \"opening\";\n        const transport = this.createTransport(transportName);\n        transport.open();\n        this.setTransport(transport);\n    }\n    /**\n     * Sets the current transport. Disables the existing one (if any).\n     *\n     * @private\n     */\n    setTransport(transport) {\n        if (this.transport) {\n            this.transport.removeAllListeners();\n        }\n        // set up transport\n        this.transport = transport;\n        // set up transport listeners\n        transport\n            .on(\"drain\", this._onDrain.bind(this))\n            .on(\"packet\", this._onPacket.bind(this))\n            .on(\"error\", this._onError.bind(this))\n            .on(\"close\", (reason) => this._onClose(\"transport close\", reason));\n    }\n    /**\n     * Called when connection is deemed open.\n     *\n     * @private\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        SocketWithoutUpgrade.priorWebsocketSuccess =\n            \"websocket\" === this.transport.name;\n        this.emitReserved(\"open\");\n        this.flush();\n    }\n    /**\n     * Handles a packet.\n     *\n     * @private\n     */\n    _onPacket(packet) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            this.emitReserved(\"packet\", packet);\n            // Socket is live - any packet counts\n            this.emitReserved(\"heartbeat\");\n            switch (packet.type) {\n                case \"open\":\n                    this.onHandshake(JSON.parse(packet.data));\n                    break;\n                case \"ping\":\n                    this._sendPacket(\"pong\");\n                    this.emitReserved(\"ping\");\n                    this.emitReserved(\"pong\");\n                    this._resetPingTimeout();\n                    break;\n                case \"error\":\n                    const err = new Error(\"server error\");\n                    // @ts-ignore\n                    err.code = packet.data;\n                    this._onError(err);\n                    break;\n                case \"message\":\n                    this.emitReserved(\"data\", packet.data);\n                    this.emitReserved(\"message\", packet.data);\n                    break;\n            }\n        }\n        else {\n        }\n    }\n    /**\n     * Called upon handshake completion.\n     *\n     * @param {Object} data - handshake obj\n     * @private\n     */\n    onHandshake(data) {\n        this.emitReserved(\"handshake\", data);\n        this.id = data.sid;\n        this.transport.query.sid = data.sid;\n        this._pingInterval = data.pingInterval;\n        this._pingTimeout = data.pingTimeout;\n        this._maxPayload = data.maxPayload;\n        this.onOpen();\n        // In case open handler closes socket\n        if (\"closed\" === this.readyState)\n            return;\n        this._resetPingTimeout();\n    }\n    /**\n     * Sets and resets ping timeout timer based on server pings.\n     *\n     * @private\n     */\n    _resetPingTimeout() {\n        this.clearTimeoutFn(this._pingTimeoutTimer);\n        const delay = this._pingInterval + this._pingTimeout;\n        this._pingTimeoutTime = Date.now() + delay;\n        this._pingTimeoutTimer = this.setTimeoutFn(() => {\n            this._onClose(\"ping timeout\");\n        }, delay);\n        if (this.opts.autoUnref) {\n            this._pingTimeoutTimer.unref();\n        }\n    }\n    /**\n     * Called on `drain` event\n     *\n     * @private\n     */\n    _onDrain() {\n        this.writeBuffer.splice(0, this._prevBufferLen);\n        // setting prevBufferLen = 0 is very important\n        // for example, when upgrading, upgrade packet is sent over,\n        // and a nonzero prevBufferLen could cause problems on `drain`\n        this._prevBufferLen = 0;\n        if (0 === this.writeBuffer.length) {\n            this.emitReserved(\"drain\");\n        }\n        else {\n            this.flush();\n        }\n    }\n    /**\n     * Flush write buffers.\n     *\n     * @private\n     */\n    flush() {\n        if (\"closed\" !== this.readyState &&\n            this.transport.writable &&\n            !this.upgrading &&\n            this.writeBuffer.length) {\n            const packets = this._getWritablePackets();\n            this.transport.send(packets);\n            // keep track of current length of writeBuffer\n            // splice writeBuffer and callbackBuffer on `drain`\n            this._prevBufferLen = packets.length;\n            this.emitReserved(\"flush\");\n        }\n    }\n    /**\n     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP\n     * long-polling)\n     *\n     * @private\n     */\n    _getWritablePackets() {\n        const shouldCheckPayloadSize = this._maxPayload &&\n            this.transport.name === \"polling\" &&\n            this.writeBuffer.length > 1;\n        if (!shouldCheckPayloadSize) {\n            return this.writeBuffer;\n        }\n        let payloadSize = 1; // first packet type\n        for (let i = 0; i < this.writeBuffer.length; i++) {\n            const data = this.writeBuffer[i].data;\n            if (data) {\n                payloadSize += (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.byteLength)(data);\n            }\n            if (i > 0 && payloadSize > this._maxPayload) {\n                return this.writeBuffer.slice(0, i);\n            }\n            payloadSize += 2; // separator + packet type\n        }\n        return this.writeBuffer;\n    }\n    /**\n     * Checks whether the heartbeat timer has expired but the socket has not yet been notified.\n     *\n     * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the\n     * `write()` method then the message would not be buffered by the Socket.IO client.\n     *\n     * @return {boolean}\n     * @private\n     */\n    /* private */ _hasPingExpired() {\n        if (!this._pingTimeoutTime)\n            return true;\n        const hasExpired = Date.now() > this._pingTimeoutTime;\n        if (hasExpired) {\n            this._pingTimeoutTime = 0;\n            (0,_globals_node_js__WEBPACK_IMPORTED_MODULE_6__.nextTick)(() => {\n                this._onClose(\"ping timeout\");\n            }, this.setTimeoutFn);\n        }\n        return hasExpired;\n    }\n    /**\n     * Sends a message.\n     *\n     * @param {String} msg - message.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @return {Socket} for chaining.\n     */\n    write(msg, options, fn) {\n        this._sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    /**\n     * Sends a message. Alias of {@link Socket#write}.\n     *\n     * @param {String} msg - message.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @return {Socket} for chaining.\n     */\n    send(msg, options, fn) {\n        this._sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} type: packet type.\n     * @param {String} data.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @private\n     */\n    _sendPacket(type, data, options, fn) {\n        if (\"function\" === typeof data) {\n            fn = data;\n            data = undefined;\n        }\n        if (\"function\" === typeof options) {\n            fn = options;\n            options = null;\n        }\n        if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n            return;\n        }\n        options = options || {};\n        options.compress = false !== options.compress;\n        const packet = {\n            type: type,\n            data: data,\n            options: options,\n        };\n        this.emitReserved(\"packetCreate\", packet);\n        this.writeBuffer.push(packet);\n        if (fn)\n            this.once(\"flush\", fn);\n        this.flush();\n    }\n    /**\n     * Closes the connection.\n     */\n    close() {\n        const close = () => {\n            this._onClose(\"forced close\");\n            this.transport.close();\n        };\n        const cleanupAndClose = () => {\n            this.off(\"upgrade\", cleanupAndClose);\n            this.off(\"upgradeError\", cleanupAndClose);\n            close();\n        };\n        const waitForUpgrade = () => {\n            // wait for upgrade to finish since we can't send packets while pausing a transport\n            this.once(\"upgrade\", cleanupAndClose);\n            this.once(\"upgradeError\", cleanupAndClose);\n        };\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n            this.readyState = \"closing\";\n            if (this.writeBuffer.length) {\n                this.once(\"drain\", () => {\n                    if (this.upgrading) {\n                        waitForUpgrade();\n                    }\n                    else {\n                        close();\n                    }\n                });\n            }\n            else if (this.upgrading) {\n                waitForUpgrade();\n            }\n            else {\n                close();\n            }\n        }\n        return this;\n    }\n    /**\n     * Called upon transport error\n     *\n     * @private\n     */\n    _onError(err) {\n        SocketWithoutUpgrade.priorWebsocketSuccess = false;\n        if (this.opts.tryAllTransports &&\n            this.transports.length > 1 &&\n            this.readyState === \"opening\") {\n            this.transports.shift();\n            return this._open();\n        }\n        this.emitReserved(\"error\", err);\n        this._onClose(\"transport error\", err);\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @private\n     */\n    _onClose(reason, description) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            // clear timers\n            this.clearTimeoutFn(this._pingTimeoutTimer);\n            // stop event from firing again for transport\n            this.transport.removeAllListeners(\"close\");\n            // ensure transport won't stay open\n            this.transport.close();\n            // ignore further transport communication\n            this.transport.removeAllListeners();\n            if (withEventListeners) {\n                if (this._beforeunloadEventListener) {\n                    removeEventListener(\"beforeunload\", this._beforeunloadEventListener, false);\n                }\n                if (this._offlineEventListener) {\n                    const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);\n                    if (i !== -1) {\n                        OFFLINE_EVENT_LISTENERS.splice(i, 1);\n                    }\n                }\n            }\n            // set ready state\n            this.readyState = \"closed\";\n            // clear session id\n            this.id = null;\n            // emit close event\n            this.emitReserved(\"close\", reason, description);\n            // clean buffers after, so users can still\n            // grab the buffers on `close` event\n            this.writeBuffer = [];\n            this._prevBufferLen = 0;\n        }\n    }\n}\nSocketWithoutUpgrade.protocol = engine_io_parser__WEBPACK_IMPORTED_MODULE_5__.protocol;\n/**\n * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established\n * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.\n *\n * This class comes with an upgrade mechanism, which means that once the connection is established with the first\n * low-level transport, it will try to upgrade to a better transport.\n *\n * In order to allow tree-shaking, there are no transports included, that's why the `transports` option is mandatory.\n *\n * @example\n * import { SocketWithUpgrade, WebSocket } from \"engine.io-client\";\n *\n * const socket = new SocketWithUpgrade({\n *   transports: [WebSocket]\n * });\n *\n * socket.on(\"open\", () => {\n *   socket.send(\"hello\");\n * });\n *\n * @see SocketWithoutUpgrade\n * @see Socket\n */\nclass SocketWithUpgrade extends SocketWithoutUpgrade {\n    constructor() {\n        super(...arguments);\n        this._upgrades = [];\n    }\n    onOpen() {\n        super.onOpen();\n        if (\"open\" === this.readyState && this.opts.upgrade) {\n            for (let i = 0; i < this._upgrades.length; i++) {\n                this._probe(this._upgrades[i]);\n            }\n        }\n    }\n    /**\n     * Probes a transport.\n     *\n     * @param {String} name - transport name\n     * @private\n     */\n    _probe(name) {\n        let transport = this.createTransport(name);\n        let failed = false;\n        SocketWithoutUpgrade.priorWebsocketSuccess = false;\n        const onTransportOpen = () => {\n            if (failed)\n                return;\n            transport.send([{ type: \"ping\", data: \"probe\" }]);\n            transport.once(\"packet\", (msg) => {\n                if (failed)\n                    return;\n                if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                    this.upgrading = true;\n                    this.emitReserved(\"upgrading\", transport);\n                    if (!transport)\n                        return;\n                    SocketWithoutUpgrade.priorWebsocketSuccess =\n                        \"websocket\" === transport.name;\n                    this.transport.pause(() => {\n                        if (failed)\n                            return;\n                        if (\"closed\" === this.readyState)\n                            return;\n                        cleanup();\n                        this.setTransport(transport);\n                        transport.send([{ type: \"upgrade\" }]);\n                        this.emitReserved(\"upgrade\", transport);\n                        transport = null;\n                        this.upgrading = false;\n                        this.flush();\n                    });\n                }\n                else {\n                    const err = new Error(\"probe error\");\n                    // @ts-ignore\n                    err.transport = transport.name;\n                    this.emitReserved(\"upgradeError\", err);\n                }\n            });\n        };\n        function freezeTransport() {\n            if (failed)\n                return;\n            // Any callback called by transport should be ignored since now\n            failed = true;\n            cleanup();\n            transport.close();\n            transport = null;\n        }\n        // Handle any error that happens while probing\n        const onerror = (err) => {\n            const error = new Error(\"probe error: \" + err);\n            // @ts-ignore\n            error.transport = transport.name;\n            freezeTransport();\n            this.emitReserved(\"upgradeError\", error);\n        };\n        function onTransportClose() {\n            onerror(\"transport closed\");\n        }\n        // When the socket is closed while we're probing\n        function onclose() {\n            onerror(\"socket closed\");\n        }\n        // When the socket is upgraded while we're probing\n        function onupgrade(to) {\n            if (transport && to.name !== transport.name) {\n                freezeTransport();\n            }\n        }\n        // Remove all listeners on the transport and on self\n        const cleanup = () => {\n            transport.removeListener(\"open\", onTransportOpen);\n            transport.removeListener(\"error\", onerror);\n            transport.removeListener(\"close\", onTransportClose);\n            this.off(\"close\", onclose);\n            this.off(\"upgrading\", onupgrade);\n        };\n        transport.once(\"open\", onTransportOpen);\n        transport.once(\"error\", onerror);\n        transport.once(\"close\", onTransportClose);\n        this.once(\"close\", onclose);\n        this.once(\"upgrading\", onupgrade);\n        if (this._upgrades.indexOf(\"webtransport\") !== -1 &&\n            name !== \"webtransport\") {\n            // favor WebTransport\n            this.setTimeoutFn(() => {\n                if (!failed) {\n                    transport.open();\n                }\n            }, 200);\n        }\n        else {\n            transport.open();\n        }\n    }\n    onHandshake(data) {\n        this._upgrades = this._filterUpgrades(data.upgrades);\n        super.onHandshake(data);\n    }\n    /**\n     * Filters upgrades, returning only those matching client transports.\n     *\n     * @param {Array} upgrades - server upgrades\n     * @private\n     */\n    _filterUpgrades(upgrades) {\n        const filteredUpgrades = [];\n        for (let i = 0; i < upgrades.length; i++) {\n            if (~this.transports.indexOf(upgrades[i]))\n                filteredUpgrades.push(upgrades[i]);\n        }\n        return filteredUpgrades;\n    }\n}\n/**\n * This class provides a WebSocket-like interface to connect to an Engine.IO server. The connection will be established\n * with one of the available low-level transports, like HTTP long-polling, WebSocket or WebTransport.\n *\n * This class comes with an upgrade mechanism, which means that once the connection is established with the first\n * low-level transport, it will try to upgrade to a better transport.\n *\n * @example\n * import { Socket } from \"engine.io-client\";\n *\n * const socket = new Socket();\n *\n * socket.on(\"open\", () => {\n *   socket.send(\"hello\");\n * });\n *\n * @see SocketWithoutUpgrade\n * @see SocketWithUpgrade\n */\nclass Socket extends SocketWithUpgrade {\n    constructor(uri, opts = {}) {\n        const o = typeof uri === \"object\" ? uri : opts;\n        if (!o.transports ||\n            (o.transports && typeof o.transports[0] === \"string\")) {\n            o.transports = (o.transports || [\"polling\", \"websocket\", \"webtransport\"])\n                .map((transportName) => _transports_index_js__WEBPACK_IMPORTED_MODULE_0__.transports[transportName])\n                .filter((t) => !!t);\n        }\n        super(uri, o);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS9zb2NrZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUF5RTtBQUNYO0FBQ2hCO0FBQ0E7QUFDUztBQUNYO0FBQ3NDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0NBQWtDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUMsaUVBQU87QUFDakQ7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0RBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx5QkFBeUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwyREFBSztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJEQUFLO0FBQ2pDO0FBQ0EsUUFBUSwrREFBcUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZ0NBQWdDO0FBQ2hDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJE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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzREFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsaUJBQWlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDREQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcc2hvcF9oYXJkaGF0XFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxlbmdpbmUuaW8tY2xpZW50XFxidWlsZFxcZXNtXFxzb2NrZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdHJhbnNwb3J0cyBhcyBERUZBVUxUX1RSQU5TUE9SVFMgfSBmcm9tIFwiLi90cmFuc3BvcnRzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpbnN0YWxsVGltZXJGdW5jdGlvbnMsIGJ5dGVMZW5ndGggfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgeyBkZWNvZGUgfSBmcm9tIFwiLi9jb250cmliL3BhcnNlcXMuanNcIjtcbmltcG9ydCB7IHBhcnNlIH0gZnJvbSBcIi4vY29udHJpYi9wYXJzZXVyaS5qc1wiO1xuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gXCJAc29ja2V0LmlvL2NvbXBvbmVudC1lbWl0dGVyXCI7XG5pbXBvcnQgeyBwcm90b2NvbCB9IGZyb20gXCJlbmdpbmUuaW8tcGFyc2VyXCI7XG5pbXBvcnQgeyBjcmVhdGVDb29raWVKYXIsIGRlZmF1bHRCaW5hcnlUeXBlLCBuZXh0VGljaywgfSBmcm9tIFwiLi9nbG9iYWxzLm5vZGUuanNcIjtcbmNvbnN0IHdpdGhFdmVudExpc3RlbmVycyA9IHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICB0eXBlb2YgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgT0ZGTElORV9FVkVOVF9MSVNURU5FUlMgPSBbXTtcbmlmICh3aXRoRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAvLyB3aXRoaW4gYSBTZXJ2aWNlV29ya2VyLCBhbnkgZXZlbnQgaGFuZGxlciBmb3IgdGhlICdvZmZsaW5lJyBldmVudCBtdXN0IGJlIGFkZGVkIG9uIHRoZSBpbml0aWFsIGV2YWx1YXRpb24gb2YgdGhlXG4gICAgLy8gc2NyaXB0LCBzbyB3ZSBjcmVhdGUgb25lIHNpbmdsZSBldmVudCBsaXN0ZW5lciBoZXJlIHdoaWNoIHdpbGwgZm9yd2FyZCB0aGUgZXZlbnQgdG8gdGhlIHNvY2tldCBpbnN0YW5jZXNcbiAgICBhZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCAoKSA9PiB7XG4gICAgICAgIE9GRkxJTkVfRVZFTlRfTElTVEVORVJTLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcigpKTtcbiAgICB9LCBmYWxzZSk7XG59XG4vKipcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgYSBXZWJTb2NrZXQtbGlrZSBpbnRlcmZhY2UgdG8gY29ubmVjdCB0byBhbiBFbmdpbmUuSU8gc2VydmVyLiBUaGUgY29ubmVjdGlvbiB3aWxsIGJlIGVzdGFibGlzaGVkXG4gKiB3aXRoIG9uZSBvZiB0aGUgYXZhaWxhYmxlIGxvdy1sZXZlbCB0cmFuc3BvcnRzLCBsaWtlIEhUVFAgbG9uZy1wb2xsaW5nLCBXZWJTb2NrZXQgb3IgV2ViVHJhbnNwb3J0LlxuICpcbiAqIFRoaXMgY2xhc3MgY29tZXMgd2l0aG91dCB1cGdyYWRlIG1lY2hhbmlzbSwgd2hpY2ggbWVhbnMgdGhhdCBpdCB3aWxsIGtlZXAgdGhlIGZpcnN0IGxvdy1sZXZlbCB0cmFuc3BvcnQgdGhhdFxuICogc3VjY2Vzc2Z1bGx5IGVzdGFibGlzaGVzIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEluIG9yZGVyIHRvIGFsbG93IHRyZWUtc2hha2luZywgdGhlcmUgYXJlIG5vIHRyYW5zcG9ydHMgaW5jbHVkZWQsIHRoYXQncyB3aHkgdGhlIGB0cmFuc3BvcnRzYCBvcHRpb24gaXMgbWFuZGF0b3J5LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBTb2NrZXRXaXRob3V0VXBncmFkZSwgV2ViU29ja2V0IH0gZnJvbSBcImVuZ2luZS5pby1jbGllbnRcIjtcbiAqXG4gKiBjb25zdCBzb2NrZXQgPSBuZXcgU29ja2V0V2l0aG91dFVwZ3JhZGUoe1xuICogICB0cmFuc3BvcnRzOiBbV2ViU29ja2V0XVxuICogfSk7XG4gKlxuICogc29ja2V0Lm9uKFwib3BlblwiLCAoKSA9PiB7XG4gKiAgIHNvY2tldC5zZW5kKFwiaGVsbG9cIik7XG4gKiB9KTtcbiAqXG4gKiBAc2VlIFNvY2tldFdpdGhVcGdyYWRlXG4gKiBAc2VlIFNvY2tldFxuICovXG5leHBvcnQgY2xhc3MgU29ja2V0V2l0aG91dFVwZ3JhZGUgZXh0ZW5kcyBFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBTb2NrZXQgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVyaSAtIHVyaSBvciBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodXJpLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmluYXJ5VHlwZSA9IGRlZmF1bHRCaW5hcnlUeXBlO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMuX3ByZXZCdWZmZXJMZW4gPSAwO1xuICAgICAgICB0aGlzLl9waW5nSW50ZXJ2YWwgPSAtMTtcbiAgICAgICAgdGhpcy5fcGluZ1RpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5fbWF4UGF5bG9hZCA9IC0xO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGV4cGlyYXRpb24gdGltZXN0YW1wIG9mIHRoZSB7QGxpbmsgX3BpbmdUaW1lb3V0VGltZXJ9IG9iamVjdCBpcyB0cmFja2VkLCBpbiBjYXNlIHRoZSB0aW1lciBpcyB0aHJvdHRsZWQgYW5kIHRoZVxuICAgICAgICAgKiBjYWxsYmFjayBpcyBub3QgZmlyZWQgb24gdGltZS4gVGhpcyBjYW4gaGFwcGVuIGZvciBleGFtcGxlIHdoZW4gYSBsYXB0b3AgaXMgc3VzcGVuZGVkIG9yIHdoZW4gYSBwaG9uZSBpcyBsb2NrZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9waW5nVGltZW91dFRpbWUgPSBJbmZpbml0eTtcbiAgICAgICAgaWYgKHVyaSAmJiBcIm9iamVjdFwiID09PSB0eXBlb2YgdXJpKSB7XG4gICAgICAgICAgICBvcHRzID0gdXJpO1xuICAgICAgICAgICAgdXJpID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXJpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRVcmkgPSBwYXJzZSh1cmkpO1xuICAgICAgICAgICAgb3B0cy5ob3N0bmFtZSA9IHBhcnNlZFVyaS5ob3N0O1xuICAgICAgICAgICAgb3B0cy5zZWN1cmUgPVxuICAgICAgICAgICAgICAgIHBhcnNlZFVyaS5wcm90b2NvbCA9PT0gXCJodHRwc1wiIHx8IHBhcnNlZFVyaS5wcm90b2NvbCA9PT0gXCJ3c3NcIjtcbiAgICAgICAgICAgIG9wdHMucG9ydCA9IHBhcnNlZFVyaS5wb3J0O1xuICAgICAgICAgICAgaWYgKHBhcnNlZFVyaS5xdWVyeSlcbiAgICAgICAgICAgICAgICBvcHRzLnF1ZXJ5ID0gcGFyc2VkVXJpLnF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdHMuaG9zdCkge1xuICAgICAgICAgICAgb3B0cy5ob3N0bmFtZSA9IHBhcnNlKG9wdHMuaG9zdCkuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YWxsVGltZXJGdW5jdGlvbnModGhpcywgb3B0cyk7XG4gICAgICAgIHRoaXMuc2VjdXJlID1cbiAgICAgICAgICAgIG51bGwgIT0gb3B0cy5zZWN1cmVcbiAgICAgICAgICAgICAgICA/IG9wdHMuc2VjdXJlXG4gICAgICAgICAgICAgICAgOiB0eXBlb2YgbG9jYXRpb24gIT09IFwidW5kZWZpbmVkXCIgJiYgXCJodHRwczpcIiA9PT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAgIGlmIChvcHRzLmhvc3RuYW1lICYmICFvcHRzLnBvcnQpIHtcbiAgICAgICAgICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcbiAgICAgICAgICAgIG9wdHMucG9ydCA9IHRoaXMuc2VjdXJlID8gXCI0NDNcIiA6IFwiODBcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhvc3RuYW1lID1cbiAgICAgICAgICAgIG9wdHMuaG9zdG5hbWUgfHxcbiAgICAgICAgICAgICAgICAodHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiID8gbG9jYXRpb24uaG9zdG5hbWUgOiBcImxvY2FsaG9zdFwiKTtcbiAgICAgICAgdGhpcy5wb3J0ID1cbiAgICAgICAgICAgIG9wdHMucG9ydCB8fFxuICAgICAgICAgICAgICAgICh0eXBlb2YgbG9jYXRpb24gIT09IFwidW5kZWZpbmVkXCIgJiYgbG9jYXRpb24ucG9ydFxuICAgICAgICAgICAgICAgICAgICA/IGxvY2F0aW9uLnBvcnRcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnNlY3VyZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIjQ0M1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwiODBcIik7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0cyA9IFtdO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRzQnlOYW1lID0ge307XG4gICAgICAgIG9wdHMudHJhbnNwb3J0cy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc3BvcnROYW1lID0gdC5wcm90b3R5cGUubmFtZTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0cy5wdXNoKHRyYW5zcG9ydE5hbWUpO1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0c0J5TmFtZVt0cmFuc3BvcnROYW1lXSA9IHQ7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIHBhdGg6IFwiL2VuZ2luZS5pb1wiLFxuICAgICAgICAgICAgYWdlbnQ6IGZhbHNlLFxuICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAgICAgICAgIHVwZ3JhZGU6IHRydWUsXG4gICAgICAgICAgICB0aW1lc3RhbXBQYXJhbTogXCJ0XCIsXG4gICAgICAgICAgICByZW1lbWJlclVwZ3JhZGU6IGZhbHNlLFxuICAgICAgICAgICAgYWRkVHJhaWxpbmdTbGFzaDogdHJ1ZSxcbiAgICAgICAgICAgIHJlamVjdFVuYXV0aG9yaXplZDogdHJ1ZSxcbiAgICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB7XG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiAxMDI0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyYW5zcG9ydE9wdGlvbnM6IHt9LFxuICAgICAgICAgICAgY2xvc2VPbkJlZm9yZXVubG9hZDogZmFsc2UsXG4gICAgICAgIH0sIG9wdHMpO1xuICAgICAgICB0aGlzLm9wdHMucGF0aCA9XG4gICAgICAgICAgICB0aGlzLm9wdHMucGF0aC5yZXBsYWNlKC9cXC8kLywgXCJcIikgK1xuICAgICAgICAgICAgICAgICh0aGlzLm9wdHMuYWRkVHJhaWxpbmdTbGFzaCA/IFwiL1wiIDogXCJcIik7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLnF1ZXJ5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLm9wdHMucXVlcnkgPSBkZWNvZGUodGhpcy5vcHRzLnF1ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2l0aEV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmNsb3NlT25CZWZvcmV1bmxvYWQpIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IGNsb3NlcyB0aGUgY29ubmVjdGlvbiB3aGVuIHRoZSBcImJlZm9yZXVubG9hZFwiIGV2ZW50IGlzIGVtaXR0ZWQgYnV0IG5vdCBDaHJvbWUuIFRoaXMgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmVzIGV2ZXJ5IGJyb3dzZXIgYmVoYXZlcyB0aGUgc2FtZSAobm8gXCJkaXNjb25uZWN0XCIgZXZlbnQgYXQgdGhlIFNvY2tldC5JTyBsZXZlbCB3aGVuIHRoZSBwYWdlIGlzXG4gICAgICAgICAgICAgICAgLy8gY2xvc2VkL3JlbG9hZGVkKVxuICAgICAgICAgICAgICAgIHRoaXMuX2JlZm9yZXVubG9hZEV2ZW50TGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2lsZW50bHkgY2xvc2UgdGhlIHRyYW5zcG9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIHRoaXMuX2JlZm9yZXVubG9hZEV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmhvc3RuYW1lICE9PSBcImxvY2FsaG9zdFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2ZmbGluZUV2ZW50TGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uQ2xvc2UoXCJ0cmFuc3BvcnQgY2xvc2VcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwibmV0d29yayBjb25uZWN0aW9uIGxvc3RcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBPRkZMSU5FX0VWRU5UX0xJU1RFTkVSUy5wdXNoKHRoaXMuX29mZmxpbmVFdmVudExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRzLndpdGhDcmVkZW50aWFscykge1xuICAgICAgICAgICAgdGhpcy5fY29va2llSmFyID0gY3JlYXRlQ29va2llSmFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3BlbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRyYW5zcG9ydCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gdHJhbnNwb3J0IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjcmVhdGVUcmFuc3BvcnQobmFtZSkge1xuICAgICAgICBjb25zdCBxdWVyeSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0cy5xdWVyeSk7XG4gICAgICAgIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICAgICAgICBxdWVyeS5FSU8gPSBwcm90b2NvbDtcbiAgICAgICAgLy8gdHJhbnNwb3J0IG5hbWVcbiAgICAgICAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcbiAgICAgICAgLy8gc2Vzc2lvbiBpZCBpZiB3ZSBhbHJlYWR5IGhhdmUgb25lXG4gICAgICAgIGlmICh0aGlzLmlkKVxuICAgICAgICAgICAgcXVlcnkuc2lkID0gdGhpcy5pZDtcbiAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0cywge1xuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBzb2NrZXQ6IHRoaXMsXG4gICAgICAgICAgICBob3N0bmFtZTogdGhpcy5ob3N0bmFtZSxcbiAgICAgICAgICAgIHNlY3VyZTogdGhpcy5zZWN1cmUsXG4gICAgICAgICAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgICAgIH0sIHRoaXMub3B0cy50cmFuc3BvcnRPcHRpb25zW25hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLl90cmFuc3BvcnRzQnlOYW1lW25hbWVdKG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0cmFuc3BvcnQgdG8gdXNlIGFuZCBzdGFydHMgcHJvYmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vcGVuKCkge1xuICAgICAgICBpZiAodGhpcy50cmFuc3BvcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gRW1pdCBlcnJvciBvbiBuZXh0IHRpY2sgc28gaXQgY2FuIGJlIGxpc3RlbmVkIHRvXG4gICAgICAgICAgICB0aGlzLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJlcnJvclwiLCBcIk5vIHRyYW5zcG9ydHMgYXZhaWxhYmxlXCIpO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNwb3J0TmFtZSA9IHRoaXMub3B0cy5yZW1lbWJlclVwZ3JhZGUgJiZcbiAgICAgICAgICAgIFNvY2tldFdpdGhvdXRVcGdyYWRlLnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJlxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnRzLmluZGV4T2YoXCJ3ZWJzb2NrZXRcIikgIT09IC0xXG4gICAgICAgICAgICA/IFwid2Vic29ja2V0XCJcbiAgICAgICAgICAgIDogdGhpcy50cmFuc3BvcnRzWzBdO1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcIm9wZW5pbmdcIjtcbiAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0TmFtZSk7XG4gICAgICAgIHRyYW5zcG9ydC5vcGVuKCk7XG4gICAgICAgIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZXRUcmFuc3BvcnQodHJhbnNwb3J0KSB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgLy8gc2V0IHVwIHRyYW5zcG9ydCBsaXN0ZW5lcnNcbiAgICAgICAgdHJhbnNwb3J0XG4gICAgICAgICAgICAub24oXCJkcmFpblwiLCB0aGlzLl9vbkRyYWluLmJpbmQodGhpcykpXG4gICAgICAgICAgICAub24oXCJwYWNrZXRcIiwgdGhpcy5fb25QYWNrZXQuYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC5vbihcImVycm9yXCIsIHRoaXMuX29uRXJyb3IuYmluZCh0aGlzKSlcbiAgICAgICAgICAgIC5vbihcImNsb3NlXCIsIChyZWFzb24pID0+IHRoaXMuX29uQ2xvc2UoXCJ0cmFuc3BvcnQgY2xvc2VcIiwgcmVhc29uKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgZGVlbWVkIG9wZW4uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uT3BlbigpIHtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJvcGVuXCI7XG4gICAgICAgIFNvY2tldFdpdGhvdXRVcGdyYWRlLnByaW9yV2Vic29ja2V0U3VjY2VzcyA9XG4gICAgICAgICAgICBcIndlYnNvY2tldFwiID09PSB0aGlzLnRyYW5zcG9ydC5uYW1lO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcIm9wZW5cIik7XG4gICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uUGFja2V0KHBhY2tldCkge1xuICAgICAgICBpZiAoXCJvcGVuaW5nXCIgPT09IHRoaXMucmVhZHlTdGF0ZSB8fFxuICAgICAgICAgICAgXCJvcGVuXCIgPT09IHRoaXMucmVhZHlTdGF0ZSB8fFxuICAgICAgICAgICAgXCJjbG9zaW5nXCIgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJwYWNrZXRcIiwgcGFja2V0KTtcbiAgICAgICAgICAgIC8vIFNvY2tldCBpcyBsaXZlIC0gYW55IHBhY2tldCBjb3VudHNcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiaGVhcnRiZWF0XCIpO1xuICAgICAgICAgICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJvcGVuXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25IYW5kc2hha2UoSlNPTi5wYXJzZShwYWNrZXQuZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicGluZ1wiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZW5kUGFja2V0KFwicG9uZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJwaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInBvbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2V0UGluZ1RpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcInNlcnZlciBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbkVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZGF0YVwiLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwibWVzc2FnZVwiLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgLSBoYW5kc2hha2Ugb2JqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkhhbmRzaGFrZShkYXRhKSB7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiaGFuZHNoYWtlXCIsIGRhdGEpO1xuICAgICAgICB0aGlzLmlkID0gZGF0YS5zaWQ7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LnF1ZXJ5LnNpZCA9IGRhdGEuc2lkO1xuICAgICAgICB0aGlzLl9waW5nSW50ZXJ2YWwgPSBkYXRhLnBpbmdJbnRlcnZhbDtcbiAgICAgICAgdGhpcy5fcGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuICAgICAgICB0aGlzLl9tYXhQYXlsb2FkID0gZGF0YS5tYXhQYXlsb2FkO1xuICAgICAgICB0aGlzLm9uT3BlbigpO1xuICAgICAgICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gICAgICAgIGlmIChcImNsb3NlZFwiID09PSB0aGlzLnJlYWR5U3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3Jlc2V0UGluZ1RpbWVvdXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhbmQgcmVzZXRzIHBpbmcgdGltZW91dCB0aW1lciBiYXNlZCBvbiBzZXJ2ZXIgcGluZ3MuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZXNldFBpbmdUaW1lb3V0KCkge1xuICAgICAgICB0aGlzLmNsZWFyVGltZW91dEZuKHRoaXMuX3BpbmdUaW1lb3V0VGltZXIpO1xuICAgICAgICBjb25zdCBkZWxheSA9IHRoaXMuX3BpbmdJbnRlcnZhbCArIHRoaXMuX3BpbmdUaW1lb3V0O1xuICAgICAgICB0aGlzLl9waW5nVGltZW91dFRpbWUgPSBEYXRlLm5vdygpICsgZGVsYXk7XG4gICAgICAgIHRoaXMuX3BpbmdUaW1lb3V0VGltZXIgPSB0aGlzLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9vbkNsb3NlKFwicGluZyB0aW1lb3V0XCIpO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuYXV0b1VucmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9waW5nVGltZW91dFRpbWVyLnVucmVmKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIG9uIGBkcmFpbmAgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uRHJhaW4oKSB7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIuc3BsaWNlKDAsIHRoaXMuX3ByZXZCdWZmZXJMZW4pO1xuICAgICAgICAvLyBzZXR0aW5nIHByZXZCdWZmZXJMZW4gPSAwIGlzIHZlcnkgaW1wb3J0YW50XG4gICAgICAgIC8vIGZvciBleGFtcGxlLCB3aGVuIHVwZ3JhZGluZywgdXBncmFkZSBwYWNrZXQgaXMgc2VudCBvdmVyLFxuICAgICAgICAvLyBhbmQgYSBub256ZXJvIHByZXZCdWZmZXJMZW4gY291bGQgY2F1c2UgcHJvYmxlbXMgb24gYGRyYWluYFxuICAgICAgICB0aGlzLl9wcmV2QnVmZmVyTGVuID0gMDtcbiAgICAgICAgaWYgKDAgPT09IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRyYWluXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsdXNoIHdyaXRlIGJ1ZmZlcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZsdXNoKCkge1xuICAgICAgICBpZiAoXCJjbG9zZWRcIiAhPT0gdGhpcy5yZWFkeVN0YXRlICYmXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuICAgICAgICAgICAgIXRoaXMudXBncmFkaW5nICYmXG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcGFja2V0cyA9IHRoaXMuX2dldFdyaXRhYmxlUGFja2V0cygpO1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZChwYWNrZXRzKTtcbiAgICAgICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgY3VycmVudCBsZW5ndGggb2Ygd3JpdGVCdWZmZXJcbiAgICAgICAgICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuICAgICAgICAgICAgdGhpcy5fcHJldkJ1ZmZlckxlbiA9IHBhY2tldHMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJmbHVzaFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhlIGVuY29kZWQgc2l6ZSBvZiB0aGUgd3JpdGVCdWZmZXIgaXMgYmVsb3cgdGhlIG1heFBheWxvYWQgdmFsdWUgc2VudCBieSB0aGUgc2VydmVyIChvbmx5IGZvciBIVFRQXG4gICAgICogbG9uZy1wb2xsaW5nKVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZ2V0V3JpdGFibGVQYWNrZXRzKCkge1xuICAgICAgICBjb25zdCBzaG91bGRDaGVja1BheWxvYWRTaXplID0gdGhpcy5fbWF4UGF5bG9hZCAmJlxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQubmFtZSA9PT0gXCJwb2xsaW5nXCIgJiZcbiAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoID4gMTtcbiAgICAgICAgaWYgKCFzaG91bGRDaGVja1BheWxvYWRTaXplKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cml0ZUJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGF5bG9hZFNpemUgPSAxOyAvLyBmaXJzdCBwYWNrZXQgdHlwZVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLndyaXRlQnVmZmVyW2ldLmRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIHBheWxvYWRTaXplICs9IGJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+IDAgJiYgcGF5bG9hZFNpemUgPiB0aGlzLl9tYXhQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVCdWZmZXIuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXlsb2FkU2l6ZSArPSAyOyAvLyBzZXBhcmF0b3IgKyBwYWNrZXQgdHlwZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndyaXRlQnVmZmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgaGVhcnRiZWF0IHRpbWVyIGhhcyBleHBpcmVkIGJ1dCB0aGUgc29ja2V0IGhhcyBub3QgeWV0IGJlZW4gbm90aWZpZWQuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGlzIG1ldGhvZCBpcyBwcml2YXRlIGZvciBub3cgYmVjYXVzZSBpdCBkb2VzIG5vdCByZWFsbHkgZml0IHRoZSBXZWJTb2NrZXQgQVBJLCBidXQgaWYgd2UgcHV0IGl0IGluIHRoZVxuICAgICAqIGB3cml0ZSgpYCBtZXRob2QgdGhlbiB0aGUgbWVzc2FnZSB3b3VsZCBub3QgYmUgYnVmZmVyZWQgYnkgdGhlIFNvY2tldC5JTyBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgLyogcHJpdmF0ZSAqLyBfaGFzUGluZ0V4cGlyZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcGluZ1RpbWVvdXRUaW1lKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IGhhc0V4cGlyZWQgPSBEYXRlLm5vdygpID4gdGhpcy5fcGluZ1RpbWVvdXRUaW1lO1xuICAgICAgICBpZiAoaGFzRXhwaXJlZCkge1xuICAgICAgICAgICAgdGhpcy5fcGluZ1RpbWVvdXRUaW1lID0gMDtcbiAgICAgICAgICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbkNsb3NlKFwicGluZyB0aW1lb3V0XCIpO1xuICAgICAgICAgICAgfSwgdGhpcy5zZXRUaW1lb3V0Rm4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYXNFeHBpcmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gbWVzc2FnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nLlxuICAgICAqL1xuICAgIHdyaXRlKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgICAgICAgdGhpcy5fc2VuZFBhY2tldChcIm1lc3NhZ2VcIiwgbXNnLCBvcHRpb25zLCBmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIG1lc3NhZ2UuIEFsaWFzIG9mIHtAbGluayBTb2NrZXQjd3JpdGV9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIG1lc3NhZ2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZy5cbiAgICAgKi9cbiAgICBzZW5kKG1zZywgb3B0aW9ucywgZm4pIHtcbiAgICAgICAgdGhpcy5fc2VuZFBhY2tldChcIm1lc3NhZ2VcIiwgbXNnLCBvcHRpb25zLCBmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlOiBwYWNrZXQgdHlwZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3NlbmRQYWNrZXQodHlwZSwgZGF0YSwgb3B0aW9ucywgZm4pIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGRhdGEpIHtcbiAgICAgICAgICAgIGZuID0gZGF0YTtcbiAgICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGZuID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcImNsb3NpbmdcIiA9PT0gdGhpcy5yZWFkeVN0YXRlIHx8IFwiY2xvc2VkXCIgPT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgIGNvbnN0IHBhY2tldCA9IHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJwYWNrZXRDcmVhdGVcIiwgcGFja2V0KTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gICAgICAgIGlmIChmbilcbiAgICAgICAgICAgIHRoaXMub25jZShcImZsdXNoXCIsIGZuKTtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGNvbnN0IGNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb25DbG9zZShcImZvcmNlZCBjbG9zZVwiKTtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsZWFudXBBbmRDbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub2ZmKFwidXBncmFkZVwiLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgICAgICAgICAgdGhpcy5vZmYoXCJ1cGdyYWRlRXJyb3JcIiwgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHdhaXRGb3JVcGdyYWRlID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gd2FpdCBmb3IgdXBncmFkZSB0byBmaW5pc2ggc2luY2Ugd2UgY2FuJ3Qgc2VuZCBwYWNrZXRzIHdoaWxlIHBhdXNpbmcgYSB0cmFuc3BvcnRcbiAgICAgICAgICAgIHRoaXMub25jZShcInVwZ3JhZGVcIiwgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgICAgICAgIHRoaXMub25jZShcInVwZ3JhZGVFcnJvclwiLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoXCJvcGVuaW5nXCIgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCBcIm9wZW5cIiA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcImNsb3NpbmdcIjtcbiAgICAgICAgICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShcImRyYWluXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgICAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbkVycm9yKGVycikge1xuICAgICAgICBTb2NrZXRXaXRob3V0VXBncmFkZS5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy50cnlBbGxUcmFuc3BvcnRzICYmXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydHMubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBcIm9wZW5pbmdcIikge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnRzLnNoaWZ0KCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3BlbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgdGhpcy5fb25DbG9zZShcInRyYW5zcG9ydCBlcnJvclwiLCBlcnIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbkNsb3NlKHJlYXNvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKFwib3BlbmluZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICAgICAgIFwib3BlblwiID09PSB0aGlzLnJlYWR5U3RhdGUgfHxcbiAgICAgICAgICAgIFwiY2xvc2luZ1wiID09PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXRGbih0aGlzLl9waW5nVGltZW91dFRpbWVyKTtcbiAgICAgICAgICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKFwiY2xvc2VcIik7XG4gICAgICAgICAgICAvLyBlbnN1cmUgdHJhbnNwb3J0IHdvbid0IHN0YXkgb3BlblxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBmdXJ0aGVyIHRyYW5zcG9ydCBjb21tdW5pY2F0aW9uXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIGlmICh3aXRoRXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYmVmb3JldW5sb2FkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIHRoaXMuX2JlZm9yZXVubG9hZEV2ZW50TGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29mZmxpbmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBPRkZMSU5FX0VWRU5UX0xJU1RFTkVSUy5pbmRleE9mKHRoaXMuX29mZmxpbmVFdmVudExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPRkZMSU5FX0VWRU5UX0xJU1RFTkVSUy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgcmVhZHkgc3RhdGVcbiAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwiY2xvc2VkXCI7XG4gICAgICAgICAgICAvLyBjbGVhciBzZXNzaW9uIGlkXG4gICAgICAgICAgICB0aGlzLmlkID0gbnVsbDtcbiAgICAgICAgICAgIC8vIGVtaXQgY2xvc2UgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiY2xvc2VcIiwgcmVhc29uLCBkZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAvLyBjbGVhbiBidWZmZXJzIGFmdGVyLCBzbyB1c2VycyBjYW4gc3RpbGxcbiAgICAgICAgICAgIC8vIGdyYWIgdGhlIGJ1ZmZlcnMgb24gYGNsb3NlYCBldmVudFxuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fcHJldkJ1ZmZlckxlbiA9IDA7XG4gICAgICAgIH1cbiAgICB9XG59XG5Tb2NrZXRXaXRob3V0VXBncmFkZS5wcm90b2NvbCA9IHByb3RvY29sO1xuLyoqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIGEgV2ViU29ja2V0LWxpa2UgaW50ZXJmYWNlIHRvIGNvbm5lY3QgdG8gYW4gRW5naW5lLklPIHNlcnZlci4gVGhlIGNvbm5lY3Rpb24gd2lsbCBiZSBlc3RhYmxpc2hlZFxuICogd2l0aCBvbmUgb2YgdGhlIGF2YWlsYWJsZSBsb3ctbGV2ZWwgdHJhbnNwb3J0cywgbGlrZSBIVFRQIGxvbmctcG9sbGluZywgV2ViU29ja2V0IG9yIFdlYlRyYW5zcG9ydC5cbiAqXG4gKiBUaGlzIGNsYXNzIGNvbWVzIHdpdGggYW4gdXBncmFkZSBtZWNoYW5pc20sIHdoaWNoIG1lYW5zIHRoYXQgb25jZSB0aGUgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZCB3aXRoIHRoZSBmaXJzdFxuICogbG93LWxldmVsIHRyYW5zcG9ydCwgaXQgd2lsbCB0cnkgdG8gdXBncmFkZSB0byBhIGJldHRlciB0cmFuc3BvcnQuXG4gKlxuICogSW4gb3JkZXIgdG8gYWxsb3cgdHJlZS1zaGFraW5nLCB0aGVyZSBhcmUgbm8gdHJhbnNwb3J0cyBpbmNsdWRlZCwgdGhhdCdzIHdoeSB0aGUgYHRyYW5zcG9ydHNgIG9wdGlvbiBpcyBtYW5kYXRvcnkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IFNvY2tldFdpdGhVcGdyYWRlLCBXZWJTb2NrZXQgfSBmcm9tIFwiZW5naW5lLmlvLWNsaWVudFwiO1xuICpcbiAqIGNvbnN0IHNvY2tldCA9IG5ldyBTb2NrZXRXaXRoVXBncmFkZSh7XG4gKiAgIHRyYW5zcG9ydHM6IFtXZWJTb2NrZXRdXG4gKiB9KTtcbiAqXG4gKiBzb2NrZXQub24oXCJvcGVuXCIsICgpID0+IHtcbiAqICAgc29ja2V0LnNlbmQoXCJoZWxsb1wiKTtcbiAqIH0pO1xuICpcbiAqIEBzZWUgU29ja2V0V2l0aG91dFVwZ3JhZGVcbiAqIEBzZWUgU29ja2V0XG4gKi9cbmV4cG9ydCBjbGFzcyBTb2NrZXRXaXRoVXBncmFkZSBleHRlbmRzIFNvY2tldFdpdGhvdXRVcGdyYWRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fdXBncmFkZXMgPSBbXTtcbiAgICB9XG4gICAgb25PcGVuKCkge1xuICAgICAgICBzdXBlci5vbk9wZW4oKTtcbiAgICAgICAgaWYgKFwib3BlblwiID09PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy5vcHRzLnVwZ3JhZGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fdXBncmFkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9iZSh0aGlzLl91cGdyYWRlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvYmVzIGEgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSB0cmFuc3BvcnQgbmFtZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3Byb2JlKG5hbWUpIHtcbiAgICAgICAgbGV0IHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KG5hbWUpO1xuICAgICAgICBsZXQgZmFpbGVkID0gZmFsc2U7XG4gICAgICAgIFNvY2tldFdpdGhvdXRVcGdyYWRlLnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBvblRyYW5zcG9ydE9wZW4gPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmFpbGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6IFwicGluZ1wiLCBkYXRhOiBcInByb2JlXCIgfV0pO1xuICAgICAgICAgICAgdHJhbnNwb3J0Lm9uY2UoXCJwYWNrZXRcIiwgKG1zZykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmYWlsZWQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoXCJwb25nXCIgPT09IG1zZy50eXBlICYmIFwicHJvYmVcIiA9PT0gbXNnLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGdyYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInVwZ3JhZGluZ1wiLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyYW5zcG9ydClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgU29ja2V0V2l0aG91dFVwZ3JhZGUucHJpb3JXZWJzb2NrZXRTdWNjZXNzID1cbiAgICAgICAgICAgICAgICAgICAgICAgIFwid2Vic29ja2V0XCIgPT09IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5wYXVzZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmFpbGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImNsb3NlZFwiID09PSB0aGlzLnJlYWR5U3RhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6IFwidXBncmFkZVwiIH1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwidXBncmFkZVwiLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBncmFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFwicHJvYmUgZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInVwZ3JhZGVFcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQoKSB7XG4gICAgICAgICAgICBpZiAoZmFpbGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIEFueSBjYWxsYmFjayBjYWxsZWQgYnkgdHJhbnNwb3J0IHNob3VsZCBiZSBpZ25vcmVkIHNpbmNlIG5vd1xuICAgICAgICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgYW55IGVycm9yIHRoYXQgaGFwcGVucyB3aGlsZSBwcm9iaW5nXG4gICAgICAgIGNvbnN0IG9uZXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcInByb2JlIGVycm9yOiBcIiArIGVycik7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJ1cGdyYWRlRXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBvblRyYW5zcG9ydENsb3NlKCkge1xuICAgICAgICAgICAgb25lcnJvcihcInRyYW5zcG9ydCBjbG9zZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2hlbiB0aGUgc29ja2V0IGlzIGNsb3NlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gICAgICAgIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgICAgICAgICBvbmVycm9yKFwic29ja2V0IGNsb3NlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZSBzb2NrZXQgaXMgdXBncmFkZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICAgICAgICBmdW5jdGlvbiBvbnVwZ3JhZGUodG8pIHtcbiAgICAgICAgICAgIGlmICh0cmFuc3BvcnQgJiYgdG8ubmFtZSAhPT0gdHJhbnNwb3J0Lm5hbWUpIHtcbiAgICAgICAgICAgICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBvbiB0aGUgdHJhbnNwb3J0IGFuZCBvbiBzZWxmXG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJvcGVuXCIsIG9uVHJhbnNwb3J0T3Blbik7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBvbmVycm9yKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgICAgICAgICAgdGhpcy5vZmYoXCJjbG9zZVwiLCBvbmNsb3NlKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKFwidXBncmFkaW5nXCIsIG9udXBncmFkZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zcG9ydC5vbmNlKFwib3BlblwiLCBvblRyYW5zcG9ydE9wZW4pO1xuICAgICAgICB0cmFuc3BvcnQub25jZShcImVycm9yXCIsIG9uZXJyb3IpO1xuICAgICAgICB0cmFuc3BvcnQub25jZShcImNsb3NlXCIsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgICAgICB0aGlzLm9uY2UoXCJjbG9zZVwiLCBvbmNsb3NlKTtcbiAgICAgICAgdGhpcy5vbmNlKFwidXBncmFkaW5nXCIsIG9udXBncmFkZSk7XG4gICAgICAgIGlmICh0aGlzLl91cGdyYWRlcy5pbmRleE9mKFwid2VidHJhbnNwb3J0XCIpICE9PSAtMSAmJlxuICAgICAgICAgICAgbmFtZSAhPT0gXCJ3ZWJ0cmFuc3BvcnRcIikge1xuICAgICAgICAgICAgLy8gZmF2b3IgV2ViVHJhbnNwb3J0XG4gICAgICAgICAgICB0aGlzLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFmYWlsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAyMDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkhhbmRzaGFrZShkYXRhKSB7XG4gICAgICAgIHRoaXMuX3VwZ3JhZGVzID0gdGhpcy5fZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG4gICAgICAgIHN1cGVyLm9uSGFuZHNoYWtlKGRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaWx0ZXJzIHVwZ3JhZGVzLCByZXR1cm5pbmcgb25seSB0aG9zZSBtYXRjaGluZyBjbGllbnQgdHJhbnNwb3J0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHVwZ3JhZGVzIC0gc2VydmVyIHVwZ3JhZGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZmlsdGVyVXBncmFkZXModXBncmFkZXMpIHtcbiAgICAgICAgY29uc3QgZmlsdGVyZWRVcGdyYWRlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVwZ3JhZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAofnRoaXMudHJhbnNwb3J0cy5pbmRleE9mKHVwZ3JhZGVzW2ldKSlcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBhIFdlYlNvY2tldC1saWtlIGludGVyZmFjZSB0byBjb25uZWN0IHRvIGFuIEVuZ2luZS5JTyBzZXJ2ZXIuIFRoZSBjb25uZWN0aW9uIHdpbGwgYmUgZXN0YWJsaXNoZWRcbiAqIHdpdGggb25lIG9mIHRoZSBhdmFpbGFibGUgbG93LWxldmVsIHRyYW5zcG9ydHMsIGxpa2UgSFRUUCBsb25nLXBvbGxpbmcsIFdlYlNvY2tldCBvciBXZWJUcmFuc3BvcnQuXG4gKlxuICogVGhpcyBjbGFzcyBjb21lcyB3aXRoIGFuIHVwZ3JhZGUgbWVjaGFuaXNtLCB3aGljaCBtZWFucyB0aGF0IG9uY2UgdGhlIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQgd2l0aCB0aGUgZmlyc3RcbiAqIGxvdy1sZXZlbCB0cmFuc3BvcnQsIGl0IHdpbGwgdHJ5IHRvIHVwZ3JhZGUgdG8gYSBiZXR0ZXIgdHJhbnNwb3J0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBTb2NrZXQgfSBmcm9tIFwiZW5naW5lLmlvLWNsaWVudFwiO1xuICpcbiAqIGNvbnN0IHNvY2tldCA9IG5ldyBTb2NrZXQoKTtcbiAqXG4gKiBzb2NrZXQub24oXCJvcGVuXCIsICgpID0+IHtcbiAqICAgc29ja2V0LnNlbmQoXCJoZWxsb1wiKTtcbiAqIH0pO1xuICpcbiAqIEBzZWUgU29ja2V0V2l0aG91dFVwZ3JhZGVcbiAqIEBzZWUgU29ja2V0V2l0aFVwZ3JhZGVcbiAqL1xuZXhwb3J0IGNsYXNzIFNvY2tldCBleHRlbmRzIFNvY2tldFdpdGhVcGdyYWRlIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmksIG9wdHMgPSB7fSkge1xuICAgICAgICBjb25zdCBvID0gdHlwZW9mIHVyaSA9PT0gXCJvYmplY3RcIiA/IHVyaSA6IG9wdHM7XG4gICAgICAgIGlmICghby50cmFuc3BvcnRzIHx8XG4gICAgICAgICAgICAoby50cmFuc3BvcnRzICYmIHR5cGVvZiBvLnRyYW5zcG9ydHNbMF0gPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICBvLnRyYW5zcG9ydHMgPSAoby50cmFuc3BvcnRzIHx8IFtcInBvbGxpbmdcIiwgXCJ3ZWJzb2NrZXRcIiwgXCJ3ZWJ0cmFuc3BvcnRcIl0pXG4gICAgICAgICAgICAgICAgLm1hcCgodHJhbnNwb3J0TmFtZSkgPT4gREVGQVVMVF9UUkFOU1BPUlRTW3RyYW5zcG9ydE5hbWVdKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKHQpID0+ICEhdCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIodXJpLCBvKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/engine.io-client/build/esm/socket.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transport.js":
/*!**************************************************************!*\
  !*** ./node_modules/engine.io-client/build/esm/transport.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Transport: () => (/* binding */ Transport),\n/* harmony export */   TransportError: () => (/* binding */ TransportError)\n/* harmony export */ });\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! engine.io-parser */ \"(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/index.js\");\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @socket.io/component-emitter */ \"(pages-dir-browser)/./node_modules/@socket.io/component-emitter/lib/esm/index.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/util.js\");\n/* harmony import */ var _contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contrib/parseqs.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/contrib/parseqs.js\");\n\n\n\n\nclass TransportError extends Error {\n    constructor(reason, description, context) {\n        super(reason);\n        this.description = description;\n        this.context = context;\n        this.type = \"TransportError\";\n    }\n}\nclass Transport extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__.Emitter {\n    /**\n     * Transport abstract constructor.\n     *\n     * @param {Object} opts - options\n     * @protected\n     */\n    constructor(opts) {\n        super();\n        this.writable = false;\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.installTimerFunctions)(this, opts);\n        this.opts = opts;\n        this.query = opts.query;\n        this.socket = opts.socket;\n        this.supportsBinary = !opts.forceBase64;\n    }\n    /**\n     * Emits an error.\n     *\n     * @param {String} reason\n     * @param description\n     * @param context - the error context\n     * @return {Transport} for chaining\n     * @protected\n     */\n    onError(reason, description, context) {\n        super.emitReserved(\"error\", new TransportError(reason, description, context));\n        return this;\n    }\n    /**\n     * Opens the transport.\n     */\n    open() {\n        this.readyState = \"opening\";\n        this.doOpen();\n        return this;\n    }\n    /**\n     * Closes the transport.\n     */\n    close() {\n        if (this.readyState === \"opening\" || this.readyState === \"open\") {\n            this.doClose();\n            this.onClose();\n        }\n        return this;\n    }\n    /**\n     * Sends multiple packets.\n     *\n     * @param {Array} packets\n     */\n    send(packets) {\n        if (this.readyState === \"open\") {\n            this.write(packets);\n        }\n        else {\n            // this might happen if the transport was silently closed in the beforeunload event handler\n        }\n    }\n    /**\n     * Called upon open\n     *\n     * @protected\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        this.writable = true;\n        super.emitReserved(\"open\");\n    }\n    /**\n     * Called with data.\n     *\n     * @param {String} data\n     * @protected\n     */\n    onData(data) {\n        const packet = (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_0__.decodePacket)(data, this.socket.binaryType);\n        this.onPacket(packet);\n    }\n    /**\n     * Called with a decoded packet.\n     *\n     * @protected\n     */\n    onPacket(packet) {\n        super.emitReserved(\"packet\", packet);\n    }\n    /**\n     * Called upon close.\n     *\n     * @protected\n     */\n    onClose(details) {\n        this.readyState = \"closed\";\n        super.emitReserved(\"close\", details);\n    }\n    /**\n     * Pauses the transport, in order not to lose packets during an upgrade.\n     *\n     * @param onPause\n     */\n    pause(onPause) { }\n    createUri(schema, query = {}) {\n        return (schema +\n            \"://\" +\n            this._hostname() +\n            this._port() +\n            this.opts.path +\n            this._query(query));\n    }\n    _hostname() {\n        const hostname = this.opts.hostname;\n        return hostname.indexOf(\":\") === -1 ? hostname : \"[\" + hostname + \"]\";\n    }\n    _port() {\n        if (this.opts.port &&\n            ((this.opts.secure && Number(this.opts.port !== 443)) ||\n                (!this.opts.secure && Number(this.opts.port) !== 80))) {\n            return \":\" + this.opts.port;\n        }\n        else {\n            return \"\";\n        }\n    }\n    _query(query) {\n        const encodedQuery = (0,_contrib_parseqs_js__WEBPACK_IMPORTED_MODULE_3__.encode)(query);\n        return encodedQuery.length ? \"?\" + encodedQuery : \"\";\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS90cmFuc3BvcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWdEO0FBQ087QUFDTDtBQUNKO0FBQ3ZDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx3QkFBd0IsaUVBQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLCtEQUFxQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhEQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDJEQUFNO0FBQ25DO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXHNob3BfaGFyZGhhdFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcZW5naW5lLmlvLWNsaWVudFxcYnVpbGRcXGVzbVxcdHJhbnNwb3J0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlY29kZVBhY2tldCB9IGZyb20gXCJlbmdpbmUuaW8tcGFyc2VyXCI7XG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSBcIkBzb2NrZXQuaW8vY29tcG9uZW50LWVtaXR0ZXJcIjtcbmltcG9ydCB7IGluc3RhbGxUaW1lckZ1bmN0aW9ucyB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCB7IGVuY29kZSB9IGZyb20gXCIuL2NvbnRyaWIvcGFyc2Vxcy5qc1wiO1xuZXhwb3J0IGNsYXNzIFRyYW5zcG9ydEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlYXNvbiwgZGVzY3JpcHRpb24sIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIocmVhc29uKTtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnR5cGUgPSBcIlRyYW5zcG9ydEVycm9yXCI7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFRyYW5zcG9ydCBleHRlbmRzIEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIFRyYW5zcG9ydCBhYnN0cmFjdCBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgaW5zdGFsbFRpbWVyRnVuY3Rpb25zKHRoaXMsIG9wdHMpO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgICAgICAgdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcbiAgICAgICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9ICFvcHRzLmZvcmNlQmFzZTY0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb25cbiAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb25cbiAgICAgKiBAcGFyYW0gY29udGV4dCAtIHRoZSBlcnJvciBjb250ZXh0XG4gICAgICogQHJldHVybiB7VHJhbnNwb3J0fSBmb3IgY2hhaW5pbmdcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25FcnJvcihyZWFzb24sIGRlc2NyaXB0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyLmVtaXRSZXNlcnZlZChcImVycm9yXCIsIG5ldyBUcmFuc3BvcnRFcnJvcihyZWFzb24sIGRlc2NyaXB0aW9uLCBjb250ZXh0KSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPcGVucyB0aGUgdHJhbnNwb3J0LlxuICAgICAqL1xuICAgIG9wZW4oKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlbmluZ1wiO1xuICAgICAgICB0aGlzLmRvT3BlbigpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFwib3BlbmluZ1wiIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJvcGVuXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gICAgICovXG4gICAgc2VuZChwYWNrZXRzKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFwib3BlblwiKSB7XG4gICAgICAgICAgICB0aGlzLndyaXRlKHBhY2tldHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBtaWdodCBoYXBwZW4gaWYgdGhlIHRyYW5zcG9ydCB3YXMgc2lsZW50bHkgY2xvc2VkIGluIHRoZSBiZWZvcmV1bmxvYWQgZXZlbnQgaGFuZGxlclxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIG9wZW5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlblwiO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgc3VwZXIuZW1pdFJlc2VydmVkKFwib3BlblwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uRGF0YShkYXRhKSB7XG4gICAgICAgIGNvbnN0IHBhY2tldCA9IGRlY29kZVBhY2tldChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKTtcbiAgICAgICAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBhIGRlY29kZWQgcGFja2V0LlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uUGFja2V0KHBhY2tldCkge1xuICAgICAgICBzdXBlci5lbWl0UmVzZXJ2ZWQoXCJwYWNrZXRcIiwgcGFja2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gY2xvc2UuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25DbG9zZShkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwiY2xvc2VkXCI7XG4gICAgICAgIHN1cGVyLmVtaXRSZXNlcnZlZChcImNsb3NlXCIsIGRldGFpbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZXMgdGhlIHRyYW5zcG9ydCwgaW4gb3JkZXIgbm90IHRvIGxvc2UgcGFja2V0cyBkdXJpbmcgYW4gdXBncmFkZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvblBhdXNlXG4gICAgICovXG4gICAgcGF1c2Uob25QYXVzZSkgeyB9XG4gICAgY3JlYXRlVXJpKHNjaGVtYSwgcXVlcnkgPSB7fSkge1xuICAgICAgICByZXR1cm4gKHNjaGVtYSArXG4gICAgICAgICAgICBcIjovL1wiICtcbiAgICAgICAgICAgIHRoaXMuX2hvc3RuYW1lKCkgK1xuICAgICAgICAgICAgdGhpcy5fcG9ydCgpICtcbiAgICAgICAgICAgIHRoaXMub3B0cy5wYXRoICtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXJ5KHF1ZXJ5KSk7XG4gICAgfVxuICAgIF9ob3N0bmFtZSgpIHtcbiAgICAgICAgY29uc3QgaG9zdG5hbWUgPSB0aGlzLm9wdHMuaG9zdG5hbWU7XG4gICAgICAgIHJldHVybiBob3N0bmFtZS5pbmRleE9mKFwiOlwiKSA9PT0gLTEgPyBob3N0bmFtZSA6IFwiW1wiICsgaG9zdG5hbWUgKyBcIl1cIjtcbiAgICB9XG4gICAgX3BvcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdHMucG9ydCAmJlxuICAgICAgICAgICAgKCh0aGlzLm9wdHMuc2VjdXJlICYmIE51bWJlcih0aGlzLm9wdHMucG9ydCAhPT0gNDQzKSkgfHxcbiAgICAgICAgICAgICAgICAoIXRoaXMub3B0cy5zZWN1cmUgJiYgTnVtYmVyKHRoaXMub3B0cy5wb3J0KSAhPT0gODApKSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiOlwiICsgdGhpcy5vcHRzLnBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcXVlcnkocXVlcnkpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlZFF1ZXJ5ID0gZW5jb2RlKHF1ZXJ5KTtcbiAgICAgICAgcmV0dXJuIGVuY29kZWRRdWVyeS5sZW5ndGggPyBcIj9cIiArIGVuY29kZWRRdWVyeSA6IFwiXCI7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transport.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/engine.io-client/build/esm/transports/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   transports: () => (/* binding */ transports)\n/* harmony export */ });\n/* harmony import */ var _polling_xhr_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polling-xhr.node.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/polling-xhr.js\");\n/* harmony import */ var _websocket_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./websocket.node.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js\");\n/* harmony import */ var _webtransport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webtransport.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/webtransport.js\");\n\n\n\nconst transports = {\n    websocket: _websocket_node_js__WEBPACK_IMPORTED_MODULE_1__.WS,\n    webtransport: _webtransport_js__WEBPACK_IMPORTED_MODULE_2__.WT,\n    polling: _polling_xhr_node_js__WEBPACK_IMPORTED_MODULE_0__.XHR,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS90cmFuc3BvcnRzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNEM7QUFDSDtBQUNGO0FBQ2hDO0FBQ1AsZUFBZSxrREFBRTtBQUNqQixrQkFBa0IsZ0RBQUU7QUFDcEIsYUFBYSxxREFBRztBQUNoQiIsInNvdXJjZXMiOlsiQzpcXHNob3BfaGFyZGhhdFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcZW5naW5lLmlvLWNsaWVudFxcYnVpbGRcXGVzbVxcdHJhbnNwb3J0c1xcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgWEhSIH0gZnJvbSBcIi4vcG9sbGluZy14aHIubm9kZS5qc1wiO1xuaW1wb3J0IHsgV1MgfSBmcm9tIFwiLi93ZWJzb2NrZXQubm9kZS5qc1wiO1xuaW1wb3J0IHsgV1QgfSBmcm9tIFwiLi93ZWJ0cmFuc3BvcnQuanNcIjtcbmV4cG9ydCBjb25zdCB0cmFuc3BvcnRzID0ge1xuICAgIHdlYnNvY2tldDogV1MsXG4gICAgd2VidHJhbnNwb3J0OiBXVCxcbiAgICBwb2xsaW5nOiBYSFIsXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/polling-fetch.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/engine.io-client/build/esm/transports/polling-fetch.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fetch: () => (/* binding */ Fetch)\n/* harmony export */ });\n/* harmony import */ var _polling_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polling.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/polling.js\");\n\n/**\n * HTTP long-polling based on the built-in `fetch()` method.\n *\n * Usage: browser, Node.js (since v18), Deno, Bun\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/fetch\n * @see https://caniuse.com/fetch\n * @see https://nodejs.org/api/globals.html#fetch\n */\nclass Fetch extends _polling_js__WEBPACK_IMPORTED_MODULE_0__.Polling {\n    doPoll() {\n        this._fetch()\n            .then((res) => {\n            if (!res.ok) {\n                return this.onError(\"fetch read error\", res.status, res);\n            }\n            res.text().then((data) => this.onData(data));\n        })\n            .catch((err) => {\n            this.onError(\"fetch read error\", err);\n        });\n    }\n    doWrite(data, callback) {\n        this._fetch(data)\n            .then((res) => {\n            if (!res.ok) {\n                return this.onError(\"fetch write error\", res.status, res);\n            }\n            callback();\n        })\n            .catch((err) => {\n            this.onError(\"fetch write error\", err);\n        });\n    }\n    _fetch(data) {\n        var _a;\n        const isPost = data !== undefined;\n        const headers = new Headers(this.opts.extraHeaders);\n        if (isPost) {\n            headers.set(\"content-type\", \"text/plain;charset=UTF-8\");\n        }\n        (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.appendCookies(headers);\n        return fetch(this.uri(), {\n            method: isPost ? \"POST\" : \"GET\",\n            body: isPost ? data : null,\n            headers,\n            credentials: this.opts.withCredentials ? \"include\" : \"omit\",\n        }).then((res) => {\n            var _a;\n            // @ts-ignore getSetCookie() was added in Node.js v19.7.0\n            (_a = this.socket._cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(res.headers.getSetCookie());\n            return res;\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS90cmFuc3BvcnRzL3BvbGxpbmctZmV0Y2guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sb0JBQW9CLGdEQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBIiwic291cmNlcyI6WyJDOlxcc2hvcF9oYXJkaGF0XFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxlbmdpbmUuaW8tY2xpZW50XFxidWlsZFxcZXNtXFx0cmFuc3BvcnRzXFxwb2xsaW5nLWZldGNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBvbGxpbmcgfSBmcm9tIFwiLi9wb2xsaW5nLmpzXCI7XG4vKipcbiAqIEhUVFAgbG9uZy1wb2xsaW5nIGJhc2VkIG9uIHRoZSBidWlsdC1pbiBgZmV0Y2goKWAgbWV0aG9kLlxuICpcbiAqIFVzYWdlOiBicm93c2VyLCBOb2RlLmpzIChzaW5jZSB2MTgpLCBEZW5vLCBCdW5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9mZXRjaFxuICogQHNlZSBodHRwczovL2Nhbml1c2UuY29tL2ZldGNoXG4gKiBAc2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZ2xvYmFscy5odG1sI2ZldGNoXG4gKi9cbmV4cG9ydCBjbGFzcyBGZXRjaCBleHRlbmRzIFBvbGxpbmcge1xuICAgIGRvUG9sbCgpIHtcbiAgICAgICAgdGhpcy5fZmV0Y2goKVxuICAgICAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vbkVycm9yKFwiZmV0Y2ggcmVhZCBlcnJvclwiLCByZXMuc3RhdHVzLCByZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLnRleHQoKS50aGVuKChkYXRhKSA9PiB0aGlzLm9uRGF0YShkYXRhKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiZmV0Y2ggcmVhZCBlcnJvclwiLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZG9Xcml0ZShkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9mZXRjaChkYXRhKVxuICAgICAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vbkVycm9yKFwiZmV0Y2ggd3JpdGUgZXJyb3JcIiwgcmVzLnN0YXR1cywgcmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiZmV0Y2ggd3JpdGUgZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9mZXRjaChkYXRhKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgaXNQb3N0ID0gZGF0YSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnModGhpcy5vcHRzLmV4dHJhSGVhZGVycyk7XG4gICAgICAgIGlmIChpc1Bvc3QpIHtcbiAgICAgICAgICAgIGhlYWRlcnMuc2V0KFwiY29udGVudC10eXBlXCIsIFwidGV4dC9wbGFpbjtjaGFyc2V0PVVURi04XCIpO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuc29ja2V0Ll9jb29raWVKYXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcHBlbmRDb29raWVzKGhlYWRlcnMpO1xuICAgICAgICByZXR1cm4gZmV0Y2godGhpcy51cmkoKSwge1xuICAgICAgICAgICAgbWV0aG9kOiBpc1Bvc3QgPyBcIlBPU1RcIiA6IFwiR0VUXCIsXG4gICAgICAgICAgICBib2R5OiBpc1Bvc3QgPyBkYXRhIDogbnVsbCxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBjcmVkZW50aWFsczogdGhpcy5vcHRzLndpdGhDcmVkZW50aWFscyA/IFwiaW5jbHVkZVwiIDogXCJvbWl0XCIsXG4gICAgICAgIH0pLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSBnZXRTZXRDb29raWUoKSB3YXMgYWRkZWQgaW4gTm9kZS5qcyB2MTkuNy4wXG4gICAgICAgICAgICAoX2EgPSB0aGlzLnNvY2tldC5fY29va2llSmFyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyc2VDb29raWVzKHJlcy5oZWFkZXJzLmdldFNldENvb2tpZSgpKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/polling-fetch.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/polling-xhr.js":
/*!***************************************************************************!*\
  !*** ./node_modules/engine.io-client/build/esm/transports/polling-xhr.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseXHR: () => (/* binding */ BaseXHR),\n/* harmony export */   Request: () => (/* binding */ Request),\n/* harmony export */   XHR: () => (/* binding */ XHR)\n/* harmony export */ });\n/* harmony import */ var _polling_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polling.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/polling.js\");\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @socket.io/component-emitter */ \"(pages-dir-browser)/./node_modules/@socket.io/component-emitter/lib/esm/index.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/util.js\");\n/* harmony import */ var _globals_node_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../globals.node.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/globals.js\");\n/* harmony import */ var _contrib_has_cors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../contrib/has-cors.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/contrib/has-cors.js\");\n\n\n\n\n\nfunction empty() { }\nclass BaseXHR extends _polling_js__WEBPACK_IMPORTED_MODULE_0__.Polling {\n    /**\n     * XHR Polling constructor.\n     *\n     * @param {Object} opts\n     * @package\n     */\n    constructor(opts) {\n        super(opts);\n        if (typeof location !== \"undefined\") {\n            const isSSL = \"https:\" === location.protocol;\n            let port = location.port;\n            // some user agents have empty `location.port`\n            if (!port) {\n                port = isSSL ? \"443\" : \"80\";\n            }\n            this.xd =\n                (typeof location !== \"undefined\" &&\n                    opts.hostname !== location.hostname) ||\n                    port !== opts.port;\n        }\n    }\n    /**\n     * Sends data.\n     *\n     * @param {String} data to send.\n     * @param {Function} called upon flush.\n     * @private\n     */\n    doWrite(data, fn) {\n        const req = this.request({\n            method: \"POST\",\n            data: data,\n        });\n        req.on(\"success\", fn);\n        req.on(\"error\", (xhrStatus, context) => {\n            this.onError(\"xhr post error\", xhrStatus, context);\n        });\n    }\n    /**\n     * Starts a poll cycle.\n     *\n     * @private\n     */\n    doPoll() {\n        const req = this.request();\n        req.on(\"data\", this.onData.bind(this));\n        req.on(\"error\", (xhrStatus, context) => {\n            this.onError(\"xhr poll error\", xhrStatus, context);\n        });\n        this.pollXhr = req;\n    }\n}\nclass Request extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_1__.Emitter {\n    /**\n     * Request constructor\n     *\n     * @param {Object} options\n     * @package\n     */\n    constructor(createRequest, uri, opts) {\n        super();\n        this.createRequest = createRequest;\n        (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.installTimerFunctions)(this, opts);\n        this._opts = opts;\n        this._method = opts.method || \"GET\";\n        this._uri = uri;\n        this._data = undefined !== opts.data ? opts.data : null;\n        this._create();\n    }\n    /**\n     * Creates the XHR object and sends the request.\n     *\n     * @private\n     */\n    _create() {\n        var _a;\n        const opts = (0,_util_js__WEBPACK_IMPORTED_MODULE_2__.pick)(this._opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n        opts.xdomain = !!this._opts.xd;\n        const xhr = (this._xhr = this.createRequest(opts));\n        try {\n            xhr.open(this._method, this._uri, true);\n            try {\n                if (this._opts.extraHeaders) {\n                    // @ts-ignore\n                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n                    for (let i in this._opts.extraHeaders) {\n                        if (this._opts.extraHeaders.hasOwnProperty(i)) {\n                            xhr.setRequestHeader(i, this._opts.extraHeaders[i]);\n                        }\n                    }\n                }\n            }\n            catch (e) { }\n            if (\"POST\" === this._method) {\n                try {\n                    xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                }\n                catch (e) { }\n            }\n            try {\n                xhr.setRequestHeader(\"Accept\", \"*/*\");\n            }\n            catch (e) { }\n            (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);\n            // ie6 check\n            if (\"withCredentials\" in xhr) {\n                xhr.withCredentials = this._opts.withCredentials;\n            }\n            if (this._opts.requestTimeout) {\n                xhr.timeout = this._opts.requestTimeout;\n            }\n            xhr.onreadystatechange = () => {\n                var _a;\n                if (xhr.readyState === 3) {\n                    (_a = this._opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(\n                    // @ts-ignore\n                    xhr.getResponseHeader(\"set-cookie\"));\n                }\n                if (4 !== xhr.readyState)\n                    return;\n                if (200 === xhr.status || 1223 === xhr.status) {\n                    this._onLoad();\n                }\n                else {\n                    // make sure the `error` event handler that's user-set\n                    // does not throw in the same tick and gets caught here\n                    this.setTimeoutFn(() => {\n                        this._onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                    }, 0);\n                }\n            };\n            xhr.send(this._data);\n        }\n        catch (e) {\n            // Need to defer since .create() is called directly from the constructor\n            // and thus the 'error' event can only be only bound *after* this exception\n            // occurs.  Therefore, also, we cannot throw here at all.\n            this.setTimeoutFn(() => {\n                this._onError(e);\n            }, 0);\n            return;\n        }\n        if (typeof document !== \"undefined\") {\n            this._index = Request.requestsCount++;\n            Request.requests[this._index] = this;\n        }\n    }\n    /**\n     * Called upon error.\n     *\n     * @private\n     */\n    _onError(err) {\n        this.emitReserved(\"error\", err, this._xhr);\n        this._cleanup(true);\n    }\n    /**\n     * Cleans up house.\n     *\n     * @private\n     */\n    _cleanup(fromError) {\n        if (\"undefined\" === typeof this._xhr || null === this._xhr) {\n            return;\n        }\n        this._xhr.onreadystatechange = empty;\n        if (fromError) {\n            try {\n                this._xhr.abort();\n            }\n            catch (e) { }\n        }\n        if (typeof document !== \"undefined\") {\n            delete Request.requests[this._index];\n        }\n        this._xhr = null;\n    }\n    /**\n     * Called upon load.\n     *\n     * @private\n     */\n    _onLoad() {\n        const data = this._xhr.responseText;\n        if (data !== null) {\n            this.emitReserved(\"data\", data);\n            this.emitReserved(\"success\");\n            this._cleanup();\n        }\n    }\n    /**\n     * Aborts the request.\n     *\n     * @package\n     */\n    abort() {\n        this._cleanup();\n    }\n}\nRequest.requestsCount = 0;\nRequest.requests = {};\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\nif (typeof document !== \"undefined\") {\n    // @ts-ignore\n    if (typeof attachEvent === \"function\") {\n        // @ts-ignore\n        attachEvent(\"onunload\", unloadHandler);\n    }\n    else if (typeof addEventListener === \"function\") {\n        const terminationEvent = \"onpagehide\" in _globals_node_js__WEBPACK_IMPORTED_MODULE_3__.globalThisShim ? \"pagehide\" : \"unload\";\n        addEventListener(terminationEvent, unloadHandler, false);\n    }\n}\nfunction unloadHandler() {\n    for (let i in Request.requests) {\n        if (Request.requests.hasOwnProperty(i)) {\n            Request.requests[i].abort();\n        }\n    }\n}\nconst hasXHR2 = (function () {\n    const xhr = newRequest({\n        xdomain: false,\n    });\n    return xhr && xhr.responseType !== null;\n})();\n/**\n * HTTP long-polling based on the built-in `XMLHttpRequest` object.\n *\n * Usage: browser\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest\n */\nclass XHR extends BaseXHR {\n    constructor(opts) {\n        super(opts);\n        const forceBase64 = opts && opts.forceBase64;\n        this.supportsBinary = hasXHR2 && !forceBase64;\n    }\n    request(opts = {}) {\n        Object.assign(opts, { xd: this.xd }, this.opts);\n        return new Request(newRequest, this.uri(), opts);\n    }\n}\nfunction newRequest(opts) {\n    const xdomain = opts.xdomain;\n    // XMLHttpRequest can be disabled on IE\n    try {\n        if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || _contrib_has_cors_js__WEBPACK_IMPORTED_MODULE_4__.hasCORS)) {\n            return new XMLHttpRequest();\n        }\n    }\n    catch (e) { }\n    if (!xdomain) {\n        try {\n            return new _globals_node_js__WEBPACK_IMPORTED_MODULE_3__.globalThisShim[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n        }\n        catch (e) { }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS90cmFuc3BvcnRzL3BvbGxpbmcteGhyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQXVDO0FBQ2dCO0FBQ0U7QUFDUztBQUNqQjtBQUNqRDtBQUNPLHNCQUFzQixnREFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLHNCQUFzQixpRUFBTztBQUNwQztBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsK0RBQXFCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDhDQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDRFQUEwQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiw4QkFBOEIsYUFBYTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSx5REFBTztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNERBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGVuZ2luZS5pby1jbGllbnRcXGJ1aWxkXFxlc21cXHRyYW5zcG9ydHNcXHBvbGxpbmcteGhyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBvbGxpbmcgfSBmcm9tIFwiLi9wb2xsaW5nLmpzXCI7XG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSBcIkBzb2NrZXQuaW8vY29tcG9uZW50LWVtaXR0ZXJcIjtcbmltcG9ydCB7IGluc3RhbGxUaW1lckZ1bmN0aW9ucywgcGljayB9IGZyb20gXCIuLi91dGlsLmpzXCI7XG5pbXBvcnQgeyBnbG9iYWxUaGlzU2hpbSBhcyBnbG9iYWxUaGlzIH0gZnJvbSBcIi4uL2dsb2JhbHMubm9kZS5qc1wiO1xuaW1wb3J0IHsgaGFzQ09SUyB9IGZyb20gXCIuLi9jb250cmliL2hhcy1jb3JzLmpzXCI7XG5mdW5jdGlvbiBlbXB0eSgpIHsgfVxuZXhwb3J0IGNsYXNzIEJhc2VYSFIgZXh0ZW5kcyBQb2xsaW5nIHtcbiAgICAvKipcbiAgICAgKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHN1cGVyKG9wdHMpO1xuICAgICAgICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBjb25zdCBpc1NTTCA9IFwiaHR0cHM6XCIgPT09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgICAgICAgbGV0IHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuICAgICAgICAgICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgICAgICAgICAgaWYgKCFwb3J0KSB7XG4gICAgICAgICAgICAgICAgcG9ydCA9IGlzU1NMID8gXCI0NDNcIiA6IFwiODBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMueGQgPVxuICAgICAgICAgICAgICAgICh0eXBlb2YgbG9jYXRpb24gIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5ob3N0bmFtZSAhPT0gbG9jYXRpb24uaG9zdG5hbWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIHBvcnQgIT09IG9wdHMucG9ydDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRvV3JpdGUoZGF0YSwgZm4pIHtcbiAgICAgICAgY29uc3QgcmVxID0gdGhpcy5yZXF1ZXN0KHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgcmVxLm9uKFwic3VjY2Vzc1wiLCBmbik7XG4gICAgICAgIHJlcS5vbihcImVycm9yXCIsICh4aHJTdGF0dXMsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcInhociBwb3N0IGVycm9yXCIsIHhoclN0YXR1cywgY29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkb1BvbGwoKSB7XG4gICAgICAgIGNvbnN0IHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICAgICAgICByZXEub24oXCJkYXRhXCIsIHRoaXMub25EYXRhLmJpbmQodGhpcykpO1xuICAgICAgICByZXEub24oXCJlcnJvclwiLCAoeGhyU3RhdHVzLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJ4aHIgcG9sbCBlcnJvclwiLCB4aHJTdGF0dXMsIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wb2xsWGhyID0gcmVxO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSZXF1ZXN0IGV4dGVuZHMgRW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBjb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNyZWF0ZVJlcXVlc3QsIHVyaSwgb3B0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNyZWF0ZVJlcXVlc3QgPSBjcmVhdGVSZXF1ZXN0O1xuICAgICAgICBpbnN0YWxsVGltZXJGdW5jdGlvbnModGhpcywgb3B0cyk7XG4gICAgICAgIHRoaXMuX29wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLl9tZXRob2QgPSBvcHRzLm1ldGhvZCB8fCBcIkdFVFwiO1xuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuX2RhdGEgPSB1bmRlZmluZWQgIT09IG9wdHMuZGF0YSA/IG9wdHMuZGF0YSA6IG51bGw7XG4gICAgICAgIHRoaXMuX2NyZWF0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NyZWF0ZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBvcHRzID0gcGljayh0aGlzLl9vcHRzLCBcImFnZW50XCIsIFwicGZ4XCIsIFwia2V5XCIsIFwicGFzc3BocmFzZVwiLCBcImNlcnRcIiwgXCJjYVwiLCBcImNpcGhlcnNcIiwgXCJyZWplY3RVbmF1dGhvcml6ZWRcIiwgXCJhdXRvVW5yZWZcIik7XG4gICAgICAgIG9wdHMueGRvbWFpbiA9ICEhdGhpcy5fb3B0cy54ZDtcbiAgICAgICAgY29uc3QgeGhyID0gKHRoaXMuX3hociA9IHRoaXMuY3JlYXRlUmVxdWVzdChvcHRzKSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB4aHIub3Blbih0aGlzLl9tZXRob2QsIHRoaXMuX3VyaSwgdHJ1ZSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRzLmV4dHJhSGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sgJiYgeGhyLnNldERpc2FibGVIZWFkZXJDaGVjayh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSBpbiB0aGlzLl9vcHRzLmV4dHJhSGVhZGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdHMuZXh0cmFIZWFkZXJzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoaSwgdGhpcy5fb3B0cy5leHRyYUhlYWRlcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgaWYgKFwiUE9TVFwiID09PSB0aGlzLl9tZXRob2QpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtdHlwZVwiLCBcInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcIiovKlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIChfYSA9IHRoaXMuX29wdHMuY29va2llSmFyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkQ29va2llcyh4aHIpO1xuICAgICAgICAgICAgLy8gaWU2IGNoZWNrXG4gICAgICAgICAgICBpZiAoXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHIpIHtcbiAgICAgICAgICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdGhpcy5fb3B0cy53aXRoQ3JlZGVudGlhbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fb3B0cy5yZXF1ZXN0VGltZW91dCkge1xuICAgICAgICAgICAgICAgIHhoci50aW1lb3V0ID0gdGhpcy5fb3B0cy5yZXF1ZXN0VGltZW91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLl9vcHRzLmNvb2tpZUphcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcnNlQ29va2llcyhcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJzZXQtY29va2llXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKDQgIT09IHhoci5yZWFkeVN0YXRlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKDIwMCA9PT0geGhyLnN0YXR1cyB8fCAxMjIzID09PSB4aHIuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uTG9hZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBgZXJyb3JgIGV2ZW50IGhhbmRsZXIgdGhhdCdzIHVzZXItc2V0XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25FcnJvcih0eXBlb2YgeGhyLnN0YXR1cyA9PT0gXCJudW1iZXJcIiA/IHhoci5zdGF0dXMgOiAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhoci5zZW5kKHRoaXMuX2RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBOZWVkIHRvIGRlZmVyIHNpbmNlIC5jcmVhdGUoKSBpcyBjYWxsZWQgZGlyZWN0bHkgZnJvbSB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuICAgICAgICAgICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG4gICAgICAgICAgICB0aGlzLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25FcnJvcihlKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gUmVxdWVzdC5yZXF1ZXN0c0NvdW50Kys7XG4gICAgICAgICAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuX2luZGV4XSA9IHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbkVycm9yKGVycikge1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImVycm9yXCIsIGVyciwgdGhpcy5feGhyKTtcbiAgICAgICAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIGhvdXNlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2xlYW51cChmcm9tRXJyb3IpIHtcbiAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgPT09IHR5cGVvZiB0aGlzLl94aHIgfHwgbnVsbCA9PT0gdGhpcy5feGhyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5feGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5O1xuICAgICAgICBpZiAoZnJvbUVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3hoci5hYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuX2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl94aHIgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBsb2FkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25Mb2FkKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5feGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZGF0YVwiLCBkYXRhKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwic3VjY2Vzc1wiKTtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFudXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBYm9ydHMgdGhlIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIGFib3J0KCkge1xuICAgICAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgfVxufVxuUmVxdWVzdC5yZXF1ZXN0c0NvdW50ID0gMDtcblJlcXVlc3QucmVxdWVzdHMgPSB7fTtcbi8qKlxuICogQWJvcnRzIHBlbmRpbmcgcmVxdWVzdHMgd2hlbiB1bmxvYWRpbmcgdGhlIHdpbmRvdy4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudFxuICogbWVtb3J5IGxlYWtzIChlLmcuIHdoZW4gdXNpbmcgSUUpIGFuZCB0byBlbnN1cmUgdGhhdCBubyBzcHVyaW91cyBlcnJvciBpc1xuICogZW1pdHRlZC5cbiAqL1xuaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAodHlwZW9mIGF0dGFjaEV2ZW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBhdHRhY2hFdmVudChcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHRlcm1pbmF0aW9uRXZlbnQgPSBcIm9ucGFnZWhpZGVcIiBpbiBnbG9iYWxUaGlzID8gXCJwYWdlaGlkZVwiIDogXCJ1bmxvYWRcIjtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcih0ZXJtaW5hdGlvbkV2ZW50LCB1bmxvYWRIYW5kbGVyLCBmYWxzZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdW5sb2FkSGFuZGxlcigpIHtcbiAgICBmb3IgKGxldCBpIGluIFJlcXVlc3QucmVxdWVzdHMpIHtcbiAgICAgICAgaWYgKFJlcXVlc3QucmVxdWVzdHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgIFJlcXVlc3QucmVxdWVzdHNbaV0uYWJvcnQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IGhhc1hIUjIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHhociA9IG5ld1JlcXVlc3Qoe1xuICAgICAgICB4ZG9tYWluOiBmYWxzZSxcbiAgICB9KTtcbiAgICByZXR1cm4geGhyICYmIHhoci5yZXNwb25zZVR5cGUgIT09IG51bGw7XG59KSgpO1xuLyoqXG4gKiBIVFRQIGxvbmctcG9sbGluZyBiYXNlZCBvbiB0aGUgYnVpbHQtaW4gYFhNTEh0dHBSZXF1ZXN0YCBvYmplY3QuXG4gKlxuICogVXNhZ2U6IGJyb3dzZXJcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9YTUxIdHRwUmVxdWVzdFxuICovXG5leHBvcnQgY2xhc3MgWEhSIGV4dGVuZHMgQmFzZVhIUiB7XG4gICAgY29uc3RydWN0b3Iob3B0cykge1xuICAgICAgICBzdXBlcihvcHRzKTtcbiAgICAgICAgY29uc3QgZm9yY2VCYXNlNjQgPSBvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQ7XG4gICAgICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBoYXNYSFIyICYmICFmb3JjZUJhc2U2NDtcbiAgICB9XG4gICAgcmVxdWVzdChvcHRzID0ge30pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLCB7IHhkOiB0aGlzLnhkIH0sIHRoaXMub3B0cyk7XG4gICAgICAgIHJldHVybiBuZXcgUmVxdWVzdChuZXdSZXF1ZXN0LCB0aGlzLnVyaSgpLCBvcHRzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBuZXdSZXF1ZXN0KG9wdHMpIHtcbiAgICBjb25zdCB4ZG9tYWluID0gb3B0cy54ZG9tYWluO1xuICAgIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuICAgIHRyeSB7XG4gICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgKCF4ZG9tYWluIHx8IGhhc0NPUlMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGUpIHsgfVxuICAgIGlmICgheGRvbWFpbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBnbG9iYWxUaGlzW1tcIkFjdGl2ZVwiXS5jb25jYXQoXCJPYmplY3RcIikuam9pbihcIlhcIildKFwiTWljcm9zb2Z0LlhNTEhUVFBcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/polling-xhr.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/polling.js":
/*!***********************************************************************!*\
  !*** ./node_modules/engine.io-client/build/esm/transports/polling.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Polling: () => (/* binding */ Polling)\n/* harmony export */ });\n/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transport.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transport.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/util.js\");\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! engine.io-parser */ \"(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/index.js\");\n\n\n\nclass Polling extends _transport_js__WEBPACK_IMPORTED_MODULE_0__.Transport {\n    constructor() {\n        super(...arguments);\n        this._polling = false;\n    }\n    get name() {\n        return \"polling\";\n    }\n    /**\n     * Opens the socket (triggers polling). We write a PING message to determine\n     * when the transport is open.\n     *\n     * @protected\n     */\n    doOpen() {\n        this._poll();\n    }\n    /**\n     * Pauses polling.\n     *\n     * @param {Function} onPause - callback upon buffers are flushed and transport is paused\n     * @package\n     */\n    pause(onPause) {\n        this.readyState = \"pausing\";\n        const pause = () => {\n            this.readyState = \"paused\";\n            onPause();\n        };\n        if (this._polling || !this.writable) {\n            let total = 0;\n            if (this._polling) {\n                total++;\n                this.once(\"pollComplete\", function () {\n                    --total || pause();\n                });\n            }\n            if (!this.writable) {\n                total++;\n                this.once(\"drain\", function () {\n                    --total || pause();\n                });\n            }\n        }\n        else {\n            pause();\n        }\n    }\n    /**\n     * Starts polling cycle.\n     *\n     * @private\n     */\n    _poll() {\n        this._polling = true;\n        this.doPoll();\n        this.emitReserved(\"poll\");\n    }\n    /**\n     * Overloads onData to detect payloads.\n     *\n     * @protected\n     */\n    onData(data) {\n        const callback = (packet) => {\n            // if its the first message we consider the transport open\n            if (\"opening\" === this.readyState && packet.type === \"open\") {\n                this.onOpen();\n            }\n            // if its a close packet, we close the ongoing requests\n            if (\"close\" === packet.type) {\n                this.onClose({ description: \"transport closed by the server\" });\n                return false;\n            }\n            // otherwise bypass onData and handle the message\n            this.onPacket(packet);\n        };\n        // decode payload\n        (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_2__.decodePayload)(data, this.socket.binaryType).forEach(callback);\n        // if an event did not trigger closing\n        if (\"closed\" !== this.readyState) {\n            // if we got data we're not polling\n            this._polling = false;\n            this.emitReserved(\"pollComplete\");\n            if (\"open\" === this.readyState) {\n                this._poll();\n            }\n            else {\n            }\n        }\n    }\n    /**\n     * For polling, send a close packet.\n     *\n     * @protected\n     */\n    doClose() {\n        const close = () => {\n            this.write([{ type: \"close\" }]);\n        };\n        if (\"open\" === this.readyState) {\n            close();\n        }\n        else {\n            // in case we're trying to close while\n            // handshaking is in progress (GH-164)\n            this.once(\"open\", close);\n        }\n    }\n    /**\n     * Writes a packets payload.\n     *\n     * @param {Array} packets - data packets\n     * @protected\n     */\n    write(packets) {\n        this.writable = false;\n        (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_2__.encodePayload)(packets, (data) => {\n            this.doWrite(data, () => {\n                this.writable = true;\n                this.emitReserved(\"drain\");\n            });\n        });\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */\n    uri() {\n        const schema = this.opts.secure ? \"https\" : \"http\";\n        const query = this.query || {};\n        // cache busting is forced\n        if (false !== this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.randomString)();\n        }\n        if (!this.supportsBinary && !query.sid) {\n            query.b64 = 1;\n        }\n        return this.createUri(schema, query);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS90cmFuc3BvcnRzL3BvbGxpbmcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE0QztBQUNGO0FBQ3NCO0FBQ3pELHNCQUFzQixvREFBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwrQ0FBK0M7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwrREFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0RBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGVuZ2luZS5pby1jbGllbnRcXGJ1aWxkXFxlc21cXHRyYW5zcG9ydHNcXHBvbGxpbmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHJhbnNwb3J0IH0gZnJvbSBcIi4uL3RyYW5zcG9ydC5qc1wiO1xuaW1wb3J0IHsgcmFuZG9tU3RyaW5nIH0gZnJvbSBcIi4uL3V0aWwuanNcIjtcbmltcG9ydCB7IGVuY29kZVBheWxvYWQsIGRlY29kZVBheWxvYWQgfSBmcm9tIFwiZW5naW5lLmlvLXBhcnNlclwiO1xuZXhwb3J0IGNsYXNzIFBvbGxpbmcgZXh0ZW5kcyBUcmFuc3BvcnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9wb2xsaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJwb2xsaW5nXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAgICAgKiB3aGVuIHRoZSB0cmFuc3BvcnQgaXMgb3Blbi5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBkb09wZW4oKSB7XG4gICAgICAgIHRoaXMuX3BvbGwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2VzIHBvbGxpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblBhdXNlIC0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICBwYXVzZShvblBhdXNlKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwicGF1c2luZ1wiO1xuICAgICAgICBjb25zdCBwYXVzZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwicGF1c2VkXCI7XG4gICAgICAgICAgICBvblBhdXNlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLl9wb2xsaW5nIHx8ICF0aGlzLndyaXRhYmxlKSB7XG4gICAgICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3BvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICB0b3RhbCsrO1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShcInBvbGxDb21wbGV0ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy53cml0YWJsZSkge1xuICAgICAgICAgICAgICAgIHRvdGFsKys7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiZHJhaW5cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXVzZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcG9sbCgpIHtcbiAgICAgICAgdGhpcy5fcG9sbGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZG9Qb2xsKCk7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicG9sbFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcmxvYWRzIG9uRGF0YSB0byBkZXRlY3QgcGF5bG9hZHMuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25EYXRhKGRhdGEpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAocGFja2V0KSA9PiB7XG4gICAgICAgICAgICAvLyBpZiBpdHMgdGhlIGZpcnN0IG1lc3NhZ2Ugd2UgY29uc2lkZXIgdGhlIHRyYW5zcG9ydCBvcGVuXG4gICAgICAgICAgICBpZiAoXCJvcGVuaW5nXCIgPT09IHRoaXMucmVhZHlTdGF0ZSAmJiBwYWNrZXQudHlwZSA9PT0gXCJvcGVuXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uT3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgaXRzIGEgY2xvc2UgcGFja2V0LCB3ZSBjbG9zZSB0aGUgb25nb2luZyByZXF1ZXN0c1xuICAgICAgICAgICAgaWYgKFwiY2xvc2VcIiA9PT0gcGFja2V0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UoeyBkZXNjcmlwdGlvbjogXCJ0cmFuc3BvcnQgY2xvc2VkIGJ5IHRoZSBzZXJ2ZXJcIiB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgYnlwYXNzIG9uRGF0YSBhbmQgaGFuZGxlIHRoZSBtZXNzYWdlXG4gICAgICAgICAgICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGRlY29kZSBwYXlsb2FkXG4gICAgICAgIGRlY29kZVBheWxvYWQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSkuZm9yRWFjaChjYWxsYmFjayk7XG4gICAgICAgIC8vIGlmIGFuIGV2ZW50IGRpZCBub3QgdHJpZ2dlciBjbG9zaW5nXG4gICAgICAgIGlmIChcImNsb3NlZFwiICE9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGdvdCBkYXRhIHdlJ3JlIG5vdCBwb2xsaW5nXG4gICAgICAgICAgICB0aGlzLl9wb2xsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInBvbGxDb21wbGV0ZVwiKTtcbiAgICAgICAgICAgIGlmIChcIm9wZW5cIiA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9sbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yIHBvbGxpbmcsIHNlbmQgYSBjbG9zZSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgZG9DbG9zZSgpIHtcbiAgICAgICAgY29uc3QgY2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndyaXRlKFt7IHR5cGU6IFwiY2xvc2VcIiB9XSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChcIm9wZW5cIiA9PT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB3ZSdyZSB0cnlpbmcgdG8gY2xvc2Ugd2hpbGVcbiAgICAgICAgICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG4gICAgICAgICAgICB0aGlzLm9uY2UoXCJvcGVuXCIsIGNsb3NlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzIC0gZGF0YSBwYWNrZXRzXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHdyaXRlKHBhY2tldHMpIHtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICBlbmNvZGVQYXlsb2FkKHBhY2tldHMsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRvV3JpdGUoZGF0YSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZHJhaW5cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVyaSgpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5vcHRzLnNlY3VyZSA/IFwiaHR0cHNcIiA6IFwiaHR0cFwiO1xuICAgICAgICBjb25zdCBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gICAgICAgIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG4gICAgICAgIGlmIChmYWxzZSAhPT0gdGhpcy5vcHRzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgICAgICAgICBxdWVyeVt0aGlzLm9wdHMudGltZXN0YW1wUGFyYW1dID0gcmFuZG9tU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmICFxdWVyeS5zaWQpIHtcbiAgICAgICAgICAgIHF1ZXJ5LmI2NCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVXJpKHNjaGVtYSwgcXVlcnkpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/polling.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js":
/*!*************************************************************************!*\
  !*** ./node_modules/engine.io-client/build/esm/transports/websocket.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseWS: () => (/* binding */ BaseWS),\n/* harmony export */   WS: () => (/* binding */ WS)\n/* harmony export */ });\n/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transport.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transport.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/util.js\");\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! engine.io-parser */ \"(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/index.js\");\n/* harmony import */ var _globals_node_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../globals.node.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/globals.js\");\n\n\n\n\n// detect ReactNative environment\nconst isReactNative = typeof navigator !== \"undefined\" &&\n    typeof navigator.product === \"string\" &&\n    navigator.product.toLowerCase() === \"reactnative\";\nclass BaseWS extends _transport_js__WEBPACK_IMPORTED_MODULE_0__.Transport {\n    get name() {\n        return \"websocket\";\n    }\n    doOpen() {\n        const uri = this.uri();\n        const protocols = this.opts.protocols;\n        // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n        const opts = isReactNative\n            ? {}\n            : (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.pick)(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n        if (this.opts.extraHeaders) {\n            opts.headers = this.opts.extraHeaders;\n        }\n        try {\n            this.ws = this.createSocket(uri, protocols, opts);\n        }\n        catch (err) {\n            return this.emitReserved(\"error\", err);\n        }\n        this.ws.binaryType = this.socket.binaryType;\n        this.addEventListeners();\n    }\n    /**\n     * Adds event listeners to the socket\n     *\n     * @private\n     */\n    addEventListeners() {\n        this.ws.onopen = () => {\n            if (this.opts.autoUnref) {\n                this.ws._socket.unref();\n            }\n            this.onOpen();\n        };\n        this.ws.onclose = (closeEvent) => this.onClose({\n            description: \"websocket connection closed\",\n            context: closeEvent,\n        });\n        this.ws.onmessage = (ev) => this.onData(ev.data);\n        this.ws.onerror = (e) => this.onError(\"websocket error\", e);\n    }\n    write(packets) {\n        this.writable = false;\n        // encodePacket efficient as it uses WS framing\n        // no need for encodePayload\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_2__.encodePacket)(packet, this.supportsBinary, (data) => {\n                // Sometimes the websocket has already been closed but the browser didn't\n                // have a chance of informing us about it yet, in that case send will\n                // throw an error\n                try {\n                    this.doWrite(packet, data);\n                }\n                catch (e) {\n                }\n                if (lastPacket) {\n                    // fake drain\n                    // defer to next tick to allow Socket to clear writeBuffer\n                    (0,_globals_node_js__WEBPACK_IMPORTED_MODULE_3__.nextTick)(() => {\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    doClose() {\n        if (typeof this.ws !== \"undefined\") {\n            this.ws.onerror = () => { };\n            this.ws.close();\n            this.ws = null;\n        }\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */\n    uri() {\n        const schema = this.opts.secure ? \"wss\" : \"ws\";\n        const query = this.query || {};\n        // append timestamp to URI\n        if (this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.randomString)();\n        }\n        // communicate binary support capabilities\n        if (!this.supportsBinary) {\n            query.b64 = 1;\n        }\n        return this.createUri(schema, query);\n    }\n}\nconst WebSocketCtor = _globals_node_js__WEBPACK_IMPORTED_MODULE_3__.globalThisShim.WebSocket || _globals_node_js__WEBPACK_IMPORTED_MODULE_3__.globalThisShim.MozWebSocket;\n/**\n * WebSocket transport based on the built-in `WebSocket` object.\n *\n * Usage: browser, Node.js (since v21), Deno, Bun\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket\n * @see https://caniuse.com/mdn-api_websocket\n * @see https://nodejs.org/api/globals.html#websocket\n */\nclass WS extends BaseWS {\n    createSocket(uri, protocols, opts) {\n        return !isReactNative\n            ? protocols\n                ? new WebSocketCtor(uri, protocols)\n                : new WebSocketCtor(uri)\n            : new WebSocketCtor(uri, protocols, opts);\n    }\n    doWrite(_packet, data) {\n        this.ws.send(data);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS90cmFuc3BvcnRzL3dlYnNvY2tldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBNEM7QUFDSTtBQUNBO0FBQzRCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUJBQXFCLG9EQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsOENBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0EsWUFBWSw4REFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBEQUFRO0FBQzVCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0RBQVk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0REFBVSxjQUFjLDREQUFVO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXHNob3BfaGFyZGhhdFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcZW5naW5lLmlvLWNsaWVudFxcYnVpbGRcXGVzbVxcdHJhbnNwb3J0c1xcd2Vic29ja2V0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyYW5zcG9ydCB9IGZyb20gXCIuLi90cmFuc3BvcnQuanNcIjtcbmltcG9ydCB7IHBpY2ssIHJhbmRvbVN0cmluZyB9IGZyb20gXCIuLi91dGlsLmpzXCI7XG5pbXBvcnQgeyBlbmNvZGVQYWNrZXQgfSBmcm9tIFwiZW5naW5lLmlvLXBhcnNlclwiO1xuaW1wb3J0IHsgZ2xvYmFsVGhpc1NoaW0gYXMgZ2xvYmFsVGhpcywgbmV4dFRpY2sgfSBmcm9tIFwiLi4vZ2xvYmFscy5ub2RlLmpzXCI7XG4vLyBkZXRlY3QgUmVhY3ROYXRpdmUgZW52aXJvbm1lbnRcbmNvbnN0IGlzUmVhY3ROYXRpdmUgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgdHlwZW9mIG5hdmlnYXRvci5wcm9kdWN0ID09PSBcInN0cmluZ1wiICYmXG4gICAgbmF2aWdhdG9yLnByb2R1Y3QudG9Mb3dlckNhc2UoKSA9PT0gXCJyZWFjdG5hdGl2ZVwiO1xuZXhwb3J0IGNsYXNzIEJhc2VXUyBleHRlbmRzIFRyYW5zcG9ydCB7XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBcIndlYnNvY2tldFwiO1xuICAgIH1cbiAgICBkb09wZW4oKSB7XG4gICAgICAgIGNvbnN0IHVyaSA9IHRoaXMudXJpKCk7XG4gICAgICAgIGNvbnN0IHByb3RvY29scyA9IHRoaXMub3B0cy5wcm90b2NvbHM7XG4gICAgICAgIC8vIFJlYWN0IE5hdGl2ZSBvbmx5IHN1cHBvcnRzIHRoZSAnaGVhZGVycycgb3B0aW9uLCBhbmQgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgYW55dGhpbmcgZWxzZSBpcyBwYXNzZWRcbiAgICAgICAgY29uc3Qgb3B0cyA9IGlzUmVhY3ROYXRpdmVcbiAgICAgICAgICAgID8ge31cbiAgICAgICAgICAgIDogcGljayh0aGlzLm9wdHMsIFwiYWdlbnRcIiwgXCJwZXJNZXNzYWdlRGVmbGF0ZVwiLCBcInBmeFwiLCBcImtleVwiLCBcInBhc3NwaHJhc2VcIiwgXCJjZXJ0XCIsIFwiY2FcIiwgXCJjaXBoZXJzXCIsIFwicmVqZWN0VW5hdXRob3JpemVkXCIsIFwibG9jYWxBZGRyZXNzXCIsIFwicHJvdG9jb2xWZXJzaW9uXCIsIFwib3JpZ2luXCIsIFwibWF4UGF5bG9hZFwiLCBcImZhbWlseVwiLCBcImNoZWNrU2VydmVySWRlbnRpdHlcIik7XG4gICAgICAgIGlmICh0aGlzLm9wdHMuZXh0cmFIZWFkZXJzKSB7XG4gICAgICAgICAgICBvcHRzLmhlYWRlcnMgPSB0aGlzLm9wdHMuZXh0cmFIZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLndzID0gdGhpcy5jcmVhdGVTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXRSZXNlcnZlZChcImVycm9yXCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53cy5iaW5hcnlUeXBlID0gdGhpcy5zb2NrZXQuYmluYXJ5VHlwZTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLndzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuYXV0b1VucmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53cy5fc29ja2V0LnVucmVmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uT3BlbigpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSAoY2xvc2VFdmVudCkgPT4gdGhpcy5vbkNsb3NlKHtcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIndlYnNvY2tldCBjb25uZWN0aW9uIGNsb3NlZFwiLFxuICAgICAgICAgICAgY29udGV4dDogY2xvc2VFdmVudCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gKGV2KSA9PiB0aGlzLm9uRGF0YShldi5kYXRhKTtcbiAgICAgICAgdGhpcy53cy5vbmVycm9yID0gKGUpID0+IHRoaXMub25FcnJvcihcIndlYnNvY2tldCBlcnJvclwiLCBlKTtcbiAgICB9XG4gICAgd3JpdGUocGFja2V0cykge1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIC8vIGVuY29kZVBhY2tldCBlZmZpY2llbnQgYXMgaXQgdXNlcyBXUyBmcmFtaW5nXG4gICAgICAgIC8vIG5vIG5lZWQgZm9yIGVuY29kZVBheWxvYWRcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYWNrZXQgPSBwYWNrZXRzW2ldO1xuICAgICAgICAgICAgY29uc3QgbGFzdFBhY2tldCA9IGkgPT09IHBhY2tldHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGVuY29kZVBhY2tldChwYWNrZXQsIHRoaXMuc3VwcG9ydHNCaW5hcnksIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gU29tZXRpbWVzIHRoZSB3ZWJzb2NrZXQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgYnV0IHRoZSBicm93c2VyIGRpZG4ndFxuICAgICAgICAgICAgICAgIC8vIGhhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuICAgICAgICAgICAgICAgIC8vIHRocm93IGFuIGVycm9yXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1dyaXRlKHBhY2tldCwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsYXN0UGFja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZha2UgZHJhaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICBuZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZHJhaW5cIik7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMuc2V0VGltZW91dEZuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkb0Nsb3NlKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMud3MgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMud3Mub25lcnJvciA9ICgpID0+IHsgfTtcbiAgICAgICAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMud3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHVyaSgpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5vcHRzLnNlY3VyZSA/IFwid3NzXCIgOiBcIndzXCI7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgICAgICAgLy8gYXBwZW5kIHRpbWVzdGFtcCB0byBVUklcbiAgICAgICAgaWYgKHRoaXMub3B0cy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgICAgICAgICAgcXVlcnlbdGhpcy5vcHRzLnRpbWVzdGFtcFBhcmFtXSA9IHJhbmRvbVN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgICAgICAgIHF1ZXJ5LmI2NCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVXJpKHNjaGVtYSwgcXVlcnkpO1xuICAgIH1cbn1cbmNvbnN0IFdlYlNvY2tldEN0b3IgPSBnbG9iYWxUaGlzLldlYlNvY2tldCB8fCBnbG9iYWxUaGlzLk1veldlYlNvY2tldDtcbi8qKlxuICogV2ViU29ja2V0IHRyYW5zcG9ydCBiYXNlZCBvbiB0aGUgYnVpbHQtaW4gYFdlYlNvY2tldGAgb2JqZWN0LlxuICpcbiAqIFVzYWdlOiBicm93c2VyLCBOb2RlLmpzIChzaW5jZSB2MjEpLCBEZW5vLCBCdW5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJTb2NrZXRcbiAqIEBzZWUgaHR0cHM6Ly9jYW5pdXNlLmNvbS9tZG4tYXBpX3dlYnNvY2tldFxuICogQHNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL2dsb2JhbHMuaHRtbCN3ZWJzb2NrZXRcbiAqL1xuZXhwb3J0IGNsYXNzIFdTIGV4dGVuZHMgQmFzZVdTIHtcbiAgICBjcmVhdGVTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpIHtcbiAgICAgICAgcmV0dXJuICFpc1JlYWN0TmF0aXZlXG4gICAgICAgICAgICA/IHByb3RvY29sc1xuICAgICAgICAgICAgICAgID8gbmV3IFdlYlNvY2tldEN0b3IodXJpLCBwcm90b2NvbHMpXG4gICAgICAgICAgICAgICAgOiBuZXcgV2ViU29ja2V0Q3Rvcih1cmkpXG4gICAgICAgICAgICA6IG5ldyBXZWJTb2NrZXRDdG9yKHVyaSwgcHJvdG9jb2xzLCBvcHRzKTtcbiAgICB9XG4gICAgZG9Xcml0ZShfcGFja2V0LCBkYXRhKSB7XG4gICAgICAgIHRoaXMud3Muc2VuZChkYXRhKTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/websocket.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/webtransport.js":
/*!****************************************************************************!*\
  !*** ./node_modules/engine.io-client/build/esm/transports/webtransport.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WT: () => (/* binding */ WT)\n/* harmony export */ });\n/* harmony import */ var _transport_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../transport.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transport.js\");\n/* harmony import */ var _globals_node_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../globals.node.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/globals.js\");\n/* harmony import */ var engine_io_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! engine.io-parser */ \"(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/index.js\");\n\n\n\n/**\n * WebTransport transport based on the built-in `WebTransport` object.\n *\n * Usage: browser, Node.js (with the `@fails-components/webtransport` package)\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WebTransport\n * @see https://caniuse.com/webtransport\n */\nclass WT extends _transport_js__WEBPACK_IMPORTED_MODULE_0__.Transport {\n    get name() {\n        return \"webtransport\";\n    }\n    doOpen() {\n        try {\n            // @ts-ignore\n            this._transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\n        }\n        catch (err) {\n            return this.emitReserved(\"error\", err);\n        }\n        this._transport.closed\n            .then(() => {\n            this.onClose();\n        })\n            .catch((err) => {\n            this.onError(\"webtransport error\", err);\n        });\n        // note: we could have used async/await, but that would require some additional polyfills\n        this._transport.ready.then(() => {\n            this._transport.createBidirectionalStream().then((stream) => {\n                const decoderStream = (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_2__.createPacketDecoderStream)(Number.MAX_SAFE_INTEGER, this.socket.binaryType);\n                const reader = stream.readable.pipeThrough(decoderStream).getReader();\n                const encoderStream = (0,engine_io_parser__WEBPACK_IMPORTED_MODULE_2__.createPacketEncoderStream)();\n                encoderStream.readable.pipeTo(stream.writable);\n                this._writer = encoderStream.writable.getWriter();\n                const read = () => {\n                    reader\n                        .read()\n                        .then(({ done, value }) => {\n                        if (done) {\n                            return;\n                        }\n                        this.onPacket(value);\n                        read();\n                    })\n                        .catch((err) => {\n                    });\n                };\n                read();\n                const packet = { type: \"open\" };\n                if (this.query.sid) {\n                    packet.data = `{\"sid\":\"${this.query.sid}\"}`;\n                }\n                this._writer.write(packet).then(() => this.onOpen());\n            });\n        });\n    }\n    write(packets) {\n        this.writable = false;\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            this._writer.write(packet).then(() => {\n                if (lastPacket) {\n                    (0,_globals_node_js__WEBPACK_IMPORTED_MODULE_1__.nextTick)(() => {\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    doClose() {\n        var _a;\n        (_a = this._transport) === null || _a === void 0 ? void 0 : _a.close();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS90cmFuc3BvcnRzL3dlYnRyYW5zcG9ydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTRDO0FBQ0U7QUFDMkM7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGlCQUFpQixvREFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDJFQUF5QjtBQUMvRDtBQUNBLHNDQUFzQywyRUFBeUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLG9DQUFvQyxTQUFTLGVBQWUsRUFBRTtBQUM5RDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBEQUFRO0FBQzVCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGVuZ2luZS5pby1jbGllbnRcXGJ1aWxkXFxlc21cXHRyYW5zcG9ydHNcXHdlYnRyYW5zcG9ydC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUcmFuc3BvcnQgfSBmcm9tIFwiLi4vdHJhbnNwb3J0LmpzXCI7XG5pbXBvcnQgeyBuZXh0VGljayB9IGZyb20gXCIuLi9nbG9iYWxzLm5vZGUuanNcIjtcbmltcG9ydCB7IGNyZWF0ZVBhY2tldERlY29kZXJTdHJlYW0sIGNyZWF0ZVBhY2tldEVuY29kZXJTdHJlYW0sIH0gZnJvbSBcImVuZ2luZS5pby1wYXJzZXJcIjtcbi8qKlxuICogV2ViVHJhbnNwb3J0IHRyYW5zcG9ydCBiYXNlZCBvbiB0aGUgYnVpbHQtaW4gYFdlYlRyYW5zcG9ydGAgb2JqZWN0LlxuICpcbiAqIFVzYWdlOiBicm93c2VyLCBOb2RlLmpzICh3aXRoIHRoZSBgQGZhaWxzLWNvbXBvbmVudHMvd2VidHJhbnNwb3J0YCBwYWNrYWdlKVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlRyYW5zcG9ydFxuICogQHNlZSBodHRwczovL2Nhbml1c2UuY29tL3dlYnRyYW5zcG9ydFxuICovXG5leHBvcnQgY2xhc3MgV1QgZXh0ZW5kcyBUcmFuc3BvcnQge1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJ3ZWJ0cmFuc3BvcnRcIjtcbiAgICB9XG4gICAgZG9PcGVuKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gbmV3IFdlYlRyYW5zcG9ydCh0aGlzLmNyZWF0ZVVyaShcImh0dHBzXCIpLCB0aGlzLm9wdHMudHJhbnNwb3J0T3B0aW9uc1t0aGlzLm5hbWVdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbWl0UmVzZXJ2ZWQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydC5jbG9zZWRcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZSgpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcIndlYnRyYW5zcG9ydCBlcnJvclwiLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gbm90ZTogd2UgY291bGQgaGF2ZSB1c2VkIGFzeW5jL2F3YWl0LCBidXQgdGhhdCB3b3VsZCByZXF1aXJlIHNvbWUgYWRkaXRpb25hbCBwb2x5ZmlsbHNcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0LnJlYWR5LnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fdHJhbnNwb3J0LmNyZWF0ZUJpZGlyZWN0aW9uYWxTdHJlYW0oKS50aGVuKChzdHJlYW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNvZGVyU3RyZWFtID0gY3JlYXRlUGFja2V0RGVjb2RlclN0cmVhbShOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLnJlYWRhYmxlLnBpcGVUaHJvdWdoKGRlY29kZXJTdHJlYW0pLmdldFJlYWRlcigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZXJTdHJlYW0gPSBjcmVhdGVQYWNrZXRFbmNvZGVyU3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgZW5jb2RlclN0cmVhbS5yZWFkYWJsZS5waXBlVG8oc3RyZWFtLndyaXRhYmxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93cml0ZXIgPSBlbmNvZGVyU3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLnJlYWQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHsgZG9uZSwgdmFsdWUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUGFja2V0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVhZCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IHsgdHlwZTogXCJvcGVuXCIgfTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5xdWVyeS5zaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFja2V0LmRhdGEgPSBge1wic2lkXCI6XCIke3RoaXMucXVlcnkuc2lkfVwifWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3dyaXRlci53cml0ZShwYWNrZXQpLnRoZW4oKCkgPT4gdGhpcy5vbk9wZW4oKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdyaXRlKHBhY2tldHMpIHtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IHBhY2tldHNbaV07XG4gICAgICAgICAgICBjb25zdCBsYXN0UGFja2V0ID0gaSA9PT0gcGFja2V0cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgdGhpcy5fd3JpdGVyLndyaXRlKHBhY2tldCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3RQYWNrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRyYWluXCIpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnNldFRpbWVvdXRGbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9DbG9zZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLl90cmFuc3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/engine.io-client/build/esm/transports/webtransport.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/engine.io-client/build/esm/util.js":
/*!*********************************************************!*\
  !*** ./node_modules/engine.io-client/build/esm/util.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   byteLength: () => (/* binding */ byteLength),\n/* harmony export */   installTimerFunctions: () => (/* binding */ installTimerFunctions),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   randomString: () => (/* binding */ randomString)\n/* harmony export */ });\n/* harmony import */ var _globals_node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals.node.js */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/globals.js\");\n\nfunction pick(obj, ...attr) {\n    return attr.reduce((acc, k) => {\n        if (obj.hasOwnProperty(k)) {\n            acc[k] = obj[k];\n        }\n        return acc;\n    }, {});\n}\n// Keep a reference to the real timeout functions so they can be used when overridden\nconst NATIVE_SET_TIMEOUT = _globals_node_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.setTimeout;\nconst NATIVE_CLEAR_TIMEOUT = _globals_node_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.clearTimeout;\nfunction installTimerFunctions(obj, opts) {\n    if (opts.useNativeTimers) {\n        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(_globals_node_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);\n        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(_globals_node_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);\n    }\n    else {\n        obj.setTimeoutFn = _globals_node_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.setTimeout.bind(_globals_node_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);\n        obj.clearTimeoutFn = _globals_node_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim.clearTimeout.bind(_globals_node_js__WEBPACK_IMPORTED_MODULE_0__.globalThisShim);\n    }\n}\n// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)\nconst BASE64_OVERHEAD = 1.33;\n// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9\nfunction byteLength(obj) {\n    if (typeof obj === \"string\") {\n        return utf8Length(obj);\n    }\n    // arraybuffer or blob\n    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);\n}\nfunction utf8Length(str) {\n    let c = 0, length = 0;\n    for (let i = 0, l = str.length; i < l; i++) {\n        c = str.charCodeAt(i);\n        if (c < 0x80) {\n            length += 1;\n        }\n        else if (c < 0x800) {\n            length += 2;\n        }\n        else if (c < 0xd800 || c >= 0xe000) {\n            length += 3;\n        }\n        else {\n            i++;\n            length += 4;\n        }\n    }\n    return length;\n}\n/**\n * Generates a random 8-characters string.\n */\nfunction randomString() {\n    return (Date.now().toString(36).substring(3) +\n        Math.random().toString(36).substring(2, 5));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2J1aWxkL2VzbS91dGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlFO0FBQzFEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQSwyQkFBMkIsNERBQVU7QUFDckMsNkJBQTZCLDREQUFVO0FBQ2hDO0FBQ1A7QUFDQSxtREFBbUQsNERBQVU7QUFDN0QsdURBQXVELDREQUFVO0FBQ2pFO0FBQ0E7QUFDQSwyQkFBMkIsNERBQVUsaUJBQWlCLDREQUFVO0FBQ2hFLDZCQUE2Qiw0REFBVSxtQkFBbUIsNERBQVU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXHNob3BfaGFyZGhhdFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcZW5naW5lLmlvLWNsaWVudFxcYnVpbGRcXGVzbVxcdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnbG9iYWxUaGlzU2hpbSBhcyBnbG9iYWxUaGlzIH0gZnJvbSBcIi4vZ2xvYmFscy5ub2RlLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gcGljayhvYmosIC4uLmF0dHIpIHtcbiAgICByZXR1cm4gYXR0ci5yZWR1Y2UoKGFjYywgaykgPT4ge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICBhY2Nba10gPSBvYmpba107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSk7XG59XG4vLyBLZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSByZWFsIHRpbWVvdXQgZnVuY3Rpb25zIHNvIHRoZXkgY2FuIGJlIHVzZWQgd2hlbiBvdmVycmlkZGVuXG5jb25zdCBOQVRJVkVfU0VUX1RJTUVPVVQgPSBnbG9iYWxUaGlzLnNldFRpbWVvdXQ7XG5jb25zdCBOQVRJVkVfQ0xFQVJfVElNRU9VVCA9IGdsb2JhbFRoaXMuY2xlYXJUaW1lb3V0O1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGxUaW1lckZ1bmN0aW9ucyhvYmosIG9wdHMpIHtcbiAgICBpZiAob3B0cy51c2VOYXRpdmVUaW1lcnMpIHtcbiAgICAgICAgb2JqLnNldFRpbWVvdXRGbiA9IE5BVElWRV9TRVRfVElNRU9VVC5iaW5kKGdsb2JhbFRoaXMpO1xuICAgICAgICBvYmouY2xlYXJUaW1lb3V0Rm4gPSBOQVRJVkVfQ0xFQVJfVElNRU9VVC5iaW5kKGdsb2JhbFRoaXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb2JqLnNldFRpbWVvdXRGbiA9IGdsb2JhbFRoaXMuc2V0VGltZW91dC5iaW5kKGdsb2JhbFRoaXMpO1xuICAgICAgICBvYmouY2xlYXJUaW1lb3V0Rm4gPSBnbG9iYWxUaGlzLmNsZWFyVGltZW91dC5iaW5kKGdsb2JhbFRoaXMpO1xuICAgIH1cbn1cbi8vIGJhc2U2NCBlbmNvZGVkIGJ1ZmZlcnMgYXJlIGFib3V0IDMzJSBiaWdnZXIgKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NClcbmNvbnN0IEJBU0U2NF9PVkVSSEVBRCA9IDEuMzM7XG4vLyB3ZSBjb3VsZCBhbHNvIGhhdmUgdXNlZCBgbmV3IEJsb2IoW29ial0pLnNpemVgLCBidXQgaXQgaXNuJ3Qgc3VwcG9ydGVkIGluIElFOVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVMZW5ndGgob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHV0ZjhMZW5ndGgob2JqKTtcbiAgICB9XG4gICAgLy8gYXJyYXlidWZmZXIgb3IgYmxvYlxuICAgIHJldHVybiBNYXRoLmNlaWwoKG9iai5ieXRlTGVuZ3RoIHx8IG9iai5zaXplKSAqIEJBU0U2NF9PVkVSSEVBRCk7XG59XG5mdW5jdGlvbiB1dGY4TGVuZ3RoKHN0cikge1xuICAgIGxldCBjID0gMCwgbGVuZ3RoID0gMDtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDB4ODApIHtcbiAgICAgICAgICAgIGxlbmd0aCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgbGVuZ3RoICs9IDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYyA8IDB4ZDgwMCB8fCBjID49IDB4ZTAwMCkge1xuICAgICAgICAgICAgbGVuZ3RoICs9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBsZW5ndGggKz0gNDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGVuZ3RoO1xufVxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gOC1jaGFyYWN0ZXJzIHN0cmluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbVN0cmluZygpIHtcbiAgICByZXR1cm4gKERhdGUubm93KCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygzKSArXG4gICAgICAgIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA1KSk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/engine.io-client/build/esm/util.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/commons.js":
/*!************************************************************!*\
  !*** ./node_modules/engine.io-parser/build/esm/commons.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ERROR_PACKET: () => (/* binding */ ERROR_PACKET),\n/* harmony export */   PACKET_TYPES: () => (/* binding */ PACKET_TYPES),\n/* harmony export */   PACKET_TYPES_REVERSE: () => (/* binding */ PACKET_TYPES_REVERSE)\n/* harmony export */ });\nconst PACKET_TYPES = Object.create(null); // no Map = no polyfill\nPACKET_TYPES[\"open\"] = \"0\";\nPACKET_TYPES[\"close\"] = \"1\";\nPACKET_TYPES[\"ping\"] = \"2\";\nPACKET_TYPES[\"pong\"] = \"3\";\nPACKET_TYPES[\"message\"] = \"4\";\nPACKET_TYPES[\"upgrade\"] = \"5\";\nPACKET_TYPES[\"noop\"] = \"6\";\nconst PACKET_TYPES_REVERSE = Object.create(null);\nObject.keys(PACKET_TYPES).forEach((key) => {\n    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n});\nconst ERROR_PACKET = { type: \"error\", data: \"parser error\" };\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2J1aWxkL2VzbS9jb21tb25zLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx1QkFBdUI7QUFDcUMiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGVuZ2luZS5pby1wYXJzZXJcXGJ1aWxkXFxlc21cXGNvbW1vbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUEFDS0VUX1RZUEVTID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgLy8gbm8gTWFwID0gbm8gcG9seWZpbGxcblBBQ0tFVF9UWVBFU1tcIm9wZW5cIl0gPSBcIjBcIjtcblBBQ0tFVF9UWVBFU1tcImNsb3NlXCJdID0gXCIxXCI7XG5QQUNLRVRfVFlQRVNbXCJwaW5nXCJdID0gXCIyXCI7XG5QQUNLRVRfVFlQRVNbXCJwb25nXCJdID0gXCIzXCI7XG5QQUNLRVRfVFlQRVNbXCJtZXNzYWdlXCJdID0gXCI0XCI7XG5QQUNLRVRfVFlQRVNbXCJ1cGdyYWRlXCJdID0gXCI1XCI7XG5QQUNLRVRfVFlQRVNbXCJub29wXCJdID0gXCI2XCI7XG5jb25zdCBQQUNLRVRfVFlQRVNfUkVWRVJTRSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5PYmplY3Qua2V5cyhQQUNLRVRfVFlQRVMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIFBBQ0tFVF9UWVBFU19SRVZFUlNFW1BBQ0tFVF9UWVBFU1trZXldXSA9IGtleTtcbn0pO1xuY29uc3QgRVJST1JfUEFDS0VUID0geyB0eXBlOiBcImVycm9yXCIsIGRhdGE6IFwicGFyc2VyIGVycm9yXCIgfTtcbmV4cG9ydCB7IFBBQ0tFVF9UWVBFUywgUEFDS0VUX1RZUEVTX1JFVkVSU0UsIEVSUk9SX1BBQ0tFVCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/commons.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   encode: () => (/* binding */ encode)\n/* harmony export */ });\n// imported from https://github.com/socketio/base64-arraybuffer\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nconst lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (let i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nconst encode = (arraybuffer) => {\n    let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nconst decode = (base64) => {\n    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2J1aWxkL2VzbS9jb250cmliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ087QUFDUDtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGVuZ2luZS5pby1wYXJzZXJcXGJ1aWxkXFxlc21cXGNvbnRyaWJcXGJhc2U2NC1hcnJheWJ1ZmZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NrZXRpby9iYXNlNjQtYXJyYXlidWZmZXJcbmNvbnN0IGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuLy8gVXNlIGEgbG9va3VwIHRhYmxlIHRvIGZpbmQgdGhlIGluZGV4LlxuY29uc3QgbG9va3VwID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gW10gOiBuZXcgVWludDhBcnJheSgyNTYpO1xuZm9yIChsZXQgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGg7IGkrKykge1xuICAgIGxvb2t1cFtjaGFycy5jaGFyQ29kZUF0KGkpXSA9IGk7XG59XG5leHBvcnQgY29uc3QgZW5jb2RlID0gKGFycmF5YnVmZmVyKSA9PiB7XG4gICAgbGV0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLCBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9ICcnO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuICAgIGlmIChsZW4gJSAzID09PSAyKSB7XG4gICAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgJz0nO1xuICAgIH1cbiAgICBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgJz09JztcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U2NDtcbn07XG5leHBvcnQgY29uc3QgZGVjb2RlID0gKGJhc2U2NCkgPT4ge1xuICAgIGxldCBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSwgbGVuID0gYmFzZTY0Lmxlbmd0aCwgaSwgcCA9IDAsIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSAnPScpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSAnPScpIHtcbiAgICAgICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgICAgICBlbmNvZGVkMSA9IGxvb2t1cFtiYXNlNjQuY2hhckNvZGVBdChpKV07XG4gICAgICAgIGVuY29kZWQyID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAxKV07XG4gICAgICAgIGVuY29kZWQzID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAyKV07XG4gICAgICAgIGVuY29kZWQ0ID0gbG9va3VwW2Jhc2U2NC5jaGFyQ29kZUF0KGkgKyAzKV07XG4gICAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDEgPDwgMikgfCAoZW5jb2RlZDIgPj4gNCk7XG4gICAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMyAmIDMpIDw8IDYpIHwgKGVuY29kZWQ0ICYgNjMpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/decodePacket.browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/engine.io-parser/build/esm/decodePacket.browser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodePacket: () => (/* binding */ decodePacket)\n/* harmony export */ });\n/* harmony import */ var _commons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commons.js */ \"(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/commons.js\");\n/* harmony import */ var _contrib_base64_arraybuffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contrib/base64-arraybuffer.js */ \"(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js\");\n\n\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst decodePacket = (encodedPacket, binaryType) => {\n    if (typeof encodedPacket !== \"string\") {\n        return {\n            type: \"message\",\n            data: mapBinary(encodedPacket, binaryType),\n        };\n    }\n    const type = encodedPacket.charAt(0);\n    if (type === \"b\") {\n        return {\n            type: \"message\",\n            data: decodeBase64Packet(encodedPacket.substring(1), binaryType),\n        };\n    }\n    const packetType = _commons_js__WEBPACK_IMPORTED_MODULE_0__.PACKET_TYPES_REVERSE[type];\n    if (!packetType) {\n        return _commons_js__WEBPACK_IMPORTED_MODULE_0__.ERROR_PACKET;\n    }\n    return encodedPacket.length > 1\n        ? {\n            type: _commons_js__WEBPACK_IMPORTED_MODULE_0__.PACKET_TYPES_REVERSE[type],\n            data: encodedPacket.substring(1),\n        }\n        : {\n            type: _commons_js__WEBPACK_IMPORTED_MODULE_0__.PACKET_TYPES_REVERSE[type],\n        };\n};\nconst decodeBase64Packet = (data, binaryType) => {\n    if (withNativeArrayBuffer) {\n        const decoded = (0,_contrib_base64_arraybuffer_js__WEBPACK_IMPORTED_MODULE_1__.decode)(data);\n        return mapBinary(decoded, binaryType);\n    }\n    else {\n        return { base64: true, data }; // fallback for old browsers\n    }\n};\nconst mapBinary = (data, binaryType) => {\n    switch (binaryType) {\n        case \"blob\":\n            if (data instanceof Blob) {\n                // from WebSocket + binaryType \"blob\"\n                return data;\n            }\n            else {\n                // from HTTP long-polling or WebTransport\n                return new Blob([data]);\n            }\n        case \"arraybuffer\":\n        default:\n            if (data instanceof ArrayBuffer) {\n                // from HTTP long-polling (base64) or WebSocket + binaryType \"arraybuffer\"\n                return data;\n            }\n            else {\n                // from WebTransport (Uint8Array)\n                return data.buffer;\n            }\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2J1aWxkL2VzbS9kZWNvZGVQYWNrZXQuYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBbUU7QUFDVjtBQUN6RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkRBQW9CO0FBQzNDO0FBQ0EsZUFBZSxxREFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNkRBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw2REFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0VBQU07QUFDOUI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXHNob3BfaGFyZGhhdFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcZW5naW5lLmlvLXBhcnNlclxcYnVpbGRcXGVzbVxcZGVjb2RlUGFja2V0LmJyb3dzZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRVJST1JfUEFDS0VULCBQQUNLRVRfVFlQRVNfUkVWRVJTRSwgfSBmcm9tIFwiLi9jb21tb25zLmpzXCI7XG5pbXBvcnQgeyBkZWNvZGUgfSBmcm9tIFwiLi9jb250cmliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qc1wiO1xuY29uc3Qgd2l0aE5hdGl2ZUFycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCI7XG5leHBvcnQgY29uc3QgZGVjb2RlUGFja2V0ID0gKGVuY29kZWRQYWNrZXQsIGJpbmFyeVR5cGUpID0+IHtcbiAgICBpZiAodHlwZW9mIGVuY29kZWRQYWNrZXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgZGF0YTogbWFwQmluYXJ5KGVuY29kZWRQYWNrZXQsIGJpbmFyeVR5cGUpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gZW5jb2RlZFBhY2tldC5jaGFyQXQoMCk7XG4gICAgaWYgKHR5cGUgPT09IFwiYlwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIm1lc3NhZ2VcIixcbiAgICAgICAgICAgIGRhdGE6IGRlY29kZUJhc2U2NFBhY2tldChlbmNvZGVkUGFja2V0LnN1YnN0cmluZygxKSwgYmluYXJ5VHlwZSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHBhY2tldFR5cGUgPSBQQUNLRVRfVFlQRVNfUkVWRVJTRVt0eXBlXTtcbiAgICBpZiAoIXBhY2tldFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIEVSUk9SX1BBQ0tFVDtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZWRQYWNrZXQubGVuZ3RoID4gMVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIHR5cGU6IFBBQ0tFVF9UWVBFU19SRVZFUlNFW3R5cGVdLFxuICAgICAgICAgICAgZGF0YTogZW5jb2RlZFBhY2tldC5zdWJzdHJpbmcoMSksXG4gICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICB0eXBlOiBQQUNLRVRfVFlQRVNfUkVWRVJTRVt0eXBlXSxcbiAgICAgICAgfTtcbn07XG5jb25zdCBkZWNvZGVCYXNlNjRQYWNrZXQgPSAoZGF0YSwgYmluYXJ5VHlwZSkgPT4ge1xuICAgIGlmICh3aXRoTmF0aXZlQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZShkYXRhKTtcbiAgICAgICAgcmV0dXJuIG1hcEJpbmFyeShkZWNvZGVkLCBiaW5hcnlUeXBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IGJhc2U2NDogdHJ1ZSwgZGF0YSB9OyAvLyBmYWxsYmFjayBmb3Igb2xkIGJyb3dzZXJzXG4gICAgfVxufTtcbmNvbnN0IG1hcEJpbmFyeSA9IChkYXRhLCBiaW5hcnlUeXBlKSA9PiB7XG4gICAgc3dpdGNoIChiaW5hcnlUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJibG9iXCI6XG4gICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgICAgICAgICAvLyBmcm9tIFdlYlNvY2tldCArIGJpbmFyeVR5cGUgXCJibG9iXCJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGZyb20gSFRUUCBsb25nLXBvbGxpbmcgb3IgV2ViVHJhbnNwb3J0XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCbG9iKFtkYXRhXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJhcnJheWJ1ZmZlclwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIC8vIGZyb20gSFRUUCBsb25nLXBvbGxpbmcgKGJhc2U2NCkgb3IgV2ViU29ja2V0ICsgYmluYXJ5VHlwZSBcImFycmF5YnVmZmVyXCJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGZyb20gV2ViVHJhbnNwb3J0IChVaW50OEFycmF5KVxuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICAgICAgICAgIH1cbiAgICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/decodePacket.browser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/encodePacket.browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/engine.io-parser/build/esm/encodePacket.browser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodePacket: () => (/* binding */ encodePacket),\n/* harmony export */   encodePacketToBinary: () => (/* binding */ encodePacketToBinary)\n/* harmony export */ });\n/* harmony import */ var _commons_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./commons.js */ \"(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/commons.js\");\n\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n// ArrayBuffer.isView method is not defined in IE10\nconst isView = (obj) => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj && obj.buffer instanceof ArrayBuffer;\n};\nconst encodePacket = ({ type, data }, supportsBinary, callback) => {\n    if (withNativeBlob && data instanceof Blob) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(data, callback);\n        }\n    }\n    else if (withNativeArrayBuffer &&\n        (data instanceof ArrayBuffer || isView(data))) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(new Blob([data]), callback);\n        }\n    }\n    // plain string\n    return callback(_commons_js__WEBPACK_IMPORTED_MODULE_0__.PACKET_TYPES[type] + (data || \"\"));\n};\nconst encodeBlobAsBase64 = (data, callback) => {\n    const fileReader = new FileReader();\n    fileReader.onload = function () {\n        const content = fileReader.result.split(\",\")[1];\n        callback(\"b\" + (content || \"\"));\n    };\n    return fileReader.readAsDataURL(data);\n};\nfunction toArray(data) {\n    if (data instanceof Uint8Array) {\n        return data;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return new Uint8Array(data);\n    }\n    else {\n        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    }\n}\nlet TEXT_ENCODER;\nfunction encodePacketToBinary(packet, callback) {\n    if (withNativeBlob && packet.data instanceof Blob) {\n        return packet.data.arrayBuffer().then(toArray).then(callback);\n    }\n    else if (withNativeArrayBuffer &&\n        (packet.data instanceof ArrayBuffer || isView(packet.data))) {\n        return callback(toArray(packet.data));\n    }\n    encodePacket(packet, false, (encoded) => {\n        if (!TEXT_ENCODER) {\n            TEXT_ENCODER = new TextEncoder();\n        }\n        callback(TEXT_ENCODER.encode(encoded));\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2J1aWxkL2VzbS9lbmNvZGVQYWNrZXQuYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscURBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDd0IiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXGVuZ2luZS5pby1wYXJzZXJcXGJ1aWxkXFxlc21cXGVuY29kZVBhY2tldC5icm93c2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBBQ0tFVF9UWVBFUyB9IGZyb20gXCIuL2NvbW1vbnMuanNcIjtcbmNvbnN0IHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICh0eXBlb2YgQmxvYiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoQmxvYikgPT09IFwiW29iamVjdCBCbG9iQ29uc3RydWN0b3JdXCIpO1xuY29uc3Qgd2l0aE5hdGl2ZUFycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCI7XG4vLyBBcnJheUJ1ZmZlci5pc1ZpZXcgbWV0aG9kIGlzIG5vdCBkZWZpbmVkIGluIElFMTBcbmNvbnN0IGlzVmlldyA9IChvYmopID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gQXJyYXlCdWZmZXIuaXNWaWV3KG9iailcbiAgICAgICAgOiBvYmogJiYgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufTtcbmNvbnN0IGVuY29kZVBhY2tldCA9ICh7IHR5cGUsIGRhdGEgfSwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSA9PiB7XG4gICAgaWYgKHdpdGhOYXRpdmVCbG9iICYmIGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGlmIChzdXBwb3J0c0JpbmFyeSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZUJsb2JBc0Jhc2U2NChkYXRhLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAod2l0aE5hdGl2ZUFycmF5QnVmZmVyICYmXG4gICAgICAgIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgaXNWaWV3KGRhdGEpKSkge1xuICAgICAgICBpZiAoc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVCbG9iQXNCYXNlNjQobmV3IEJsb2IoW2RhdGFdKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHBsYWluIHN0cmluZ1xuICAgIHJldHVybiBjYWxsYmFjayhQQUNLRVRfVFlQRVNbdHlwZV0gKyAoZGF0YSB8fCBcIlwiKSk7XG59O1xuY29uc3QgZW5jb2RlQmxvYkFzQmFzZTY0ID0gKGRhdGEsIGNhbGxiYWNrKSA9PiB7XG4gICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBmaWxlUmVhZGVyLnJlc3VsdC5zcGxpdChcIixcIilbMV07XG4gICAgICAgIGNhbGxiYWNrKFwiYlwiICsgKGNvbnRlbnQgfHwgXCJcIikpO1xuICAgIH07XG4gICAgcmV0dXJuIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChkYXRhKTtcbn07XG5mdW5jdGlvbiB0b0FycmF5KGRhdGEpIHtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICB9XG59XG5sZXQgVEVYVF9FTkNPREVSO1xuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZVBhY2tldFRvQmluYXJ5KHBhY2tldCwgY2FsbGJhY2spIHtcbiAgICBpZiAod2l0aE5hdGl2ZUJsb2IgJiYgcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIHJldHVybiBwYWNrZXQuZGF0YS5hcnJheUJ1ZmZlcigpLnRoZW4odG9BcnJheSkudGhlbihjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHdpdGhOYXRpdmVBcnJheUJ1ZmZlciAmJlxuICAgICAgICAocGFja2V0LmRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBpc1ZpZXcocGFja2V0LmRhdGEpKSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sodG9BcnJheShwYWNrZXQuZGF0YSkpO1xuICAgIH1cbiAgICBlbmNvZGVQYWNrZXQocGFja2V0LCBmYWxzZSwgKGVuY29kZWQpID0+IHtcbiAgICAgICAgaWYgKCFURVhUX0VOQ09ERVIpIHtcbiAgICAgICAgICAgIFRFWFRfRU5DT0RFUiA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKFRFWFRfRU5DT0RFUi5lbmNvZGUoZW5jb2RlZCkpO1xuICAgIH0pO1xufVxuZXhwb3J0IHsgZW5jb2RlUGFja2V0IH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/encodePacket.browser.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/engine.io-parser/build/esm/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPacketDecoderStream: () => (/* binding */ createPacketDecoderStream),\n/* harmony export */   createPacketEncoderStream: () => (/* binding */ createPacketEncoderStream),\n/* harmony export */   decodePacket: () => (/* reexport safe */ _decodePacket_js__WEBPACK_IMPORTED_MODULE_1__.decodePacket),\n/* harmony export */   decodePayload: () => (/* binding */ decodePayload),\n/* harmony export */   encodePacket: () => (/* reexport safe */ _encodePacket_js__WEBPACK_IMPORTED_MODULE_0__.encodePacket),\n/* harmony export */   encodePayload: () => (/* binding */ encodePayload),\n/* harmony export */   protocol: () => (/* binding */ protocol)\n/* harmony export */ });\n/* harmony import */ var _encodePacket_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encodePacket.js */ \"(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/encodePacket.browser.js\");\n/* harmony import */ var _decodePacket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./decodePacket.js */ \"(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/decodePacket.browser.js\");\n/* harmony import */ var _commons_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./commons.js */ \"(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/commons.js\");\n\n\n\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nconst encodePayload = (packets, callback) => {\n    // some packets may be added to the array while encoding, so the initial length must be saved\n    const length = packets.length;\n    const encodedPackets = new Array(length);\n    let count = 0;\n    packets.forEach((packet, i) => {\n        // force base64 encoding for binary packets\n        (0,_encodePacket_js__WEBPACK_IMPORTED_MODULE_0__.encodePacket)(packet, false, (encodedPacket) => {\n            encodedPackets[i] = encodedPacket;\n            if (++count === length) {\n                callback(encodedPackets.join(SEPARATOR));\n            }\n        });\n    });\n};\nconst decodePayload = (encodedPayload, binaryType) => {\n    const encodedPackets = encodedPayload.split(SEPARATOR);\n    const packets = [];\n    for (let i = 0; i < encodedPackets.length; i++) {\n        const decodedPacket = (0,_decodePacket_js__WEBPACK_IMPORTED_MODULE_1__.decodePacket)(encodedPackets[i], binaryType);\n        packets.push(decodedPacket);\n        if (decodedPacket.type === \"error\") {\n            break;\n        }\n    }\n    return packets;\n};\nfunction createPacketEncoderStream() {\n    return new TransformStream({\n        transform(packet, controller) {\n            (0,_encodePacket_js__WEBPACK_IMPORTED_MODULE_0__.encodePacketToBinary)(packet, (encodedPacket) => {\n                const payloadLength = encodedPacket.length;\n                let header;\n                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length\n                if (payloadLength < 126) {\n                    header = new Uint8Array(1);\n                    new DataView(header.buffer).setUint8(0, payloadLength);\n                }\n                else if (payloadLength < 65536) {\n                    header = new Uint8Array(3);\n                    const view = new DataView(header.buffer);\n                    view.setUint8(0, 126);\n                    view.setUint16(1, payloadLength);\n                }\n                else {\n                    header = new Uint8Array(9);\n                    const view = new DataView(header.buffer);\n                    view.setUint8(0, 127);\n                    view.setBigUint64(1, BigInt(payloadLength));\n                }\n                // first bit indicates whether the payload is plain text (0) or binary (1)\n                if (packet.data && typeof packet.data !== \"string\") {\n                    header[0] |= 0x80;\n                }\n                controller.enqueue(header);\n                controller.enqueue(encodedPacket);\n            });\n        },\n    });\n}\nlet TEXT_DECODER;\nfunction totalLength(chunks) {\n    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);\n}\nfunction concatChunks(chunks, size) {\n    if (chunks[0].length === size) {\n        return chunks.shift();\n    }\n    const buffer = new Uint8Array(size);\n    let j = 0;\n    for (let i = 0; i < size; i++) {\n        buffer[i] = chunks[0][j++];\n        if (j === chunks[0].length) {\n            chunks.shift();\n            j = 0;\n        }\n    }\n    if (chunks.length && j < chunks[0].length) {\n        chunks[0] = chunks[0].slice(j);\n    }\n    return buffer;\n}\nfunction createPacketDecoderStream(maxPayload, binaryType) {\n    if (!TEXT_DECODER) {\n        TEXT_DECODER = new TextDecoder();\n    }\n    const chunks = [];\n    let state = 0 /* State.READ_HEADER */;\n    let expectedLength = -1;\n    let isBinary = false;\n    return new TransformStream({\n        transform(chunk, controller) {\n            chunks.push(chunk);\n            while (true) {\n                if (state === 0 /* State.READ_HEADER */) {\n                    if (totalLength(chunks) < 1) {\n                        break;\n                    }\n                    const header = concatChunks(chunks, 1);\n                    isBinary = (header[0] & 0x80) === 0x80;\n                    expectedLength = header[0] & 0x7f;\n                    if (expectedLength < 126) {\n                        state = 3 /* State.READ_PAYLOAD */;\n                    }\n                    else if (expectedLength === 126) {\n                        state = 1 /* State.READ_EXTENDED_LENGTH_16 */;\n                    }\n                    else {\n                        state = 2 /* State.READ_EXTENDED_LENGTH_64 */;\n                    }\n                }\n                else if (state === 1 /* State.READ_EXTENDED_LENGTH_16 */) {\n                    if (totalLength(chunks) < 2) {\n                        break;\n                    }\n                    const headerArray = concatChunks(chunks, 2);\n                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);\n                    state = 3 /* State.READ_PAYLOAD */;\n                }\n                else if (state === 2 /* State.READ_EXTENDED_LENGTH_64 */) {\n                    if (totalLength(chunks) < 8) {\n                        break;\n                    }\n                    const headerArray = concatChunks(chunks, 8);\n                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);\n                    const n = view.getUint32(0);\n                    if (n > Math.pow(2, 53 - 32) - 1) {\n                        // the maximum safe integer in JavaScript is 2^53 - 1\n                        controller.enqueue(_commons_js__WEBPACK_IMPORTED_MODULE_2__.ERROR_PACKET);\n                        break;\n                    }\n                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);\n                    state = 3 /* State.READ_PAYLOAD */;\n                }\n                else {\n                    if (totalLength(chunks) < expectedLength) {\n                        break;\n                    }\n                    const data = concatChunks(chunks, expectedLength);\n                    controller.enqueue((0,_decodePacket_js__WEBPACK_IMPORTED_MODULE_1__.decodePacket)(isBinary ? data : TEXT_DECODER.decode(data), binaryType));\n                    state = 0 /* State.READ_HEADER */;\n                }\n                if (expectedLength === 0 || expectedLength > maxPayload) {\n                    controller.enqueue(_commons_js__WEBPACK_IMPORTED_MODULE_2__.ERROR_PACKET);\n                    break;\n                }\n            }\n        },\n    });\n}\nconst protocol = 4;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2J1aWxkL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXVFO0FBQ3RCO0FBQ0o7QUFDN0MsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4REFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DLDhCQUE4Qiw4REFBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLFlBQVksc0VBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxxREFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw4REFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMscURBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNPO0FBQzhEIiwic291cmNlcyI6WyJDOlxcc2hvcF9oYXJkaGF0XFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxlbmdpbmUuaW8tcGFyc2VyXFxidWlsZFxcZXNtXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlbmNvZGVQYWNrZXQsIGVuY29kZVBhY2tldFRvQmluYXJ5IH0gZnJvbSBcIi4vZW5jb2RlUGFja2V0LmpzXCI7XG5pbXBvcnQgeyBkZWNvZGVQYWNrZXQgfSBmcm9tIFwiLi9kZWNvZGVQYWNrZXQuanNcIjtcbmltcG9ydCB7IEVSUk9SX1BBQ0tFVCwgfSBmcm9tIFwiLi9jb21tb25zLmpzXCI7XG5jb25zdCBTRVBBUkFUT1IgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMwKTsgLy8gc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RlbGltaXRlciNBU0NJSV9kZWxpbWl0ZWRfdGV4dFxuY29uc3QgZW5jb2RlUGF5bG9hZCA9IChwYWNrZXRzLCBjYWxsYmFjaykgPT4ge1xuICAgIC8vIHNvbWUgcGFja2V0cyBtYXkgYmUgYWRkZWQgdG8gdGhlIGFycmF5IHdoaWxlIGVuY29kaW5nLCBzbyB0aGUgaW5pdGlhbCBsZW5ndGggbXVzdCBiZSBzYXZlZFxuICAgIGNvbnN0IGxlbmd0aCA9IHBhY2tldHMubGVuZ3RoO1xuICAgIGNvbnN0IGVuY29kZWRQYWNrZXRzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBwYWNrZXRzLmZvckVhY2goKHBhY2tldCwgaSkgPT4ge1xuICAgICAgICAvLyBmb3JjZSBiYXNlNjQgZW5jb2RpbmcgZm9yIGJpbmFyeSBwYWNrZXRzXG4gICAgICAgIGVuY29kZVBhY2tldChwYWNrZXQsIGZhbHNlLCAoZW5jb2RlZFBhY2tldCkgPT4ge1xuICAgICAgICAgICAgZW5jb2RlZFBhY2tldHNbaV0gPSBlbmNvZGVkUGFja2V0O1xuICAgICAgICAgICAgaWYgKCsrY291bnQgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVuY29kZWRQYWNrZXRzLmpvaW4oU0VQQVJBVE9SKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmNvbnN0IGRlY29kZVBheWxvYWQgPSAoZW5jb2RlZFBheWxvYWQsIGJpbmFyeVR5cGUpID0+IHtcbiAgICBjb25zdCBlbmNvZGVkUGFja2V0cyA9IGVuY29kZWRQYXlsb2FkLnNwbGl0KFNFUEFSQVRPUik7XG4gICAgY29uc3QgcGFja2V0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZFBhY2tldCA9IGRlY29kZVBhY2tldChlbmNvZGVkUGFja2V0c1tpXSwgYmluYXJ5VHlwZSk7XG4gICAgICAgIHBhY2tldHMucHVzaChkZWNvZGVkUGFja2V0KTtcbiAgICAgICAgaWYgKGRlY29kZWRQYWNrZXQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFja2V0cztcbn07XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUGFja2V0RW5jb2RlclN0cmVhbSgpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIHRyYW5zZm9ybShwYWNrZXQsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGVuY29kZVBhY2tldFRvQmluYXJ5KHBhY2tldCwgKGVuY29kZWRQYWNrZXQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkTGVuZ3RoID0gZW5jb2RlZFBhY2tldC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgbGV0IGhlYWRlcjtcbiAgICAgICAgICAgICAgICAvLyBpbnNwaXJlZCBieSB0aGUgV2ViU29ja2V0IGZvcm1hdDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlNvY2tldHNfQVBJL1dyaXRpbmdfV2ViU29ja2V0X3NlcnZlcnMjZGVjb2RpbmdfcGF5bG9hZF9sZW5ndGhcbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZExlbmd0aCA8IDEyNikge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3IERhdGFWaWV3KGhlYWRlci5idWZmZXIpLnNldFVpbnQ4KDAsIHBheWxvYWRMZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoIDwgNjU1MzYpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyID0gbmV3IFVpbnQ4QXJyYXkoMyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoaGVhZGVyLmJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgoMCwgMTI2KTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5zZXRVaW50MTYoMSwgcGF5bG9hZExlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXIgPSBuZXcgVWludDhBcnJheSg5KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhoZWFkZXIuYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5zZXRVaW50OCgwLCAxMjcpO1xuICAgICAgICAgICAgICAgICAgICB2aWV3LnNldEJpZ1VpbnQ2NCgxLCBCaWdJbnQocGF5bG9hZExlbmd0aCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmaXJzdCBiaXQgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHBheWxvYWQgaXMgcGxhaW4gdGV4dCAoMCkgb3IgYmluYXJ5ICgxKVxuICAgICAgICAgICAgICAgIGlmIChwYWNrZXQuZGF0YSAmJiB0eXBlb2YgcGFja2V0LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyWzBdIHw9IDB4ODA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShoZWFkZXIpO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkUGFja2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxubGV0IFRFWFRfREVDT0RFUjtcbmZ1bmN0aW9uIHRvdGFsTGVuZ3RoKGNodW5rcykge1xuICAgIHJldHVybiBjaHVua3MucmVkdWNlKChhY2MsIGNodW5rKSA9PiBhY2MgKyBjaHVuay5sZW5ndGgsIDApO1xufVxuZnVuY3Rpb24gY29uY2F0Q2h1bmtzKGNodW5rcywgc2l6ZSkge1xuICAgIGlmIChjaHVua3NbMF0ubGVuZ3RoID09PSBzaXplKSB7XG4gICAgICAgIHJldHVybiBjaHVua3Muc2hpZnQoKTtcbiAgICB9XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgbGV0IGogPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IGNodW5rc1swXVtqKytdO1xuICAgICAgICBpZiAoaiA9PT0gY2h1bmtzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgY2h1bmtzLnNoaWZ0KCk7XG4gICAgICAgICAgICBqID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2h1bmtzLmxlbmd0aCAmJiBqIDwgY2h1bmtzWzBdLmxlbmd0aCkge1xuICAgICAgICBjaHVua3NbMF0gPSBjaHVua3NbMF0uc2xpY2Uoaik7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUGFja2V0RGVjb2RlclN0cmVhbShtYXhQYXlsb2FkLCBiaW5hcnlUeXBlKSB7XG4gICAgaWYgKCFURVhUX0RFQ09ERVIpIHtcbiAgICAgICAgVEVYVF9ERUNPREVSID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIGxldCBzdGF0ZSA9IDAgLyogU3RhdGUuUkVBRF9IRUFERVIgKi87XG4gICAgbGV0IGV4cGVjdGVkTGVuZ3RoID0gLTE7XG4gICAgbGV0IGlzQmluYXJ5ID0gZmFsc2U7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAwIC8qIFN0YXRlLlJFQURfSEVBREVSICovKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbExlbmd0aChjaHVua3MpIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gY29uY2F0Q2h1bmtzKGNodW5rcywgMSk7XG4gICAgICAgICAgICAgICAgICAgIGlzQmluYXJ5ID0gKGhlYWRlclswXSAmIDB4ODApID09PSAweDgwO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZExlbmd0aCA9IGhlYWRlclswXSAmIDB4N2Y7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBlY3RlZExlbmd0aCA8IDEyNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAzIC8qIFN0YXRlLlJFQURfUEFZTE9BRCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChleHBlY3RlZExlbmd0aCA9PT0gMTI2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDEgLyogU3RhdGUuUkVBRF9FWFRFTkRFRF9MRU5HVEhfMTYgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDIgLyogU3RhdGUuUkVBRF9FWFRFTkRFRF9MRU5HVEhfNjQgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09IDEgLyogU3RhdGUuUkVBRF9FWFRFTkRFRF9MRU5HVEhfMTYgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvdGFsTGVuZ3RoKGNodW5rcykgPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJBcnJheSA9IGNvbmNhdENodW5rcyhjaHVua3MsIDIpO1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZExlbmd0aCA9IG5ldyBEYXRhVmlldyhoZWFkZXJBcnJheS5idWZmZXIsIGhlYWRlckFycmF5LmJ5dGVPZmZzZXQsIGhlYWRlckFycmF5Lmxlbmd0aCkuZ2V0VWludDE2KDApO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDMgLyogU3RhdGUuUkVBRF9QQVlMT0FEICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gMiAvKiBTdGF0ZS5SRUFEX0VYVEVOREVEX0xFTkdUSF82NCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG90YWxMZW5ndGgoY2h1bmtzKSA8IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlckFycmF5ID0gY29uY2F0Q2h1bmtzKGNodW5rcywgOCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoaGVhZGVyQXJyYXkuYnVmZmVyLCBoZWFkZXJBcnJheS5ieXRlT2Zmc2V0LCBoZWFkZXJBcnJheS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuID0gdmlldy5nZXRVaW50MzIoMCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuID4gTWF0aC5wb3coMiwgNTMgLSAzMikgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbWF4aW11bSBzYWZlIGludGVnZXIgaW4gSmF2YVNjcmlwdCBpcyAyXjUzIC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKEVSUk9SX1BBQ0tFVCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZExlbmd0aCA9IG4gKiBNYXRoLnBvdygyLCAzMikgKyB2aWV3LmdldFVpbnQzMig0KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAzIC8qIFN0YXRlLlJFQURfUEFZTE9BRCAqLztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3RhbExlbmd0aChjaHVua3MpIDwgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBjb25jYXRDaHVua3MoY2h1bmtzLCBleHBlY3RlZExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShkZWNvZGVQYWNrZXQoaXNCaW5hcnkgPyBkYXRhIDogVEVYVF9ERUNPREVSLmRlY29kZShkYXRhKSwgYmluYXJ5VHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDAgLyogU3RhdGUuUkVBRF9IRUFERVIgKi87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChleHBlY3RlZExlbmd0aCA9PT0gMCB8fCBleHBlY3RlZExlbmd0aCA+IG1heFBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKEVSUk9SX1BBQ0tFVCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBwcm90b2NvbCA9IDQ7XG5leHBvcnQgeyBlbmNvZGVQYWNrZXQsIGVuY29kZVBheWxvYWQsIGRlY29kZVBhY2tldCwgZGVjb2RlUGF5bG9hZCwgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/engine.io-parser/build/esm/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/eventemitter2/lib/eventemitter2.js":
/*!*********************************************************!*\
  !*** ./node_modules/eventemitter2/lib/eventemitter2.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/process/browser.js\");\nvar __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * EventEmitter2\n * https://github.com/hij1nx/EventEmitter2\n *\n * Copyright (c) 2013 hij1nx\n * Licensed under the MIT license.\n */\n;!function(undefined) {\n  var hasOwnProperty= Object.hasOwnProperty;\n  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n  var defaultMaxListeners = 10;\n  var nextTickSupported= typeof process=='object' && typeof process.nextTick=='function';\n  var symbolsSupported= typeof Symbol==='function';\n  var reflectSupported= typeof Reflect === 'object';\n  var setImmediateSupported= typeof setImmediate === 'function';\n  var _setImmediate= setImmediateSupported ? setImmediate : setTimeout;\n  var ownKeys= symbolsSupported? (reflectSupported && typeof Reflect.ownKeys==='function'? Reflect.ownKeys : function(obj){\n    var arr= Object.getOwnPropertyNames(obj);\n    arr.push.apply(arr, Object.getOwnPropertySymbols(obj));\n    return arr;\n  }) : Object.keys;\n\n  function init() {\n    this._events = {};\n    if (this._conf) {\n      configure.call(this, this._conf);\n    }\n  }\n\n  function configure(conf) {\n    if (conf) {\n      this._conf = conf;\n\n      conf.delimiter && (this.delimiter = conf.delimiter);\n\n      if(conf.maxListeners!==undefined){\n          this._maxListeners= conf.maxListeners;\n      }\n\n      conf.wildcard && (this.wildcard = conf.wildcard);\n      conf.newListener && (this._newListener = conf.newListener);\n      conf.removeListener && (this._removeListener = conf.removeListener);\n      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);\n      conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);\n\n      if (this.wildcard) {\n        this.listenerTree = {};\n      }\n    }\n  }\n\n  function logPossibleMemoryLeak(count, eventName) {\n    var errorMsg = '(node) warning: possible EventEmitter memory ' +\n        'leak detected. ' + count + ' listeners added. ' +\n        'Use emitter.setMaxListeners() to increase limit.';\n\n    if(this.verboseMemoryLeak){\n      errorMsg += ' Event name: ' + eventName + '.';\n    }\n\n    if(typeof process !== 'undefined' && process.emitWarning){\n      var e = new Error(errorMsg);\n      e.name = 'MaxListenersExceededWarning';\n      e.emitter = this;\n      e.count = count;\n      process.emitWarning(e);\n    } else {\n      console.error(errorMsg);\n\n      if (console.trace){\n        console.trace();\n      }\n    }\n  }\n\n  var toArray = function (a, b, c) {\n    var n = arguments.length;\n    switch (n) {\n      case 0:\n        return [];\n      case 1:\n        return [a];\n      case 2:\n        return [a, b];\n      case 3:\n        return [a, b, c];\n      default:\n        var arr = new Array(n);\n        while (n--) {\n          arr[n] = arguments[n];\n        }\n        return arr;\n    }\n  };\n\n  function toObject(keys, values) {\n    var obj = {};\n    var key;\n    var len = keys.length;\n    var valuesCount = values ? values.length : 0;\n    for (var i = 0; i < len; i++) {\n      key = keys[i];\n      obj[key] = i < valuesCount ? values[i] : undefined;\n    }\n    return obj;\n  }\n\n  function TargetObserver(emitter, target, options) {\n    this._emitter = emitter;\n    this._target = target;\n    this._listeners = {};\n    this._listenersCount = 0;\n\n    var on, off;\n\n    if (options.on || options.off) {\n      on = options.on;\n      off = options.off;\n    }\n\n    if (target.addEventListener) {\n      on = target.addEventListener;\n      off = target.removeEventListener;\n    } else if (target.addListener) {\n      on = target.addListener;\n      off = target.removeListener;\n    } else if (target.on) {\n      on = target.on;\n      off = target.off;\n    }\n\n    if (!on && !off) {\n      throw Error('target does not implement any known event API');\n    }\n\n    if (typeof on !== 'function') {\n      throw TypeError('on method must be a function');\n    }\n\n    if (typeof off !== 'function') {\n      throw TypeError('off method must be a function');\n    }\n\n    this._on = on;\n    this._off = off;\n\n    var _observers= emitter._observers;\n    if(_observers){\n      _observers.push(this);\n    }else{\n      emitter._observers= [this];\n    }\n  }\n\n  Object.assign(TargetObserver.prototype, {\n    subscribe: function(event, localEvent, reducer){\n      var observer= this;\n      var target= this._target;\n      var emitter= this._emitter;\n      var listeners= this._listeners;\n      var handler= function(){\n        var args= toArray.apply(null, arguments);\n        var eventObj= {\n          data: args,\n          name: localEvent,\n          original: event\n        };\n        if(reducer){\n          var result= reducer.call(target, eventObj);\n          if(result!==false){\n            emitter.emit.apply(emitter, [eventObj.name].concat(args))\n          }\n          return;\n        }\n        emitter.emit.apply(emitter, [localEvent].concat(args));\n      };\n\n\n      if(listeners[event]){\n        throw Error('Event \\'' + event + '\\' is already listening');\n      }\n\n      this._listenersCount++;\n\n      if(emitter._newListener && emitter._removeListener && !observer._onNewListener){\n\n        this._onNewListener = function (_event) {\n          if (_event === localEvent && listeners[event] === null) {\n            listeners[event] = handler;\n            observer._on.call(target, event, handler);\n          }\n        };\n\n        emitter.on('newListener', this._onNewListener);\n\n        this._onRemoveListener= function(_event){\n          if(_event === localEvent && !emitter.hasListeners(_event) && listeners[event]){\n            listeners[event]= null;\n            observer._off.call(target, event, handler);\n          }\n        };\n\n        listeners[event]= null;\n\n        emitter.on('removeListener', this._onRemoveListener);\n      }else{\n        listeners[event]= handler;\n        observer._on.call(target, event, handler);\n      }\n    },\n\n    unsubscribe: function(event){\n      var observer= this;\n      var listeners= this._listeners;\n      var emitter= this._emitter;\n      var handler;\n      var events;\n      var off= this._off;\n      var target= this._target;\n      var i;\n\n      if(event && typeof event!=='string'){\n        throw TypeError('event must be a string');\n      }\n\n      function clearRefs(){\n        if(observer._onNewListener){\n          emitter.off('newListener', observer._onNewListener);\n          emitter.off('removeListener', observer._onRemoveListener);\n          observer._onNewListener= null;\n          observer._onRemoveListener= null;\n        }\n        var index= findTargetIndex.call(emitter, observer);\n        emitter._observers.splice(index, 1);\n      }\n\n      if(event){\n        handler= listeners[event];\n        if(!handler) return;\n        off.call(target, event, handler);\n        delete listeners[event];\n        if(!--this._listenersCount){\n          clearRefs();\n        }\n      }else{\n        events= ownKeys(listeners);\n        i= events.length;\n        while(i-->0){\n          event= events[i];\n          off.call(target, event, listeners[event]);\n        }\n        this._listeners= {};\n        this._listenersCount= 0;\n        clearRefs();\n      }\n    }\n  });\n\n  function resolveOptions(options, schema, reducers, allowUnknown) {\n    var computedOptions = Object.assign({}, schema);\n\n    if (!options) return computedOptions;\n\n    if (typeof options !== 'object') {\n      throw TypeError('options must be an object')\n    }\n\n    var keys = Object.keys(options);\n    var length = keys.length;\n    var option, value;\n    var reducer;\n\n    function reject(reason) {\n      throw Error('Invalid \"' + option + '\" option value' + (reason ? '. Reason: ' + reason : ''))\n    }\n\n    for (var i = 0; i < length; i++) {\n      option = keys[i];\n      if (!allowUnknown && !hasOwnProperty.call(schema, option)) {\n        throw Error('Unknown \"' + option + '\" option');\n      }\n      value = options[option];\n      if (value !== undefined) {\n        reducer = reducers[option];\n        computedOptions[option] = reducer ? reducer(value, reject) : value;\n      }\n    }\n    return computedOptions;\n  }\n\n  function constructorReducer(value, reject) {\n    if (typeof value !== 'function' || !value.hasOwnProperty('prototype')) {\n      reject('value must be a constructor');\n    }\n    return value;\n  }\n\n  function makeTypeReducer(types) {\n    var message= 'value must be type of ' + types.join('|');\n    var len= types.length;\n    var firstType= types[0];\n    var secondType= types[1];\n\n    if (len === 1) {\n      return function (v, reject) {\n        if (typeof v === firstType) {\n          return v;\n        }\n        reject(message);\n      }\n    }\n\n    if (len === 2) {\n      return function (v, reject) {\n        var kind= typeof v;\n        if (kind === firstType || kind === secondType) return v;\n        reject(message);\n      }\n    }\n\n    return function (v, reject) {\n      var kind = typeof v;\n      var i = len;\n      while (i-- > 0) {\n        if (kind === types[i]) return v;\n      }\n      reject(message);\n    }\n  }\n\n  var functionReducer= makeTypeReducer(['function']);\n\n  var objectFunctionReducer= makeTypeReducer(['object', 'function']);\n\n  function makeCancelablePromise(Promise, executor, options) {\n    var isCancelable;\n    var callbacks;\n    var timer= 0;\n    var subscriptionClosed;\n\n    var promise = new Promise(function (resolve, reject, onCancel) {\n      options= resolveOptions(options, {\n        timeout: 0,\n        overload: false\n      }, {\n        timeout: function(value, reject){\n          value*= 1;\n          if (typeof value !== 'number' || value < 0 || !Number.isFinite(value)) {\n            reject('timeout must be a positive number');\n          }\n          return value;\n        }\n      });\n\n      isCancelable = !options.overload && typeof Promise.prototype.cancel === 'function' && typeof onCancel === 'function';\n\n      function cleanup() {\n        if (callbacks) {\n          callbacks = null;\n        }\n        if (timer) {\n          clearTimeout(timer);\n          timer = 0;\n        }\n      }\n\n      var _resolve= function(value){\n        cleanup();\n        resolve(value);\n      };\n\n      var _reject= function(err){\n        cleanup();\n        reject(err);\n      };\n\n      if (isCancelable) {\n        executor(_resolve, _reject, onCancel);\n      } else {\n        callbacks = [function(reason){\n          _reject(reason || Error('canceled'));\n        }];\n        executor(_resolve, _reject, function (cb) {\n          if (subscriptionClosed) {\n            throw Error('Unable to subscribe on cancel event asynchronously')\n          }\n          if (typeof cb !== 'function') {\n            throw TypeError('onCancel callback must be a function');\n          }\n          callbacks.push(cb);\n        });\n        subscriptionClosed= true;\n      }\n\n      if (options.timeout > 0) {\n        timer= setTimeout(function(){\n          var reason= Error('timeout');\n          reason.code = 'ETIMEDOUT'\n          timer= 0;\n          promise.cancel(reason);\n          reject(reason);\n        }, options.timeout);\n      }\n    });\n\n    if (!isCancelable) {\n      promise.cancel = function (reason) {\n        if (!callbacks) {\n          return;\n        }\n        var length = callbacks.length;\n        for (var i = 1; i < length; i++) {\n          callbacks[i](reason);\n        }\n        // internal callback to reject the promise\n        callbacks[0](reason);\n        callbacks = null;\n      };\n    }\n\n    return promise;\n  }\n\n  function findTargetIndex(observer) {\n    var observers = this._observers;\n    if(!observers){\n      return -1;\n    }\n    var len = observers.length;\n    for (var i = 0; i < len; i++) {\n      if (observers[i]._target === observer) return i;\n    }\n    return -1;\n  }\n\n  // Attention, function return type now is array, always !\n  // It has zero elements if no any matches found and one or more\n  // elements (leafs) if there are matches\n  //\n  function searchListenerTree(handlers, type, tree, i, typeLength) {\n    if (!tree) {\n      return null;\n    }\n\n    if (i === 0) {\n      var kind = typeof type;\n      if (kind === 'string') {\n        var ns, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;\n        if ((n = type.indexOf(delimiter)) !== -1) {\n          ns = new Array(5);\n          do {\n            ns[l++] = type.slice(j, n);\n            j = n + dl;\n          } while ((n = type.indexOf(delimiter, j)) !== -1);\n\n          ns[l++] = type.slice(j);\n          type = ns;\n          typeLength = l;\n        } else {\n          type = [type];\n          typeLength = 1;\n        }\n      } else if (kind === 'object') {\n        typeLength = type.length;\n      } else {\n        type = [type];\n        typeLength = 1;\n      }\n    }\n\n    var listeners= null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i],\n        nextType = type[i + 1], branches, _listeners;\n\n    if (i === typeLength) {\n      //\n      // If at the end of the event(s) list and the tree has listeners\n      // invoke those listeners.\n      //\n\n      if(tree._listeners) {\n        if (typeof tree._listeners === 'function') {\n          handlers && handlers.push(tree._listeners);\n          listeners = [tree];\n        } else {\n          handlers && handlers.push.apply(handlers, tree._listeners);\n          listeners = [tree];\n        }\n      }\n    } else {\n\n      if (currentType === '*') {\n        //\n        // If the event emitted is '*' at this part\n        // or there is a concrete match at this patch\n        //\n        branches = ownKeys(tree);\n        n = branches.length;\n        while (n-- > 0) {\n          branch = branches[n];\n          if (branch !== '_listeners') {\n            _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);\n            if (_listeners) {\n              if (listeners) {\n                listeners.push.apply(listeners, _listeners);\n              } else {\n                listeners = _listeners;\n              }\n            }\n          }\n        }\n        return listeners;\n      } else if (currentType === '**') {\n        endReached = (i + 1 === typeLength || (i + 2 === typeLength && nextType === '*'));\n        if (endReached && tree._listeners) {\n          // The next element has a _listeners, add it to the handlers.\n          listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);\n        }\n\n        branches = ownKeys(tree);\n        n = branches.length;\n        while (n-- > 0) {\n          branch = branches[n];\n          if (branch !== '_listeners') {\n            if (branch === '*' || branch === '**') {\n              if (tree[branch]._listeners && !endReached) {\n                _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);\n                if (_listeners) {\n                  if (listeners) {\n                    listeners.push.apply(listeners, _listeners);\n                  } else {\n                    listeners = _listeners;\n                  }\n                }\n              }\n              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n            } else if (branch === nextType) {\n              _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);\n            } else {\n              // No match on this one, shift into the tree but not in the type array.\n              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);\n            }\n            if (_listeners) {\n              if (listeners) {\n                listeners.push.apply(listeners, _listeners);\n              } else {\n                listeners = _listeners;\n              }\n            }\n          }\n        }\n        return listeners;\n      } else if (tree[currentType]) {\n        listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);\n      }\n    }\n\n      xTree = tree['*'];\n    if (xTree) {\n      //\n      // If the listener tree will allow any match for this part,\n      // then recursively explore all branches of the tree\n      //\n      searchListenerTree(handlers, type, xTree, i + 1, typeLength);\n    }\n\n    xxTree = tree['**'];\n    if (xxTree) {\n      if (i < typeLength) {\n        if (xxTree._listeners) {\n          // If we have a listener on a '**', it will catch all, so add its handler.\n          searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n        }\n\n        // Build arrays of matching next branches and others.\n        branches= ownKeys(xxTree);\n        n= branches.length;\n        while(n-->0){\n          branch= branches[n];\n          if (branch !== '_listeners') {\n            if (branch === nextType) {\n              // We know the next element will match, so jump twice.\n              searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);\n            } else if (branch === currentType) {\n              // Current node matches, move into the tree.\n              searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);\n            } else {\n              isolatedBranch = {};\n              isolatedBranch[branch] = xxTree[branch];\n              searchListenerTree(handlers, type, {'**': isolatedBranch}, i + 1, typeLength);\n            }\n          }\n        }\n      } else if (xxTree._listeners) {\n        // We have reached the end and still on a '**'\n        searchListenerTree(handlers, type, xxTree, typeLength, typeLength);\n      } else if (xxTree['*'] && xxTree['*']._listeners) {\n        searchListenerTree(handlers, type, xxTree['*'], typeLength, typeLength);\n      }\n    }\n\n    return listeners;\n  }\n\n  function growListenerTree(type, listener, prepend) {\n    var len = 0, j = 0, i, delimiter = this.delimiter, dl= delimiter.length, ns;\n\n    if(typeof type==='string') {\n      if ((i = type.indexOf(delimiter)) !== -1) {\n        ns = new Array(5);\n        do {\n          ns[len++] = type.slice(j, i);\n          j = i + dl;\n        } while ((i = type.indexOf(delimiter, j)) !== -1);\n\n        ns[len++] = type.slice(j);\n      }else{\n        ns= [type];\n        len= 1;\n      }\n    }else{\n      ns= type;\n      len= type.length;\n    }\n\n    //\n    // Looks for two consecutive '**', if so, don't add the event at all.\n    //\n    if (len > 1) {\n      for (i = 0; i + 1 < len; i++) {\n        if (ns[i] === '**' && ns[i + 1] === '**') {\n          return;\n        }\n      }\n    }\n\n\n\n    var tree = this.listenerTree, name;\n\n    for (i = 0; i < len; i++) {\n      name = ns[i];\n\n      tree = tree[name] || (tree[name] = {});\n\n      if (i === len - 1) {\n        if (!tree._listeners) {\n          tree._listeners = listener;\n        } else {\n          if (typeof tree._listeners === 'function') {\n            tree._listeners = [tree._listeners];\n          }\n\n          if (prepend) {\n            tree._listeners.unshift(listener);\n          } else {\n            tree._listeners.push(listener);\n          }\n\n          if (\n              !tree._listeners.warned &&\n              this._maxListeners > 0 &&\n              tree._listeners.length > this._maxListeners\n          ) {\n            tree._listeners.warned = true;\n            logPossibleMemoryLeak.call(this, tree._listeners.length, name);\n          }\n        }\n        return true;\n      }\n    }\n\n    return true;\n  }\n\n  function collectTreeEvents(tree, events, root, asArray){\n     var branches= ownKeys(tree);\n     var i= branches.length;\n     var branch, branchName, path;\n     var hasListeners= tree['_listeners'];\n     var isArrayPath;\n\n     while(i-->0){\n         branchName= branches[i];\n\n         branch= tree[branchName];\n\n         if(branchName==='_listeners'){\n             path= root;\n         }else {\n             path = root ? root.concat(branchName) : [branchName];\n         }\n\n         isArrayPath= asArray || typeof branchName==='symbol';\n\n         hasListeners && events.push(isArrayPath? path : path.join(this.delimiter));\n\n         if(typeof branch==='object'){\n             collectTreeEvents.call(this, branch, events, path, isArrayPath);\n         }\n     }\n\n     return events;\n  }\n\n  function recursivelyGarbageCollect(root) {\n    var keys = ownKeys(root);\n    var i= keys.length;\n    var obj, key, flag;\n    while(i-->0){\n      key = keys[i];\n      obj = root[key];\n\n      if(obj){\n          flag= true;\n          if(key !== '_listeners' && !recursivelyGarbageCollect(obj)){\n             delete root[key];\n          }\n      }\n    }\n\n    return flag;\n  }\n\n  function Listener(emitter, event, listener){\n    this.emitter= emitter;\n    this.event= event;\n    this.listener= listener;\n  }\n\n  Listener.prototype.off= function(){\n    this.emitter.off(this.event, this.listener);\n    return this;\n  };\n\n  function setupListener(event, listener, options){\n      if (options === true) {\n        promisify = true;\n      } else if (options === false) {\n        async = true;\n      } else {\n        if (!options || typeof options !== 'object') {\n          throw TypeError('options should be an object or true');\n        }\n        var async = options.async;\n        var promisify = options.promisify;\n        var nextTick = options.nextTick;\n        var objectify = options.objectify;\n      }\n\n      if (async || nextTick || promisify) {\n        var _listener = listener;\n        var _origin = listener._origin || listener;\n\n        if (nextTick && !nextTickSupported) {\n          throw Error('process.nextTick is not supported');\n        }\n\n        if (promisify === undefined) {\n          promisify = listener.constructor.name === 'AsyncFunction';\n        }\n\n        listener = function () {\n          var args = arguments;\n          var context = this;\n          var event = this.event;\n\n          return promisify ? (nextTick ? Promise.resolve() : new Promise(function (resolve) {\n            _setImmediate(resolve);\n          }).then(function () {\n            context.event = event;\n            return _listener.apply(context, args)\n          })) : (nextTick ? process.nextTick : _setImmediate)(function () {\n            context.event = event;\n            _listener.apply(context, args)\n          });\n        };\n\n        listener._async = true;\n        listener._origin = _origin;\n      }\n\n    return [listener, objectify? new Listener(this, event, listener): this];\n  }\n\n  function EventEmitter(conf) {\n    this._events = {};\n    this._newListener = false;\n    this._removeListener = false;\n    this.verboseMemoryLeak = false;\n    configure.call(this, conf);\n  }\n\n  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property\n\n  EventEmitter.prototype.listenTo= function(target, events, options){\n    if(typeof target!=='object'){\n      throw TypeError('target musts be an object');\n    }\n\n    var emitter= this;\n\n    options = resolveOptions(options, {\n      on: undefined,\n      off: undefined,\n      reducers: undefined\n    }, {\n      on: functionReducer,\n      off: functionReducer,\n      reducers: objectFunctionReducer\n    });\n\n    function listen(events){\n      if(typeof events!=='object'){\n        throw TypeError('events must be an object');\n      }\n\n      var reducers= options.reducers;\n      var index= findTargetIndex.call(emitter, target);\n      var observer;\n\n      if(index===-1){\n        observer= new TargetObserver(emitter, target, options);\n      }else{\n        observer= emitter._observers[index];\n      }\n\n      var keys= ownKeys(events);\n      var len= keys.length;\n      var event;\n      var isSingleReducer= typeof reducers==='function';\n\n      for(var i=0; i<len; i++){\n        event= keys[i];\n        observer.subscribe(\n            event,\n            events[event] || event,\n            isSingleReducer ? reducers : reducers && reducers[event]\n        );\n      }\n    }\n\n    isArray(events)?\n        listen(toObject(events)) :\n        (typeof events==='string'? listen(toObject(events.split(/\\s+/))): listen(events));\n\n    return this;\n  };\n\n  EventEmitter.prototype.stopListeningTo = function (target, event) {\n    var observers = this._observers;\n\n    if(!observers){\n      return false;\n    }\n\n    var i = observers.length;\n    var observer;\n    var matched= false;\n\n    if(target && typeof target!=='object'){\n      throw TypeError('target should be an object');\n    }\n\n    while (i-- > 0) {\n      observer = observers[i];\n      if (!target || observer._target === target) {\n        observer.unsubscribe(event);\n        matched= true;\n      }\n    }\n\n    return matched;\n  };\n\n  // By default EventEmitters will print a warning if more than\n  // 10 listeners are added to it. This is a useful default which\n  // helps finding memory leaks.\n  //\n  // Obviously not all Emitters should be limited to 10. This function allows\n  // that to be increased. Set to zero for unlimited.\n\n  EventEmitter.prototype.delimiter = '.';\n\n  EventEmitter.prototype.setMaxListeners = function(n) {\n    if (n !== undefined) {\n      this._maxListeners = n;\n      if (!this._conf) this._conf = {};\n      this._conf.maxListeners = n;\n    }\n  };\n\n  EventEmitter.prototype.getMaxListeners = function() {\n    return this._maxListeners;\n  };\n\n  EventEmitter.prototype.event = '';\n\n  EventEmitter.prototype.once = function(event, fn, options) {\n    return this._once(event, fn, false, options);\n  };\n\n  EventEmitter.prototype.prependOnceListener = function(event, fn, options) {\n    return this._once(event, fn, true, options);\n  };\n\n  EventEmitter.prototype._once = function(event, fn, prepend, options) {\n    return this._many(event, 1, fn, prepend, options);\n  };\n\n  EventEmitter.prototype.many = function(event, ttl, fn, options) {\n    return this._many(event, ttl, fn, false, options);\n  };\n\n  EventEmitter.prototype.prependMany = function(event, ttl, fn, options) {\n    return this._many(event, ttl, fn, true, options);\n  };\n\n  EventEmitter.prototype._many = function(event, ttl, fn, prepend, options) {\n    var self = this;\n\n    if (typeof fn !== 'function') {\n      throw new Error('many only accepts instances of Function');\n    }\n\n    function listener() {\n      if (--ttl === 0) {\n        self.off(event, listener);\n      }\n      return fn.apply(this, arguments);\n    }\n\n    listener._origin = fn;\n\n    return this._on(event, listener, prepend, options);\n  };\n\n  EventEmitter.prototype.emit = function() {\n    if (!this._events && !this._all) {\n      return false;\n    }\n\n    this._events || init.call(this);\n\n    var type = arguments[0], ns, wildcard= this.wildcard;\n    var args,l,i,j, containsSymbol;\n\n    if (type === 'newListener' && !this._newListener) {\n      if (!this._events.newListener) {\n        return false;\n      }\n    }\n\n    if (wildcard) {\n      ns= type;\n      if(type!=='newListener' && type!=='removeListener'){\n        if (typeof type === 'object') {\n          l = type.length;\n          if (symbolsSupported) {\n            for (i = 0; i < l; i++) {\n              if (typeof type[i] === 'symbol') {\n                containsSymbol = true;\n                break;\n              }\n            }\n          }\n          if (!containsSymbol) {\n            type = type.join(this.delimiter);\n          }\n        }\n      }\n    }\n\n    var al = arguments.length;\n    var handler;\n\n    if (this._all && this._all.length) {\n      handler = this._all.slice();\n\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler[i].call(this, type);\n          break;\n        case 2:\n          handler[i].call(this, type, arguments[1]);\n          break;\n        case 3:\n          handler[i].call(this, type, arguments[1], arguments[2]);\n          break;\n        default:\n          handler[i].apply(this, arguments);\n        }\n      }\n    }\n\n    if (wildcard) {\n      handler = [];\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);\n    } else {\n      handler = this._events[type];\n      if (typeof handler === 'function') {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler.call(this);\n          break;\n        case 2:\n          handler.call(this, arguments[1]);\n          break;\n        case 3:\n          handler.call(this, arguments[1], arguments[2]);\n          break;\n        default:\n          args = new Array(al - 1);\n          for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n          handler.apply(this, args);\n        }\n        return true;\n      } else if (handler) {\n        // need to make copy of handlers because list can change in the middle\n        // of emit call\n        handler = handler.slice();\n      }\n    }\n\n    if (handler && handler.length) {\n      if (al > 3) {\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          handler[i].call(this);\n          break;\n        case 2:\n          handler[i].call(this, arguments[1]);\n          break;\n        case 3:\n          handler[i].call(this, arguments[1], arguments[2]);\n          break;\n        default:\n          handler[i].apply(this, args);\n        }\n      }\n      return true;\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        throw arguments[1]; // Unhandled 'error' event\n      } else {\n        throw new Error(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n\n    return !!this._all;\n  };\n\n  EventEmitter.prototype.emitAsync = function() {\n    if (!this._events && !this._all) {\n      return false;\n    }\n\n    this._events || init.call(this);\n\n    var type = arguments[0], wildcard= this.wildcard, ns, containsSymbol;\n    var args,l,i,j;\n\n    if (type === 'newListener' && !this._newListener) {\n        if (!this._events.newListener) { return Promise.resolve([false]); }\n    }\n\n    if (wildcard) {\n      ns= type;\n      if(type!=='newListener' && type!=='removeListener'){\n        if (typeof type === 'object') {\n          l = type.length;\n          if (symbolsSupported) {\n            for (i = 0; i < l; i++) {\n              if (typeof type[i] === 'symbol') {\n                containsSymbol = true;\n                break;\n              }\n            }\n          }\n          if (!containsSymbol) {\n            type = type.join(this.delimiter);\n          }\n        }\n      }\n    }\n\n    var promises= [];\n\n    var al = arguments.length;\n    var handler;\n\n    if (this._all) {\n      for (i = 0, l = this._all.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          promises.push(this._all[i].call(this, type));\n          break;\n        case 2:\n          promises.push(this._all[i].call(this, type, arguments[1]));\n          break;\n        case 3:\n          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));\n          break;\n        default:\n          promises.push(this._all[i].apply(this, arguments));\n        }\n      }\n    }\n\n    if (wildcard) {\n      handler = [];\n      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);\n    } else {\n      handler = this._events[type];\n    }\n\n    if (typeof handler === 'function') {\n      this.event = type;\n      switch (al) {\n      case 1:\n        promises.push(handler.call(this));\n        break;\n      case 2:\n        promises.push(handler.call(this, arguments[1]));\n        break;\n      case 3:\n        promises.push(handler.call(this, arguments[1], arguments[2]));\n        break;\n      default:\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n        promises.push(handler.apply(this, args));\n      }\n    } else if (handler && handler.length) {\n      handler = handler.slice();\n      if (al > 3) {\n        args = new Array(al - 1);\n        for (j = 1; j < al; j++) args[j - 1] = arguments[j];\n      }\n      for (i = 0, l = handler.length; i < l; i++) {\n        this.event = type;\n        switch (al) {\n        case 1:\n          promises.push(handler[i].call(this));\n          break;\n        case 2:\n          promises.push(handler[i].call(this, arguments[1]));\n          break;\n        case 3:\n          promises.push(handler[i].call(this, arguments[1], arguments[2]));\n          break;\n        default:\n          promises.push(handler[i].apply(this, args));\n        }\n      }\n    } else if (!this.ignoreErrors && !this._all && type === 'error') {\n      if (arguments[1] instanceof Error) {\n        return Promise.reject(arguments[1]); // Unhandled 'error' event\n      } else {\n        return Promise.reject(\"Uncaught, unspecified 'error' event.\");\n      }\n    }\n\n    return Promise.all(promises);\n  };\n\n  EventEmitter.prototype.on = function(type, listener, options) {\n    return this._on(type, listener, false, options);\n  };\n\n  EventEmitter.prototype.prependListener = function(type, listener, options) {\n    return this._on(type, listener, true, options);\n  };\n\n  EventEmitter.prototype.onAny = function(fn) {\n    return this._onAny(fn, false);\n  };\n\n  EventEmitter.prototype.prependAny = function(fn) {\n    return this._onAny(fn, true);\n  };\n\n  EventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n  EventEmitter.prototype._onAny = function(fn, prepend){\n    if (typeof fn !== 'function') {\n      throw new Error('onAny only accepts instances of Function');\n    }\n\n    if (!this._all) {\n      this._all = [];\n    }\n\n    // Add the function to the event listener collection.\n    if(prepend){\n      this._all.unshift(fn);\n    }else{\n      this._all.push(fn);\n    }\n\n    return this;\n  };\n\n  EventEmitter.prototype._on = function(type, listener, prepend, options) {\n    if (typeof type === 'function') {\n      this._onAny(type, listener);\n      return this;\n    }\n\n    if (typeof listener !== 'function') {\n      throw new Error('on only accepts instances of Function');\n    }\n    this._events || init.call(this);\n\n    var returnValue= this, temp;\n\n    if (options !== undefined) {\n      temp = setupListener.call(this, type, listener, options);\n      listener = temp[0];\n      returnValue = temp[1];\n    }\n\n    // To avoid recursion in the case that type == \"newListeners\"! Before\n    // adding it to the listeners, first emit \"newListeners\".\n    if (this._newListener) {\n      this.emit('newListener', type, listener);\n    }\n\n    if (this.wildcard) {\n      growListenerTree.call(this, type, listener, prepend);\n      return returnValue;\n    }\n\n    if (!this._events[type]) {\n      // Optimize the case of one listener. Don't need the extra array object.\n      this._events[type] = listener;\n    } else {\n      if (typeof this._events[type] === 'function') {\n        // Change to array.\n        this._events[type] = [this._events[type]];\n      }\n\n      // If we've already got an array, just add\n      if(prepend){\n        this._events[type].unshift(listener);\n      }else{\n        this._events[type].push(listener);\n      }\n\n      // Check for listener leak\n      if (\n        !this._events[type].warned &&\n        this._maxListeners > 0 &&\n        this._events[type].length > this._maxListeners\n      ) {\n        this._events[type].warned = true;\n        logPossibleMemoryLeak.call(this, this._events[type].length, type);\n      }\n    }\n\n    return returnValue;\n  };\n\n  EventEmitter.prototype.off = function(type, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('removeListener only takes instances of Function');\n    }\n\n    var handlers,leafs=[];\n\n    if(this.wildcard) {\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);\n      if(!leafs) return this;\n    } else {\n      // does not use listeners(), so no side effect of creating _events[type]\n      if (!this._events[type]) return this;\n      handlers = this._events[type];\n      leafs.push({_listeners:handlers});\n    }\n\n    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {\n      var leaf = leafs[iLeaf];\n      handlers = leaf._listeners;\n      if (isArray(handlers)) {\n\n        var position = -1;\n\n        for (var i = 0, length = handlers.length; i < length; i++) {\n          if (handlers[i] === listener ||\n            (handlers[i].listener && handlers[i].listener === listener) ||\n            (handlers[i]._origin && handlers[i]._origin === listener)) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0) {\n          continue;\n        }\n\n        if(this.wildcard) {\n          leaf._listeners.splice(position, 1);\n        }\n        else {\n          this._events[type].splice(position, 1);\n        }\n\n        if (handlers.length === 0) {\n          if(this.wildcard) {\n            delete leaf._listeners;\n          }\n          else {\n            delete this._events[type];\n          }\n        }\n        if (this._removeListener)\n          this.emit(\"removeListener\", type, listener);\n\n        return this;\n      }\n      else if (handlers === listener ||\n        (handlers.listener && handlers.listener === listener) ||\n        (handlers._origin && handlers._origin === listener)) {\n        if(this.wildcard) {\n          delete leaf._listeners;\n        }\n        else {\n          delete this._events[type];\n        }\n        if (this._removeListener)\n          this.emit(\"removeListener\", type, listener);\n      }\n    }\n\n    this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n\n    return this;\n  };\n\n  EventEmitter.prototype.offAny = function(fn) {\n    var i = 0, l = 0, fns;\n    if (fn && this._all && this._all.length > 0) {\n      fns = this._all;\n      for(i = 0, l = fns.length; i < l; i++) {\n        if(fn === fns[i]) {\n          fns.splice(i, 1);\n          if (this._removeListener)\n            this.emit(\"removeListenerAny\", fn);\n          return this;\n        }\n      }\n    } else {\n      fns = this._all;\n      if (this._removeListener) {\n        for(i = 0, l = fns.length; i < l; i++)\n          this.emit(\"removeListenerAny\", fns[i]);\n      }\n      this._all = [];\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;\n\n  EventEmitter.prototype.removeAllListeners = function (type) {\n    if (type === undefined) {\n      !this._events || init.call(this);\n      return this;\n    }\n\n    if (this.wildcard) {\n      var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;\n      if (!leafs) return this;\n      for (i = 0; i < leafs.length; i++) {\n        leaf = leafs[i];\n        leaf._listeners = null;\n      }\n      this.listenerTree && recursivelyGarbageCollect(this.listenerTree);\n    } else if (this._events) {\n      this._events[type] = null;\n    }\n    return this;\n  };\n\n  EventEmitter.prototype.listeners = function (type) {\n    var _events = this._events;\n    var keys, listeners, allListeners;\n    var i;\n    var listenerTree;\n\n    if (type === undefined) {\n      if (this.wildcard) {\n        throw Error('event name required for wildcard emitter');\n      }\n\n      if (!_events) {\n        return [];\n      }\n\n      keys = ownKeys(_events);\n      i = keys.length;\n      allListeners = [];\n      while (i-- > 0) {\n        listeners = _events[keys[i]];\n        if (typeof listeners === 'function') {\n          allListeners.push(listeners);\n        } else {\n          allListeners.push.apply(allListeners, listeners);\n        }\n      }\n      return allListeners;\n    } else {\n      if (this.wildcard) {\n        listenerTree= this.listenerTree;\n        if(!listenerTree) return [];\n        var handlers = [];\n        var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n        searchListenerTree.call(this, handlers, ns, listenerTree, 0);\n        return handlers;\n      }\n\n      if (!_events) {\n        return [];\n      }\n\n      listeners = _events[type];\n\n      if (!listeners) {\n        return [];\n      }\n      return typeof listeners === 'function' ? [listeners] : listeners;\n    }\n  };\n\n  EventEmitter.prototype.eventNames = function(nsAsArray){\n    var _events= this._events;\n    return this.wildcard? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : (_events? ownKeys(_events) : []);\n  };\n\n  EventEmitter.prototype.listenerCount = function(type) {\n    return this.listeners(type).length;\n  };\n\n  EventEmitter.prototype.hasListeners = function (type) {\n    if (this.wildcard) {\n      var handlers = [];\n      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();\n      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);\n      return handlers.length > 0;\n    }\n\n    var _events = this._events;\n    var _all = this._all;\n\n    return !!(_all && _all.length || _events && (type === undefined ? ownKeys(_events).length : _events[type]));\n  };\n\n  EventEmitter.prototype.listenersAny = function() {\n\n    if(this._all) {\n      return this._all;\n    }\n    else {\n      return [];\n    }\n\n  };\n\n  EventEmitter.prototype.waitFor = function (event, options) {\n    var self = this;\n    var type = typeof options;\n    if (type === 'number') {\n      options = {timeout: options};\n    } else if (type === 'function') {\n      options = {filter: options};\n    }\n\n    options= resolveOptions(options, {\n      timeout: 0,\n      filter: undefined,\n      handleError: false,\n      Promise: Promise,\n      overload: false\n    }, {\n      filter: functionReducer,\n      Promise: constructorReducer\n    });\n\n    return makeCancelablePromise(options.Promise, function (resolve, reject, onCancel) {\n      function listener() {\n        var filter= options.filter;\n        if (filter && !filter.apply(self, arguments)) {\n          return;\n        }\n        self.off(event, listener);\n        if (options.handleError) {\n          var err = arguments[0];\n          err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));\n        } else {\n          resolve(toArray.apply(null, arguments));\n        }\n      }\n\n      onCancel(function(){\n        self.off(event, listener);\n      });\n\n      self._on(event, listener, false);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    })\n  };\n\n  function once(emitter, name, options) {\n    options= resolveOptions(options, {\n      Promise: Promise,\n      timeout: 0,\n      overload: false\n    }, {\n      Promise: constructorReducer\n    });\n\n    var _Promise= options.Promise;\n\n    return makeCancelablePromise(_Promise, function(resolve, reject, onCancel){\n      var handler;\n      if (typeof emitter.addEventListener === 'function') {\n        handler=  function () {\n          resolve(toArray.apply(null, arguments));\n        };\n\n        onCancel(function(){\n          emitter.removeEventListener(name, handler);\n        });\n\n        emitter.addEventListener(\n            name,\n            handler,\n            {once: true}\n        );\n        return;\n      }\n\n      var eventListener = function(){\n        errorListener && emitter.removeListener('error', errorListener);\n        resolve(toArray.apply(null, arguments));\n      };\n\n      var errorListener;\n\n      if (name !== 'error') {\n        errorListener = function (err){\n          emitter.removeListener(name, eventListener);\n          reject(err);\n        };\n\n        emitter.once('error', errorListener);\n      }\n\n      onCancel(function(){\n        errorListener && emitter.removeListener('error', errorListener);\n        emitter.removeListener(name, eventListener);\n      });\n\n      emitter.once(name, eventListener);\n    }, {\n      timeout: options.timeout,\n      overload: options.overload\n    });\n  }\n\n  var prototype= EventEmitter.prototype;\n\n  Object.defineProperties(EventEmitter, {\n    defaultMaxListeners: {\n      get: function () {\n        return prototype._maxListeners;\n      },\n      set: function (n) {\n        if (typeof n !== 'number' || n < 0 || Number.isNaN(n)) {\n          throw TypeError('n must be a non-negative number')\n        }\n        prototype._maxListeners = n;\n      },\n      enumerable: true\n    },\n    once: {\n      value: once,\n      writable: true,\n      configurable: true\n    }\n  });\n\n  Object.defineProperties(prototype, {\n      _maxListeners: {\n          value: defaultMaxListeners,\n          writable: true,\n          configurable: true\n      },\n      _observers: {value: null, writable: true, configurable: true}\n  });\n\n  if (true) {\n     // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n      return EventEmitter;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else { var _global; }\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIyL2xpYi9ldmVudGVtaXR0ZXIyLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU8scUJBQXFCLE9BQU87QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLE9BQU8sb0JBQW9CLE9BQU87QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLE9BQU87QUFDYixNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMENBQTBDOztBQUUxQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFD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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDRCQUE0QjtBQUM1QixRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0Esc0NBQXNDLE9BQU87QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNkNBQTZDO0FBQzdDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0Qzs7QUFFQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrREFBa0QsWUFBWTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLE1BQU07QUFDTixpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG1CQUFtQjtBQUNuQixHQUFHOztBQUVILE1BQU0sSUFBMEM7QUFDaEQ7QUFDQSxJQUFJLG1DQUFPO0FBQ1g7QUFDQSxLQUFLO0FBQUEsa0dBQUM7QUFDTixJQUFJLEtBQUssZ0JBUU47QUFDSCxDQUFDIiwic291cmNlcyI6WyJDOlxcc2hvcF9oYXJkaGF0XFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxldmVudGVtaXR0ZXIyXFxsaWJcXGV2ZW50ZW1pdHRlcjIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBFdmVudEVtaXR0ZXIyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vaGlqMW54L0V2ZW50RW1pdHRlcjJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMgaGlqMW54XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbjshZnVuY3Rpb24odW5kZWZpbmVkKSB7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eT0gT2JqZWN0Lmhhc093blByb3BlcnR5O1xuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgPyBBcnJheS5pc0FycmF5IDogZnVuY3Rpb24gX2lzQXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSBcIltvYmplY3QgQXJyYXldXCI7XG4gIH07XG4gIHZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG4gIHZhciBuZXh0VGlja1N1cHBvcnRlZD0gdHlwZW9mIHByb2Nlc3M9PSdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrPT0nZnVuY3Rpb24nO1xuICB2YXIgc3ltYm9sc1N1cHBvcnRlZD0gdHlwZW9mIFN5bWJvbD09PSdmdW5jdGlvbic7XG4gIHZhciByZWZsZWN0U3VwcG9ydGVkPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCc7XG4gIHZhciBzZXRJbW1lZGlhdGVTdXBwb3J0ZWQ9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbic7XG4gIHZhciBfc2V0SW1tZWRpYXRlPSBzZXRJbW1lZGlhdGVTdXBwb3J0ZWQgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0O1xuICB2YXIgb3duS2V5cz0gc3ltYm9sc1N1cHBvcnRlZD8gKHJlZmxlY3RTdXBwb3J0ZWQgJiYgdHlwZW9mIFJlZmxlY3Qub3duS2V5cz09PSdmdW5jdGlvbic/IFJlZmxlY3Qub3duS2V5cyA6IGZ1bmN0aW9uKG9iail7XG4gICAgdmFyIGFycj0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKTtcbiAgICBhcnIucHVzaC5hcHBseShhcnIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqKSk7XG4gICAgcmV0dXJuIGFycjtcbiAgfSkgOiBPYmplY3Qua2V5cztcblxuICBmdW5jdGlvbiBpbml0KCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGlmICh0aGlzLl9jb25mKSB7XG4gICAgICBjb25maWd1cmUuY2FsbCh0aGlzLCB0aGlzLl9jb25mKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb25maWd1cmUoY29uZikge1xuICAgIGlmIChjb25mKSB7XG4gICAgICB0aGlzLl9jb25mID0gY29uZjtcblxuICAgICAgY29uZi5kZWxpbWl0ZXIgJiYgKHRoaXMuZGVsaW1pdGVyID0gY29uZi5kZWxpbWl0ZXIpO1xuXG4gICAgICBpZihjb25mLm1heExpc3RlbmVycyE9PXVuZGVmaW5lZCl7XG4gICAgICAgICAgdGhpcy5fbWF4TGlzdGVuZXJzPSBjb25mLm1heExpc3RlbmVycztcbiAgICAgIH1cblxuICAgICAgY29uZi53aWxkY2FyZCAmJiAodGhpcy53aWxkY2FyZCA9IGNvbmYud2lsZGNhcmQpO1xuICAgICAgY29uZi5uZXdMaXN0ZW5lciAmJiAodGhpcy5fbmV3TGlzdGVuZXIgPSBjb25mLm5ld0xpc3RlbmVyKTtcbiAgICAgIGNvbmYucmVtb3ZlTGlzdGVuZXIgJiYgKHRoaXMuX3JlbW92ZUxpc3RlbmVyID0gY29uZi5yZW1vdmVMaXN0ZW5lcik7XG4gICAgICBjb25mLnZlcmJvc2VNZW1vcnlMZWFrICYmICh0aGlzLnZlcmJvc2VNZW1vcnlMZWFrID0gY29uZi52ZXJib3NlTWVtb3J5TGVhayk7XG4gICAgICBjb25mLmlnbm9yZUVycm9ycyAmJiAodGhpcy5pZ25vcmVFcnJvcnMgPSBjb25mLmlnbm9yZUVycm9ycyk7XG5cbiAgICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJUcmVlID0ge307XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbG9nUG9zc2libGVNZW1vcnlMZWFrKGNvdW50LCBldmVudE5hbWUpIHtcbiAgICB2YXIgZXJyb3JNc2cgPSAnKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICdsZWFrIGRldGVjdGVkLiAnICsgY291bnQgKyAnIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nO1xuXG4gICAgaWYodGhpcy52ZXJib3NlTWVtb3J5TGVhayl7XG4gICAgICBlcnJvck1zZyArPSAnIEV2ZW50IG5hbWU6ICcgKyBldmVudE5hbWUgKyAnLic7XG4gICAgfVxuXG4gICAgaWYodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW1pdFdhcm5pbmcpe1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoZXJyb3JNc2cpO1xuICAgICAgZS5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICBlLmVtaXR0ZXIgPSB0aGlzO1xuICAgICAgZS5jb3VudCA9IGNvdW50O1xuICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihlcnJvck1zZyk7XG5cbiAgICAgIGlmIChjb25zb2xlLnRyYWNlKXtcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB0b0FycmF5ID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgc3dpdGNoIChuKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIFthXTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIFthLCBiXTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBhcnIgPSBuZXcgQXJyYXkobik7XG4gICAgICAgIHdoaWxlIChuLS0pIHtcbiAgICAgICAgICBhcnJbbl0gPSBhcmd1bWVudHNbbl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gdG9PYmplY3Qoa2V5cywgdmFsdWVzKSB7XG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIHZhciBrZXk7XG4gICAgdmFyIGxlbiA9IGtleXMubGVuZ3RoO1xuICAgIHZhciB2YWx1ZXNDb3VudCA9IHZhbHVlcyA/IHZhbHVlcy5sZW5ndGggOiAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBvYmpba2V5XSA9IGkgPCB2YWx1ZXNDb3VudCA/IHZhbHVlc1tpXSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIFRhcmdldE9ic2VydmVyKGVtaXR0ZXIsIHRhcmdldCwgb3B0aW9ucykge1xuICAgIHRoaXMuX2VtaXR0ZXIgPSBlbWl0dGVyO1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLl9saXN0ZW5lcnNDb3VudCA9IDA7XG5cbiAgICB2YXIgb24sIG9mZjtcblxuICAgIGlmIChvcHRpb25zLm9uIHx8IG9wdGlvbnMub2ZmKSB7XG4gICAgICBvbiA9IG9wdGlvbnMub247XG4gICAgICBvZmYgPSBvcHRpb25zLm9mZjtcbiAgICB9XG5cbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIG9uID0gdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXI7XG4gICAgICBvZmYgPSB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hZGRMaXN0ZW5lcikge1xuICAgICAgb24gPSB0YXJnZXQuYWRkTGlzdGVuZXI7XG4gICAgICBvZmYgPSB0YXJnZXQucmVtb3ZlTGlzdGVuZXI7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQub24pIHtcbiAgICAgIG9uID0gdGFyZ2V0Lm9uO1xuICAgICAgb2ZmID0gdGFyZ2V0Lm9mZjtcbiAgICB9XG5cbiAgICBpZiAoIW9uICYmICFvZmYpIHtcbiAgICAgIHRocm93IEVycm9yKCd0YXJnZXQgZG9lcyBub3QgaW1wbGVtZW50IGFueSBrbm93biBldmVudCBBUEknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9uICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ29uIG1ldGhvZCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9mZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdvZmYgbWV0aG9kIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIH1cblxuICAgIHRoaXMuX29uID0gb247XG4gICAgdGhpcy5fb2ZmID0gb2ZmO1xuXG4gICAgdmFyIF9vYnNlcnZlcnM9IGVtaXR0ZXIuX29ic2VydmVycztcbiAgICBpZihfb2JzZXJ2ZXJzKXtcbiAgICAgIF9vYnNlcnZlcnMucHVzaCh0aGlzKTtcbiAgICB9ZWxzZXtcbiAgICAgIGVtaXR0ZXIuX29ic2VydmVycz0gW3RoaXNdO1xuICAgIH1cbiAgfVxuXG4gIE9iamVjdC5hc3NpZ24oVGFyZ2V0T2JzZXJ2ZXIucHJvdG90eXBlLCB7XG4gICAgc3Vic2NyaWJlOiBmdW5jdGlvbihldmVudCwgbG9jYWxFdmVudCwgcmVkdWNlcil7XG4gICAgICB2YXIgb2JzZXJ2ZXI9IHRoaXM7XG4gICAgICB2YXIgdGFyZ2V0PSB0aGlzLl90YXJnZXQ7XG4gICAgICB2YXIgZW1pdHRlcj0gdGhpcy5fZW1pdHRlcjtcbiAgICAgIHZhciBsaXN0ZW5lcnM9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgIHZhciBoYW5kbGVyPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgYXJncz0gdG9BcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICB2YXIgZXZlbnRPYmo9IHtcbiAgICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICAgIG5hbWU6IGxvY2FsRXZlbnQsXG4gICAgICAgICAgb3JpZ2luYWw6IGV2ZW50XG4gICAgICAgIH07XG4gICAgICAgIGlmKHJlZHVjZXIpe1xuICAgICAgICAgIHZhciByZXN1bHQ9IHJlZHVjZXIuY2FsbCh0YXJnZXQsIGV2ZW50T2JqKTtcbiAgICAgICAgICBpZihyZXN1bHQhPT1mYWxzZSl7XG4gICAgICAgICAgICBlbWl0dGVyLmVtaXQuYXBwbHkoZW1pdHRlciwgW2V2ZW50T2JqLm5hbWVdLmNvbmNhdChhcmdzKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVtaXR0ZXIuZW1pdC5hcHBseShlbWl0dGVyLCBbbG9jYWxFdmVudF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH07XG5cblxuICAgICAgaWYobGlzdGVuZXJzW2V2ZW50XSl7XG4gICAgICAgIHRocm93IEVycm9yKCdFdmVudCBcXCcnICsgZXZlbnQgKyAnXFwnIGlzIGFscmVhZHkgbGlzdGVuaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xpc3RlbmVyc0NvdW50Kys7XG5cbiAgICAgIGlmKGVtaXR0ZXIuX25ld0xpc3RlbmVyICYmIGVtaXR0ZXIuX3JlbW92ZUxpc3RlbmVyICYmICFvYnNlcnZlci5fb25OZXdMaXN0ZW5lcil7XG5cbiAgICAgICAgdGhpcy5fb25OZXdMaXN0ZW5lciA9IGZ1bmN0aW9uIChfZXZlbnQpIHtcbiAgICAgICAgICBpZiAoX2V2ZW50ID09PSBsb2NhbEV2ZW50ICYmIGxpc3RlbmVyc1tldmVudF0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tldmVudF0gPSBoYW5kbGVyO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuX29uLmNhbGwodGFyZ2V0LCBldmVudCwgaGFuZGxlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGVtaXR0ZXIub24oJ25ld0xpc3RlbmVyJywgdGhpcy5fb25OZXdMaXN0ZW5lcik7XG5cbiAgICAgICAgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcj0gZnVuY3Rpb24oX2V2ZW50KXtcbiAgICAgICAgICBpZihfZXZlbnQgPT09IGxvY2FsRXZlbnQgJiYgIWVtaXR0ZXIuaGFzTGlzdGVuZXJzKF9ldmVudCkgJiYgbGlzdGVuZXJzW2V2ZW50XSl7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdPSBudWxsO1xuICAgICAgICAgICAgb2JzZXJ2ZXIuX29mZi5jYWxsKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBsaXN0ZW5lcnNbZXZlbnRdPSBudWxsO1xuXG4gICAgICAgIGVtaXR0ZXIub24oJ3JlbW92ZUxpc3RlbmVyJywgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgbGlzdGVuZXJzW2V2ZW50XT0gaGFuZGxlcjtcbiAgICAgICAgb2JzZXJ2ZXIuX29uLmNhbGwodGFyZ2V0LCBldmVudCwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbihldmVudCl7XG4gICAgICB2YXIgb2JzZXJ2ZXI9IHRoaXM7XG4gICAgICB2YXIgbGlzdGVuZXJzPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICB2YXIgZW1pdHRlcj0gdGhpcy5fZW1pdHRlcjtcbiAgICAgIHZhciBoYW5kbGVyO1xuICAgICAgdmFyIGV2ZW50cztcbiAgICAgIHZhciBvZmY9IHRoaXMuX29mZjtcbiAgICAgIHZhciB0YXJnZXQ9IHRoaXMuX3RhcmdldDtcbiAgICAgIHZhciBpO1xuXG4gICAgICBpZihldmVudCAmJiB0eXBlb2YgZXZlbnQhPT0nc3RyaW5nJyl7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignZXZlbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbGVhclJlZnMoKXtcbiAgICAgICAgaWYob2JzZXJ2ZXIuX29uTmV3TGlzdGVuZXIpe1xuICAgICAgICAgIGVtaXR0ZXIub2ZmKCduZXdMaXN0ZW5lcicsIG9ic2VydmVyLl9vbk5ld0xpc3RlbmVyKTtcbiAgICAgICAgICBlbWl0dGVyLm9mZigncmVtb3ZlTGlzdGVuZXInLCBvYnNlcnZlci5fb25SZW1vdmVMaXN0ZW5lcik7XG4gICAgICAgICAgb2JzZXJ2ZXIuX29uTmV3TGlzdGVuZXI9IG51bGw7XG4gICAgICAgICAgb2JzZXJ2ZXIuX29uUmVtb3ZlTGlzdGVuZXI9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4PSBmaW5kVGFyZ2V0SW5kZXguY2FsbChlbWl0dGVyLCBvYnNlcnZlcik7XG4gICAgICAgIGVtaXR0ZXIuX29ic2VydmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuXG4gICAgICBpZihldmVudCl7XG4gICAgICAgIGhhbmRsZXI9IGxpc3RlbmVyc1tldmVudF07XG4gICAgICAgIGlmKCFoYW5kbGVyKSByZXR1cm47XG4gICAgICAgIG9mZi5jYWxsKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICBkZWxldGUgbGlzdGVuZXJzW2V2ZW50XTtcbiAgICAgICAgaWYoIS0tdGhpcy5fbGlzdGVuZXJzQ291bnQpe1xuICAgICAgICAgIGNsZWFyUmVmcygpO1xuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgZXZlbnRzPSBvd25LZXlzKGxpc3RlbmVycyk7XG4gICAgICAgIGk9IGV2ZW50cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlKGktLT4wKXtcbiAgICAgICAgICBldmVudD0gZXZlbnRzW2ldO1xuICAgICAgICAgIG9mZi5jYWxsKHRhcmdldCwgZXZlbnQsIGxpc3RlbmVyc1tldmVudF0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycz0ge307XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc0NvdW50PSAwO1xuICAgICAgICBjbGVhclJlZnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgcmVkdWNlcnMsIGFsbG93VW5rbm93bikge1xuICAgIHZhciBjb21wdXRlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBzY2hlbWEpO1xuXG4gICAgaWYgKCFvcHRpb25zKSByZXR1cm4gY29tcHV0ZWRPcHRpb25zO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0JylcbiAgICB9XG5cbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgb3B0aW9uLCB2YWx1ZTtcbiAgICB2YXIgcmVkdWNlcjtcblxuICAgIGZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIFwiJyArIG9wdGlvbiArICdcIiBvcHRpb24gdmFsdWUnICsgKHJlYXNvbiA/ICcuIFJlYXNvbjogJyArIHJlYXNvbiA6ICcnKSlcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBvcHRpb24gPSBrZXlzW2ldO1xuICAgICAgaWYgKCFhbGxvd1Vua25vd24gJiYgIWhhc093blByb3BlcnR5LmNhbGwoc2NoZW1hLCBvcHRpb24pKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdVbmtub3duIFwiJyArIG9wdGlvbiArICdcIiBvcHRpb24nKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gb3B0aW9uc1tvcHRpb25dO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVkdWNlciA9IHJlZHVjZXJzW29wdGlvbl07XG4gICAgICAgIGNvbXB1dGVkT3B0aW9uc1tvcHRpb25dID0gcmVkdWNlciA/IHJlZHVjZXIodmFsdWUsIHJlamVjdCkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbXB1dGVkT3B0aW9ucztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0cnVjdG9yUmVkdWNlcih2YWx1ZSwgcmVqZWN0KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyB8fCAhdmFsdWUuaGFzT3duUHJvcGVydHkoJ3Byb3RvdHlwZScpKSB7XG4gICAgICByZWplY3QoJ3ZhbHVlIG11c3QgYmUgYSBjb25zdHJ1Y3RvcicpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlVHlwZVJlZHVjZXIodHlwZXMpIHtcbiAgICB2YXIgbWVzc2FnZT0gJ3ZhbHVlIG11c3QgYmUgdHlwZSBvZiAnICsgdHlwZXMuam9pbignfCcpO1xuICAgIHZhciBsZW49IHR5cGVzLmxlbmd0aDtcbiAgICB2YXIgZmlyc3RUeXBlPSB0eXBlc1swXTtcbiAgICB2YXIgc2Vjb25kVHlwZT0gdHlwZXNbMV07XG5cbiAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHYsIHJlamVjdCkge1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09IGZpcnN0VHlwZSkge1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICAgIHJlamVjdChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGVuID09PSAyKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHYsIHJlamVjdCkge1xuICAgICAgICB2YXIga2luZD0gdHlwZW9mIHY7XG4gICAgICAgIGlmIChraW5kID09PSBmaXJzdFR5cGUgfHwga2luZCA9PT0gc2Vjb25kVHlwZSkgcmV0dXJuIHY7XG4gICAgICAgIHJlamVjdChtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKHYsIHJlamVjdCkge1xuICAgICAgdmFyIGtpbmQgPSB0eXBlb2YgdjtcbiAgICAgIHZhciBpID0gbGVuO1xuICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgaWYgKGtpbmQgPT09IHR5cGVzW2ldKSByZXR1cm4gdjtcbiAgICAgIH1cbiAgICAgIHJlamVjdChtZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZnVuY3Rpb25SZWR1Y2VyPSBtYWtlVHlwZVJlZHVjZXIoWydmdW5jdGlvbiddKTtcblxuICB2YXIgb2JqZWN0RnVuY3Rpb25SZWR1Y2VyPSBtYWtlVHlwZVJlZHVjZXIoWydvYmplY3QnLCAnZnVuY3Rpb24nXSk7XG5cbiAgZnVuY3Rpb24gbWFrZUNhbmNlbGFibGVQcm9taXNlKFByb21pc2UsIGV4ZWN1dG9yLCBvcHRpb25zKSB7XG4gICAgdmFyIGlzQ2FuY2VsYWJsZTtcbiAgICB2YXIgY2FsbGJhY2tzO1xuICAgIHZhciB0aW1lcj0gMDtcbiAgICB2YXIgc3Vic2NyaXB0aW9uQ2xvc2VkO1xuXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBvbkNhbmNlbCkge1xuICAgICAgb3B0aW9ucz0gcmVzb2x2ZU9wdGlvbnMob3B0aW9ucywge1xuICAgICAgICB0aW1lb3V0OiAwLFxuICAgICAgICBvdmVybG9hZDogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgdGltZW91dDogZnVuY3Rpb24odmFsdWUsIHJlamVjdCl7XG4gICAgICAgICAgdmFsdWUqPSAxO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInIHx8IHZhbHVlIDwgMCB8fCAhTnVtYmVyLmlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmVqZWN0KCd0aW1lb3V0IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaXNDYW5jZWxhYmxlID0gIW9wdGlvbnMub3ZlcmxvYWQgJiYgdHlwZW9mIFByb21pc2UucHJvdG90eXBlLmNhbmNlbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb25DYW5jZWwgPT09ICdmdW5jdGlvbic7XG5cbiAgICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICBjYWxsYmFja3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgdGltZXIgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfcmVzb2x2ZT0gZnVuY3Rpb24odmFsdWUpe1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgdmFyIF9yZWplY3Q9IGZ1bmN0aW9uKGVycil7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9O1xuXG4gICAgICBpZiAoaXNDYW5jZWxhYmxlKSB7XG4gICAgICAgIGV4ZWN1dG9yKF9yZXNvbHZlLCBfcmVqZWN0LCBvbkNhbmNlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFja3MgPSBbZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgICBfcmVqZWN0KHJlYXNvbiB8fCBFcnJvcignY2FuY2VsZWQnKSk7XG4gICAgICAgIH1dO1xuICAgICAgICBleGVjdXRvcihfcmVzb2x2ZSwgX3JlamVjdCwgZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbkNsb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1VuYWJsZSB0byBzdWJzY3JpYmUgb24gY2FuY2VsIGV2ZW50IGFzeW5jaHJvbm91c2x5JylcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdvbkNhbmNlbCBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3Vic2NyaXB0aW9uQ2xvc2VkPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy50aW1lb3V0ID4gMCkge1xuICAgICAgICB0aW1lcj0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciByZWFzb249IEVycm9yKCd0aW1lb3V0Jyk7XG4gICAgICAgICAgcmVhc29uLmNvZGUgPSAnRVRJTUVET1VUJ1xuICAgICAgICAgIHRpbWVyPSAwO1xuICAgICAgICAgIHByb21pc2UuY2FuY2VsKHJlYXNvbik7XG4gICAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0sIG9wdGlvbnMudGltZW91dCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoIWlzQ2FuY2VsYWJsZSkge1xuICAgICAgcHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2tzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsZW5ndGggPSBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY2FsbGJhY2tzW2ldKHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW50ZXJuYWwgY2FsbGJhY2sgdG8gcmVqZWN0IHRoZSBwcm9taXNlXG4gICAgICAgIGNhbGxiYWNrc1swXShyZWFzb24pO1xuICAgICAgICBjYWxsYmFja3MgPSBudWxsO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRUYXJnZXRJbmRleChvYnNlcnZlcikge1xuICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLl9vYnNlcnZlcnM7XG4gICAgaWYoIW9ic2VydmVycyl7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIHZhciBsZW4gPSBvYnNlcnZlcnMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChvYnNlcnZlcnNbaV0uX3RhcmdldCA9PT0gb2JzZXJ2ZXIpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvLyBBdHRlbnRpb24sIGZ1bmN0aW9uIHJldHVybiB0eXBlIG5vdyBpcyBhcnJheSwgYWx3YXlzICFcbiAgLy8gSXQgaGFzIHplcm8gZWxlbWVudHMgaWYgbm8gYW55IG1hdGNoZXMgZm91bmQgYW5kIG9uZSBvciBtb3JlXG4gIC8vIGVsZW1lbnRzIChsZWFmcykgaWYgdGhlcmUgYXJlIG1hdGNoZXNcbiAgLy9cbiAgZnVuY3Rpb24gc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlLCBpLCB0eXBlTGVuZ3RoKSB7XG4gICAgaWYgKCF0cmVlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgdmFyIGtpbmQgPSB0eXBlb2YgdHlwZTtcbiAgICAgIGlmIChraW5kID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgbnMsIG4sIGwgPSAwLCBqID0gMCwgZGVsaW1pdGVyID0gdGhpcy5kZWxpbWl0ZXIsIGRsID0gZGVsaW1pdGVyLmxlbmd0aDtcbiAgICAgICAgaWYgKChuID0gdHlwZS5pbmRleE9mKGRlbGltaXRlcikpICE9PSAtMSkge1xuICAgICAgICAgIG5zID0gbmV3IEFycmF5KDUpO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIG5zW2wrK10gPSB0eXBlLnNsaWNlKGosIG4pO1xuICAgICAgICAgICAgaiA9IG4gKyBkbDtcbiAgICAgICAgICB9IHdoaWxlICgobiA9IHR5cGUuaW5kZXhPZihkZWxpbWl0ZXIsIGopKSAhPT0gLTEpO1xuXG4gICAgICAgICAgbnNbbCsrXSA9IHR5cGUuc2xpY2Uoaik7XG4gICAgICAgICAgdHlwZSA9IG5zO1xuICAgICAgICAgIHR5cGVMZW5ndGggPSBsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR5cGUgPSBbdHlwZV07XG4gICAgICAgICAgdHlwZUxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdHlwZUxlbmd0aCA9IHR5cGUubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICAgICAgdHlwZUxlbmd0aCA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycz0gbnVsbCwgYnJhbmNoLCB4VHJlZSwgeHhUcmVlLCBpc29sYXRlZEJyYW5jaCwgZW5kUmVhY2hlZCwgY3VycmVudFR5cGUgPSB0eXBlW2ldLFxuICAgICAgICBuZXh0VHlwZSA9IHR5cGVbaSArIDFdLCBicmFuY2hlcywgX2xpc3RlbmVycztcblxuICAgIGlmIChpID09PSB0eXBlTGVuZ3RoKSB7XG4gICAgICAvL1xuICAgICAgLy8gSWYgYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQocykgbGlzdCBhbmQgdGhlIHRyZWUgaGFzIGxpc3RlbmVyc1xuICAgICAgLy8gaW52b2tlIHRob3NlIGxpc3RlbmVycy5cbiAgICAgIC8vXG5cbiAgICAgIGlmKHRyZWUuX2xpc3RlbmVycykge1xuICAgICAgICBpZiAodHlwZW9mIHRyZWUuX2xpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGhhbmRsZXJzICYmIGhhbmRsZXJzLnB1c2godHJlZS5fbGlzdGVuZXJzKTtcbiAgICAgICAgICBsaXN0ZW5lcnMgPSBbdHJlZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlcnMgJiYgaGFuZGxlcnMucHVzaC5hcHBseShoYW5kbGVycywgdHJlZS5fbGlzdGVuZXJzKTtcbiAgICAgICAgICBsaXN0ZW5lcnMgPSBbdHJlZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiAoY3VycmVudFR5cGUgPT09ICcqJykge1xuICAgICAgICAvL1xuICAgICAgICAvLyBJZiB0aGUgZXZlbnQgZW1pdHRlZCBpcyAnKicgYXQgdGhpcyBwYXJ0XG4gICAgICAgIC8vIG9yIHRoZXJlIGlzIGEgY29uY3JldGUgbWF0Y2ggYXQgdGhpcyBwYXRjaFxuICAgICAgICAvL1xuICAgICAgICBicmFuY2hlcyA9IG93bktleXModHJlZSk7XG4gICAgICAgIG4gPSBicmFuY2hlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChuLS0gPiAwKSB7XG4gICAgICAgICAgYnJhbmNoID0gYnJhbmNoZXNbbl07XG4gICAgICAgICAgaWYgKGJyYW5jaCAhPT0gJ19saXN0ZW5lcnMnKSB7XG4gICAgICAgICAgICBfbGlzdGVuZXJzID0gc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2JyYW5jaF0sIGkgKyAxLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChfbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaC5hcHBseShsaXN0ZW5lcnMsIF9saXN0ZW5lcnMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycyA9IF9saXN0ZW5lcnM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3RlbmVycztcbiAgICAgIH0gZWxzZSBpZiAoY3VycmVudFR5cGUgPT09ICcqKicpIHtcbiAgICAgICAgZW5kUmVhY2hlZCA9IChpICsgMSA9PT0gdHlwZUxlbmd0aCB8fCAoaSArIDIgPT09IHR5cGVMZW5ndGggJiYgbmV4dFR5cGUgPT09ICcqJykpO1xuICAgICAgICBpZiAoZW5kUmVhY2hlZCAmJiB0cmVlLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAvLyBUaGUgbmV4dCBlbGVtZW50IGhhcyBhIF9saXN0ZW5lcnMsIGFkZCBpdCB0byB0aGUgaGFuZGxlcnMuXG4gICAgICAgICAgbGlzdGVuZXJzID0gc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlLCB0eXBlTGVuZ3RoLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyYW5jaGVzID0gb3duS2V5cyh0cmVlKTtcbiAgICAgICAgbiA9IGJyYW5jaGVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKG4tLSA+IDApIHtcbiAgICAgICAgICBicmFuY2ggPSBicmFuY2hlc1tuXTtcbiAgICAgICAgICBpZiAoYnJhbmNoICE9PSAnX2xpc3RlbmVycycpIHtcbiAgICAgICAgICAgIGlmIChicmFuY2ggPT09ICcqJyB8fCBicmFuY2ggPT09ICcqKicpIHtcbiAgICAgICAgICAgICAgaWYgKHRyZWVbYnJhbmNoXS5fbGlzdGVuZXJzICYmICFlbmRSZWFjaGVkKSB7XG4gICAgICAgICAgICAgICAgX2xpc3RlbmVycyA9IHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCB0eXBlTGVuZ3RoLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoX2xpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMucHVzaC5hcHBseShsaXN0ZW5lcnMsIF9saXN0ZW5lcnMpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzID0gX2xpc3RlbmVycztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2xpc3RlbmVycyA9IHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVticmFuY2hdLCBpLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYnJhbmNoID09PSBuZXh0VHlwZSkge1xuICAgICAgICAgICAgICBfbGlzdGVuZXJzID0gc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB0cmVlW2JyYW5jaF0sIGkgKyAyLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE5vIG1hdGNoIG9uIHRoaXMgb25lLCBzaGlmdCBpbnRvIHRoZSB0cmVlIGJ1dCBub3QgaW4gdGhlIHR5cGUgYXJyYXkuXG4gICAgICAgICAgICAgIF9saXN0ZW5lcnMgPSBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHRyZWVbYnJhbmNoXSwgaSwgdHlwZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX2xpc3RlbmVycykge1xuICAgICAgICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2guYXBwbHkobGlzdGVuZXJzLCBfbGlzdGVuZXJzKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnMgPSBfbGlzdGVuZXJzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0ZW5lcnM7XG4gICAgICB9IGVsc2UgaWYgKHRyZWVbY3VycmVudFR5cGVdKSB7XG4gICAgICAgIGxpc3RlbmVycyA9IHNlYXJjaExpc3RlbmVyVHJlZShoYW5kbGVycywgdHlwZSwgdHJlZVtjdXJyZW50VHlwZV0sIGkgKyAxLCB0eXBlTGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAgIHhUcmVlID0gdHJlZVsnKiddO1xuICAgIGlmICh4VHJlZSkge1xuICAgICAgLy9cbiAgICAgIC8vIElmIHRoZSBsaXN0ZW5lciB0cmVlIHdpbGwgYWxsb3cgYW55IG1hdGNoIGZvciB0aGlzIHBhcnQsXG4gICAgICAvLyB0aGVuIHJlY3Vyc2l2ZWx5IGV4cGxvcmUgYWxsIGJyYW5jaGVzIG9mIHRoZSB0cmVlXG4gICAgICAvL1xuICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4VHJlZSwgaSArIDEsIHR5cGVMZW5ndGgpO1xuICAgIH1cblxuICAgIHh4VHJlZSA9IHRyZWVbJyoqJ107XG4gICAgaWYgKHh4VHJlZSkge1xuICAgICAgaWYgKGkgPCB0eXBlTGVuZ3RoKSB7XG4gICAgICAgIGlmICh4eFRyZWUuX2xpc3RlbmVycykge1xuICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBsaXN0ZW5lciBvbiBhICcqKicsIGl0IHdpbGwgY2F0Y2ggYWxsLCBzbyBhZGQgaXRzIGhhbmRsZXIuXG4gICAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWUsIHR5cGVMZW5ndGgsIHR5cGVMZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQnVpbGQgYXJyYXlzIG9mIG1hdGNoaW5nIG5leHQgYnJhbmNoZXMgYW5kIG90aGVycy5cbiAgICAgICAgYnJhbmNoZXM9IG93bktleXMoeHhUcmVlKTtcbiAgICAgICAgbj0gYnJhbmNoZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZShuLS0+MCl7XG4gICAgICAgICAgYnJhbmNoPSBicmFuY2hlc1tuXTtcbiAgICAgICAgICBpZiAoYnJhbmNoICE9PSAnX2xpc3RlbmVycycpIHtcbiAgICAgICAgICAgIGlmIChicmFuY2ggPT09IG5leHRUeXBlKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGtub3cgdGhlIG5leHQgZWxlbWVudCB3aWxsIG1hdGNoLCBzbyBqdW1wIHR3aWNlLlxuICAgICAgICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHh4VHJlZVticmFuY2hdLCBpICsgMiwgdHlwZUxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJyYW5jaCA9PT0gY3VycmVudFR5cGUpIHtcbiAgICAgICAgICAgICAgLy8gQ3VycmVudCBub2RlIG1hdGNoZXMsIG1vdmUgaW50byB0aGUgdHJlZS5cbiAgICAgICAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWVbYnJhbmNoXSwgaSArIDEsIHR5cGVMZW5ndGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXNvbGF0ZWRCcmFuY2ggPSB7fTtcbiAgICAgICAgICAgICAgaXNvbGF0ZWRCcmFuY2hbYnJhbmNoXSA9IHh4VHJlZVticmFuY2hdO1xuICAgICAgICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHsnKionOiBpc29sYXRlZEJyYW5jaH0sIGkgKyAxLCB0eXBlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoeHhUcmVlLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSByZWFjaGVkIHRoZSBlbmQgYW5kIHN0aWxsIG9uIGEgJyoqJ1xuICAgICAgICBzZWFyY2hMaXN0ZW5lclRyZWUoaGFuZGxlcnMsIHR5cGUsIHh4VHJlZSwgdHlwZUxlbmd0aCwgdHlwZUxlbmd0aCk7XG4gICAgICB9IGVsc2UgaWYgKHh4VHJlZVsnKiddICYmIHh4VHJlZVsnKiddLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlKGhhbmRsZXJzLCB0eXBlLCB4eFRyZWVbJyonXSwgdHlwZUxlbmd0aCwgdHlwZUxlbmd0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpc3RlbmVycztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdyb3dMaXN0ZW5lclRyZWUodHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgICB2YXIgbGVuID0gMCwgaiA9IDAsIGksIGRlbGltaXRlciA9IHRoaXMuZGVsaW1pdGVyLCBkbD0gZGVsaW1pdGVyLmxlbmd0aCwgbnM7XG5cbiAgICBpZih0eXBlb2YgdHlwZT09PSdzdHJpbmcnKSB7XG4gICAgICBpZiAoKGkgPSB0eXBlLmluZGV4T2YoZGVsaW1pdGVyKSkgIT09IC0xKSB7XG4gICAgICAgIG5zID0gbmV3IEFycmF5KDUpO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgbnNbbGVuKytdID0gdHlwZS5zbGljZShqLCBpKTtcbiAgICAgICAgICBqID0gaSArIGRsO1xuICAgICAgICB9IHdoaWxlICgoaSA9IHR5cGUuaW5kZXhPZihkZWxpbWl0ZXIsIGopKSAhPT0gLTEpO1xuXG4gICAgICAgIG5zW2xlbisrXSA9IHR5cGUuc2xpY2Uoaik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgbnM9IFt0eXBlXTtcbiAgICAgICAgbGVuPSAxO1xuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgbnM9IHR5cGU7XG4gICAgICBsZW49IHR5cGUubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gTG9va3MgZm9yIHR3byBjb25zZWN1dGl2ZSAnKionLCBpZiBzbywgZG9uJ3QgYWRkIHRoZSBldmVudCBhdCBhbGwuXG4gICAgLy9cbiAgICBpZiAobGVuID4gMSkge1xuICAgICAgZm9yIChpID0gMDsgaSArIDEgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAobnNbaV0gPT09ICcqKicgJiYgbnNbaSArIDFdID09PSAnKionKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG5cblxuICAgIHZhciB0cmVlID0gdGhpcy5saXN0ZW5lclRyZWUsIG5hbWU7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG5hbWUgPSBuc1tpXTtcblxuICAgICAgdHJlZSA9IHRyZWVbbmFtZV0gfHwgKHRyZWVbbmFtZV0gPSB7fSk7XG5cbiAgICAgIGlmIChpID09PSBsZW4gLSAxKSB7XG4gICAgICAgIGlmICghdHJlZS5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgdHJlZS5fbGlzdGVuZXJzID0gbGlzdGVuZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0cmVlLl9saXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRyZWUuX2xpc3RlbmVycyA9IFt0cmVlLl9saXN0ZW5lcnNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICAgICAgICB0cmVlLl9saXN0ZW5lcnMudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyZWUuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICF0cmVlLl9saXN0ZW5lcnMud2FybmVkICYmXG4gICAgICAgICAgICAgIHRoaXMuX21heExpc3RlbmVycyA+IDAgJiZcbiAgICAgICAgICAgICAgdHJlZS5fbGlzdGVuZXJzLmxlbmd0aCA+IHRoaXMuX21heExpc3RlbmVyc1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgdHJlZS5fbGlzdGVuZXJzLndhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICBsb2dQb3NzaWJsZU1lbW9yeUxlYWsuY2FsbCh0aGlzLCB0cmVlLl9saXN0ZW5lcnMubGVuZ3RoLCBuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBjb2xsZWN0VHJlZUV2ZW50cyh0cmVlLCBldmVudHMsIHJvb3QsIGFzQXJyYXkpe1xuICAgICB2YXIgYnJhbmNoZXM9IG93bktleXModHJlZSk7XG4gICAgIHZhciBpPSBicmFuY2hlcy5sZW5ndGg7XG4gICAgIHZhciBicmFuY2gsIGJyYW5jaE5hbWUsIHBhdGg7XG4gICAgIHZhciBoYXNMaXN0ZW5lcnM9IHRyZWVbJ19saXN0ZW5lcnMnXTtcbiAgICAgdmFyIGlzQXJyYXlQYXRoO1xuXG4gICAgIHdoaWxlKGktLT4wKXtcbiAgICAgICAgIGJyYW5jaE5hbWU9IGJyYW5jaGVzW2ldO1xuXG4gICAgICAgICBicmFuY2g9IHRyZWVbYnJhbmNoTmFtZV07XG5cbiAgICAgICAgIGlmKGJyYW5jaE5hbWU9PT0nX2xpc3RlbmVycycpe1xuICAgICAgICAgICAgIHBhdGg9IHJvb3Q7XG4gICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgcGF0aCA9IHJvb3QgPyByb290LmNvbmNhdChicmFuY2hOYW1lKSA6IFticmFuY2hOYW1lXTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaXNBcnJheVBhdGg9IGFzQXJyYXkgfHwgdHlwZW9mIGJyYW5jaE5hbWU9PT0nc3ltYm9sJztcblxuICAgICAgICAgaGFzTGlzdGVuZXJzICYmIGV2ZW50cy5wdXNoKGlzQXJyYXlQYXRoPyBwYXRoIDogcGF0aC5qb2luKHRoaXMuZGVsaW1pdGVyKSk7XG5cbiAgICAgICAgIGlmKHR5cGVvZiBicmFuY2g9PT0nb2JqZWN0Jyl7XG4gICAgICAgICAgICAgY29sbGVjdFRyZWVFdmVudHMuY2FsbCh0aGlzLCBicmFuY2gsIGV2ZW50cywgcGF0aCwgaXNBcnJheVBhdGgpO1xuICAgICAgICAgfVxuICAgICB9XG5cbiAgICAgcmV0dXJuIGV2ZW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5R2FyYmFnZUNvbGxlY3Qocm9vdCkge1xuICAgIHZhciBrZXlzID0gb3duS2V5cyhyb290KTtcbiAgICB2YXIgaT0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIG9iaiwga2V5LCBmbGFnO1xuICAgIHdoaWxlKGktLT4wKXtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBvYmogPSByb290W2tleV07XG5cbiAgICAgIGlmKG9iail7XG4gICAgICAgICAgZmxhZz0gdHJ1ZTtcbiAgICAgICAgICBpZihrZXkgIT09ICdfbGlzdGVuZXJzJyAmJiAhcmVjdXJzaXZlbHlHYXJiYWdlQ29sbGVjdChvYmopKXtcbiAgICAgICAgICAgICBkZWxldGUgcm9vdFtrZXldO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmxhZztcbiAgfVxuXG4gIGZ1bmN0aW9uIExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBsaXN0ZW5lcil7XG4gICAgdGhpcy5lbWl0dGVyPSBlbWl0dGVyO1xuICAgIHRoaXMuZXZlbnQ9IGV2ZW50O1xuICAgIHRoaXMubGlzdGVuZXI9IGxpc3RlbmVyO1xuICB9XG5cbiAgTGlzdGVuZXIucHJvdG90eXBlLm9mZj0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmVtaXR0ZXIub2ZmKHRoaXMuZXZlbnQsIHRoaXMubGlzdGVuZXIpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNldHVwTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBvcHRpb25zKXtcbiAgICAgIGlmIChvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgIHByb21pc2lmeSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIGFzeW5jID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ29wdGlvbnMgc2hvdWxkIGJlIGFuIG9iamVjdCBvciB0cnVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFzeW5jID0gb3B0aW9ucy5hc3luYztcbiAgICAgICAgdmFyIHByb21pc2lmeSA9IG9wdGlvbnMucHJvbWlzaWZ5O1xuICAgICAgICB2YXIgbmV4dFRpY2sgPSBvcHRpb25zLm5leHRUaWNrO1xuICAgICAgICB2YXIgb2JqZWN0aWZ5ID0gb3B0aW9ucy5vYmplY3RpZnk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhc3luYyB8fCBuZXh0VGljayB8fCBwcm9taXNpZnkpIHtcbiAgICAgICAgdmFyIF9saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB2YXIgX29yaWdpbiA9IGxpc3RlbmVyLl9vcmlnaW4gfHwgbGlzdGVuZXI7XG5cbiAgICAgICAgaWYgKG5leHRUaWNrICYmICFuZXh0VGlja1N1cHBvcnRlZCkge1xuICAgICAgICAgIHRocm93IEVycm9yKCdwcm9jZXNzLm5leHRUaWNrIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9taXNpZnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb21pc2lmeSA9IGxpc3RlbmVyLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBc3luY0Z1bmN0aW9uJztcbiAgICAgICAgfVxuXG4gICAgICAgIGxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgICAgICB2YXIgZXZlbnQgPSB0aGlzLmV2ZW50O1xuXG4gICAgICAgICAgcmV0dXJuIHByb21pc2lmeSA/IChuZXh0VGljayA/IFByb21pc2UucmVzb2x2ZSgpIDogbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgIF9zZXRJbW1lZGlhdGUocmVzb2x2ZSk7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb250ZXh0LmV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2xpc3RlbmVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpXG4gICAgICAgICAgfSkpIDogKG5leHRUaWNrID8gcHJvY2Vzcy5uZXh0VGljayA6IF9zZXRJbW1lZGlhdGUpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgIF9saXN0ZW5lci5hcHBseShjb250ZXh0LCBhcmdzKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGxpc3RlbmVyLl9hc3luYyA9IHRydWU7XG4gICAgICAgIGxpc3RlbmVyLl9vcmlnaW4gPSBfb3JpZ2luO1xuICAgICAgfVxuXG4gICAgcmV0dXJuIFtsaXN0ZW5lciwgb2JqZWN0aWZ5PyBuZXcgTGlzdGVuZXIodGhpcywgZXZlbnQsIGxpc3RlbmVyKTogdGhpc107XG4gIH1cblxuICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoY29uZikge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHRoaXMuX25ld0xpc3RlbmVyID0gZmFsc2U7XG4gICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXIgPSBmYWxzZTtcbiAgICB0aGlzLnZlcmJvc2VNZW1vcnlMZWFrID0gZmFsc2U7XG4gICAgY29uZmlndXJlLmNhbGwodGhpcywgY29uZik7XG4gIH1cblxuICBFdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyMiA9IEV2ZW50RW1pdHRlcjsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIGV4cG9ydGluZyBFdmVudEVtaXR0ZXIgcHJvcGVydHlcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlblRvPSBmdW5jdGlvbih0YXJnZXQsIGV2ZW50cywgb3B0aW9ucyl7XG4gICAgaWYodHlwZW9mIHRhcmdldCE9PSdvYmplY3QnKXtcbiAgICAgIHRocm93IFR5cGVFcnJvcigndGFyZ2V0IG11c3RzIGJlIGFuIG9iamVjdCcpO1xuICAgIH1cblxuICAgIHZhciBlbWl0dGVyPSB0aGlzO1xuXG4gICAgb3B0aW9ucyA9IHJlc29sdmVPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIG9uOiB1bmRlZmluZWQsXG4gICAgICBvZmY6IHVuZGVmaW5lZCxcbiAgICAgIHJlZHVjZXJzOiB1bmRlZmluZWRcbiAgICB9LCB7XG4gICAgICBvbjogZnVuY3Rpb25SZWR1Y2VyLFxuICAgICAgb2ZmOiBmdW5jdGlvblJlZHVjZXIsXG4gICAgICByZWR1Y2Vyczogb2JqZWN0RnVuY3Rpb25SZWR1Y2VyXG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW4oZXZlbnRzKXtcbiAgICAgIGlmKHR5cGVvZiBldmVudHMhPT0nb2JqZWN0Jyl7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignZXZlbnRzIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWR1Y2Vycz0gb3B0aW9ucy5yZWR1Y2VycztcbiAgICAgIHZhciBpbmRleD0gZmluZFRhcmdldEluZGV4LmNhbGwoZW1pdHRlciwgdGFyZ2V0KTtcbiAgICAgIHZhciBvYnNlcnZlcjtcblxuICAgICAgaWYoaW5kZXg9PT0tMSl7XG4gICAgICAgIG9ic2VydmVyPSBuZXcgVGFyZ2V0T2JzZXJ2ZXIoZW1pdHRlciwgdGFyZ2V0LCBvcHRpb25zKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBvYnNlcnZlcj0gZW1pdHRlci5fb2JzZXJ2ZXJzW2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXM9IG93bktleXMoZXZlbnRzKTtcbiAgICAgIHZhciBsZW49IGtleXMubGVuZ3RoO1xuICAgICAgdmFyIGV2ZW50O1xuICAgICAgdmFyIGlzU2luZ2xlUmVkdWNlcj0gdHlwZW9mIHJlZHVjZXJzPT09J2Z1bmN0aW9uJztcblxuICAgICAgZm9yKHZhciBpPTA7IGk8bGVuOyBpKyspe1xuICAgICAgICBldmVudD0ga2V5c1tpXTtcbiAgICAgICAgb2JzZXJ2ZXIuc3Vic2NyaWJlKFxuICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICBldmVudHNbZXZlbnRdIHx8IGV2ZW50LFxuICAgICAgICAgICAgaXNTaW5nbGVSZWR1Y2VyID8gcmVkdWNlcnMgOiByZWR1Y2VycyAmJiByZWR1Y2Vyc1tldmVudF1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc0FycmF5KGV2ZW50cyk/XG4gICAgICAgIGxpc3Rlbih0b09iamVjdChldmVudHMpKSA6XG4gICAgICAgICh0eXBlb2YgZXZlbnRzPT09J3N0cmluZyc/IGxpc3Rlbih0b09iamVjdChldmVudHMuc3BsaXQoL1xccysvKSkpOiBsaXN0ZW4oZXZlbnRzKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnN0b3BMaXN0ZW5pbmdUbyA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50KSB7XG4gICAgdmFyIG9ic2VydmVycyA9IHRoaXMuX29ic2VydmVycztcblxuICAgIGlmKCFvYnNlcnZlcnMpe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICB2YXIgb2JzZXJ2ZXI7XG4gICAgdmFyIG1hdGNoZWQ9IGZhbHNlO1xuXG4gICAgaWYodGFyZ2V0ICYmIHR5cGVvZiB0YXJnZXQhPT0nb2JqZWN0Jyl7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ3RhcmdldCBzaG91bGQgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgIG9ic2VydmVyID0gb2JzZXJ2ZXJzW2ldO1xuICAgICAgaWYgKCF0YXJnZXQgfHwgb2JzZXJ2ZXIuX3RhcmdldCA9PT0gdGFyZ2V0KSB7XG4gICAgICAgIG9ic2VydmVyLnVuc3Vic2NyaWJlKGV2ZW50KTtcbiAgICAgICAgbWF0Y2hlZD0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF0Y2hlZDtcbiAgfTtcblxuICAvLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuXG4gIC8vIDEwIGxpc3RlbmVycyBhcmUgYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaFxuICAvLyBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbiAgLy9cbiAgLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4gIC8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZGVsaW1pdGVyID0gJy4nO1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICAgIGlmIChuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gICAgICBpZiAoIXRoaXMuX2NvbmYpIHRoaXMuX2NvbmYgPSB7fTtcbiAgICAgIHRoaXMuX2NvbmYubWF4TGlzdGVuZXJzID0gbjtcbiAgICB9XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnQgPSAnJztcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fb25jZShldmVudCwgZm4sIGZhbHNlLCBvcHRpb25zKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fb25jZShldmVudCwgZm4sIHRydWUsIG9wdGlvbnMpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX29uY2UgPSBmdW5jdGlvbihldmVudCwgZm4sIHByZXBlbmQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFueShldmVudCwgMSwgZm4sIHByZXBlbmQsIG9wdGlvbnMpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubWFueSA9IGZ1bmN0aW9uKGV2ZW50LCB0dGwsIGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hbnkoZXZlbnQsIHR0bCwgZm4sIGZhbHNlLCBvcHRpb25zKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRNYW55ID0gZnVuY3Rpb24oZXZlbnQsIHR0bCwgZm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFueShldmVudCwgdHRsLCBmbiwgdHJ1ZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWFueSA9IGZ1bmN0aW9uKGV2ZW50LCB0dGwsIGZuLCBwcmVwZW5kLCBvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYW55IG9ubHkgYWNjZXB0cyBpbnN0YW5jZXMgb2YgRnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW5lcigpIHtcbiAgICAgIGlmICgtLXR0bCA9PT0gMCkge1xuICAgICAgICBzZWxmLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgbGlzdGVuZXIuX29yaWdpbiA9IGZuO1xuXG4gICAgcmV0dXJuIHRoaXMuX29uKGV2ZW50LCBsaXN0ZW5lciwgcHJlcGVuZCwgb3B0aW9ucyk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMgJiYgIXRoaXMuX2FsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuX2V2ZW50cyB8fCBpbml0LmNhbGwodGhpcyk7XG5cbiAgICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXSwgbnMsIHdpbGRjYXJkPSB0aGlzLndpbGRjYXJkO1xuICAgIHZhciBhcmdzLGwsaSxqLCBjb250YWluc1N5bWJvbDtcblxuICAgIGlmICh0eXBlID09PSAnbmV3TGlzdGVuZXInICYmICF0aGlzLl9uZXdMaXN0ZW5lcikge1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3aWxkY2FyZCkge1xuICAgICAgbnM9IHR5cGU7XG4gICAgICBpZih0eXBlIT09J25ld0xpc3RlbmVyJyAmJiB0eXBlIT09J3JlbW92ZUxpc3RlbmVyJyl7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBsID0gdHlwZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKHN5bWJvbHNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlW2ldID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5zU3ltYm9sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNvbnRhaW5zU3ltYm9sKSB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5qb2luKHRoaXMuZGVsaW1pdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWwgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciBoYW5kbGVyO1xuXG4gICAgaWYgKHRoaXMuX2FsbCAmJiB0aGlzLl9hbGwubGVuZ3RoKSB7XG4gICAgICBoYW5kbGVyID0gdGhpcy5fYWxsLnNsaWNlKCk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBoYW5kbGVyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcbiAgICAgICAgc3dpdGNoIChhbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaGFuZGxlcltpXS5jYWxsKHRoaXMsIHR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaGFuZGxlcltpXS5jYWxsKHRoaXMsIHR5cGUsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBoYW5kbGVyW2ldLmNhbGwodGhpcywgdHlwZSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGhhbmRsZXJbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh3aWxkY2FyZCkge1xuICAgICAgaGFuZGxlciA9IFtdO1xuICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlLmNhbGwodGhpcywgaGFuZGxlciwgbnMsIHRoaXMubGlzdGVuZXJUcmVlLCAwLCBsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcbiAgICAgICAgc3dpdGNoIChhbCkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYWwgLSAxKTtcbiAgICAgICAgICBmb3IgKGogPSAxOyBqIDwgYWw7IGorKykgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaGFuZGxlcikge1xuICAgICAgICAvLyBuZWVkIHRvIG1ha2UgY29weSBvZiBoYW5kbGVycyBiZWNhdXNlIGxpc3QgY2FuIGNoYW5nZSBpbiB0aGUgbWlkZGxlXG4gICAgICAgIC8vIG9mIGVtaXQgY2FsbFxuICAgICAgICBoYW5kbGVyID0gaGFuZGxlci5zbGljZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVyICYmIGhhbmRsZXIubGVuZ3RoKSB7XG4gICAgICBpZiAoYWwgPiAzKSB7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYWwgLSAxKTtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IGFsOyBqKyspIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMCwgbCA9IGhhbmRsZXIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZXZlbnQgPSB0eXBlO1xuICAgICAgICBzd2l0Y2ggKGFsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBoYW5kbGVyW2ldLmNhbGwodGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBoYW5kbGVyW2ldLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGhhbmRsZXJbaV0uY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaGFuZGxlcltpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICghdGhpcy5pZ25vcmVFcnJvcnMgJiYgIXRoaXMuX2FsbCAmJiB0eXBlID09PSAnZXJyb3InKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgYXJndW1lbnRzWzFdOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5jYXVnaHQsIHVuc3BlY2lmaWVkICdlcnJvcicgZXZlbnQuXCIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAhIXRoaXMuX2FsbDtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXRBc3luYyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fZXZlbnRzICYmICF0aGlzLl9hbGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9ldmVudHMgfHwgaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHR5cGUgPSBhcmd1bWVudHNbMF0sIHdpbGRjYXJkPSB0aGlzLndpbGRjYXJkLCBucywgY29udGFpbnNTeW1ib2w7XG4gICAgdmFyIGFyZ3MsbCxpLGo7XG5cbiAgICBpZiAodHlwZSA9PT0gJ25ld0xpc3RlbmVyJyAmJiAhdGhpcy5fbmV3TGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbZmFsc2VdKTsgfVxuICAgIH1cblxuICAgIGlmICh3aWxkY2FyZCkge1xuICAgICAgbnM9IHR5cGU7XG4gICAgICBpZih0eXBlIT09J25ld0xpc3RlbmVyJyAmJiB0eXBlIT09J3JlbW92ZUxpc3RlbmVyJyl7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBsID0gdHlwZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKHN5bWJvbHNTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlW2ldID09PSAnc3ltYm9sJykge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5zU3ltYm9sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWNvbnRhaW5zU3ltYm9sKSB7XG4gICAgICAgICAgICB0eXBlID0gdHlwZS5qb2luKHRoaXMuZGVsaW1pdGVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZXM9IFtdO1xuXG4gICAgdmFyIGFsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaGFuZGxlcjtcblxuICAgIGlmICh0aGlzLl9hbGwpIHtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSB0aGlzLl9hbGwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZXZlbnQgPSB0eXBlO1xuICAgICAgICBzd2l0Y2ggKGFsKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2FsbFtpXS5jYWxsKHRoaXMsIHR5cGUpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5fYWxsW2ldLmNhbGwodGhpcywgdHlwZSwgYXJndW1lbnRzWzFdKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHRoaXMuX2FsbFtpXS5jYWxsKHRoaXMsIHR5cGUsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLl9hbGxbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod2lsZGNhcmQpIHtcbiAgICAgIGhhbmRsZXIgPSBbXTtcbiAgICAgIHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIGhhbmRsZXIsIG5zLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLmV2ZW50ID0gdHlwZTtcbiAgICAgIHN3aXRjaCAoYWwpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyLmNhbGwodGhpcykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkoYWwgLSAxKTtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IGFsOyBqKyspIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXIuYXBwbHkodGhpcywgYXJncykpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFuZGxlciAmJiBoYW5kbGVyLmxlbmd0aCkge1xuICAgICAgaGFuZGxlciA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICAgIGlmIChhbCA+IDMpIHtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShhbCAtIDEpO1xuICAgICAgICBmb3IgKGogPSAxOyBqIDwgYWw7IGorKykgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwLCBsID0gaGFuZGxlci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5ldmVudCA9IHR5cGU7XG4gICAgICAgIHN3aXRjaCAoYWwpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlcltpXS5jYWxsKHRoaXMpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHByb21pc2VzLnB1c2goaGFuZGxlcltpXS5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgcHJvbWlzZXMucHVzaChoYW5kbGVyW2ldLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKGhhbmRsZXJbaV0uYXBwbHkodGhpcywgYXJncykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdGhpcy5pZ25vcmVFcnJvcnMgJiYgIXRoaXMuX2FsbCAmJiB0eXBlID09PSAnZXJyb3InKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGFyZ3VtZW50c1sxXSk7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJVbmNhdWdodCwgdW5zcGVjaWZpZWQgJ2Vycm9yJyBldmVudC5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fb24odHlwZSwgbGlzdGVuZXIsIGZhbHNlLCBvcHRpb25zKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX29uKHR5cGUsIGxpc3RlbmVyLCB0cnVlLCBvcHRpb25zKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uQW55ID0gZnVuY3Rpb24oZm4pIHtcbiAgICByZXR1cm4gdGhpcy5fb25BbnkoZm4sIGZhbHNlKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRBbnkgPSBmdW5jdGlvbihmbikge1xuICAgIHJldHVybiB0aGlzLl9vbkFueShmbiwgdHJ1ZSk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fb25BbnkgPSBmdW5jdGlvbihmbiwgcHJlcGVuZCl7XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbkFueSBvbmx5IGFjY2VwdHMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9hbGwpIHtcbiAgICAgIHRoaXMuX2FsbCA9IFtdO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZnVuY3Rpb24gdG8gdGhlIGV2ZW50IGxpc3RlbmVyIGNvbGxlY3Rpb24uXG4gICAgaWYocHJlcGVuZCl7XG4gICAgICB0aGlzLl9hbGwudW5zaGlmdChmbik7XG4gICAgfWVsc2V7XG4gICAgICB0aGlzLl9hbGwucHVzaChmbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fb24gPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fb25BbnkodHlwZSwgbGlzdGVuZXIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbiBvbmx5IGFjY2VwdHMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50cyB8fCBpbml0LmNhbGwodGhpcyk7XG5cbiAgICB2YXIgcmV0dXJuVmFsdWU9IHRoaXMsIHRlbXA7XG5cbiAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0ZW1wID0gc2V0dXBMaXN0ZW5lci5jYWxsKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgIGxpc3RlbmVyID0gdGVtcFswXTtcbiAgICAgIHJldHVyblZhbHVlID0gdGVtcFsxXTtcbiAgICB9XG5cbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09IFwibmV3TGlzdGVuZXJzXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJzXCIuXG4gICAgaWYgKHRoaXMuX25ld0xpc3RlbmVyKSB7XG4gICAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XG4gICAgICBncm93TGlzdGVuZXJUcmVlLmNhbGwodGhpcywgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpO1xuICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSB7XG4gICAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2V2ZW50c1t0eXBlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBDaGFuZ2UgdG8gYXJyYXkuXG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhZGRcbiAgICAgIGlmKHByZXBlbmQpe1xuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0udW5zaGlmdChsaXN0ZW5lcik7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgICAgaWYgKFxuICAgICAgICAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCAmJlxuICAgICAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPiAwICYmXG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiB0aGlzLl9tYXhMaXN0ZW5lcnNcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgbG9nUG9zc2libGVNZW1vcnlMZWFrLmNhbGwodGhpcywgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCwgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92ZUxpc3RlbmVyIG9ubHkgdGFrZXMgaW5zdGFuY2VzIG9mIEZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgdmFyIGhhbmRsZXJzLGxlYWZzPVtdO1xuXG4gICAgaWYodGhpcy53aWxkY2FyZCkge1xuICAgICAgdmFyIG5zID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZS5zcGxpdCh0aGlzLmRlbGltaXRlcikgOiB0eXBlLnNsaWNlKCk7XG4gICAgICBsZWFmcyA9IHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIG51bGwsIG5zLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCk7XG4gICAgICBpZighbGVhZnMpIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkb2VzIG5vdCB1c2UgbGlzdGVuZXJzKCksIHNvIG5vIHNpZGUgZWZmZWN0IG9mIGNyZWF0aW5nIF9ldmVudHNbdHlwZV1cbiAgICAgIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSByZXR1cm4gdGhpcztcbiAgICAgIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgICAgbGVhZnMucHVzaCh7X2xpc3RlbmVyczpoYW5kbGVyc30pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGlMZWFmPTA7IGlMZWFmPGxlYWZzLmxlbmd0aDsgaUxlYWYrKykge1xuICAgICAgdmFyIGxlYWYgPSBsZWFmc1tpTGVhZl07XG4gICAgICBoYW5kbGVycyA9IGxlYWYuX2xpc3RlbmVycztcbiAgICAgIGlmIChpc0FycmF5KGhhbmRsZXJzKSkge1xuXG4gICAgICAgIHZhciBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChoYW5kbGVyc1tpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAgIChoYW5kbGVyc1tpXS5saXN0ZW5lciAmJiBoYW5kbGVyc1tpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHx8XG4gICAgICAgICAgICAoaGFuZGxlcnNbaV0uX29yaWdpbiAmJiBoYW5kbGVyc1tpXS5fb3JpZ2luID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgICAgICBsZWFmLl9saXN0ZW5lcnMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0uc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYW5kbGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZih0aGlzLndpbGRjYXJkKSB7XG4gICAgICAgICAgICBkZWxldGUgbGVhZi5fbGlzdGVuZXJzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICB0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lclwiLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChoYW5kbGVycyA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgKGhhbmRsZXJzLmxpc3RlbmVyICYmIGhhbmRsZXJzLmxpc3RlbmVyID09PSBsaXN0ZW5lcikgfHxcbiAgICAgICAgKGhhbmRsZXJzLl9vcmlnaW4gJiYgaGFuZGxlcnMuX29yaWdpbiA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIGlmKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgICAgICBkZWxldGUgbGVhZi5fbGlzdGVuZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgIHRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsIHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxpc3RlbmVyVHJlZSAmJiByZWN1cnNpdmVseUdhcmJhZ2VDb2xsZWN0KHRoaXMubGlzdGVuZXJUcmVlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmQW55ID0gZnVuY3Rpb24oZm4pIHtcbiAgICB2YXIgaSA9IDAsIGwgPSAwLCBmbnM7XG4gICAgaWYgKGZuICYmIHRoaXMuX2FsbCAmJiB0aGlzLl9hbGwubGVuZ3RoID4gMCkge1xuICAgICAgZm5zID0gdGhpcy5fYWxsO1xuICAgICAgZm9yKGkgPSAwLCBsID0gZm5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZihmbiA9PT0gZm5zW2ldKSB7XG4gICAgICAgICAgZm5zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBpZiAodGhpcy5fcmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJyZW1vdmVMaXN0ZW5lckFueVwiLCBmbik7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm5zID0gdGhpcy5fYWxsO1xuICAgICAgaWYgKHRoaXMuX3JlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIGZvcihpID0gMCwgbCA9IGZucy5sZW5ndGg7IGkgPCBsOyBpKyspXG4gICAgICAgICAgdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJBbnlcIiwgZm5zW2ldKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FsbCA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmY7XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICF0aGlzLl9ldmVudHMgfHwgaW5pdC5jYWxsKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgIHZhciBsZWFmcyA9IHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIG51bGwsIHR5cGUsIHRoaXMubGlzdGVuZXJUcmVlLCAwKSwgbGVhZiwgaTtcbiAgICAgIGlmICghbGVhZnMpIHJldHVybiB0aGlzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlYWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxlYWYgPSBsZWFmc1tpXTtcbiAgICAgICAgbGVhZi5fbGlzdGVuZXJzID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMubGlzdGVuZXJUcmVlICYmIHJlY3Vyc2l2ZWx5R2FyYmFnZUNvbGxlY3QodGhpcy5saXN0ZW5lclRyZWUpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIF9ldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgdmFyIGtleXMsIGxpc3RlbmVycywgYWxsTGlzdGVuZXJzO1xuICAgIHZhciBpO1xuICAgIHZhciBsaXN0ZW5lclRyZWU7XG5cbiAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodGhpcy53aWxkY2FyZCkge1xuICAgICAgICB0aHJvdyBFcnJvcignZXZlbnQgbmFtZSByZXF1aXJlZCBmb3Igd2lsZGNhcmQgZW1pdHRlcicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV9ldmVudHMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBrZXlzID0gb3duS2V5cyhfZXZlbnRzKTtcbiAgICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGFsbExpc3RlbmVycyA9IFtdO1xuICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgbGlzdGVuZXJzID0gX2V2ZW50c1trZXlzW2ldXTtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBhbGxMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFsbExpc3RlbmVycy5wdXNoLmFwcGx5KGFsbExpc3RlbmVycywgbGlzdGVuZXJzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFsbExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMud2lsZGNhcmQpIHtcbiAgICAgICAgbGlzdGVuZXJUcmVlPSB0aGlzLmxpc3RlbmVyVHJlZTtcbiAgICAgICAgaWYoIWxpc3RlbmVyVHJlZSkgcmV0dXJuIFtdO1xuICAgICAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICAgICAgdmFyIG5zID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZS5zcGxpdCh0aGlzLmRlbGltaXRlcikgOiB0eXBlLnNsaWNlKCk7XG4gICAgICAgIHNlYXJjaExpc3RlbmVyVHJlZS5jYWxsKHRoaXMsIGhhbmRsZXJzLCBucywgbGlzdGVuZXJUcmVlLCAwKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXJzO1xuICAgICAgfVxuXG4gICAgICBpZiAoIV9ldmVudHMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBfZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAoIWxpc3RlbmVycykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJyA/IFtsaXN0ZW5lcnNdIDogbGlzdGVuZXJzO1xuICAgIH1cbiAgfTtcblxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbihuc0FzQXJyYXkpe1xuICAgIHZhciBfZXZlbnRzPSB0aGlzLl9ldmVudHM7XG4gICAgcmV0dXJuIHRoaXMud2lsZGNhcmQ/IGNvbGxlY3RUcmVlRXZlbnRzLmNhbGwodGhpcywgdGhpcy5saXN0ZW5lclRyZWUsIFtdLCBudWxsLCBuc0FzQXJyYXkpIDogKF9ldmVudHM/IG93bktleXMoX2V2ZW50cykgOiBbXSk7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG4gIH07XG5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIGlmICh0aGlzLndpbGRjYXJkKSB7XG4gICAgICB2YXIgaGFuZGxlcnMgPSBbXTtcbiAgICAgIHZhciBucyA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyA/IHR5cGUuc3BsaXQodGhpcy5kZWxpbWl0ZXIpIDogdHlwZS5zbGljZSgpO1xuICAgICAgc2VhcmNoTGlzdGVuZXJUcmVlLmNhbGwodGhpcywgaGFuZGxlcnMsIG5zLCB0aGlzLmxpc3RlbmVyVHJlZSwgMCk7XG4gICAgICByZXR1cm4gaGFuZGxlcnMubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICB2YXIgX2V2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICB2YXIgX2FsbCA9IHRoaXMuX2FsbDtcblxuICAgIHJldHVybiAhIShfYWxsICYmIF9hbGwubGVuZ3RoIHx8IF9ldmVudHMgJiYgKHR5cGUgPT09IHVuZGVmaW5lZCA/IG93bktleXMoX2V2ZW50cykubGVuZ3RoIDogX2V2ZW50c1t0eXBlXSkpO1xuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzQW55ID0gZnVuY3Rpb24oKSB7XG5cbiAgICBpZih0aGlzLl9hbGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hbGw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICB9O1xuXG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUud2FpdEZvciA9IGZ1bmN0aW9uIChldmVudCwgb3B0aW9ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvcHRpb25zO1xuICAgIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgb3B0aW9ucyA9IHt0aW1lb3V0OiBvcHRpb25zfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdGlvbnMgPSB7ZmlsdGVyOiBvcHRpb25zfTtcbiAgICB9XG5cbiAgICBvcHRpb25zPSByZXNvbHZlT3B0aW9ucyhvcHRpb25zLCB7XG4gICAgICB0aW1lb3V0OiAwLFxuICAgICAgZmlsdGVyOiB1bmRlZmluZWQsXG4gICAgICBoYW5kbGVFcnJvcjogZmFsc2UsXG4gICAgICBQcm9taXNlOiBQcm9taXNlLFxuICAgICAgb3ZlcmxvYWQ6IGZhbHNlXG4gICAgfSwge1xuICAgICAgZmlsdGVyOiBmdW5jdGlvblJlZHVjZXIsXG4gICAgICBQcm9taXNlOiBjb25zdHJ1Y3RvclJlZHVjZXJcbiAgICB9KTtcblxuICAgIHJldHVybiBtYWtlQ2FuY2VsYWJsZVByb21pc2Uob3B0aW9ucy5Qcm9taXNlLCBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0LCBvbkNhbmNlbCkge1xuICAgICAgZnVuY3Rpb24gbGlzdGVuZXIoKSB7XG4gICAgICAgIHZhciBmaWx0ZXI9IG9wdGlvbnMuZmlsdGVyO1xuICAgICAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXIuYXBwbHkoc2VsZiwgYXJndW1lbnRzKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLm9mZihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICBpZiAob3B0aW9ucy5oYW5kbGVFcnJvcikge1xuICAgICAgICAgIHZhciBlcnIgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHRvQXJyYXkuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5zbGljZSgxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSh0b0FycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9uQ2FuY2VsKGZ1bmN0aW9uKCl7XG4gICAgICAgIHNlbGYub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICB9KTtcblxuICAgICAgc2VsZi5fb24oZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfSwge1xuICAgICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0LFxuICAgICAgb3ZlcmxvYWQ6IG9wdGlvbnMub3ZlcmxvYWRcbiAgICB9KVxuICB9O1xuXG4gIGZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnM9IHJlc29sdmVPcHRpb25zKG9wdGlvbnMsIHtcbiAgICAgIFByb21pc2U6IFByb21pc2UsXG4gICAgICB0aW1lb3V0OiAwLFxuICAgICAgb3ZlcmxvYWQ6IGZhbHNlXG4gICAgfSwge1xuICAgICAgUHJvbWlzZTogY29uc3RydWN0b3JSZWR1Y2VyXG4gICAgfSk7XG5cbiAgICB2YXIgX1Byb21pc2U9IG9wdGlvbnMuUHJvbWlzZTtcblxuICAgIHJldHVybiBtYWtlQ2FuY2VsYWJsZVByb21pc2UoX1Byb21pc2UsIGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCwgb25DYW5jZWwpe1xuICAgICAgdmFyIGhhbmRsZXI7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBoYW5kbGVyPSAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc29sdmUodG9BcnJheS5hcHBseShudWxsLCBhcmd1bWVudHMpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBvbkNhbmNlbChmdW5jdGlvbigpe1xuICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgICB7b25jZTogdHJ1ZX1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGVycm9yTGlzdGVuZXIgJiYgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgICAgcmVzb2x2ZSh0b0FycmF5LmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgfTtcblxuICAgICAgdmFyIGVycm9yTGlzdGVuZXI7XG5cbiAgICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICAgIGVycm9yTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXJyKXtcbiAgICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGVtaXR0ZXIub25jZSgnZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgb25DYW5jZWwoZnVuY3Rpb24oKXtcbiAgICAgICAgZXJyb3JMaXN0ZW5lciAmJiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIGV2ZW50TGlzdGVuZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBldmVudExpc3RlbmVyKTtcbiAgICB9LCB7XG4gICAgICB0aW1lb3V0OiBvcHRpb25zLnRpbWVvdXQsXG4gICAgICBvdmVybG9hZDogb3B0aW9ucy5vdmVybG9hZFxuICAgIH0pO1xuICB9XG5cbiAgdmFyIHByb3RvdHlwZT0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhFdmVudEVtaXR0ZXIsIHtcbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvdHlwZS5fbWF4TGlzdGVuZXJzO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXIuaXNOYU4obikpIHtcbiAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKVxuICAgICAgICB9XG4gICAgICAgIHByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gbjtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgfSxcbiAgICBvbmNlOiB7XG4gICAgICB2YWx1ZTogb25jZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwcm90b3R5cGUsIHtcbiAgICAgIF9tYXhMaXN0ZW5lcnM6IHtcbiAgICAgICAgICB2YWx1ZTogZGVmYXVsdE1heExpc3RlbmVycyxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0sXG4gICAgICBfb2JzZXJ2ZXJzOiB7dmFsdWU6IG51bGwsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWV9XG4gIH0pO1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBFdmVudEVtaXR0ZXI7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBnbG9iYWwgZm9yIGFueSBraW5kIG9mIGVudmlyb25tZW50LlxuICAgIHZhciBfZ2xvYmFsPSBuZXcgRnVuY3Rpb24oJycsJ3JldHVybiB0aGlzJykoKTtcbiAgICBfZ2xvYmFsLkV2ZW50RW1pdHRlcjIgPSBFdmVudEVtaXR0ZXI7XG4gIH1cbn0oKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/eventemitter2/lib/eventemitter2.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/openapi-fetch/dist/cjs/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/openapi-fetch/dist/cjs/index.cjs ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var process = __webpack_require__(/*! process */ \"(pages-dir-browser)/./node_modules/process/browser.js\");\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n// src/index.js\nvar index_exports = {};\n__export(index_exports, {\n  createFinalURL: () => createFinalURL,\n  createPathBasedClient: () => createPathBasedClient,\n  createQuerySerializer: () => createQuerySerializer,\n  default: () => createClient,\n  defaultBodySerializer: () => defaultBodySerializer,\n  defaultPathSerializer: () => defaultPathSerializer,\n  mergeHeaders: () => mergeHeaders,\n  randomID: () => randomID,\n  removeTrailingSlash: () => removeTrailingSlash,\n  serializeArrayParam: () => serializeArrayParam,\n  serializeObjectParam: () => serializeObjectParam,\n  serializePrimitiveParam: () => serializePrimitiveParam,\n  wrapAsPathBasedClient: () => wrapAsPathBasedClient\n});\nmodule.exports = __toCommonJS(index_exports);\nvar PATH_PARAM_RE = /\\{[^{}]+\\}/g;\nvar supportsRequestInitExt = () => {\n  return typeof process === \"object\" && Number.parseInt(process?.versions?.node?.substring(0, 2)) >= 18 && process.versions.undici;\n};\nfunction randomID() {\n  return Math.random().toString(36).slice(2, 11);\n}\nfunction createClient(clientOptions) {\n  let {\n    baseUrl = \"\",\n    Request: CustomRequest = globalThis.Request,\n    fetch: baseFetch = globalThis.fetch,\n    querySerializer: globalQuerySerializer,\n    bodySerializer: globalBodySerializer,\n    headers: baseHeaders,\n    requestInitExt = void 0,\n    ...baseOptions\n  } = { ...clientOptions };\n  requestInitExt = supportsRequestInitExt() ? requestInitExt : void 0;\n  baseUrl = removeTrailingSlash(baseUrl);\n  const middlewares = [];\n  async function coreFetch(schemaPath, fetchOptions) {\n    const {\n      baseUrl: localBaseUrl,\n      fetch = baseFetch,\n      Request = CustomRequest,\n      headers,\n      params = {},\n      parseAs = \"json\",\n      querySerializer: requestQuerySerializer,\n      bodySerializer = globalBodySerializer ?? defaultBodySerializer,\n      body,\n      ...init\n    } = fetchOptions || {};\n    let finalBaseUrl = baseUrl;\n    if (localBaseUrl) {\n      finalBaseUrl = removeTrailingSlash(localBaseUrl) ?? baseUrl;\n    }\n    let querySerializer = typeof globalQuerySerializer === \"function\" ? globalQuerySerializer : createQuerySerializer(globalQuerySerializer);\n    if (requestQuerySerializer) {\n      querySerializer = typeof requestQuerySerializer === \"function\" ? requestQuerySerializer : createQuerySerializer({\n        ...typeof globalQuerySerializer === \"object\" ? globalQuerySerializer : {},\n        ...requestQuerySerializer\n      });\n    }\n    const serializedBody = body === void 0 ? void 0 : bodySerializer(\n      body,\n      // Note: we declare mergeHeaders() both here and below because its a bit of a chicken-or-egg situation:\n      // bodySerializer() needs all headers so we arent dropping ones set by the user, however,\n      // the result of this ALSO sets the lowest-priority content-type header. So we re-merge below,\n      // setting the content-type at the very beginning to be overwritten.\n      // Lastly, based on the way headers work, its not a simplepresent-or-not check becauase null intentionally un-sets headers.\n      mergeHeaders(baseHeaders, headers, params.header)\n    );\n    const finalHeaders = mergeHeaders(\n      // with no body, we should not to set Content-Type\n      serializedBody === void 0 || // if serialized body is FormData; browser will correctly set Content-Type & boundary expression\n      serializedBody instanceof FormData ? {} : {\n        \"Content-Type\": \"application/json\"\n      },\n      baseHeaders,\n      headers,\n      params.header\n    );\n    const requestInit = {\n      redirect: \"follow\",\n      ...baseOptions,\n      ...init,\n      body: serializedBody,\n      headers: finalHeaders\n    };\n    let id;\n    let options;\n    let request = new CustomRequest(\n      createFinalURL(schemaPath, { baseUrl: finalBaseUrl, params, querySerializer }),\n      requestInit\n    );\n    let response;\n    for (const key in init) {\n      if (!(key in request)) {\n        request[key] = init[key];\n      }\n    }\n    if (middlewares.length) {\n      id = randomID();\n      options = Object.freeze({\n        baseUrl: finalBaseUrl,\n        fetch,\n        parseAs,\n        querySerializer,\n        bodySerializer\n      });\n      for (const m of middlewares) {\n        if (m && typeof m === \"object\" && typeof m.onRequest === \"function\") {\n          const result = await m.onRequest({\n            request,\n            schemaPath,\n            params,\n            options,\n            id\n          });\n          if (result) {\n            if (result instanceof CustomRequest) {\n              request = result;\n            } else if (result instanceof Response) {\n              response = result;\n              break;\n            } else {\n              throw new Error(\"onRequest: must return new Request() or Response() when modifying the request\");\n            }\n          }\n        }\n      }\n    }\n    if (!response) {\n      try {\n        response = await fetch(request, requestInitExt);\n      } catch (error2) {\n        let errorAfterMiddleware = error2;\n        if (middlewares.length) {\n          for (let i = middlewares.length - 1; i >= 0; i--) {\n            const m = middlewares[i];\n            if (m && typeof m === \"object\" && typeof m.onError === \"function\") {\n              const result = await m.onError({\n                request,\n                error: errorAfterMiddleware,\n                schemaPath,\n                params,\n                options,\n                id\n              });\n              if (result) {\n                if (result instanceof Response) {\n                  errorAfterMiddleware = void 0;\n                  response = result;\n                  break;\n                }\n                if (result instanceof Error) {\n                  errorAfterMiddleware = result;\n                  continue;\n                }\n                throw new Error(\"onError: must return new Response() or instance of Error\");\n              }\n            }\n          }\n        }\n        if (errorAfterMiddleware) {\n          throw errorAfterMiddleware;\n        }\n      }\n      if (middlewares.length) {\n        for (let i = middlewares.length - 1; i >= 0; i--) {\n          const m = middlewares[i];\n          if (m && typeof m === \"object\" && typeof m.onResponse === \"function\") {\n            const result = await m.onResponse({\n              request,\n              response,\n              schemaPath,\n              params,\n              options,\n              id\n            });\n            if (result) {\n              if (!(result instanceof Response)) {\n                throw new Error(\"onResponse: must return new Response() when modifying the response\");\n              }\n              response = result;\n            }\n          }\n        }\n      }\n    }\n    if (response.status === 204 || request.method === \"HEAD\" || response.headers.get(\"Content-Length\") === \"0\") {\n      return response.ok ? { data: void 0, response } : { error: void 0, response };\n    }\n    if (response.ok) {\n      if (parseAs === \"stream\") {\n        return { data: response.body, response };\n      }\n      return { data: await response[parseAs](), response };\n    }\n    let error = await response.text();\n    try {\n      error = JSON.parse(error);\n    } catch {\n    }\n    return { error, response };\n  }\n  return {\n    request(method, url, init) {\n      return coreFetch(url, { ...init, method: method.toUpperCase() });\n    },\n    /** Call a GET endpoint */\n    GET(url, init) {\n      return coreFetch(url, { ...init, method: \"GET\" });\n    },\n    /** Call a PUT endpoint */\n    PUT(url, init) {\n      return coreFetch(url, { ...init, method: \"PUT\" });\n    },\n    /** Call a POST endpoint */\n    POST(url, init) {\n      return coreFetch(url, { ...init, method: \"POST\" });\n    },\n    /** Call a DELETE endpoint */\n    DELETE(url, init) {\n      return coreFetch(url, { ...init, method: \"DELETE\" });\n    },\n    /** Call a OPTIONS endpoint */\n    OPTIONS(url, init) {\n      return coreFetch(url, { ...init, method: \"OPTIONS\" });\n    },\n    /** Call a HEAD endpoint */\n    HEAD(url, init) {\n      return coreFetch(url, { ...init, method: \"HEAD\" });\n    },\n    /** Call a PATCH endpoint */\n    PATCH(url, init) {\n      return coreFetch(url, { ...init, method: \"PATCH\" });\n    },\n    /** Call a TRACE endpoint */\n    TRACE(url, init) {\n      return coreFetch(url, { ...init, method: \"TRACE\" });\n    },\n    /** Register middleware */\n    use(...middleware) {\n      for (const m of middleware) {\n        if (!m) {\n          continue;\n        }\n        if (typeof m !== \"object\" || !(\"onRequest\" in m || \"onResponse\" in m || \"onError\" in m)) {\n          throw new Error(\"Middleware must be an object with one of `onRequest()`, `onResponse() or `onError()`\");\n        }\n        middlewares.push(m);\n      }\n    },\n    /** Unregister middleware */\n    eject(...middleware) {\n      for (const m of middleware) {\n        const i = middlewares.indexOf(m);\n        if (i !== -1) {\n          middlewares.splice(i, 1);\n        }\n      }\n    }\n  };\n}\nvar PathCallForwarder = class {\n  constructor(client, url) {\n    this.client = client;\n    this.url = url;\n  }\n  GET = (init) => {\n    return this.client.GET(this.url, init);\n  };\n  PUT = (init) => {\n    return this.client.PUT(this.url, init);\n  };\n  POST = (init) => {\n    return this.client.POST(this.url, init);\n  };\n  DELETE = (init) => {\n    return this.client.DELETE(this.url, init);\n  };\n  OPTIONS = (init) => {\n    return this.client.OPTIONS(this.url, init);\n  };\n  HEAD = (init) => {\n    return this.client.HEAD(this.url, init);\n  };\n  PATCH = (init) => {\n    return this.client.PATCH(this.url, init);\n  };\n  TRACE = (init) => {\n    return this.client.TRACE(this.url, init);\n  };\n};\nvar PathClientProxyHandler = class {\n  constructor() {\n    this.client = null;\n  }\n  // Assume the property is an URL.\n  get(coreClient, url) {\n    const forwarder = new PathCallForwarder(coreClient, url);\n    this.client[url] = forwarder;\n    return forwarder;\n  }\n};\nfunction wrapAsPathBasedClient(coreClient) {\n  const handler = new PathClientProxyHandler();\n  const proxy = new Proxy(coreClient, handler);\n  function Client() {\n  }\n  Client.prototype = proxy;\n  const client = new Client();\n  handler.client = client;\n  return client;\n}\nfunction createPathBasedClient(clientOptions) {\n  return wrapAsPathBasedClient(createClient(clientOptions));\n}\nfunction serializePrimitiveParam(name, value, options) {\n  if (value === void 0 || value === null) {\n    return \"\";\n  }\n  if (typeof value === \"object\") {\n    throw new Error(\n      \"Deeply-nested arrays/objects aren\\u2019t supported. Provide your own `querySerializer()` to handle these.\"\n    );\n  }\n  return `${name}=${options?.allowReserved === true ? value : encodeURIComponent(value)}`;\n}\nfunction serializeObjectParam(name, value, options) {\n  if (!value || typeof value !== \"object\") {\n    return \"\";\n  }\n  const values = [];\n  const joiner = {\n    simple: \",\",\n    label: \".\",\n    matrix: \";\"\n  }[options.style] || \"&\";\n  if (options.style !== \"deepObject\" && options.explode === false) {\n    for (const k in value) {\n      values.push(k, options.allowReserved === true ? value[k] : encodeURIComponent(value[k]));\n    }\n    const final2 = values.join(\",\");\n    switch (options.style) {\n      case \"form\": {\n        return `${name}=${final2}`;\n      }\n      case \"label\": {\n        return `.${final2}`;\n      }\n      case \"matrix\": {\n        return `;${name}=${final2}`;\n      }\n      default: {\n        return final2;\n      }\n    }\n  }\n  for (const k in value) {\n    const finalName = options.style === \"deepObject\" ? `${name}[${k}]` : k;\n    values.push(serializePrimitiveParam(finalName, value[k], options));\n  }\n  const final = values.join(joiner);\n  return options.style === \"label\" || options.style === \"matrix\" ? `${joiner}${final}` : final;\n}\nfunction serializeArrayParam(name, value, options) {\n  if (!Array.isArray(value)) {\n    return \"\";\n  }\n  if (options.explode === false) {\n    const joiner2 = { form: \",\", spaceDelimited: \"%20\", pipeDelimited: \"|\" }[options.style] || \",\";\n    const final = (options.allowReserved === true ? value : value.map((v) => encodeURIComponent(v))).join(joiner2);\n    switch (options.style) {\n      case \"simple\": {\n        return final;\n      }\n      case \"label\": {\n        return `.${final}`;\n      }\n      case \"matrix\": {\n        return `;${name}=${final}`;\n      }\n      // case \"spaceDelimited\":\n      // case \"pipeDelimited\":\n      default: {\n        return `${name}=${final}`;\n      }\n    }\n  }\n  const joiner = { simple: \",\", label: \".\", matrix: \";\" }[options.style] || \"&\";\n  const values = [];\n  for (const v of value) {\n    if (options.style === \"simple\" || options.style === \"label\") {\n      values.push(options.allowReserved === true ? v : encodeURIComponent(v));\n    } else {\n      values.push(serializePrimitiveParam(name, v, options));\n    }\n  }\n  return options.style === \"label\" || options.style === \"matrix\" ? `${joiner}${values.join(joiner)}` : values.join(joiner);\n}\nfunction createQuerySerializer(options) {\n  return function querySerializer(queryParams) {\n    const search = [];\n    if (queryParams && typeof queryParams === \"object\") {\n      for (const name in queryParams) {\n        const value = queryParams[name];\n        if (value === void 0 || value === null) {\n          continue;\n        }\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            continue;\n          }\n          search.push(\n            serializeArrayParam(name, value, {\n              style: \"form\",\n              explode: true,\n              ...options?.array,\n              allowReserved: options?.allowReserved || false\n            })\n          );\n          continue;\n        }\n        if (typeof value === \"object\") {\n          search.push(\n            serializeObjectParam(name, value, {\n              style: \"deepObject\",\n              explode: true,\n              ...options?.object,\n              allowReserved: options?.allowReserved || false\n            })\n          );\n          continue;\n        }\n        search.push(serializePrimitiveParam(name, value, options));\n      }\n    }\n    return search.join(\"&\");\n  };\n}\nfunction defaultPathSerializer(pathname, pathParams) {\n  let nextURL = pathname;\n  for (const match of pathname.match(PATH_PARAM_RE) ?? []) {\n    let name = match.substring(1, match.length - 1);\n    let explode = false;\n    let style = \"simple\";\n    if (name.endsWith(\"*\")) {\n      explode = true;\n      name = name.substring(0, name.length - 1);\n    }\n    if (name.startsWith(\".\")) {\n      style = \"label\";\n      name = name.substring(1);\n    } else if (name.startsWith(\";\")) {\n      style = \"matrix\";\n      name = name.substring(1);\n    }\n    if (!pathParams || pathParams[name] === void 0 || pathParams[name] === null) {\n      continue;\n    }\n    const value = pathParams[name];\n    if (Array.isArray(value)) {\n      nextURL = nextURL.replace(match, serializeArrayParam(name, value, { style, explode }));\n      continue;\n    }\n    if (typeof value === \"object\") {\n      nextURL = nextURL.replace(match, serializeObjectParam(name, value, { style, explode }));\n      continue;\n    }\n    if (style === \"matrix\") {\n      nextURL = nextURL.replace(match, `;${serializePrimitiveParam(name, value)}`);\n      continue;\n    }\n    nextURL = nextURL.replace(match, style === \"label\" ? `.${encodeURIComponent(value)}` : encodeURIComponent(value));\n  }\n  return nextURL;\n}\nfunction defaultBodySerializer(body, headers) {\n  if (body instanceof FormData) {\n    return body;\n  }\n  if (headers) {\n    const contentType = headers.get instanceof Function ? headers.get(\"Content-Type\") ?? headers.get(\"content-type\") : headers[\"Content-Type\"] ?? headers[\"content-type\"];\n    if (contentType === \"application/x-www-form-urlencoded\") {\n      return new URLSearchParams(body).toString();\n    }\n  }\n  return JSON.stringify(body);\n}\nfunction createFinalURL(pathname, options) {\n  let finalURL = `${options.baseUrl}${pathname}`;\n  if (options.params?.path) {\n    finalURL = defaultPathSerializer(finalURL, options.params.path);\n  }\n  let search = options.querySerializer(options.params.query ?? {});\n  if (search.startsWith(\"?\")) {\n    search = search.substring(1);\n  }\n  if (search) {\n    finalURL += `?${search}`;\n  }\n  return finalURL;\n}\nfunction mergeHeaders(...allHeaders) {\n  const finalHeaders = new Headers();\n  for (const h of allHeaders) {\n    if (!h || typeof h !== \"object\") {\n      continue;\n    }\n    const iterator = h instanceof Headers ? h.entries() : Object.entries(h);\n    for (const [k, v] of iterator) {\n      if (v === null) {\n        finalHeaders.delete(k);\n      } else if (Array.isArray(v)) {\n        for (const v2 of v) {\n          finalHeaders.append(k, v2);\n        }\n      } else if (v !== void 0) {\n        finalHeaders.set(k, v);\n      }\n    }\n  }\n  return finalHeaders;\n}\nfunction removeTrailingSlash(url) {\n  if (url.endsWith(\"/\")) {\n    return url.substring(0, url.length - 1);\n  }\n  return url;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vcGVuYXBpLWZldGNoL2Rpc3QvY2pzL2luZGV4LmNqcyIsIm1hcHBpbmdzIjoiO0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxrQkFBa0IsYUFBYTs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx1QkFBdUIsSUFBSSxJQUFJO0FBQy9CO0FBQ0EsZ0JBQWdCLE9BQU8saUNBQWlDLE9BQU8sNENBQTRDLE9BQU87QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RSw4Q0FBOEM7QUFDOUM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxnREFBZ0Q7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXG9wZW5hcGktZmV0Y2hcXGRpc3RcXGNqc1xcaW5kZXguY2pzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19leHBvcnQgPSAodGFyZ2V0LCBhbGwpID0+IHtcbiAgZm9yICh2YXIgbmFtZSBpbiBhbGwpXG4gICAgX19kZWZQcm9wKHRhcmdldCwgbmFtZSwgeyBnZXQ6IGFsbFtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0NvbW1vbkpTID0gKG1vZCkgPT4gX19jb3B5UHJvcHMoX19kZWZQcm9wKHt9LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KSwgbW9kKTtcblxuLy8gc3JjL2luZGV4LmpzXG52YXIgaW5kZXhfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaW5kZXhfZXhwb3J0cywge1xuICBjcmVhdGVGaW5hbFVSTDogKCkgPT4gY3JlYXRlRmluYWxVUkwsXG4gIGNyZWF0ZVBhdGhCYXNlZENsaWVudDogKCkgPT4gY3JlYXRlUGF0aEJhc2VkQ2xpZW50LFxuICBjcmVhdGVRdWVyeVNlcmlhbGl6ZXI6ICgpID0+IGNyZWF0ZVF1ZXJ5U2VyaWFsaXplcixcbiAgZGVmYXVsdDogKCkgPT4gY3JlYXRlQ2xpZW50LFxuICBkZWZhdWx0Qm9keVNlcmlhbGl6ZXI6ICgpID0+IGRlZmF1bHRCb2R5U2VyaWFsaXplcixcbiAgZGVmYXVsdFBhdGhTZXJpYWxpemVyOiAoKSA9PiBkZWZhdWx0UGF0aFNlcmlhbGl6ZXIsXG4gIG1lcmdlSGVhZGVyczogKCkgPT4gbWVyZ2VIZWFkZXJzLFxuICByYW5kb21JRDogKCkgPT4gcmFuZG9tSUQsXG4gIHJlbW92ZVRyYWlsaW5nU2xhc2g6ICgpID0+IHJlbW92ZVRyYWlsaW5nU2xhc2gsXG4gIHNlcmlhbGl6ZUFycmF5UGFyYW06ICgpID0+IHNlcmlhbGl6ZUFycmF5UGFyYW0sXG4gIHNlcmlhbGl6ZU9iamVjdFBhcmFtOiAoKSA9PiBzZXJpYWxpemVPYmplY3RQYXJhbSxcbiAgc2VyaWFsaXplUHJpbWl0aXZlUGFyYW06ICgpID0+IHNlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtLFxuICB3cmFwQXNQYXRoQmFzZWRDbGllbnQ6ICgpID0+IHdyYXBBc1BhdGhCYXNlZENsaWVudFxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IF9fdG9Db21tb25KUyhpbmRleF9leHBvcnRzKTtcbnZhciBQQVRIX1BBUkFNX1JFID0gL1xce1tee31dK1xcfS9nO1xudmFyIHN1cHBvcnRzUmVxdWVzdEluaXRFeHQgPSAoKSA9PiB7XG4gIHJldHVybiB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBOdW1iZXIucGFyc2VJbnQocHJvY2Vzcz8udmVyc2lvbnM/Lm5vZGU/LnN1YnN0cmluZygwLCAyKSkgPj0gMTggJiYgcHJvY2Vzcy52ZXJzaW9ucy51bmRpY2k7XG59O1xuZnVuY3Rpb24gcmFuZG9tSUQoKSB7XG4gIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyLCAxMSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDbGllbnQoY2xpZW50T3B0aW9ucykge1xuICBsZXQge1xuICAgIGJhc2VVcmwgPSBcIlwiLFxuICAgIFJlcXVlc3Q6IEN1c3RvbVJlcXVlc3QgPSBnbG9iYWxUaGlzLlJlcXVlc3QsXG4gICAgZmV0Y2g6IGJhc2VGZXRjaCA9IGdsb2JhbFRoaXMuZmV0Y2gsXG4gICAgcXVlcnlTZXJpYWxpemVyOiBnbG9iYWxRdWVyeVNlcmlhbGl6ZXIsXG4gICAgYm9keVNlcmlhbGl6ZXI6IGdsb2JhbEJvZHlTZXJpYWxpemVyLFxuICAgIGhlYWRlcnM6IGJhc2VIZWFkZXJzLFxuICAgIHJlcXVlc3RJbml0RXh0ID0gdm9pZCAwLFxuICAgIC4uLmJhc2VPcHRpb25zXG4gIH0gPSB7IC4uLmNsaWVudE9wdGlvbnMgfTtcbiAgcmVxdWVzdEluaXRFeHQgPSBzdXBwb3J0c1JlcXVlc3RJbml0RXh0KCkgPyByZXF1ZXN0SW5pdEV4dCA6IHZvaWQgMDtcbiAgYmFzZVVybCA9IHJlbW92ZVRyYWlsaW5nU2xhc2goYmFzZVVybCk7XG4gIGNvbnN0IG1pZGRsZXdhcmVzID0gW107XG4gIGFzeW5jIGZ1bmN0aW9uIGNvcmVGZXRjaChzY2hlbWFQYXRoLCBmZXRjaE9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBiYXNlVXJsOiBsb2NhbEJhc2VVcmwsXG4gICAgICBmZXRjaCA9IGJhc2VGZXRjaCxcbiAgICAgIFJlcXVlc3QgPSBDdXN0b21SZXF1ZXN0LFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcyA9IHt9LFxuICAgICAgcGFyc2VBcyA9IFwianNvblwiLFxuICAgICAgcXVlcnlTZXJpYWxpemVyOiByZXF1ZXN0UXVlcnlTZXJpYWxpemVyLFxuICAgICAgYm9keVNlcmlhbGl6ZXIgPSBnbG9iYWxCb2R5U2VyaWFsaXplciA/PyBkZWZhdWx0Qm9keVNlcmlhbGl6ZXIsXG4gICAgICBib2R5LFxuICAgICAgLi4uaW5pdFxuICAgIH0gPSBmZXRjaE9wdGlvbnMgfHwge307XG4gICAgbGV0IGZpbmFsQmFzZVVybCA9IGJhc2VVcmw7XG4gICAgaWYgKGxvY2FsQmFzZVVybCkge1xuICAgICAgZmluYWxCYXNlVXJsID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChsb2NhbEJhc2VVcmwpID8/IGJhc2VVcmw7XG4gICAgfVxuICAgIGxldCBxdWVyeVNlcmlhbGl6ZXIgPSB0eXBlb2YgZ2xvYmFsUXVlcnlTZXJpYWxpemVyID09PSBcImZ1bmN0aW9uXCIgPyBnbG9iYWxRdWVyeVNlcmlhbGl6ZXIgOiBjcmVhdGVRdWVyeVNlcmlhbGl6ZXIoZ2xvYmFsUXVlcnlTZXJpYWxpemVyKTtcbiAgICBpZiAocmVxdWVzdFF1ZXJ5U2VyaWFsaXplcikge1xuICAgICAgcXVlcnlTZXJpYWxpemVyID0gdHlwZW9mIHJlcXVlc3RRdWVyeVNlcmlhbGl6ZXIgPT09IFwiZnVuY3Rpb25cIiA/IHJlcXVlc3RRdWVyeVNlcmlhbGl6ZXIgOiBjcmVhdGVRdWVyeVNlcmlhbGl6ZXIoe1xuICAgICAgICAuLi50eXBlb2YgZ2xvYmFsUXVlcnlTZXJpYWxpemVyID09PSBcIm9iamVjdFwiID8gZ2xvYmFsUXVlcnlTZXJpYWxpemVyIDoge30sXG4gICAgICAgIC4uLnJlcXVlc3RRdWVyeVNlcmlhbGl6ZXJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzZXJpYWxpemVkQm9keSA9IGJvZHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJvZHlTZXJpYWxpemVyKFxuICAgICAgYm9keSxcbiAgICAgIC8vIE5vdGU6IHdlIGRlY2xhcmUgbWVyZ2VIZWFkZXJzKCkgYm90aCBoZXJlIGFuZCBiZWxvdyBiZWNhdXNlIGl04oCZcyBhIGJpdCBvZiBhIGNoaWNrZW4tb3ItZWdnIHNpdHVhdGlvbjpcbiAgICAgIC8vIGJvZHlTZXJpYWxpemVyKCkgbmVlZHMgYWxsIGhlYWRlcnMgc28gd2UgYXJlbuKAmXQgZHJvcHBpbmcgb25lcyBzZXQgYnkgdGhlIHVzZXIsIGhvd2V2ZXIsXG4gICAgICAvLyB0aGUgcmVzdWx0IG9mIHRoaXMgQUxTTyBzZXRzIHRoZSBsb3dlc3QtcHJpb3JpdHkgY29udGVudC10eXBlIGhlYWRlci4gU28gd2UgcmUtbWVyZ2UgYmVsb3csXG4gICAgICAvLyBzZXR0aW5nIHRoZSBjb250ZW50LXR5cGUgYXQgdGhlIHZlcnkgYmVnaW5uaW5nIHRvIGJlIG92ZXJ3cml0dGVuLlxuICAgICAgLy8gTGFzdGx5LCBiYXNlZCBvbiB0aGUgd2F5IGhlYWRlcnMgd29yaywgaXTigJlzIG5vdCBhIHNpbXBsZcKg4oCccHJlc2VudC1vci1ub3TigJ0gY2hlY2sgYmVjYXVhc2UgbnVsbCBpbnRlbnRpb25hbGx5IHVuLXNldHMgaGVhZGVycy5cbiAgICAgIG1lcmdlSGVhZGVycyhiYXNlSGVhZGVycywgaGVhZGVycywgcGFyYW1zLmhlYWRlcilcbiAgICApO1xuICAgIGNvbnN0IGZpbmFsSGVhZGVycyA9IG1lcmdlSGVhZGVycyhcbiAgICAgIC8vIHdpdGggbm8gYm9keSwgd2Ugc2hvdWxkIG5vdCB0byBzZXQgQ29udGVudC1UeXBlXG4gICAgICBzZXJpYWxpemVkQm9keSA9PT0gdm9pZCAwIHx8IC8vIGlmIHNlcmlhbGl6ZWQgYm9keSBpcyBGb3JtRGF0YTsgYnJvd3NlciB3aWxsIGNvcnJlY3RseSBzZXQgQ29udGVudC1UeXBlICYgYm91bmRhcnkgZXhwcmVzc2lvblxuICAgICAgc2VyaWFsaXplZEJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSA/IHt9IDoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgfSxcbiAgICAgIGJhc2VIZWFkZXJzLFxuICAgICAgaGVhZGVycyxcbiAgICAgIHBhcmFtcy5oZWFkZXJcbiAgICApO1xuICAgIGNvbnN0IHJlcXVlc3RJbml0ID0ge1xuICAgICAgcmVkaXJlY3Q6IFwiZm9sbG93XCIsXG4gICAgICAuLi5iYXNlT3B0aW9ucyxcbiAgICAgIC4uLmluaXQsXG4gICAgICBib2R5OiBzZXJpYWxpemVkQm9keSxcbiAgICAgIGhlYWRlcnM6IGZpbmFsSGVhZGVyc1xuICAgIH07XG4gICAgbGV0IGlkO1xuICAgIGxldCBvcHRpb25zO1xuICAgIGxldCByZXF1ZXN0ID0gbmV3IEN1c3RvbVJlcXVlc3QoXG4gICAgICBjcmVhdGVGaW5hbFVSTChzY2hlbWFQYXRoLCB7IGJhc2VVcmw6IGZpbmFsQmFzZVVybCwgcGFyYW1zLCBxdWVyeVNlcmlhbGl6ZXIgfSksXG4gICAgICByZXF1ZXN0SW5pdFxuICAgICk7XG4gICAgbGV0IHJlc3BvbnNlO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGluaXQpIHtcbiAgICAgIGlmICghKGtleSBpbiByZXF1ZXN0KSkge1xuICAgICAgICByZXF1ZXN0W2tleV0gPSBpbml0W2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtaWRkbGV3YXJlcy5sZW5ndGgpIHtcbiAgICAgIGlkID0gcmFuZG9tSUQoKTtcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgYmFzZVVybDogZmluYWxCYXNlVXJsLFxuICAgICAgICBmZXRjaCxcbiAgICAgICAgcGFyc2VBcyxcbiAgICAgICAgcXVlcnlTZXJpYWxpemVyLFxuICAgICAgICBib2R5U2VyaWFsaXplclxuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgbWlkZGxld2FyZXMpIHtcbiAgICAgICAgaWYgKG0gJiYgdHlwZW9mIG0gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG0ub25SZXF1ZXN0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtLm9uUmVxdWVzdCh7XG4gICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgc2NoZW1hUGF0aCxcbiAgICAgICAgICAgIHBhcmFtcyxcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBpZFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBDdXN0b21SZXF1ZXN0KSB7XG4gICAgICAgICAgICAgIHJlcXVlc3QgPSByZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzdWx0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9uUmVxdWVzdDogbXVzdCByZXR1cm4gbmV3IFJlcXVlc3QoKSBvciBSZXNwb25zZSgpIHdoZW4gbW9kaWZ5aW5nIHRoZSByZXF1ZXN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJlcXVlc3QsIHJlcXVlc3RJbml0RXh0KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICBsZXQgZXJyb3JBZnRlck1pZGRsZXdhcmUgPSBlcnJvcjI7XG4gICAgICAgIGlmIChtaWRkbGV3YXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gbWlkZGxld2FyZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSBtaWRkbGV3YXJlc1tpXTtcbiAgICAgICAgICAgIGlmIChtICYmIHR5cGVvZiBtID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtLm9uRXJyb3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtLm9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yQWZ0ZXJNaWRkbGV3YXJlLFxuICAgICAgICAgICAgICAgIHNjaGVtYVBhdGgsXG4gICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yQWZ0ZXJNaWRkbGV3YXJlID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvckFmdGVyTWlkZGxld2FyZSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvbkVycm9yOiBtdXN0IHJldHVybiBuZXcgUmVzcG9uc2UoKSBvciBpbnN0YW5jZSBvZiBFcnJvclwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3JBZnRlck1pZGRsZXdhcmUpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvckFmdGVyTWlkZGxld2FyZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1pZGRsZXdhcmVzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gbWlkZGxld2FyZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBtID0gbWlkZGxld2FyZXNbaV07XG4gICAgICAgICAgaWYgKG0gJiYgdHlwZW9mIG0gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG0ub25SZXNwb25zZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtLm9uUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICByZXF1ZXN0LFxuICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgc2NoZW1hUGF0aCxcbiAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgIGlmICghKHJlc3VsdCBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9uUmVzcG9uc2U6IG11c3QgcmV0dXJuIG5ldyBSZXNwb25zZSgpIHdoZW4gbW9kaWZ5aW5nIHRoZSByZXNwb25zZVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNwb25zZSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0IHx8IHJlcXVlc3QubWV0aG9kID09PSBcIkhFQURcIiB8fCByZXNwb25zZS5oZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpID09PSBcIjBcIikge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLm9rID8geyBkYXRhOiB2b2lkIDAsIHJlc3BvbnNlIH0gOiB7IGVycm9yOiB2b2lkIDAsIHJlc3BvbnNlIH07XG4gICAgfVxuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgaWYgKHBhcnNlQXMgPT09IFwic3RyZWFtXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogcmVzcG9uc2UuYm9keSwgcmVzcG9uc2UgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRhdGE6IGF3YWl0IHJlc3BvbnNlW3BhcnNlQXNdKCksIHJlc3BvbnNlIH07XG4gICAgfVxuICAgIGxldCBlcnJvciA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICB0cnkge1xuICAgICAgZXJyb3IgPSBKU09OLnBhcnNlKGVycm9yKTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgcmV0dXJuIHsgZXJyb3IsIHJlc3BvbnNlIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZXF1ZXN0KG1ldGhvZCwgdXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IG1ldGhvZC50b1VwcGVyQ2FzZSgpIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBHRVQgZW5kcG9pbnQgKi9cbiAgICBHRVQodXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiR0VUXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIFBVVCBlbmRwb2ludCAqL1xuICAgIFBVVCh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJQVVRcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgUE9TVCBlbmRwb2ludCAqL1xuICAgIFBPU1QodXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiUE9TVFwiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBERUxFVEUgZW5kcG9pbnQgKi9cbiAgICBERUxFVEUodXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiREVMRVRFXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIE9QVElPTlMgZW5kcG9pbnQgKi9cbiAgICBPUFRJT05TKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIk9QVElPTlNcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgSEVBRCBlbmRwb2ludCAqL1xuICAgIEhFQUQodXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiSEVBRFwiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBQQVRDSCBlbmRwb2ludCAqL1xuICAgIFBBVENIKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIlBBVENIXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIFRSQUNFIGVuZHBvaW50ICovXG4gICAgVFJBQ0UodXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiVFJBQ0VcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBSZWdpc3RlciBtaWRkbGV3YXJlICovXG4gICAgdXNlKC4uLm1pZGRsZXdhcmUpIHtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBtaWRkbGV3YXJlKSB7XG4gICAgICAgIGlmICghbSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbSAhPT0gXCJvYmplY3RcIiB8fCAhKFwib25SZXF1ZXN0XCIgaW4gbSB8fCBcIm9uUmVzcG9uc2VcIiBpbiBtIHx8IFwib25FcnJvclwiIGluIG0pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlkZGxld2FyZSBtdXN0IGJlIGFuIG9iamVjdCB3aXRoIG9uZSBvZiBgb25SZXF1ZXN0KClgLCBgb25SZXNwb25zZSgpIG9yIGBvbkVycm9yKClgXCIpO1xuICAgICAgICB9XG4gICAgICAgIG1pZGRsZXdhcmVzLnB1c2gobSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKiogVW5yZWdpc3RlciBtaWRkbGV3YXJlICovXG4gICAgZWplY3QoLi4ubWlkZGxld2FyZSkge1xuICAgICAgZm9yIChjb25zdCBtIG9mIG1pZGRsZXdhcmUpIHtcbiAgICAgICAgY29uc3QgaSA9IG1pZGRsZXdhcmVzLmluZGV4T2YobSk7XG4gICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgIG1pZGRsZXdhcmVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbnZhciBQYXRoQ2FsbEZvcndhcmRlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2xpZW50LCB1cmwpIHtcbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgfVxuICBHRVQgPSAoaW5pdCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5HRVQodGhpcy51cmwsIGluaXQpO1xuICB9O1xuICBQVVQgPSAoaW5pdCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5QVVQodGhpcy51cmwsIGluaXQpO1xuICB9O1xuICBQT1NUID0gKGluaXQpID0+IHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuUE9TVCh0aGlzLnVybCwgaW5pdCk7XG4gIH07XG4gIERFTEVURSA9IChpbml0KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LkRFTEVURSh0aGlzLnVybCwgaW5pdCk7XG4gIH07XG4gIE9QVElPTlMgPSAoaW5pdCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5PUFRJT05TKHRoaXMudXJsLCBpbml0KTtcbiAgfTtcbiAgSEVBRCA9IChpbml0KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LkhFQUQodGhpcy51cmwsIGluaXQpO1xuICB9O1xuICBQQVRDSCA9IChpbml0KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LlBBVENIKHRoaXMudXJsLCBpbml0KTtcbiAgfTtcbiAgVFJBQ0UgPSAoaW5pdCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5UUkFDRSh0aGlzLnVybCwgaW5pdCk7XG4gIH07XG59O1xudmFyIFBhdGhDbGllbnRQcm94eUhhbmRsZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2xpZW50ID0gbnVsbDtcbiAgfVxuICAvLyBBc3N1bWUgdGhlIHByb3BlcnR5IGlzIGFuIFVSTC5cbiAgZ2V0KGNvcmVDbGllbnQsIHVybCkge1xuICAgIGNvbnN0IGZvcndhcmRlciA9IG5ldyBQYXRoQ2FsbEZvcndhcmRlcihjb3JlQ2xpZW50LCB1cmwpO1xuICAgIHRoaXMuY2xpZW50W3VybF0gPSBmb3J3YXJkZXI7XG4gICAgcmV0dXJuIGZvcndhcmRlcjtcbiAgfVxufTtcbmZ1bmN0aW9uIHdyYXBBc1BhdGhCYXNlZENsaWVudChjb3JlQ2xpZW50KSB7XG4gIGNvbnN0IGhhbmRsZXIgPSBuZXcgUGF0aENsaWVudFByb3h5SGFuZGxlcigpO1xuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShjb3JlQ2xpZW50LCBoYW5kbGVyKTtcbiAgZnVuY3Rpb24gQ2xpZW50KCkge1xuICB9XG4gIENsaWVudC5wcm90b3R5cGUgPSBwcm94eTtcbiAgY29uc3QgY2xpZW50ID0gbmV3IENsaWVudCgpO1xuICBoYW5kbGVyLmNsaWVudCA9IGNsaWVudDtcbiAgcmV0dXJuIGNsaWVudDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhCYXNlZENsaWVudChjbGllbnRPcHRpb25zKSB7XG4gIHJldHVybiB3cmFwQXNQYXRoQmFzZWRDbGllbnQoY3JlYXRlQ2xpZW50KGNsaWVudE9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiRGVlcGx5LW5lc3RlZCBhcnJheXMvb2JqZWN0cyBhcmVuXFx1MjAxOXQgc3VwcG9ydGVkLiBQcm92aWRlIHlvdXIgb3duIGBxdWVyeVNlcmlhbGl6ZXIoKWAgdG8gaGFuZGxlIHRoZXNlLlwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gYCR7bmFtZX09JHtvcHRpb25zPy5hbGxvd1Jlc2VydmVkID09PSB0cnVlID8gdmFsdWUgOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpfWA7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVPYmplY3RQYXJhbShuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGNvbnN0IHZhbHVlcyA9IFtdO1xuICBjb25zdCBqb2luZXIgPSB7XG4gICAgc2ltcGxlOiBcIixcIixcbiAgICBsYWJlbDogXCIuXCIsXG4gICAgbWF0cml4OiBcIjtcIlxuICB9W29wdGlvbnMuc3R5bGVdIHx8IFwiJlwiO1xuICBpZiAob3B0aW9ucy5zdHlsZSAhPT0gXCJkZWVwT2JqZWN0XCIgJiYgb3B0aW9ucy5leHBsb2RlID09PSBmYWxzZSkge1xuICAgIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgICAgdmFsdWVzLnB1c2goaywgb3B0aW9ucy5hbGxvd1Jlc2VydmVkID09PSB0cnVlID8gdmFsdWVba10gOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWVba10pKTtcbiAgICB9XG4gICAgY29uc3QgZmluYWwyID0gdmFsdWVzLmpvaW4oXCIsXCIpO1xuICAgIHN3aXRjaCAob3B0aW9ucy5zdHlsZSkge1xuICAgICAgY2FzZSBcImZvcm1cIjoge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX09JHtmaW5hbDJ9YDtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJsYWJlbFwiOiB7XG4gICAgICAgIHJldHVybiBgLiR7ZmluYWwyfWA7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWF0cml4XCI6IHtcbiAgICAgICAgcmV0dXJuIGA7JHtuYW1lfT0ke2ZpbmFsMn1gO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICByZXR1cm4gZmluYWwyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICBjb25zdCBmaW5hbE5hbWUgPSBvcHRpb25zLnN0eWxlID09PSBcImRlZXBPYmplY3RcIiA/IGAke25hbWV9WyR7a31dYCA6IGs7XG4gICAgdmFsdWVzLnB1c2goc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0oZmluYWxOYW1lLCB2YWx1ZVtrXSwgb3B0aW9ucykpO1xuICB9XG4gIGNvbnN0IGZpbmFsID0gdmFsdWVzLmpvaW4oam9pbmVyKTtcbiAgcmV0dXJuIG9wdGlvbnMuc3R5bGUgPT09IFwibGFiZWxcIiB8fCBvcHRpb25zLnN0eWxlID09PSBcIm1hdHJpeFwiID8gYCR7am9pbmVyfSR7ZmluYWx9YCA6IGZpbmFsO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQXJyYXlQYXJhbShuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZXhwbG9kZSA9PT0gZmFsc2UpIHtcbiAgICBjb25zdCBqb2luZXIyID0geyBmb3JtOiBcIixcIiwgc3BhY2VEZWxpbWl0ZWQ6IFwiJTIwXCIsIHBpcGVEZWxpbWl0ZWQ6IFwifFwiIH1bb3B0aW9ucy5zdHlsZV0gfHwgXCIsXCI7XG4gICAgY29uc3QgZmluYWwgPSAob3B0aW9ucy5hbGxvd1Jlc2VydmVkID09PSB0cnVlID8gdmFsdWUgOiB2YWx1ZS5tYXAoKHYpID0+IGVuY29kZVVSSUNvbXBvbmVudCh2KSkpLmpvaW4oam9pbmVyMik7XG4gICAgc3dpdGNoIChvcHRpb25zLnN0eWxlKSB7XG4gICAgICBjYXNlIFwic2ltcGxlXCI6IHtcbiAgICAgICAgcmV0dXJuIGZpbmFsO1xuICAgICAgfVxuICAgICAgY2FzZSBcImxhYmVsXCI6IHtcbiAgICAgICAgcmV0dXJuIGAuJHtmaW5hbH1gO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hdHJpeFwiOiB7XG4gICAgICAgIHJldHVybiBgOyR7bmFtZX09JHtmaW5hbH1gO1xuICAgICAgfVxuICAgICAgLy8gY2FzZSBcInNwYWNlRGVsaW1pdGVkXCI6XG4gICAgICAvLyBjYXNlIFwicGlwZURlbGltaXRlZFwiOlxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX09JHtmaW5hbH1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBqb2luZXIgPSB7IHNpbXBsZTogXCIsXCIsIGxhYmVsOiBcIi5cIiwgbWF0cml4OiBcIjtcIiB9W29wdGlvbnMuc3R5bGVdIHx8IFwiJlwiO1xuICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgaWYgKG9wdGlvbnMuc3R5bGUgPT09IFwic2ltcGxlXCIgfHwgb3B0aW9ucy5zdHlsZSA9PT0gXCJsYWJlbFwiKSB7XG4gICAgICB2YWx1ZXMucHVzaChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT09IHRydWUgPyB2IDogZW5jb2RlVVJJQ29tcG9uZW50KHYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzLnB1c2goc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0obmFtZSwgdiwgb3B0aW9ucykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9ucy5zdHlsZSA9PT0gXCJsYWJlbFwiIHx8IG9wdGlvbnMuc3R5bGUgPT09IFwibWF0cml4XCIgPyBgJHtqb2luZXJ9JHt2YWx1ZXMuam9pbihqb2luZXIpfWAgOiB2YWx1ZXMuam9pbihqb2luZXIpO1xufVxuZnVuY3Rpb24gY3JlYXRlUXVlcnlTZXJpYWxpemVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHF1ZXJ5U2VyaWFsaXplcihxdWVyeVBhcmFtcykge1xuICAgIGNvbnN0IHNlYXJjaCA9IFtdO1xuICAgIGlmIChxdWVyeVBhcmFtcyAmJiB0eXBlb2YgcXVlcnlQYXJhbXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBxdWVyeVBhcmFtcykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHF1ZXJ5UGFyYW1zW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWFyY2gucHVzaChcbiAgICAgICAgICAgIHNlcmlhbGl6ZUFycmF5UGFyYW0obmFtZSwgdmFsdWUsIHtcbiAgICAgICAgICAgICAgc3R5bGU6IFwiZm9ybVwiLFxuICAgICAgICAgICAgICBleHBsb2RlOiB0cnVlLFxuICAgICAgICAgICAgICAuLi5vcHRpb25zPy5hcnJheSxcbiAgICAgICAgICAgICAgYWxsb3dSZXNlcnZlZDogb3B0aW9ucz8uYWxsb3dSZXNlcnZlZCB8fCBmYWxzZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBzZWFyY2gucHVzaChcbiAgICAgICAgICAgIHNlcmlhbGl6ZU9iamVjdFBhcmFtKG5hbWUsIHZhbHVlLCB7XG4gICAgICAgICAgICAgIHN0eWxlOiBcImRlZXBPYmplY3RcIixcbiAgICAgICAgICAgICAgZXhwbG9kZTogdHJ1ZSxcbiAgICAgICAgICAgICAgLi4ub3B0aW9ucz8ub2JqZWN0LFxuICAgICAgICAgICAgICBhbGxvd1Jlc2VydmVkOiBvcHRpb25zPy5hbGxvd1Jlc2VydmVkIHx8IGZhbHNlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc2VhcmNoLnB1c2goc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0obmFtZSwgdmFsdWUsIG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlYXJjaC5qb2luKFwiJlwiKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRQYXRoU2VyaWFsaXplcihwYXRobmFtZSwgcGF0aFBhcmFtcykge1xuICBsZXQgbmV4dFVSTCA9IHBhdGhuYW1lO1xuICBmb3IgKGNvbnN0IG1hdGNoIG9mIHBhdGhuYW1lLm1hdGNoKFBBVEhfUEFSQU1fUkUpID8/IFtdKSB7XG4gICAgbGV0IG5hbWUgPSBtYXRjaC5zdWJzdHJpbmcoMSwgbWF0Y2gubGVuZ3RoIC0gMSk7XG4gICAgbGV0IGV4cGxvZGUgPSBmYWxzZTtcbiAgICBsZXQgc3R5bGUgPSBcInNpbXBsZVwiO1xuICAgIGlmIChuYW1lLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgICAgZXhwbG9kZSA9IHRydWU7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICAgIHN0eWxlID0gXCJsYWJlbFwiO1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgIH0gZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKFwiO1wiKSkge1xuICAgICAgc3R5bGUgPSBcIm1hdHJpeFwiO1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBpZiAoIXBhdGhQYXJhbXMgfHwgcGF0aFBhcmFtc1tuYW1lXSA9PT0gdm9pZCAwIHx8IHBhdGhQYXJhbXNbbmFtZV0gPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHBhdGhQYXJhbXNbbmFtZV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBuZXh0VVJMID0gbmV4dFVSTC5yZXBsYWNlKG1hdGNoLCBzZXJpYWxpemVBcnJheVBhcmFtKG5hbWUsIHZhbHVlLCB7IHN0eWxlLCBleHBsb2RlIH0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBuZXh0VVJMID0gbmV4dFVSTC5yZXBsYWNlKG1hdGNoLCBzZXJpYWxpemVPYmplY3RQYXJhbShuYW1lLCB2YWx1ZSwgeyBzdHlsZSwgZXhwbG9kZSB9KSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHN0eWxlID09PSBcIm1hdHJpeFwiKSB7XG4gICAgICBuZXh0VVJMID0gbmV4dFVSTC5yZXBsYWNlKG1hdGNoLCBgOyR7c2VyaWFsaXplUHJpbWl0aXZlUGFyYW0obmFtZSwgdmFsdWUpfWApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG5leHRVUkwgPSBuZXh0VVJMLnJlcGxhY2UobWF0Y2gsIHN0eWxlID09PSBcImxhYmVsXCIgPyBgLiR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKX1gIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIG5leHRVUkw7XG59XG5mdW5jdGlvbiBkZWZhdWx0Qm9keVNlcmlhbGl6ZXIoYm9keSwgaGVhZGVycykge1xuICBpZiAoYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgaWYgKGhlYWRlcnMpIHtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnMuZ2V0IGluc3RhbmNlb2YgRnVuY3Rpb24gPyBoZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKSA/PyBoZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSA6IGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPz8gaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXTtcbiAgICBpZiAoY29udGVudFR5cGUgPT09IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpIHtcbiAgICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKGJvZHkpLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShib2R5KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpbmFsVVJMKHBhdGhuYW1lLCBvcHRpb25zKSB7XG4gIGxldCBmaW5hbFVSTCA9IGAke29wdGlvbnMuYmFzZVVybH0ke3BhdGhuYW1lfWA7XG4gIGlmIChvcHRpb25zLnBhcmFtcz8ucGF0aCkge1xuICAgIGZpbmFsVVJMID0gZGVmYXVsdFBhdGhTZXJpYWxpemVyKGZpbmFsVVJMLCBvcHRpb25zLnBhcmFtcy5wYXRoKTtcbiAgfVxuICBsZXQgc2VhcmNoID0gb3B0aW9ucy5xdWVyeVNlcmlhbGl6ZXIob3B0aW9ucy5wYXJhbXMucXVlcnkgPz8ge30pO1xuICBpZiAoc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpKSB7XG4gICAgc2VhcmNoID0gc2VhcmNoLnN1YnN0cmluZygxKTtcbiAgfVxuICBpZiAoc2VhcmNoKSB7XG4gICAgZmluYWxVUkwgKz0gYD8ke3NlYXJjaH1gO1xuICB9XG4gIHJldHVybiBmaW5hbFVSTDtcbn1cbmZ1bmN0aW9uIG1lcmdlSGVhZGVycyguLi5hbGxIZWFkZXJzKSB7XG4gIGNvbnN0IGZpbmFsSGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIGZvciAoY29uc3QgaCBvZiBhbGxIZWFkZXJzKSB7XG4gICAgaWYgKCFoIHx8IHR5cGVvZiBoICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgaXRlcmF0b3IgPSBoIGluc3RhbmNlb2YgSGVhZGVycyA/IGguZW50cmllcygpIDogT2JqZWN0LmVudHJpZXMoaCk7XG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgaXRlcmF0b3IpIHtcbiAgICAgIGlmICh2ID09PSBudWxsKSB7XG4gICAgICAgIGZpbmFsSGVhZGVycy5kZWxldGUoayk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgZm9yIChjb25zdCB2MiBvZiB2KSB7XG4gICAgICAgICAgZmluYWxIZWFkZXJzLmFwcGVuZChrLCB2Mik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGZpbmFsSGVhZGVycy5zZXQoaywgdik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmaW5hbEhlYWRlcnM7XG59XG5mdW5jdGlvbiByZW1vdmVUcmFpbGluZ1NsYXNoKHVybCkge1xuICBpZiAodXJsLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKDAsIHVybC5sZW5ndGggLSAxKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/openapi-fetch/dist/cjs/index.cjs\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/socket.io-client/build/esm/contrib/backo2.js":
/*!*******************************************************************!*\
  !*** ./node_modules/socket.io-client/build/esm/contrib/backo2.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Backoff: () => (/* binding */ Backoff)\n/* harmony export */ });\n/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\nfunction Backoff(opts) {\n    opts = opts || {};\n    this.ms = opts.min || 100;\n    this.max = opts.max || 10000;\n    this.factor = opts.factor || 2;\n    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n    this.attempts = 0;\n}\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\nBackoff.prototype.duration = function () {\n    var ms = this.ms * Math.pow(this.factor, this.attempts++);\n    if (this.jitter) {\n        var rand = Math.random();\n        var deviation = Math.floor(rand * this.jitter * ms);\n        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n    }\n    return Math.min(ms, this.max) | 0;\n};\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\nBackoff.prototype.reset = function () {\n    this.attempts = 0;\n};\n/**\n * Set the minimum duration\n *\n * @api public\n */\nBackoff.prototype.setMin = function (min) {\n    this.ms = min;\n};\n/**\n * Set the maximum duration\n *\n * @api public\n */\nBackoff.prototype.setMax = function (max) {\n    this.max = max;\n};\n/**\n * Set the jitter\n *\n * @api public\n */\nBackoff.prototype.setJitter = function (jitter) {\n    this.jitter = jitter;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2J1aWxkL2VzbS9jb250cmliL2JhY2tvMi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXHNob3BfaGFyZGhhdFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcc29ja2V0LmlvLWNsaWVudFxcYnVpbGRcXGVzbVxcY29udHJpYlxcYmFja28yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW5pdGlhbGl6ZSBiYWNrb2ZmIHRpbWVyIHdpdGggYG9wdHNgLlxuICpcbiAqIC0gYG1pbmAgaW5pdGlhbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBbMTAwXVxuICogLSBgbWF4YCBtYXggdGltZW91dCBbMTAwMDBdXG4gKiAtIGBqaXR0ZXJgIFswXVxuICogLSBgZmFjdG9yYCBbMl1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHRoaXMubXMgPSBvcHRzLm1pbiB8fCAxMDA7XG4gICAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcbiAgICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gICAgdGhpcy5qaXR0ZXIgPSBvcHRzLmppdHRlciA+IDAgJiYgb3B0cy5qaXR0ZXIgPD0gMSA/IG9wdHMuaml0dGVyIDogMDtcbiAgICB0aGlzLmF0dGVtcHRzID0gMDtcbn1cbi8qKlxuICogUmV0dXJuIHRoZSBiYWNrb2ZmIGR1cmF0aW9uLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cbkJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtcyA9IHRoaXMubXMgKiBNYXRoLnBvdyh0aGlzLmZhY3RvciwgdGhpcy5hdHRlbXB0cysrKTtcbiAgICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB2YXIgZGV2aWF0aW9uID0gTWF0aC5mbG9vcihyYW5kICogdGhpcy5qaXR0ZXIgKiBtcyk7XG4gICAgICAgIG1zID0gKE1hdGguZmxvb3IocmFuZCAqIDEwKSAmIDEpID09IDAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5taW4obXMsIHRoaXMubWF4KSB8IDA7XG59O1xuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbkJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXR0ZW1wdHMgPSAwO1xufTtcbi8qKlxuICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuQmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24gKG1pbikge1xuICAgIHRoaXMubXMgPSBtaW47XG59O1xuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbiAobWF4KSB7XG4gICAgdGhpcy5tYXggPSBtYXg7XG59O1xuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbkJhY2tvZmYucHJvdG90eXBlLnNldEppdHRlciA9IGZ1bmN0aW9uIChqaXR0ZXIpIHtcbiAgICB0aGlzLmppdHRlciA9IGppdHRlcjtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/socket.io-client/build/esm/contrib/backo2.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/socket.io-client/build/esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/socket.io-client/build/esm/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Fetch: () => (/* reexport safe */ engine_io_client__WEBPACK_IMPORTED_MODULE_4__.Fetch),\n/* harmony export */   Manager: () => (/* reexport safe */ _manager_js__WEBPACK_IMPORTED_MODULE_1__.Manager),\n/* harmony export */   NodeWebSocket: () => (/* reexport safe */ engine_io_client__WEBPACK_IMPORTED_MODULE_4__.NodeWebSocket),\n/* harmony export */   NodeXHR: () => (/* reexport safe */ engine_io_client__WEBPACK_IMPORTED_MODULE_4__.NodeXHR),\n/* harmony export */   Socket: () => (/* reexport safe */ _socket_js__WEBPACK_IMPORTED_MODULE_2__.Socket),\n/* harmony export */   WebSocket: () => (/* reexport safe */ engine_io_client__WEBPACK_IMPORTED_MODULE_4__.WebSocket),\n/* harmony export */   WebTransport: () => (/* reexport safe */ engine_io_client__WEBPACK_IMPORTED_MODULE_4__.WebTransport),\n/* harmony export */   XHR: () => (/* reexport safe */ engine_io_client__WEBPACK_IMPORTED_MODULE_4__.XHR),\n/* harmony export */   connect: () => (/* binding */ lookup),\n/* harmony export */   \"default\": () => (/* binding */ lookup),\n/* harmony export */   io: () => (/* binding */ lookup),\n/* harmony export */   protocol: () => (/* reexport safe */ socket_io_parser__WEBPACK_IMPORTED_MODULE_3__.protocol)\n/* harmony export */ });\n/* harmony import */ var _url_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url.js */ \"(pages-dir-browser)/./node_modules/socket.io-client/build/esm/url.js\");\n/* harmony import */ var _manager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./manager.js */ \"(pages-dir-browser)/./node_modules/socket.io-client/build/esm/manager.js\");\n/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./socket.js */ \"(pages-dir-browser)/./node_modules/socket.io-client/build/esm/socket.js\");\n/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! socket.io-parser */ \"(pages-dir-browser)/./node_modules/socket.io-parser/build/esm/index.js\");\n/* harmony import */ var engine_io_client__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! engine.io-client */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/index.js\");\n\n\n\n/**\n * Managers cache.\n */\nconst cache = {};\nfunction lookup(uri, opts) {\n    if (typeof uri === \"object\") {\n        opts = uri;\n        uri = undefined;\n    }\n    opts = opts || {};\n    const parsed = (0,_url_js__WEBPACK_IMPORTED_MODULE_0__.url)(uri, opts.path || \"/socket.io\");\n    const source = parsed.source;\n    const id = parsed.id;\n    const path = parsed.path;\n    const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n    const newConnection = opts.forceNew ||\n        opts[\"force new connection\"] ||\n        false === opts.multiplex ||\n        sameNamespace;\n    let io;\n    if (newConnection) {\n        io = new _manager_js__WEBPACK_IMPORTED_MODULE_1__.Manager(source, opts);\n    }\n    else {\n        if (!cache[id]) {\n            cache[id] = new _manager_js__WEBPACK_IMPORTED_MODULE_1__.Manager(source, opts);\n        }\n        io = cache[id];\n    }\n    if (parsed.query && !opts.query) {\n        opts.query = parsed.queryKey;\n    }\n    return io.socket(parsed.path, opts);\n}\n// so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\n// namespace (e.g. `io.connect(...)`), for backward compatibility\nObject.assign(lookup, {\n    Manager: _manager_js__WEBPACK_IMPORTED_MODULE_1__.Manager,\n    Socket: _socket_js__WEBPACK_IMPORTED_MODULE_2__.Socket,\n    io: lookup,\n    connect: lookup,\n});\n/**\n * Protocol version.\n *\n * @public\n */\n\n/**\n * Expose constructors for standalone build.\n *\n * @public\n */\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2J1aWxkL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNRO0FBQ0Y7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNENBQUc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0RBQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdEQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2dGO0FBQ2dCIiwic291cmNlcyI6WyJDOlxcc2hvcF9oYXJkaGF0XFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxzb2NrZXQuaW8tY2xpZW50XFxidWlsZFxcZXNtXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1cmwgfSBmcm9tIFwiLi91cmwuanNcIjtcbmltcG9ydCB7IE1hbmFnZXIgfSBmcm9tIFwiLi9tYW5hZ2VyLmpzXCI7XG5pbXBvcnQgeyBTb2NrZXQgfSBmcm9tIFwiLi9zb2NrZXQuanNcIjtcbi8qKlxuICogTWFuYWdlcnMgY2FjaGUuXG4gKi9cbmNvbnN0IGNhY2hlID0ge307XG5mdW5jdGlvbiBsb29rdXAodXJpLCBvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiB1cmkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgb3B0cyA9IHVyaTtcbiAgICAgICAgdXJpID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICBjb25zdCBwYXJzZWQgPSB1cmwodXJpLCBvcHRzLnBhdGggfHwgXCIvc29ja2V0LmlvXCIpO1xuICAgIGNvbnN0IHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG4gICAgY29uc3QgaWQgPSBwYXJzZWQuaWQ7XG4gICAgY29uc3QgcGF0aCA9IHBhcnNlZC5wYXRoO1xuICAgIGNvbnN0IHNhbWVOYW1lc3BhY2UgPSBjYWNoZVtpZF0gJiYgcGF0aCBpbiBjYWNoZVtpZF1bXCJuc3BzXCJdO1xuICAgIGNvbnN0IG5ld0Nvbm5lY3Rpb24gPSBvcHRzLmZvcmNlTmV3IHx8XG4gICAgICAgIG9wdHNbXCJmb3JjZSBuZXcgY29ubmVjdGlvblwiXSB8fFxuICAgICAgICBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXggfHxcbiAgICAgICAgc2FtZU5hbWVzcGFjZTtcbiAgICBsZXQgaW87XG4gICAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgaW8gPSBuZXcgTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgICAgICAgIGNhY2hlW2lkXSA9IG5ldyBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gICAgICAgIH1cbiAgICAgICAgaW8gPSBjYWNoZVtpZF07XG4gICAgfVxuICAgIGlmIChwYXJzZWQucXVlcnkgJiYgIW9wdHMucXVlcnkpIHtcbiAgICAgICAgb3B0cy5xdWVyeSA9IHBhcnNlZC5xdWVyeUtleTtcbiAgICB9XG4gICAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCwgb3B0cyk7XG59XG4vLyBzbyB0aGF0IFwibG9va3VwXCIgY2FuIGJlIHVzZWQgYm90aCBhcyBhIGZ1bmN0aW9uIChlLmcuIGBpbyguLi4pYCkgYW5kIGFzIGFcbi8vIG5hbWVzcGFjZSAoZS5nLiBgaW8uY29ubmVjdCguLi4pYCksIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5PYmplY3QuYXNzaWduKGxvb2t1cCwge1xuICAgIE1hbmFnZXIsXG4gICAgU29ja2V0LFxuICAgIGlvOiBsb29rdXAsXG4gICAgY29ubmVjdDogbG9va3VwLFxufSk7XG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgeyBwcm90b2NvbCB9IGZyb20gXCJzb2NrZXQuaW8tcGFyc2VyXCI7XG4vKipcbiAqIEV4cG9zZSBjb25zdHJ1Y3RvcnMgZm9yIHN0YW5kYWxvbmUgYnVpbGQuXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgeyBNYW5hZ2VyLCBTb2NrZXQsIGxvb2t1cCBhcyBpbywgbG9va3VwIGFzIGNvbm5lY3QsIGxvb2t1cCBhcyBkZWZhdWx0LCB9O1xuZXhwb3J0IHsgRmV0Y2gsIE5vZGVYSFIsIFhIUiwgTm9kZVdlYlNvY2tldCwgV2ViU29ja2V0LCBXZWJUcmFuc3BvcnQsIH0gZnJvbSBcImVuZ2luZS5pby1jbGllbnRcIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/socket.io-client/build/esm/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/socket.io-client/build/esm/manager.js":
/*!************************************************************!*\
  !*** ./node_modules/socket.io-client/build/esm/manager.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Manager: () => (/* binding */ Manager)\n/* harmony export */ });\n/* harmony import */ var engine_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! engine.io-client */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/index.js\");\n/* harmony import */ var _socket_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./socket.js */ \"(pages-dir-browser)/./node_modules/socket.io-client/build/esm/socket.js\");\n/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-parser */ \"(pages-dir-browser)/./node_modules/socket.io-parser/build/esm/index.js\");\n/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./on.js */ \"(pages-dir-browser)/./node_modules/socket.io-client/build/esm/on.js\");\n/* harmony import */ var _contrib_backo2_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./contrib/backo2.js */ \"(pages-dir-browser)/./node_modules/socket.io-client/build/esm/contrib/backo2.js\");\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @socket.io/component-emitter */ \"(pages-dir-browser)/./node_modules/@socket.io/component-emitter/lib/esm/index.js\");\n\n\n\n\n\n\nclass Manager extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_5__.Emitter {\n    constructor(uri, opts) {\n        var _a;\n        super();\n        this.nsps = {};\n        this.subs = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        opts.path = opts.path || \"/socket.io\";\n        this.opts = opts;\n        (0,engine_io_client__WEBPACK_IMPORTED_MODULE_0__.installTimerFunctions)(this, opts);\n        this.reconnection(opts.reconnection !== false);\n        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n        this.reconnectionDelay(opts.reconnectionDelay || 1000);\n        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n        this.backoff = new _contrib_backo2_js__WEBPACK_IMPORTED_MODULE_4__.Backoff({\n            min: this.reconnectionDelay(),\n            max: this.reconnectionDelayMax(),\n            jitter: this.randomizationFactor(),\n        });\n        this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n        this._readyState = \"closed\";\n        this.uri = uri;\n        const _parser = opts.parser || socket_io_parser__WEBPACK_IMPORTED_MODULE_2__;\n        this.encoder = new _parser.Encoder();\n        this.decoder = new _parser.Decoder();\n        this._autoConnect = opts.autoConnect !== false;\n        if (this._autoConnect)\n            this.open();\n    }\n    reconnection(v) {\n        if (!arguments.length)\n            return this._reconnection;\n        this._reconnection = !!v;\n        if (!v) {\n            this.skipReconnect = true;\n        }\n        return this;\n    }\n    reconnectionAttempts(v) {\n        if (v === undefined)\n            return this._reconnectionAttempts;\n        this._reconnectionAttempts = v;\n        return this;\n    }\n    reconnectionDelay(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelay;\n        this._reconnectionDelay = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n        return this;\n    }\n    randomizationFactor(v) {\n        var _a;\n        if (v === undefined)\n            return this._randomizationFactor;\n        this._randomizationFactor = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n        return this;\n    }\n    reconnectionDelayMax(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelayMax;\n        this._reconnectionDelayMax = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n        return this;\n    }\n    timeout(v) {\n        if (!arguments.length)\n            return this._timeout;\n        this._timeout = v;\n        return this;\n    }\n    /**\n     * Starts trying to reconnect if reconnection is enabled and we have not\n     * started reconnecting yet\n     *\n     * @private\n     */\n    maybeReconnectOnOpen() {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this._reconnecting &&\n            this._reconnection &&\n            this.backoff.attempts === 0) {\n            // keeps reconnection from firing twice for the same reconnection loop\n            this.reconnect();\n        }\n    }\n    /**\n     * Sets the current transport `socket`.\n     *\n     * @param {Function} fn - optional, callback\n     * @return self\n     * @public\n     */\n    open(fn) {\n        if (~this._readyState.indexOf(\"open\"))\n            return this;\n        this.engine = new engine_io_client__WEBPACK_IMPORTED_MODULE_0__.Socket(this.uri, this.opts);\n        const socket = this.engine;\n        const self = this;\n        this._readyState = \"opening\";\n        this.skipReconnect = false;\n        // emit `open`\n        const openSubDestroy = (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, \"open\", function () {\n            self.onopen();\n            fn && fn();\n        });\n        const onError = (err) => {\n            this.cleanup();\n            this._readyState = \"closed\";\n            this.emitReserved(\"error\", err);\n            if (fn) {\n                fn(err);\n            }\n            else {\n                // Only do this if there is no fn to handle the error\n                this.maybeReconnectOnOpen();\n            }\n        };\n        // emit `error`\n        const errorSub = (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, \"error\", onError);\n        if (false !== this._timeout) {\n            const timeout = this._timeout;\n            // set timer\n            const timer = this.setTimeoutFn(() => {\n                openSubDestroy();\n                onError(new Error(\"timeout\"));\n                socket.close();\n            }, timeout);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(() => {\n                this.clearTimeoutFn(timer);\n            });\n        }\n        this.subs.push(openSubDestroy);\n        this.subs.push(errorSub);\n        return this;\n    }\n    /**\n     * Alias for open()\n     *\n     * @return self\n     * @public\n     */\n    connect(fn) {\n        return this.open(fn);\n    }\n    /**\n     * Called upon transport open.\n     *\n     * @private\n     */\n    onopen() {\n        // clear old subs\n        this.cleanup();\n        // mark as open\n        this._readyState = \"open\";\n        this.emitReserved(\"open\");\n        // add new subs\n        const socket = this.engine;\n        this.subs.push((0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, \"ping\", this.onping.bind(this)), (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, \"data\", this.ondata.bind(this)), (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, \"error\", this.onerror.bind(this)), (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(socket, \"close\", this.onclose.bind(this)), \n        // @ts-ignore\n        (0,_on_js__WEBPACK_IMPORTED_MODULE_3__.on)(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n    }\n    /**\n     * Called upon a ping.\n     *\n     * @private\n     */\n    onping() {\n        this.emitReserved(\"ping\");\n    }\n    /**\n     * Called with data.\n     *\n     * @private\n     */\n    ondata(data) {\n        try {\n            this.decoder.add(data);\n        }\n        catch (e) {\n            this.onclose(\"parse error\", e);\n        }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a \"parse error\"\n        (0,engine_io_client__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {\n            this.emitReserved(\"packet\", packet);\n        }, this.setTimeoutFn);\n    }\n    /**\n     * Called upon socket error.\n     *\n     * @private\n     */\n    onerror(err) {\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Creates a new socket for the given `nsp`.\n     *\n     * @return {Socket}\n     * @public\n     */\n    socket(nsp, opts) {\n        let socket = this.nsps[nsp];\n        if (!socket) {\n            socket = new _socket_js__WEBPACK_IMPORTED_MODULE_1__.Socket(this, nsp, opts);\n            this.nsps[nsp] = socket;\n        }\n        else if (this._autoConnect && !socket.active) {\n            socket.connect();\n        }\n        return socket;\n    }\n    /**\n     * Called upon a socket close.\n     *\n     * @param socket\n     * @private\n     */\n    _destroy(socket) {\n        const nsps = Object.keys(this.nsps);\n        for (const nsp of nsps) {\n            const socket = this.nsps[nsp];\n            if (socket.active) {\n                return;\n            }\n        }\n        this._close();\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param packet\n     * @private\n     */\n    _packet(packet) {\n        const encodedPackets = this.encoder.encode(packet);\n        for (let i = 0; i < encodedPackets.length; i++) {\n            this.engine.write(encodedPackets[i], packet.options);\n        }\n    }\n    /**\n     * Clean up transport subscriptions and packet buffer.\n     *\n     * @private\n     */\n    cleanup() {\n        this.subs.forEach((subDestroy) => subDestroy());\n        this.subs.length = 0;\n        this.decoder.destroy();\n    }\n    /**\n     * Close the current socket.\n     *\n     * @private\n     */\n    _close() {\n        this.skipReconnect = true;\n        this._reconnecting = false;\n        this.onclose(\"forced close\");\n    }\n    /**\n     * Alias for close()\n     *\n     * @private\n     */\n    disconnect() {\n        return this._close();\n    }\n    /**\n     * Called when:\n     *\n     * - the low-level engine is closed\n     * - the parser encountered a badly formatted packet\n     * - all sockets are disconnected\n     *\n     * @private\n     */\n    onclose(reason, description) {\n        var _a;\n        this.cleanup();\n        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        this.emitReserved(\"close\", reason, description);\n        if (this._reconnection && !this.skipReconnect) {\n            this.reconnect();\n        }\n    }\n    /**\n     * Attempt a reconnection.\n     *\n     * @private\n     */\n    reconnect() {\n        if (this._reconnecting || this.skipReconnect)\n            return this;\n        const self = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\n            this.backoff.reset();\n            this.emitReserved(\"reconnect_failed\");\n            this._reconnecting = false;\n        }\n        else {\n            const delay = this.backoff.duration();\n            this._reconnecting = true;\n            const timer = this.setTimeoutFn(() => {\n                if (self.skipReconnect)\n                    return;\n                this.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\n                // check again for the case socket closed in above events\n                if (self.skipReconnect)\n                    return;\n                self.open((err) => {\n                    if (err) {\n                        self._reconnecting = false;\n                        self.reconnect();\n                        this.emitReserved(\"reconnect_error\", err);\n                    }\n                    else {\n                        self.onreconnect();\n                    }\n                });\n            }, delay);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(() => {\n                this.clearTimeoutFn(timer);\n            });\n        }\n    }\n    /**\n     * Called upon successful reconnect.\n     *\n     * @private\n     */\n    onreconnect() {\n        const attempt = this.backoff.attempts;\n        this._reconnecting = false;\n        this.backoff.reset();\n        this.emitReserved(\"reconnect\", attempt);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2J1aWxkL2VzbS9tYW5hZ2VyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBc0Y7QUFDakQ7QUFDTTtBQUNkO0FBQ2lCO0FBQ1U7QUFDakQsc0JBQXNCLGlFQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUVBQXFCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdURBQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw2Q0FBTTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9EQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMENBQUU7QUFDakM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQ0FBRTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQ0FBRSwwQ0FBMEMsMENBQUUsMENBQTBDLDBDQUFFLDRDQUE0QywwQ0FBRTtBQUMvSjtBQUNBLFFBQVEsMENBQUU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwREFBUTtBQUNoQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw4Q0FBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHNvY2tldC5pby1jbGllbnRcXGJ1aWxkXFxlc21cXG1hbmFnZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU29ja2V0IGFzIEVuZ2luZSwgaW5zdGFsbFRpbWVyRnVuY3Rpb25zLCBuZXh0VGljaywgfSBmcm9tIFwiZW5naW5lLmlvLWNsaWVudFwiO1xuaW1wb3J0IHsgU29ja2V0IH0gZnJvbSBcIi4vc29ja2V0LmpzXCI7XG5pbXBvcnQgKiBhcyBwYXJzZXIgZnJvbSBcInNvY2tldC5pby1wYXJzZXJcIjtcbmltcG9ydCB7IG9uIH0gZnJvbSBcIi4vb24uanNcIjtcbmltcG9ydCB7IEJhY2tvZmYgfSBmcm9tIFwiLi9jb250cmliL2JhY2tvMi5qc1wiO1xuaW1wb3J0IHsgRW1pdHRlciwgfSBmcm9tIFwiQHNvY2tldC5pby9jb21wb25lbnQtZW1pdHRlclwiO1xuZXhwb3J0IGNsYXNzIE1hbmFnZXIgZXh0ZW5kcyBFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih1cmksIG9wdHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5zcHMgPSB7fTtcbiAgICAgICAgdGhpcy5zdWJzID0gW107XG4gICAgICAgIGlmICh1cmkgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHVyaSkge1xuICAgICAgICAgICAgb3B0cyA9IHVyaTtcbiAgICAgICAgICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8IFwiL3NvY2tldC5pb1wiO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICBpbnN0YWxsVGltZXJGdW5jdGlvbnModGhpcywgb3B0cyk7XG4gICAgICAgIHRoaXMucmVjb25uZWN0aW9uKG9wdHMucmVjb25uZWN0aW9uICE9PSBmYWxzZSk7XG4gICAgICAgIHRoaXMucmVjb25uZWN0aW9uQXR0ZW1wdHMob3B0cy5yZWNvbm5lY3Rpb25BdHRlbXB0cyB8fCBJbmZpbml0eSk7XG4gICAgICAgIHRoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheSB8fCAxMDAwKTtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heChvcHRzLnJlY29ubmVjdGlvbkRlbGF5TWF4IHx8IDUwMDApO1xuICAgICAgICB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3IoKF9hID0gb3B0cy5yYW5kb21pemF0aW9uRmFjdG9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLjUpO1xuICAgICAgICB0aGlzLmJhY2tvZmYgPSBuZXcgQmFja29mZih7XG4gICAgICAgICAgICBtaW46IHRoaXMucmVjb25uZWN0aW9uRGVsYXkoKSxcbiAgICAgICAgICAgIG1heDogdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heCgpLFxuICAgICAgICAgICAgaml0dGVyOiB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3IoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGltZW91dChudWxsID09IG9wdHMudGltZW91dCA/IDIwMDAwIDogb3B0cy50aW1lb3V0KTtcbiAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFwiY2xvc2VkXCI7XG4gICAgICAgIHRoaXMudXJpID0gdXJpO1xuICAgICAgICBjb25zdCBfcGFyc2VyID0gb3B0cy5wYXJzZXIgfHwgcGFyc2VyO1xuICAgICAgICB0aGlzLmVuY29kZXIgPSBuZXcgX3BhcnNlci5FbmNvZGVyKCk7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBfcGFyc2VyLkRlY29kZXIoKTtcbiAgICAgICAgdGhpcy5fYXV0b0Nvbm5lY3QgPSBvcHRzLmF1dG9Db25uZWN0ICE9PSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2F1dG9Db25uZWN0KVxuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfVxuICAgIHJlY29ubmVjdGlvbih2KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb247XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdGlvbiA9ICEhdjtcbiAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICB0aGlzLnNraXBSZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZWNvbm5lY3Rpb25BdHRlbXB0cyh2KSB7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHM7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzID0gdjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlY29ubmVjdGlvbkRlbGF5KHYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG4gICAgICAgIChfYSA9IHRoaXMuYmFja29mZikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldE1pbih2KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJhbmRvbWl6YXRpb25GYWN0b3Iodikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvcjtcbiAgICAgICAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG4gICAgICAgIChfYSA9IHRoaXMuYmFja29mZikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEppdHRlcih2KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlY29ubmVjdGlvbkRlbGF5TWF4KHYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICAgICAgICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gICAgICAgIChfYSA9IHRoaXMuYmFja29mZikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldE1heCh2KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRpbWVvdXQodikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IHY7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3RcbiAgICAgKiBzdGFydGVkIHJlY29ubmVjdGluZyB5ZXRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbWF5YmVSZWNvbm5lY3RPbk9wZW4oKSB7XG4gICAgICAgIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgICAgICAgaWYgKCF0aGlzLl9yZWNvbm5lY3RpbmcgJiZcbiAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdGlvbiAmJlxuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG4gICAgICAgICAgICAvLyBrZWVwcyByZWNvbm5lY3Rpb24gZnJvbSBmaXJpbmcgdHdpY2UgZm9yIHRoZSBzYW1lIHJlY29ubmVjdGlvbiBsb29wXG4gICAgICAgICAgICB0aGlzLnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0IGBzb2NrZXRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBvcHRpb25hbCwgY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgb3Blbihmbikge1xuICAgICAgICBpZiAofnRoaXMuX3JlYWR5U3RhdGUuaW5kZXhPZihcIm9wZW5cIikpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBuZXcgRW5naW5lKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBcIm9wZW5pbmdcIjtcbiAgICAgICAgdGhpcy5za2lwUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgIC8vIGVtaXQgYG9wZW5gXG4gICAgICAgIGNvbnN0IG9wZW5TdWJEZXN0cm95ID0gb24oc29ja2V0LCBcIm9wZW5cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5vbm9wZW4oKTtcbiAgICAgICAgICAgIGZuICYmIGZuKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gXCJjbG9zZWRcIjtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIGZuKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGRvIHRoaXMgaWYgdGhlcmUgaXMgbm8gZm4gdG8gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgICAgICAgICAgIHRoaXMubWF5YmVSZWNvbm5lY3RPbk9wZW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gZW1pdCBgZXJyb3JgXG4gICAgICAgIGNvbnN0IGVycm9yU3ViID0gb24oc29ja2V0LCBcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgICBpZiAoZmFsc2UgIT09IHRoaXMuX3RpbWVvdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0O1xuICAgICAgICAgICAgLy8gc2V0IHRpbWVyXG4gICAgICAgICAgICBjb25zdCB0aW1lciA9IHRoaXMuc2V0VGltZW91dEZuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBvcGVuU3ViRGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIG9uRXJyb3IobmV3IEVycm9yKFwidGltZW91dFwiKSk7XG4gICAgICAgICAgICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdHMuYXV0b1VucmVmKSB7XG4gICAgICAgICAgICAgICAgdGltZXIudW5yZWYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3Vicy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dEZuKHRpbWVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vicy5wdXNoKG9wZW5TdWJEZXN0cm95KTtcbiAgICAgICAgdGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIG9wZW4oKVxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNvbm5lY3QoZm4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3Blbihmbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBvcGVuLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbm9wZW4oKSB7XG4gICAgICAgIC8vIGNsZWFyIG9sZCBzdWJzXG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICAvLyBtYXJrIGFzIG9wZW5cbiAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFwib3BlblwiO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcIm9wZW5cIik7XG4gICAgICAgIC8vIGFkZCBuZXcgc3Vic1xuICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgICAgICAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCBcInBpbmdcIiwgdGhpcy5vbnBpbmcuYmluZCh0aGlzKSksIG9uKHNvY2tldCwgXCJkYXRhXCIsIHRoaXMub25kYXRhLmJpbmQodGhpcykpLCBvbihzb2NrZXQsIFwiZXJyb3JcIiwgdGhpcy5vbmVycm9yLmJpbmQodGhpcykpLCBvbihzb2NrZXQsIFwiY2xvc2VcIiwgdGhpcy5vbmNsb3NlLmJpbmQodGhpcykpLCBcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBvbih0aGlzLmRlY29kZXIsIFwiZGVjb2RlZFwiLCB0aGlzLm9uZGVjb2RlZC5iaW5kKHRoaXMpKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGEgcGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25waW5nKCkge1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInBpbmdcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZGF0YShkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmRlY29kZXIuYWRkKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLm9uY2xvc2UoXCJwYXJzZSBlcnJvclwiLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBwYXJzZXIgZnVsbHkgZGVjb2RlcyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25kZWNvZGVkKHBhY2tldCkge1xuICAgICAgICAvLyB0aGUgbmV4dFRpY2sgY2FsbCBwcmV2ZW50cyBhbiBleGNlcHRpb24gaW4gYSB1c2VyLXByb3ZpZGVkIGV2ZW50IGxpc3RlbmVyIGZyb20gdHJpZ2dlcmluZyBhIGRpc2Nvbm5lY3Rpb24gZHVlIHRvIGEgXCJwYXJzZSBlcnJvclwiXG4gICAgICAgIG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicGFja2V0XCIsIHBhY2tldCk7XG4gICAgICAgIH0sIHRoaXMuc2V0VGltZW91dEZuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gc29ja2V0IGVycm9yLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmVycm9yKGVycikge1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImVycm9yXCIsIGVycik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNvY2tldChuc3AsIG9wdHMpIHtcbiAgICAgICAgbGV0IHNvY2tldCA9IHRoaXMubnNwc1tuc3BdO1xuICAgICAgICBpZiAoIXNvY2tldCkge1xuICAgICAgICAgICAgc29ja2V0ID0gbmV3IFNvY2tldCh0aGlzLCBuc3AsIG9wdHMpO1xuICAgICAgICAgICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fYXV0b0Nvbm5lY3QgJiYgIXNvY2tldC5hY3RpdmUpIHtcbiAgICAgICAgICAgIHNvY2tldC5jb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc29ja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGVzdHJveShzb2NrZXQpIHtcbiAgICAgICAgY29uc3QgbnNwcyA9IE9iamVjdC5rZXlzKHRoaXMubnNwcyk7XG4gICAgICAgIGZvciAoY29uc3QgbnNwIG9mIG5zcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubnNwc1tuc3BdO1xuICAgICAgICAgICAgaWYgKHNvY2tldC5hY3RpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BhY2tldChwYWNrZXQpIHtcbiAgICAgICAgY29uc3QgZW5jb2RlZFBhY2tldHMgPSB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZW5naW5lLndyaXRlKGVuY29kZWRQYWNrZXRzW2ldLCBwYWNrZXQub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW4gdXAgdHJhbnNwb3J0IHN1YnNjcmlwdGlvbnMgYW5kIHBhY2tldCBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIHRoaXMuc3Vicy5mb3JFYWNoKChzdWJEZXN0cm95KSA9PiBzdWJEZXN0cm95KCkpO1xuICAgICAgICB0aGlzLnN1YnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm9uY2xvc2UoXCJmb3JjZWQgY2xvc2VcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciBjbG9zZSgpXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbjpcbiAgICAgKlxuICAgICAqIC0gdGhlIGxvdy1sZXZlbCBlbmdpbmUgaXMgY2xvc2VkXG4gICAgICogLSB0aGUgcGFyc2VyIGVuY291bnRlcmVkIGEgYmFkbHkgZm9ybWF0dGVkIHBhY2tldFxuICAgICAqIC0gYWxsIHNvY2tldHMgYXJlIGRpc2Nvbm5lY3RlZFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmNsb3NlKHJlYXNvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgKF9hID0gdGhpcy5lbmdpbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xuICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFwiY2xvc2VkXCI7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiY2xvc2VcIiwgcmVhc29uLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IGEgcmVjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZWNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZWNvbm5lY3RpbmcgfHwgdGhpcy5za2lwUmVjb25uZWN0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwicmVjb25uZWN0X2ZhaWxlZFwiKTtcbiAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuX3JlY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCB0aW1lciA9IHRoaXMuc2V0VGltZW91dEZuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJyZWNvbm5lY3RfYXR0ZW1wdFwiLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBzZWxmLm9wZW4oKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInJlY29ubmVjdF9lcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5vbnJlY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRzLmF1dG9VbnJlZikge1xuICAgICAgICAgICAgICAgIHRpbWVyLnVucmVmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN1YnMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXRGbih0aW1lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlY29ubmVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25yZWNvbm5lY3QoKSB7XG4gICAgICAgIGNvbnN0IGF0dGVtcHQgPSB0aGlzLmJhY2tvZmYuYXR0ZW1wdHM7XG4gICAgICAgIHRoaXMuX3JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJyZWNvbm5lY3RcIiwgYXR0ZW1wdCk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/socket.io-client/build/esm/manager.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/socket.io-client/build/esm/on.js":
/*!*******************************************************!*\
  !*** ./node_modules/socket.io-client/build/esm/on.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   on: () => (/* binding */ on)\n/* harmony export */ });\nfunction on(obj, ev, fn) {\n    obj.on(ev, fn);\n    return function subDestroy() {\n        obj.off(ev, fn);\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2J1aWxkL2VzbS9vbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJDOlxcc2hvcF9oYXJkaGF0XFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFxzb2NrZXQuaW8tY2xpZW50XFxidWlsZFxcZXNtXFxvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gb24ob2JqLCBldiwgZm4pIHtcbiAgICBvYmoub24oZXYsIGZuKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gc3ViRGVzdHJveSgpIHtcbiAgICAgICAgb2JqLm9mZihldiwgZm4pO1xuICAgIH07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/socket.io-client/build/esm/on.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/socket.io-client/build/esm/socket.js":
/*!***********************************************************!*\
  !*** ./node_modules/socket.io-client/build/esm/socket.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Socket: () => (/* binding */ Socket)\n/* harmony export */ });\n/* harmony import */ var socket_io_parser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! socket.io-parser */ \"(pages-dir-browser)/./node_modules/socket.io-parser/build/esm/index.js\");\n/* harmony import */ var _on_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./on.js */ \"(pages-dir-browser)/./node_modules/socket.io-client/build/esm/on.js\");\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @socket.io/component-emitter */ \"(pages-dir-browser)/./node_modules/@socket.io/component-emitter/lib/esm/index.js\");\n\n\n\n/**\n * Internal events.\n * These events can't be emitted by the user.\n */\nconst RESERVED_EVENTS = Object.freeze({\n    connect: 1,\n    connect_error: 1,\n    disconnect: 1,\n    disconnecting: 1,\n    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n    newListener: 1,\n    removeListener: 1,\n});\n/**\n * A Socket is the fundamental class for interacting with the server.\n *\n * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.\n *\n * @example\n * const socket = io();\n *\n * socket.on(\"connect\", () => {\n *   console.log(\"connected\");\n * });\n *\n * // send an event to the server\n * socket.emit(\"foo\", \"bar\");\n *\n * socket.on(\"foobar\", () => {\n *   // an event was received from the server\n * });\n *\n * // upon disconnection\n * socket.on(\"disconnect\", (reason) => {\n *   console.log(`disconnected due to ${reason}`);\n * });\n */\nclass Socket extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_2__.Emitter {\n    /**\n     * `Socket` constructor.\n     */\n    constructor(io, nsp, opts) {\n        super();\n        /**\n         * Whether the socket is currently connected to the server.\n         *\n         * @example\n         * const socket = io();\n         *\n         * socket.on(\"connect\", () => {\n         *   console.log(socket.connected); // true\n         * });\n         *\n         * socket.on(\"disconnect\", () => {\n         *   console.log(socket.connected); // false\n         * });\n         */\n        this.connected = false;\n        /**\n         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\n         * be transmitted by the server.\n         */\n        this.recovered = false;\n        /**\n         * Buffer for packets received before the CONNECT packet\n         */\n        this.receiveBuffer = [];\n        /**\n         * Buffer for packets that will be sent once the socket is connected\n         */\n        this.sendBuffer = [];\n        /**\n         * The queue of packets to be sent with retry in case of failure.\n         *\n         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.\n         * @private\n         */\n        this._queue = [];\n        /**\n         * A sequence to generate the ID of the {@link QueuedPacket}.\n         * @private\n         */\n        this._queueSeq = 0;\n        this.ids = 0;\n        /**\n         * A map containing acknowledgement handlers.\n         *\n         * The `withError` attribute is used to differentiate handlers that accept an error as first argument:\n         *\n         * - `socket.emit(\"test\", (err, value) => { ... })` with `ackTimeout` option\n         * - `socket.timeout(5000).emit(\"test\", (err, value) => { ... })`\n         * - `const value = await socket.emitWithAck(\"test\")`\n         *\n         * From those that don't:\n         *\n         * - `socket.emit(\"test\", (value) => { ... });`\n         *\n         * In the first case, the handlers will be called with an error when:\n         *\n         * - the timeout is reached\n         * - the socket gets disconnected\n         *\n         * In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive\n         * an acknowledgement from the server.\n         *\n         * @private\n         */\n        this.acks = {};\n        this.flags = {};\n        this.io = io;\n        this.nsp = nsp;\n        if (opts && opts.auth) {\n            this.auth = opts.auth;\n        }\n        this._opts = Object.assign({}, opts);\n        if (this.io._autoConnect)\n            this.open();\n    }\n    /**\n     * Whether the socket is currently disconnected\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"connect\", () => {\n     *   console.log(socket.disconnected); // false\n     * });\n     *\n     * socket.on(\"disconnect\", () => {\n     *   console.log(socket.disconnected); // true\n     * });\n     */\n    get disconnected() {\n        return !this.connected;\n    }\n    /**\n     * Subscribe to open, close and packet events\n     *\n     * @private\n     */\n    subEvents() {\n        if (this.subs)\n            return;\n        const io = this.io;\n        this.subs = [\n            (0,_on_js__WEBPACK_IMPORTED_MODULE_1__.on)(io, \"open\", this.onopen.bind(this)),\n            (0,_on_js__WEBPACK_IMPORTED_MODULE_1__.on)(io, \"packet\", this.onpacket.bind(this)),\n            (0,_on_js__WEBPACK_IMPORTED_MODULE_1__.on)(io, \"error\", this.onerror.bind(this)),\n            (0,_on_js__WEBPACK_IMPORTED_MODULE_1__.on)(io, \"close\", this.onclose.bind(this)),\n        ];\n    }\n    /**\n     * Whether the Socket will try to reconnect when its Manager connects or reconnects.\n     *\n     * @example\n     * const socket = io();\n     *\n     * console.log(socket.active); // true\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   if (reason === \"io server disconnect\") {\n     *     // the disconnection was initiated by the server, you need to manually reconnect\n     *     console.log(socket.active); // false\n     *   }\n     *   // else the socket will automatically try to reconnect\n     *   console.log(socket.active); // true\n     * });\n     */\n    get active() {\n        return !!this.subs;\n    }\n    /**\n     * \"Opens\" the socket.\n     *\n     * @example\n     * const socket = io({\n     *   autoConnect: false\n     * });\n     *\n     * socket.connect();\n     */\n    connect() {\n        if (this.connected)\n            return this;\n        this.subEvents();\n        if (!this.io[\"_reconnecting\"])\n            this.io.open(); // ensure open\n        if (\"open\" === this.io._readyState)\n            this.onopen();\n        return this;\n    }\n    /**\n     * Alias for {@link connect()}.\n     */\n    open() {\n        return this.connect();\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * socket.send(\"hello\");\n     *\n     * // this is equivalent to\n     * socket.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */\n    send(...args) {\n        args.unshift(\"message\");\n        this.emit.apply(this, args);\n        return this;\n    }\n    /**\n     * Override `emit`.\n     * If the event is in `events`, it's emitted normally.\n     *\n     * @example\n     * socket.emit(\"hello\", \"world\");\n     *\n     * // all serializable datastructures are supported (no need to call JSON.stringify)\n     * socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n     *\n     * // with an acknowledgement from the server\n     * socket.emit(\"hello\", \"world\", (val) => {\n     *   // ...\n     * });\n     *\n     * @return self\n     */\n    emit(ev, ...args) {\n        var _a, _b, _c;\n        if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n            throw new Error('\"' + ev.toString() + '\" is a reserved event name');\n        }\n        args.unshift(ev);\n        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {\n            this._addToQueue(args);\n            return this;\n        }\n        const packet = {\n            type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.EVENT,\n            data: args,\n        };\n        packet.options = {};\n        packet.options.compress = this.flags.compress !== false;\n        // event ack callback\n        if (\"function\" === typeof args[args.length - 1]) {\n            const id = this.ids++;\n            const ack = args.pop();\n            this._registerAckCallback(id, ack);\n            packet.id = id;\n        }\n        const isTransportWritable = (_b = (_a = this.io.engine) === null || _a === void 0 ? void 0 : _a.transport) === null || _b === void 0 ? void 0 : _b.writable;\n        const isConnected = this.connected && !((_c = this.io.engine) === null || _c === void 0 ? void 0 : _c._hasPingExpired());\n        const discardPacket = this.flags.volatile && !isTransportWritable;\n        if (discardPacket) {\n        }\n        else if (isConnected) {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        }\n        else {\n            this.sendBuffer.push(packet);\n        }\n        this.flags = {};\n        return this;\n    }\n    /**\n     * @private\n     */\n    _registerAckCallback(id, ack) {\n        var _a;\n        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;\n        if (timeout === undefined) {\n            this.acks[id] = ack;\n            return;\n        }\n        // @ts-ignore\n        const timer = this.io.setTimeoutFn(() => {\n            delete this.acks[id];\n            for (let i = 0; i < this.sendBuffer.length; i++) {\n                if (this.sendBuffer[i].id === id) {\n                    this.sendBuffer.splice(i, 1);\n                }\n            }\n            ack.call(this, new Error(\"operation has timed out\"));\n        }, timeout);\n        const fn = (...args) => {\n            // @ts-ignore\n            this.io.clearTimeoutFn(timer);\n            ack.apply(this, args);\n        };\n        fn.withError = true;\n        this.acks[id] = fn;\n    }\n    /**\n     * Emits an event and waits for an acknowledgement\n     *\n     * @example\n     * // without timeout\n     * const response = await socket.emitWithAck(\"hello\", \"world\");\n     *\n     * // with a specific timeout\n     * try {\n     *   const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n     * } catch (err) {\n     *   // the server did not acknowledge the event in the given delay\n     * }\n     *\n     * @return a Promise that will be fulfilled when the server acknowledges the event\n     */\n    emitWithAck(ev, ...args) {\n        return new Promise((resolve, reject) => {\n            const fn = (arg1, arg2) => {\n                return arg1 ? reject(arg1) : resolve(arg2);\n            };\n            fn.withError = true;\n            args.push(fn);\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * Add the packet to the queue.\n     * @param args\n     * @private\n     */\n    _addToQueue(args) {\n        let ack;\n        if (typeof args[args.length - 1] === \"function\") {\n            ack = args.pop();\n        }\n        const packet = {\n            id: this._queueSeq++,\n            tryCount: 0,\n            pending: false,\n            args,\n            flags: Object.assign({ fromQueue: true }, this.flags),\n        };\n        args.push((err, ...responseArgs) => {\n            if (packet !== this._queue[0]) {\n                // the packet has already been acknowledged\n                return;\n            }\n            const hasError = err !== null;\n            if (hasError) {\n                if (packet.tryCount > this._opts.retries) {\n                    this._queue.shift();\n                    if (ack) {\n                        ack(err);\n                    }\n                }\n            }\n            else {\n                this._queue.shift();\n                if (ack) {\n                    ack(null, ...responseArgs);\n                }\n            }\n            packet.pending = false;\n            return this._drainQueue();\n        });\n        this._queue.push(packet);\n        this._drainQueue();\n    }\n    /**\n     * Send the first packet of the queue, and wait for an acknowledgement from the server.\n     * @param force - whether to resend a packet that has not been acknowledged yet\n     *\n     * @private\n     */\n    _drainQueue(force = false) {\n        if (!this.connected || this._queue.length === 0) {\n            return;\n        }\n        const packet = this._queue[0];\n        if (packet.pending && !force) {\n            return;\n        }\n        packet.pending = true;\n        packet.tryCount++;\n        this.flags = packet.flags;\n        this.emit.apply(this, packet.args);\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param packet\n     * @private\n     */\n    packet(packet) {\n        packet.nsp = this.nsp;\n        this.io._packet(packet);\n    }\n    /**\n     * Called upon engine `open`.\n     *\n     * @private\n     */\n    onopen() {\n        if (typeof this.auth == \"function\") {\n            this.auth((data) => {\n                this._sendConnectPacket(data);\n            });\n        }\n        else {\n            this._sendConnectPacket(this.auth);\n        }\n    }\n    /**\n     * Sends a CONNECT packet to initiate the Socket.IO session.\n     *\n     * @param data\n     * @private\n     */\n    _sendConnectPacket(data) {\n        this.packet({\n            type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.CONNECT,\n            data: this._pid\n                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data)\n                : data,\n        });\n    }\n    /**\n     * Called upon engine or manager `error`.\n     *\n     * @param err\n     * @private\n     */\n    onerror(err) {\n        if (!this.connected) {\n            this.emitReserved(\"connect_error\", err);\n        }\n    }\n    /**\n     * Called upon engine `close`.\n     *\n     * @param reason\n     * @param description\n     * @private\n     */\n    onclose(reason, description) {\n        this.connected = false;\n        delete this.id;\n        this.emitReserved(\"disconnect\", reason, description);\n        this._clearAcks();\n    }\n    /**\n     * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from\n     * the server.\n     *\n     * @private\n     */\n    _clearAcks() {\n        Object.keys(this.acks).forEach((id) => {\n            const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);\n            if (!isBuffered) {\n                // note: handlers that do not accept an error as first argument are ignored here\n                const ack = this.acks[id];\n                delete this.acks[id];\n                if (ack.withError) {\n                    ack.call(this, new Error(\"socket has been disconnected\"));\n                }\n            }\n        });\n    }\n    /**\n     * Called with socket packet.\n     *\n     * @param packet\n     * @private\n     */\n    onpacket(packet) {\n        const sameNamespace = packet.nsp === this.nsp;\n        if (!sameNamespace)\n            return;\n        switch (packet.type) {\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.CONNECT:\n                if (packet.data && packet.data.sid) {\n                    this.onconnect(packet.data.sid, packet.data.pid);\n                }\n                else {\n                    this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                }\n                break;\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.EVENT:\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.ACK:\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n            case socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.CONNECT_ERROR:\n                this.destroy();\n                const err = new Error(packet.data.message);\n                // @ts-ignore\n                err.data = packet.data.data;\n                this.emitReserved(\"connect_error\", err);\n                break;\n        }\n    }\n    /**\n     * Called upon a server event.\n     *\n     * @param packet\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        if (null != packet.id) {\n            args.push(this.ack(packet.id));\n        }\n        if (this.connected) {\n            this.emitEvent(args);\n        }\n        else {\n            this.receiveBuffer.push(Object.freeze(args));\n        }\n    }\n    emitEvent(args) {\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        super.emit.apply(this, args);\n        if (this._pid && args.length && typeof args[args.length - 1] === \"string\") {\n            this._lastOffset = args[args.length - 1];\n        }\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function (...args) {\n            // prevent double callbacks\n            if (sent)\n                return;\n            sent = true;\n            self.packet({\n                type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.ACK,\n                id: id,\n                data: args,\n            });\n        };\n    }\n    /**\n     * Called upon a server acknowledgement.\n     *\n     * @param packet\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks[packet.id];\n        if (typeof ack !== \"function\") {\n            return;\n        }\n        delete this.acks[packet.id];\n        // @ts-ignore FIXME ack is incorrectly inferred as 'never'\n        if (ack.withError) {\n            packet.data.unshift(null);\n        }\n        // @ts-ignore\n        ack.apply(this, packet.data);\n    }\n    /**\n     * Called upon server connect.\n     *\n     * @private\n     */\n    onconnect(id, pid) {\n        this.id = id;\n        this.recovered = pid && this._pid === pid;\n        this._pid = pid; // defined only if connection state recovery is enabled\n        this.connected = true;\n        this.emitBuffered();\n        this.emitReserved(\"connect\");\n        this._drainQueue(true);\n    }\n    /**\n     * Emit buffered events (received and emitted).\n     *\n     * @private\n     */\n    emitBuffered() {\n        this.receiveBuffer.forEach((args) => this.emitEvent(args));\n        this.receiveBuffer = [];\n        this.sendBuffer.forEach((packet) => {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        });\n        this.sendBuffer = [];\n    }\n    /**\n     * Called upon server disconnect.\n     *\n     * @private\n     */\n    ondisconnect() {\n        this.destroy();\n        this.onclose(\"io server disconnect\");\n    }\n    /**\n     * Called upon forced client/server side disconnections,\n     * this method ensures the manager stops tracking us and\n     * that reconnections don't get triggered for this.\n     *\n     * @private\n     */\n    destroy() {\n        if (this.subs) {\n            // clean subscriptions to avoid reconnections\n            this.subs.forEach((subDestroy) => subDestroy());\n            this.subs = undefined;\n        }\n        this.io[\"_destroy\"](this);\n    }\n    /**\n     * Disconnects the socket manually. In that case, the socket will not try to reconnect.\n     *\n     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   // console.log(reason); prints \"io client disconnect\"\n     * });\n     *\n     * socket.disconnect();\n     *\n     * @return self\n     */\n    disconnect() {\n        if (this.connected) {\n            this.packet({ type: socket_io_parser__WEBPACK_IMPORTED_MODULE_0__.PacketType.DISCONNECT });\n        }\n        // remove socket from pool\n        this.destroy();\n        if (this.connected) {\n            // fire events\n            this.onclose(\"io client disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Alias for {@link disconnect()}.\n     *\n     * @return self\n     */\n    close() {\n        return this.disconnect();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * socket.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n     * ready to send messages.\n     *\n     * @example\n     * socket.volatile.emit(\"hello\"); // the server may or may not receive it\n     *\n     * @returns self\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n     * given number of milliseconds have elapsed without an acknowledgement from the server:\n     *\n     * @example\n     * socket.timeout(5000).emit(\"my-event\", (err) => {\n     *   if (err) {\n     *     // the server did not acknowledge the event in the given delay\n     *   }\n     * });\n     *\n     * @returns self\n     */\n    timeout(timeout) {\n        this.flags.timeout = timeout;\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * @example\n     * socket.onAny((event, ...args) => {\n     *   console.log(`got ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @example\n     * socket.prependAny((event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * }\n     *\n     * socket.onAny(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAny(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAny();\n     *\n     * @param listener\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.onAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.prependAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * }\n     *\n     * socket.onAnyOutgoing(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAnyOutgoing(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAnyOutgoing();\n     *\n     * @param [listener] - the catch-all listener (optional)\n     */\n    offAnyOutgoing(listener) {\n        if (!this._anyOutgoingListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyOutgoingListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyOutgoingListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAnyOutgoing() {\n        return this._anyOutgoingListeners || [];\n    }\n    /**\n     * Notify the listeners for each packet sent\n     *\n     * @param packet\n     *\n     * @private\n     */\n    notifyOutgoingListeners(packet) {\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n            const listeners = this._anyOutgoingListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, packet.data);\n            }\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2J1aWxkL2VzbS9zb2NrZXQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE4QztBQUNqQjtBQUMyQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLGVBQWU7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQyxJQUFJO0FBQ0o7QUFDTyxxQkFBcUIsaUVBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLFlBQVk7QUFDWjtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELG1CQUFtQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsS0FBSztBQUN6RCxrRUFBa0UsS0FBSztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxLQUFLLEVBQUU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLFFBQVE7QUFDUjtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQ0FBRTtBQUNkLFlBQVksMENBQUU7QUFDZCxZQUFZLDBDQUFFO0FBQ2QsWUFBWSwwQ0FBRTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLHFDQUFxQztBQUNyQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1DQUFtQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdEQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3REFBVTtBQUM1QjtBQUNBLGtDQUFrQywwQ0FBMEM7QUFDNUU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3REFBVTtBQUMzQixpQkFBaUIsd0RBQVU7QUFDM0I7QUFDQTtBQUNBLGlCQUFpQix3REFBVTtBQUMzQixpQkFBaUIsd0RBQVU7QUFDM0I7QUFDQTtBQUNBLGlCQUFpQix3REFBVTtBQUMzQjtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdEQUFVO0FBQ2hDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTSx3REFBVSxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQyxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxNQUFNO0FBQ3pDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxNQUFNO0FBQ3pDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxNQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHNvY2tldC5pby1jbGllbnRcXGJ1aWxkXFxlc21cXHNvY2tldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYWNrZXRUeXBlIH0gZnJvbSBcInNvY2tldC5pby1wYXJzZXJcIjtcbmltcG9ydCB7IG9uIH0gZnJvbSBcIi4vb24uanNcIjtcbmltcG9ydCB7IEVtaXR0ZXIsIH0gZnJvbSBcIkBzb2NrZXQuaW8vY29tcG9uZW50LWVtaXR0ZXJcIjtcbi8qKlxuICogSW50ZXJuYWwgZXZlbnRzLlxuICogVGhlc2UgZXZlbnRzIGNhbid0IGJlIGVtaXR0ZWQgYnkgdGhlIHVzZXIuXG4gKi9cbmNvbnN0IFJFU0VSVkVEX0VWRU5UUyA9IE9iamVjdC5mcmVlemUoe1xuICAgIGNvbm5lY3Q6IDEsXG4gICAgY29ubmVjdF9lcnJvcjogMSxcbiAgICBkaXNjb25uZWN0OiAxLFxuICAgIGRpc2Nvbm5lY3Rpbmc6IDEsXG4gICAgLy8gRXZlbnRFbWl0dGVyIHJlc2VydmVkIGV2ZW50czogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNldmVudHNfZXZlbnRfbmV3bGlzdGVuZXJcbiAgICBuZXdMaXN0ZW5lcjogMSxcbiAgICByZW1vdmVMaXN0ZW5lcjogMSxcbn0pO1xuLyoqXG4gKiBBIFNvY2tldCBpcyB0aGUgZnVuZGFtZW50YWwgY2xhc3MgZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIHNlcnZlci5cbiAqXG4gKiBBIFNvY2tldCBiZWxvbmdzIHRvIGEgY2VydGFpbiBOYW1lc3BhY2UgKGJ5IGRlZmF1bHQgLykgYW5kIHVzZXMgYW4gdW5kZXJseWluZyB7QGxpbmsgTWFuYWdlcn0gdG8gY29tbXVuaWNhdGUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHNvY2tldCA9IGlvKCk7XG4gKlxuICogc29ja2V0Lm9uKFwiY29ubmVjdFwiLCAoKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKFwiY29ubmVjdGVkXCIpO1xuICogfSk7XG4gKlxuICogLy8gc2VuZCBhbiBldmVudCB0byB0aGUgc2VydmVyXG4gKiBzb2NrZXQuZW1pdChcImZvb1wiLCBcImJhclwiKTtcbiAqXG4gKiBzb2NrZXQub24oXCJmb29iYXJcIiwgKCkgPT4ge1xuICogICAvLyBhbiBldmVudCB3YXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyXG4gKiB9KTtcbiAqXG4gKiAvLyB1cG9uIGRpc2Nvbm5lY3Rpb25cbiAqIHNvY2tldC5vbihcImRpc2Nvbm5lY3RcIiwgKHJlYXNvbikgPT4ge1xuICogICBjb25zb2xlLmxvZyhgZGlzY29ubmVjdGVkIGR1ZSB0byAke3JlYXNvbn1gKTtcbiAqIH0pO1xuICovXG5leHBvcnQgY2xhc3MgU29ja2V0IGV4dGVuZHMgRW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogYFNvY2tldGAgY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW8sIG5zcCwgb3B0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgc29ja2V0IGlzIGN1cnJlbnRseSBjb25uZWN0ZWQgdG8gdGhlIHNlcnZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogY29uc3Qgc29ja2V0ID0gaW8oKTtcbiAgICAgICAgICpcbiAgICAgICAgICogc29ja2V0Lm9uKFwiY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmNvbm5lY3RlZCk7IC8vIHRydWVcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIHNvY2tldC5vbihcImRpc2Nvbm5lY3RcIiwgKCkgPT4ge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5jb25uZWN0ZWQpOyAvLyBmYWxzZVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoZSBjb25uZWN0aW9uIHN0YXRlIHdhcyByZWNvdmVyZWQgYWZ0ZXIgYSB0ZW1wb3JhcnkgZGlzY29ubmVjdGlvbi4gSW4gdGhhdCBjYXNlLCBhbnkgbWlzc2VkIHBhY2tldHMgd2lsbFxuICAgICAgICAgKiBiZSB0cmFuc21pdHRlZCBieSB0aGUgc2VydmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWNvdmVyZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1ZmZlciBmb3IgcGFja2V0cyByZWNlaXZlZCBiZWZvcmUgdGhlIENPTk5FQ1QgcGFja2V0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEJ1ZmZlciBmb3IgcGFja2V0cyB0aGF0IHdpbGwgYmUgc2VudCBvbmNlIHRoZSBzb2NrZXQgaXMgY29ubmVjdGVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBxdWV1ZSBvZiBwYWNrZXRzIHRvIGJlIHNlbnQgd2l0aCByZXRyeSBpbiBjYXNlIG9mIGZhaWx1cmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBhY2tldHMgYXJlIHNlbnQgb25lIGJ5IG9uZSwgZWFjaCB3YWl0aW5nIGZvciB0aGUgc2VydmVyIGFja25vd2xlZGdlbWVudCwgaW4gb3JkZXIgdG8gZ3VhcmFudGVlIHRoZSBkZWxpdmVyeSBvcmRlci5cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNlcXVlbmNlIHRvIGdlbmVyYXRlIHRoZSBJRCBvZiB0aGUge0BsaW5rIFF1ZXVlZFBhY2tldH0uXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9xdWV1ZVNlcSA9IDA7XG4gICAgICAgIHRoaXMuaWRzID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIGNvbnRhaW5pbmcgYWNrbm93bGVkZ2VtZW50IGhhbmRsZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgYHdpdGhFcnJvcmAgYXR0cmlidXRlIGlzIHVzZWQgdG8gZGlmZmVyZW50aWF0ZSBoYW5kbGVycyB0aGF0IGFjY2VwdCBhbiBlcnJvciBhcyBmaXJzdCBhcmd1bWVudDpcbiAgICAgICAgICpcbiAgICAgICAgICogLSBgc29ja2V0LmVtaXQoXCJ0ZXN0XCIsIChlcnIsIHZhbHVlKSA9PiB7IC4uLiB9KWAgd2l0aCBgYWNrVGltZW91dGAgb3B0aW9uXG4gICAgICAgICAqIC0gYHNvY2tldC50aW1lb3V0KDUwMDApLmVtaXQoXCJ0ZXN0XCIsIChlcnIsIHZhbHVlKSA9PiB7IC4uLiB9KWBcbiAgICAgICAgICogLSBgY29uc3QgdmFsdWUgPSBhd2FpdCBzb2NrZXQuZW1pdFdpdGhBY2soXCJ0ZXN0XCIpYFxuICAgICAgICAgKlxuICAgICAgICAgKiBGcm9tIHRob3NlIHRoYXQgZG9uJ3Q6XG4gICAgICAgICAqXG4gICAgICAgICAqIC0gYHNvY2tldC5lbWl0KFwidGVzdFwiLCAodmFsdWUpID0+IHsgLi4uIH0pO2BcbiAgICAgICAgICpcbiAgICAgICAgICogSW4gdGhlIGZpcnN0IGNhc2UsIHRoZSBoYW5kbGVycyB3aWxsIGJlIGNhbGxlZCB3aXRoIGFuIGVycm9yIHdoZW46XG4gICAgICAgICAqXG4gICAgICAgICAqIC0gdGhlIHRpbWVvdXQgaXMgcmVhY2hlZFxuICAgICAgICAgKiAtIHRoZSBzb2NrZXQgZ2V0cyBkaXNjb25uZWN0ZWRcbiAgICAgICAgICpcbiAgICAgICAgICogSW4gdGhlIHNlY29uZCBjYXNlLCB0aGUgaGFuZGxlcnMgd2lsbCBiZSBzaW1wbHkgZGlzY2FyZGVkIHVwb24gZGlzY29ubmVjdGlvbiwgc2luY2UgdGhlIGNsaWVudCB3aWxsIG5ldmVyIHJlY2VpdmVcbiAgICAgICAgICogYW4gYWNrbm93bGVkZ2VtZW50IGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWNrcyA9IHt9O1xuICAgICAgICB0aGlzLmZsYWdzID0ge307XG4gICAgICAgIHRoaXMuaW8gPSBpbztcbiAgICAgICAgdGhpcy5uc3AgPSBuc3A7XG4gICAgICAgIGlmIChvcHRzICYmIG9wdHMuYXV0aCkge1xuICAgICAgICAgICAgdGhpcy5hdXRoID0gb3B0cy5hdXRoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzKTtcbiAgICAgICAgaWYgKHRoaXMuaW8uX2F1dG9Db25uZWN0KVxuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHNvY2tldCBpcyBjdXJyZW50bHkgZGlzY29ubmVjdGVkXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGNvbnN0IHNvY2tldCA9IGlvKCk7XG4gICAgICpcbiAgICAgKiBzb2NrZXQub24oXCJjb25uZWN0XCIsICgpID0+IHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHNvY2tldC5kaXNjb25uZWN0ZWQpOyAvLyBmYWxzZVxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc29ja2V0Lm9uKFwiZGlzY29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhzb2NrZXQuZGlzY29ubmVjdGVkKTsgLy8gdHJ1ZVxuICAgICAqIH0pO1xuICAgICAqL1xuICAgIGdldCBkaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb25uZWN0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzdWJFdmVudHMoKSB7XG4gICAgICAgIGlmICh0aGlzLnN1YnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGlvID0gdGhpcy5pbztcbiAgICAgICAgdGhpcy5zdWJzID0gW1xuICAgICAgICAgICAgb24oaW8sIFwib3BlblwiLCB0aGlzLm9ub3Blbi5iaW5kKHRoaXMpKSxcbiAgICAgICAgICAgIG9uKGlvLCBcInBhY2tldFwiLCB0aGlzLm9ucGFja2V0LmJpbmQodGhpcykpLFxuICAgICAgICAgICAgb24oaW8sIFwiZXJyb3JcIiwgdGhpcy5vbmVycm9yLmJpbmQodGhpcykpLFxuICAgICAgICAgICAgb24oaW8sIFwiY2xvc2VcIiwgdGhpcy5vbmNsb3NlLmJpbmQodGhpcykpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBTb2NrZXQgd2lsbCB0cnkgdG8gcmVjb25uZWN0IHdoZW4gaXRzIE1hbmFnZXIgY29ubmVjdHMgb3IgcmVjb25uZWN0cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3Qgc29ja2V0ID0gaW8oKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHNvY2tldC5hY3RpdmUpOyAvLyB0cnVlXG4gICAgICpcbiAgICAgKiBzb2NrZXQub24oXCJkaXNjb25uZWN0XCIsIChyZWFzb24pID0+IHtcbiAgICAgKiAgIGlmIChyZWFzb24gPT09IFwiaW8gc2VydmVyIGRpc2Nvbm5lY3RcIikge1xuICAgICAqICAgICAvLyB0aGUgZGlzY29ubmVjdGlvbiB3YXMgaW5pdGlhdGVkIGJ5IHRoZSBzZXJ2ZXIsIHlvdSBuZWVkIHRvIG1hbnVhbGx5IHJlY29ubmVjdFxuICAgICAqICAgICBjb25zb2xlLmxvZyhzb2NrZXQuYWN0aXZlKTsgLy8gZmFsc2VcbiAgICAgKiAgIH1cbiAgICAgKiAgIC8vIGVsc2UgdGhlIHNvY2tldCB3aWxsIGF1dG9tYXRpY2FsbHkgdHJ5IHRvIHJlY29ubmVjdFxuICAgICAqICAgY29uc29sZS5sb2coc29ja2V0LmFjdGl2ZSk7IC8vIHRydWVcbiAgICAgKiB9KTtcbiAgICAgKi9cbiAgICBnZXQgYWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnN1YnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFwiT3BlbnNcIiB0aGUgc29ja2V0LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBzb2NrZXQgPSBpbyh7XG4gICAgICogICBhdXRvQ29ubmVjdDogZmFsc2VcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNvY2tldC5jb25uZWN0KCk7XG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHRoaXMuc3ViRXZlbnRzKCk7XG4gICAgICAgIGlmICghdGhpcy5pb1tcIl9yZWNvbm5lY3RpbmdcIl0pXG4gICAgICAgICAgICB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cbiAgICAgICAgaWYgKFwib3BlblwiID09PSB0aGlzLmlvLl9yZWFkeVN0YXRlKVxuICAgICAgICAgICAgdGhpcy5vbm9wZW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFsaWFzIGZvciB7QGxpbmsgY29ubmVjdCgpfS5cbiAgICAgKi9cbiAgICBvcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWltaWNzIHRoZSBXZWJTb2NrZXQuc2VuZCgpIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dlYlNvY2tldC9zZW5kXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvY2tldC5zZW5kKFwiaGVsbG9cIik7XG4gICAgICpcbiAgICAgKiAvLyB0aGlzIGlzIGVxdWl2YWxlbnQgdG9cbiAgICAgKiBzb2NrZXQuZW1pdChcIm1lc3NhZ2VcIiwgXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIHNlbmQoLi4uYXJncykge1xuICAgICAgICBhcmdzLnVuc2hpZnQoXCJtZXNzYWdlXCIpO1xuICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBgZW1pdGAuXG4gICAgICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvY2tldC5lbWl0KFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAgICAgKlxuICAgICAqIC8vIGFsbCBzZXJpYWxpemFibGUgZGF0YXN0cnVjdHVyZXMgYXJlIHN1cHBvcnRlZCAobm8gbmVlZCB0byBjYWxsIEpTT04uc3RyaW5naWZ5KVxuICAgICAqIHNvY2tldC5lbWl0KFwiaGVsbG9cIiwgMSwgXCIyXCIsIHsgMzogW1wiNFwiXSwgNTogVWludDhBcnJheS5mcm9tKFs2XSkgfSk7XG4gICAgICpcbiAgICAgKiAvLyB3aXRoIGFuIGFja25vd2xlZGdlbWVudCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgKiBzb2NrZXQuZW1pdChcImhlbGxvXCIsIFwid29ybGRcIiwgKHZhbCkgPT4ge1xuICAgICAqICAgLy8gLi4uXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAoUkVTRVJWRURfRVZFTlRTLmhhc093blByb3BlcnR5KGV2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBldi50b1N0cmluZygpICsgJ1wiIGlzIGEgcmVzZXJ2ZWQgZXZlbnQgbmFtZScpO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MudW5zaGlmdChldik7XG4gICAgICAgIGlmICh0aGlzLl9vcHRzLnJldHJpZXMgJiYgIXRoaXMuZmxhZ3MuZnJvbVF1ZXVlICYmICF0aGlzLmZsYWdzLnZvbGF0aWxlKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb1F1ZXVlKGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFja2V0ID0ge1xuICAgICAgICAgICAgdHlwZTogUGFja2V0VHlwZS5FVkVOVCxcbiAgICAgICAgICAgIGRhdGE6IGFyZ3MsXG4gICAgICAgIH07XG4gICAgICAgIHBhY2tldC5vcHRpb25zID0ge307XG4gICAgICAgIHBhY2tldC5vcHRpb25zLmNvbXByZXNzID0gdGhpcy5mbGFncy5jb21wcmVzcyAhPT0gZmFsc2U7XG4gICAgICAgIC8vIGV2ZW50IGFjayBjYWxsYmFja1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHRoaXMuaWRzKys7XG4gICAgICAgICAgICBjb25zdCBhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXJBY2tDYWxsYmFjayhpZCwgYWNrKTtcbiAgICAgICAgICAgIHBhY2tldC5pZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzVHJhbnNwb3J0V3JpdGFibGUgPSAoX2IgPSAoX2EgPSB0aGlzLmlvLmVuZ2luZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRyYW5zcG9ydCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLndyaXRhYmxlO1xuICAgICAgICBjb25zdCBpc0Nvbm5lY3RlZCA9IHRoaXMuY29ubmVjdGVkICYmICEoKF9jID0gdGhpcy5pby5lbmdpbmUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5faGFzUGluZ0V4cGlyZWQoKSk7XG4gICAgICAgIGNvbnN0IGRpc2NhcmRQYWNrZXQgPSB0aGlzLmZsYWdzLnZvbGF0aWxlICYmICFpc1RyYW5zcG9ydFdyaXRhYmxlO1xuICAgICAgICBpZiAoZGlzY2FyZFBhY2tldCkge1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeU91dGdvaW5nTGlzdGVuZXJzKHBhY2tldCk7XG4gICAgICAgICAgICB0aGlzLnBhY2tldChwYWNrZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZW5kQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZsYWdzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZWdpc3RlckFja0NhbGxiYWNrKGlkLCBhY2spIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gKF9hID0gdGhpcy5mbGFncy50aW1lb3V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLl9vcHRzLmFja1RpbWVvdXQ7XG4gICAgICAgIGlmICh0aW1lb3V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuYWNrc1tpZF0gPSBhY2s7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCB0aW1lciA9IHRoaXMuaW8uc2V0VGltZW91dEZuKCgpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmFja3NbaWRdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZW5kQnVmZmVyW2ldLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRCdWZmZXIuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFjay5jYWxsKHRoaXMsIG5ldyBFcnJvcihcIm9wZXJhdGlvbiBoYXMgdGltZWQgb3V0XCIpKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgIGNvbnN0IGZuID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuaW8uY2xlYXJUaW1lb3V0Rm4odGltZXIpO1xuICAgICAgICAgICAgYWNrLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBmbi53aXRoRXJyb3IgPSB0cnVlO1xuICAgICAgICB0aGlzLmFja3NbaWRdID0gZm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGFuZCB3YWl0cyBmb3IgYW4gYWNrbm93bGVkZ2VtZW50XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIC8vIHdpdGhvdXQgdGltZW91dFxuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc29ja2V0LmVtaXRXaXRoQWNrKFwiaGVsbG9cIiwgXCJ3b3JsZFwiKTtcbiAgICAgKlxuICAgICAqIC8vIHdpdGggYSBzcGVjaWZpYyB0aW1lb3V0XG4gICAgICogdHJ5IHtcbiAgICAgKiAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgc29ja2V0LnRpbWVvdXQoMTAwMCkuZW1pdFdpdGhBY2soXCJoZWxsb1wiLCBcIndvcmxkXCIpO1xuICAgICAqIH0gY2F0Y2ggKGVycikge1xuICAgICAqICAgLy8gdGhlIHNlcnZlciBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIHNlcnZlciBhY2tub3dsZWRnZXMgdGhlIGV2ZW50XG4gICAgICovXG4gICAgZW1pdFdpdGhBY2soZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZuID0gKGFyZzEsIGFyZzIpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJnMSA/IHJlamVjdChhcmcxKSA6IHJlc29sdmUoYXJnMik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm4ud2l0aEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIGFyZ3MucHVzaChmbik7XG4gICAgICAgICAgICB0aGlzLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBwYWNrZXQgdG8gdGhlIHF1ZXVlLlxuICAgICAqIEBwYXJhbSBhcmdzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkVG9RdWV1ZShhcmdzKSB7XG4gICAgICAgIGxldCBhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFja2V0ID0ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuX3F1ZXVlU2VxKyssXG4gICAgICAgICAgICB0cnlDb3VudDogMCxcbiAgICAgICAgICAgIHBlbmRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgIGZsYWdzOiBPYmplY3QuYXNzaWduKHsgZnJvbVF1ZXVlOiB0cnVlIH0sIHRoaXMuZmxhZ3MpLFxuICAgICAgICB9O1xuICAgICAgICBhcmdzLnB1c2goKGVyciwgLi4ucmVzcG9uc2VBcmdzKSA9PiB7XG4gICAgICAgICAgICBpZiAocGFja2V0ICE9PSB0aGlzLl9xdWV1ZVswXSkge1xuICAgICAgICAgICAgICAgIC8vIHRoZSBwYWNrZXQgaGFzIGFscmVhZHkgYmVlbiBhY2tub3dsZWRnZWRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYXNFcnJvciA9IGVyciAhPT0gbnVsbDtcbiAgICAgICAgICAgIGlmIChoYXNFcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChwYWNrZXQudHJ5Q291bnQgPiB0aGlzLl9vcHRzLnJldHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGlmIChhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgYWNrKG51bGwsIC4uLnJlc3BvbnNlQXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFja2V0LnBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kcmFpblF1ZXVlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHBhY2tldCk7XG4gICAgICAgIHRoaXMuX2RyYWluUXVldWUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCB0aGUgZmlyc3QgcGFja2V0IG9mIHRoZSBxdWV1ZSwgYW5kIHdhaXQgZm9yIGFuIGFja25vd2xlZGdlbWVudCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIGZvcmNlIC0gd2hldGhlciB0byByZXNlbmQgYSBwYWNrZXQgdGhhdCBoYXMgbm90IGJlZW4gYWNrbm93bGVkZ2VkIHlldFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZHJhaW5RdWV1ZShmb3JjZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQgfHwgdGhpcy5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFja2V0ID0gdGhpcy5fcXVldWVbMF07XG4gICAgICAgIGlmIChwYWNrZXQucGVuZGluZyAmJiAhZm9yY2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYWNrZXQucGVuZGluZyA9IHRydWU7XG4gICAgICAgIHBhY2tldC50cnlDb3VudCsrO1xuICAgICAgICB0aGlzLmZsYWdzID0gcGFja2V0LmZsYWdzO1xuICAgICAgICB0aGlzLmVtaXQuYXBwbHkodGhpcywgcGFja2V0LmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYWNrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBhY2tldChwYWNrZXQpIHtcbiAgICAgICAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuICAgICAgICB0aGlzLmlvLl9wYWNrZXQocGFja2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gZW5naW5lIGBvcGVuYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25vcGVuKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuYXV0aCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuYXV0aCgoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRDb25uZWN0UGFja2V0KGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZW5kQ29ubmVjdFBhY2tldCh0aGlzLmF1dGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgQ09OTkVDVCBwYWNrZXQgdG8gaW5pdGlhdGUgdGhlIFNvY2tldC5JTyBzZXNzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRhdGFcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zZW5kQ29ubmVjdFBhY2tldChkYXRhKSB7XG4gICAgICAgIHRoaXMucGFja2V0KHtcbiAgICAgICAgICAgIHR5cGU6IFBhY2tldFR5cGUuQ09OTkVDVCxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuX3BpZFxuICAgICAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbih7IHBpZDogdGhpcy5fcGlkLCBvZmZzZXQ6IHRoaXMuX2xhc3RPZmZzZXQgfSwgZGF0YSlcbiAgICAgICAgICAgICAgICA6IGRhdGEsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBlbmdpbmUgb3IgbWFuYWdlciBgZXJyb3JgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVyclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25lcnJvcihlcnIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJjb25uZWN0X2Vycm9yXCIsIGVycik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gZW5naW5lIGBjbG9zZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVhc29uXG4gICAgICogQHBhcmFtIGRlc2NyaXB0aW9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmNsb3NlKHJlYXNvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgZGVsZXRlIHRoaXMuaWQ7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZGlzY29ubmVjdFwiLCByZWFzb24sIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgdGhpcy5fY2xlYXJBY2tzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgYWNrbm93bGVkZ2VtZW50IGhhbmRsZXJzIHVwb24gZGlzY29ubmVjdGlvbiwgc2luY2UgdGhlIGNsaWVudCB3aWxsIG5ldmVyIHJlY2VpdmUgYW4gYWNrbm93bGVkZ2VtZW50IGZyb21cbiAgICAgKiB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2xlYXJBY2tzKCkge1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmFja3MpLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0J1ZmZlcmVkID0gdGhpcy5zZW5kQnVmZmVyLnNvbWUoKHBhY2tldCkgPT4gU3RyaW5nKHBhY2tldC5pZCkgPT09IGlkKTtcbiAgICAgICAgICAgIGlmICghaXNCdWZmZXJlZCkge1xuICAgICAgICAgICAgICAgIC8vIG5vdGU6IGhhbmRsZXJzIHRoYXQgZG8gbm90IGFjY2VwdCBhbiBlcnJvciBhcyBmaXJzdCBhcmd1bWVudCBhcmUgaWdub3JlZCBoZXJlXG4gICAgICAgICAgICAgICAgY29uc3QgYWNrID0gdGhpcy5hY2tzW2lkXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5hY2tzW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAoYWNrLndpdGhFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBhY2suY2FsbCh0aGlzLCBuZXcgRXJyb3IoXCJzb2NrZXQgaGFzIGJlZW4gZGlzY29ubmVjdGVkXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBzb2NrZXQgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25wYWNrZXQocGFja2V0KSB7XG4gICAgICAgIGNvbnN0IHNhbWVOYW1lc3BhY2UgPSBwYWNrZXQubnNwID09PSB0aGlzLm5zcDtcbiAgICAgICAgaWYgKCFzYW1lTmFtZXNwYWNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuQ09OTkVDVDpcbiAgICAgICAgICAgICAgICBpZiAocGFja2V0LmRhdGEgJiYgcGFja2V0LmRhdGEuc2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25jb25uZWN0KHBhY2tldC5kYXRhLnNpZCwgcGFja2V0LmRhdGEucGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiY29ubmVjdF9lcnJvclwiLCBuZXcgRXJyb3IoXCJJdCBzZWVtcyB5b3UgYXJlIHRyeWluZyB0byByZWFjaCBhIFNvY2tldC5JTyBzZXJ2ZXIgaW4gdjIueCB3aXRoIGEgdjMueCBjbGllbnQsIGJ1dCB0aGV5IGFyZSBub3QgY29tcGF0aWJsZSAobW9yZSBpbmZvcm1hdGlvbiBoZXJlOiBodHRwczovL3NvY2tldC5pby9kb2NzL3YzL21pZ3JhdGluZy1mcm9tLTIteC10by0zLTAvKVwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkVWRU5UOlxuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkJJTkFSWV9FVkVOVDpcbiAgICAgICAgICAgICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgUGFja2V0VHlwZS5BQ0s6XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuQklOQVJZX0FDSzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuRElTQ09OTkVDVDpcbiAgICAgICAgICAgICAgICB0aGlzLm9uZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkNPTk5FQ1RfRVJST1I6XG4gICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKHBhY2tldC5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBlcnIuZGF0YSA9IHBhY2tldC5kYXRhLmRhdGE7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJjb25uZWN0X2Vycm9yXCIsIGVycik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmV2ZW50KHBhY2tldCkge1xuICAgICAgICBjb25zdCBhcmdzID0gcGFja2V0LmRhdGEgfHwgW107XG4gICAgICAgIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuICAgICAgICAgICAgYXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlY2VpdmVCdWZmZXIucHVzaChPYmplY3QuZnJlZXplKGFyZ3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbWl0RXZlbnQoYXJncykge1xuICAgICAgICBpZiAodGhpcy5fYW55TGlzdGVuZXJzICYmIHRoaXMuX2FueUxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2FueUxpc3RlbmVycy5zbGljZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBpZiAodGhpcy5fcGlkICYmIGFyZ3MubGVuZ3RoICYmIHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RPZmZzZXQgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYWNrKGlkKSB7XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgc2VudCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuICAgICAgICAgICAgaWYgKHNlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2VudCA9IHRydWU7XG4gICAgICAgICAgICBzZWxmLnBhY2tldCh7XG4gICAgICAgICAgICAgICAgdHlwZTogUGFja2V0VHlwZS5BQ0ssXG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIGRhdGE6IGFyZ3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgYWNrbm93bGVkZ2VtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhY2tldFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25hY2socGFja2V0KSB7XG4gICAgICAgIGNvbnN0IGFjayA9IHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICAgICAgICBpZiAodHlwZW9mIGFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FIGFjayBpcyBpbmNvcnJlY3RseSBpbmZlcnJlZCBhcyAnbmV2ZXInXG4gICAgICAgIGlmIChhY2sud2l0aEVycm9yKSB7XG4gICAgICAgICAgICBwYWNrZXQuZGF0YS51bnNoaWZ0KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgYWNrLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gc2VydmVyIGNvbm5lY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uY29ubmVjdChpZCwgcGlkKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5yZWNvdmVyZWQgPSBwaWQgJiYgdGhpcy5fcGlkID09PSBwaWQ7XG4gICAgICAgIHRoaXMuX3BpZCA9IHBpZDsgLy8gZGVmaW5lZCBvbmx5IGlmIGNvbm5lY3Rpb24gc3RhdGUgcmVjb3ZlcnkgaXMgZW5hYmxlZFxuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdEJ1ZmZlcmVkKCk7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiY29ubmVjdFwiKTtcbiAgICAgICAgdGhpcy5fZHJhaW5RdWV1ZSh0cnVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdCBidWZmZXJlZCBldmVudHMgKHJlY2VpdmVkIGFuZCBlbWl0dGVkKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZW1pdEJ1ZmZlcmVkKCkge1xuICAgICAgICB0aGlzLnJlY2VpdmVCdWZmZXIuZm9yRWFjaCgoYXJncykgPT4gdGhpcy5lbWl0RXZlbnQoYXJncykpO1xuICAgICAgICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5zZW5kQnVmZmVyLmZvckVhY2goKHBhY2tldCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlPdXRnb2luZ0xpc3RlbmVycyhwYWNrZXQpO1xuICAgICAgICAgICAgdGhpcy5wYWNrZXQocGFja2V0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgZGlzY29ubmVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25kaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5vbmNsb3NlKFwiaW8gc2VydmVyIGRpc2Nvbm5lY3RcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGZvcmNlZCBjbGllbnQvc2VydmVyIHNpZGUgZGlzY29ubmVjdGlvbnMsXG4gICAgICogdGhpcyBtZXRob2QgZW5zdXJlcyB0aGUgbWFuYWdlciBzdG9wcyB0cmFja2luZyB1cyBhbmRcbiAgICAgKiB0aGF0IHJlY29ubmVjdGlvbnMgZG9uJ3QgZ2V0IHRyaWdnZXJlZCBmb3IgdGhpcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3Vicykge1xuICAgICAgICAgICAgLy8gY2xlYW4gc3Vic2NyaXB0aW9ucyB0byBhdm9pZCByZWNvbm5lY3Rpb25zXG4gICAgICAgICAgICB0aGlzLnN1YnMuZm9yRWFjaCgoc3ViRGVzdHJveSkgPT4gc3ViRGVzdHJveSgpKTtcbiAgICAgICAgICAgIHRoaXMuc3VicyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlvW1wiX2Rlc3Ryb3lcIl0odGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQgbWFudWFsbHkuIEluIHRoYXQgY2FzZSwgdGhlIHNvY2tldCB3aWxsIG5vdCB0cnkgdG8gcmVjb25uZWN0LlxuICAgICAqXG4gICAgICogSWYgdGhpcyBpcyB0aGUgbGFzdCBhY3RpdmUgU29ja2V0IGluc3RhbmNlIG9mIHRoZSB7QGxpbmsgTWFuYWdlcn0sIHRoZSBsb3ctbGV2ZWwgY29ubmVjdGlvbiB3aWxsIGJlIGNsb3NlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogY29uc3Qgc29ja2V0ID0gaW8oKTtcbiAgICAgKlxuICAgICAqIHNvY2tldC5vbihcImRpc2Nvbm5lY3RcIiwgKHJlYXNvbikgPT4ge1xuICAgICAqICAgLy8gY29uc29sZS5sb2cocmVhc29uKTsgcHJpbnRzIFwiaW8gY2xpZW50IGRpc2Nvbm5lY3RcIlxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBQYWNrZXRUeXBlLkRJU0NPTk5FQ1QgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIHNvY2tldCBmcm9tIHBvb2xcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgLy8gZmlyZSBldmVudHNcbiAgICAgICAgICAgIHRoaXMub25jbG9zZShcImlvIGNsaWVudCBkaXNjb25uZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3Ige0BsaW5rIGRpc2Nvbm5lY3QoKX0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzb2NrZXQuY29tcHJlc3MoZmFsc2UpLmVtaXQoXCJoZWxsb1wiKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21wcmVzcyAtIGlmIGB0cnVlYCwgY29tcHJlc3NlcyB0aGUgc2VuZGluZyBkYXRhXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICovXG4gICAgY29tcHJlc3MoY29tcHJlc3MpIHtcbiAgICAgICAgdGhpcy5mbGFncy5jb21wcmVzcyA9IGNvbXByZXNzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgbWVzc2FnZSB3aWxsIGJlIGRyb3BwZWQgd2hlbiB0aGlzIHNvY2tldCBpcyBub3RcbiAgICAgKiByZWFkeSB0byBzZW5kIG1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzb2NrZXQudm9sYXRpbGUuZW1pdChcImhlbGxvXCIpOyAvLyB0aGUgc2VydmVyIG1heSBvciBtYXkgbm90IHJlY2VpdmUgaXRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHNlbGZcbiAgICAgKi9cbiAgICBnZXQgdm9sYXRpbGUoKSB7XG4gICAgICAgIHRoaXMuZmxhZ3Mudm9sYXRpbGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgd2l0aCBhbiBlcnJvciB3aGVuIHRoZVxuICAgICAqIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHdpdGhvdXQgYW4gYWNrbm93bGVkZ2VtZW50IGZyb20gdGhlIHNlcnZlcjpcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogc29ja2V0LnRpbWVvdXQoNTAwMCkuZW1pdChcIm15LWV2ZW50XCIsIChlcnIpID0+IHtcbiAgICAgKiAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgLy8gdGhlIHNlcnZlciBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHNlbGZcbiAgICAgKi9cbiAgICB0aW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5mbGFncy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgZW1pdHRlZC4gVGhlIGV2ZW50IG5hbWUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGVcbiAgICAgKiBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogc29ja2V0Lm9uQW55KChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coYGdvdCAke2V2ZW50fWApO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgb25BbnkobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fYW55TGlzdGVuZXJzID0gdGhpcy5fYW55TGlzdGVuZXJzIHx8IFtdO1xuICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIGVtaXR0ZWQuIFRoZSBldmVudCBuYW1lIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlXG4gICAgICogY2FsbGJhY2suIFRoZSBsaXN0ZW5lciBpcyBhZGRlZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvY2tldC5wcmVwZW5kQW55KChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coYGdvdCBldmVudCAke2V2ZW50fWApO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgcHJlcGVuZEFueShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnMgfHwgW107XG4gICAgICAgIHRoaXMuX2FueUxpc3RlbmVycy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyBlbWl0dGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBjYXRjaEFsbExpc3RlbmVyID0gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhgZ290IGV2ZW50ICR7ZXZlbnR9YCk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogc29ja2V0Lm9uQW55KGNhdGNoQWxsTGlzdGVuZXIpO1xuICAgICAqXG4gICAgICogLy8gcmVtb3ZlIGEgc3BlY2lmaWMgbGlzdGVuZXJcbiAgICAgKiBzb2NrZXQub2ZmQW55KGNhdGNoQWxsTGlzdGVuZXIpO1xuICAgICAqXG4gICAgICogLy8gb3IgcmVtb3ZlIGFsbCBsaXN0ZW5lcnNcbiAgICAgKiBzb2NrZXQub2ZmQW55KCk7XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKi9cbiAgICBvZmZBbnkobGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9hbnlMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fYW55TGlzdGVuZXJzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIgPT09IGxpc3RlbmVyc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgdGhhdCBhcmUgbGlzdGVuaW5nIGZvciBhbnkgZXZlbnQgdGhhdCBpcyBzcGVjaWZpZWQuIFRoaXMgYXJyYXkgY2FuIGJlIG1hbmlwdWxhdGVkLFxuICAgICAqIGUuZy4gdG8gcmVtb3ZlIGxpc3RlbmVycy5cbiAgICAgKi9cbiAgICBsaXN0ZW5lcnNBbnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbnlMaXN0ZW5lcnMgfHwgW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgZW1pdHRlZC4gVGhlIGV2ZW50IG5hbWUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGVcbiAgICAgKiBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIE5vdGU6IGFja25vd2xlZGdlbWVudHMgc2VudCB0byB0aGUgc2VydmVyIGFyZSBub3QgaW5jbHVkZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHNvY2tldC5vbkFueU91dGdvaW5nKChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coYHNlbnQgZXZlbnQgJHtldmVudH1gKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqL1xuICAgIG9uQW55T3V0Z29pbmcobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMgPSB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIGVtaXR0ZWQuIFRoZSBldmVudCBuYW1lIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlXG4gICAgICogY2FsbGJhY2suIFRoZSBsaXN0ZW5lciBpcyBhZGRlZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkuXG4gICAgICpcbiAgICAgKiBOb3RlOiBhY2tub3dsZWRnZW1lbnRzIHNlbnQgdG8gdGhlIHNlcnZlciBhcmUgbm90IGluY2x1ZGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBzb2NrZXQucHJlcGVuZEFueU91dGdvaW5nKChldmVudCwgLi4uYXJncykgPT4ge1xuICAgICAqICAgY29uc29sZS5sb2coYHNlbnQgZXZlbnQgJHtldmVudH1gKTtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqL1xuICAgIHByZXBlbmRBbnlPdXRnb2luZyhsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyA9IHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzIHx8IFtdO1xuICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyBlbWl0dGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBjb25zdCBjYXRjaEFsbExpc3RlbmVyID0gKGV2ZW50LCAuLi5hcmdzKSA9PiB7XG4gICAgICogICBjb25zb2xlLmxvZyhgc2VudCBldmVudCAke2V2ZW50fWApO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHNvY2tldC5vbkFueU91dGdvaW5nKGNhdGNoQWxsTGlzdGVuZXIpO1xuICAgICAqXG4gICAgICogLy8gcmVtb3ZlIGEgc3BlY2lmaWMgbGlzdGVuZXJcbiAgICAgKiBzb2NrZXQub2ZmQW55T3V0Z29pbmcoY2F0Y2hBbGxMaXN0ZW5lcik7XG4gICAgICpcbiAgICAgKiAvLyBvciByZW1vdmUgYWxsIGxpc3RlbmVyc1xuICAgICAqIHNvY2tldC5vZmZBbnlPdXRnb2luZygpO1xuICAgICAqXG4gICAgICogQHBhcmFtIFtsaXN0ZW5lcl0gLSB0aGUgY2F0Y2gtYWxsIGxpc3RlbmVyIChvcHRpb25hbClcbiAgICAgKi9cbiAgICBvZmZBbnlPdXRnb2luZyhsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIXRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIgPT09IGxpc3RlbmVyc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0aGF0IGFyZSBsaXN0ZW5pbmcgZm9yIGFueSBldmVudCB0aGF0IGlzIHNwZWNpZmllZC4gVGhpcyBhcnJheSBjYW4gYmUgbWFuaXB1bGF0ZWQsXG4gICAgICogZS5nLiB0byByZW1vdmUgbGlzdGVuZXJzLlxuICAgICAqL1xuICAgIGxpc3RlbmVyc0FueU91dGdvaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMgfHwgW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmeSB0aGUgbGlzdGVuZXJzIGZvciBlYWNoIHBhY2tldCBzZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFja2V0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG5vdGlmeU91dGdvaW5nTGlzdGVuZXJzKHBhY2tldCkge1xuICAgICAgICBpZiAodGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMgJiYgdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycy5zbGljZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/socket.io-client/build/esm/socket.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/socket.io-client/build/esm/url.js":
/*!********************************************************!*\
  !*** ./node_modules/socket.io-client/build/esm/url.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   url: () => (/* binding */ url)\n/* harmony export */ });\n/* harmony import */ var engine_io_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! engine.io-client */ \"(pages-dir-browser)/./node_modules/engine.io-client/build/esm/index.js\");\n\n/**\n * URL parser.\n *\n * @param uri - url\n * @param path - the request path of the connection\n * @param loc - An object meant to mimic window.location.\n *        Defaults to window.location.\n * @public\n */\nfunction url(uri, path = \"\", loc) {\n    let obj = uri;\n    // default to window.location\n    loc = loc || (typeof location !== \"undefined\" && location);\n    if (null == uri)\n        uri = loc.protocol + \"//\" + loc.host;\n    // relative path support\n    if (typeof uri === \"string\") {\n        if (\"/\" === uri.charAt(0)) {\n            if (\"/\" === uri.charAt(1)) {\n                uri = loc.protocol + uri;\n            }\n            else {\n                uri = loc.host + uri;\n            }\n        }\n        if (!/^(https?|wss?):\\/\\//.test(uri)) {\n            if (\"undefined\" !== typeof loc) {\n                uri = loc.protocol + \"//\" + uri;\n            }\n            else {\n                uri = \"https://\" + uri;\n            }\n        }\n        // parse\n        obj = (0,engine_io_client__WEBPACK_IMPORTED_MODULE_0__.parse)(uri);\n    }\n    // make sure we treat `localhost:80` and `localhost` equally\n    if (!obj.port) {\n        if (/^(http|ws)$/.test(obj.protocol)) {\n            obj.port = \"80\";\n        }\n        else if (/^(http|ws)s$/.test(obj.protocol)) {\n            obj.port = \"443\";\n        }\n    }\n    obj.path = obj.path || \"/\";\n    const ipv6 = obj.host.indexOf(\":\") !== -1;\n    const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n    // define unique id\n    obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n    // define href\n    obj.href =\n        obj.protocol +\n            \"://\" +\n            host +\n            (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n    return obj;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2J1aWxkL2VzbS91cmwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHVEQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHNvY2tldC5pby1jbGllbnRcXGJ1aWxkXFxlc21cXHVybC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwYXJzZSB9IGZyb20gXCJlbmdpbmUuaW8tY2xpZW50XCI7XG4vKipcbiAqIFVSTCBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHVyaSAtIHVybFxuICogQHBhcmFtIHBhdGggLSB0aGUgcmVxdWVzdCBwYXRoIG9mIHRoZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gbG9jIC0gQW4gb2JqZWN0IG1lYW50IHRvIG1pbWljIHdpbmRvdy5sb2NhdGlvbi5cbiAqICAgICAgICBEZWZhdWx0cyB0byB3aW5kb3cubG9jYXRpb24uXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cmwodXJpLCBwYXRoID0gXCJcIiwgbG9jKSB7XG4gICAgbGV0IG9iaiA9IHVyaTtcbiAgICAvLyBkZWZhdWx0IHRvIHdpbmRvdy5sb2NhdGlvblxuICAgIGxvYyA9IGxvYyB8fCAodHlwZW9mIGxvY2F0aW9uICE9PSBcInVuZGVmaW5lZFwiICYmIGxvY2F0aW9uKTtcbiAgICBpZiAobnVsbCA9PSB1cmkpXG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIFwiLy9cIiArIGxvYy5ob3N0O1xuICAgIC8vIHJlbGF0aXZlIHBhdGggc3VwcG9ydFxuICAgIGlmICh0eXBlb2YgdXJpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmIChcIi9cIiA9PT0gdXJpLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgaWYgKFwiL1wiID09PSB1cmkuY2hhckF0KDEpKSB7XG4gICAgICAgICAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgdXJpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXJpID0gbG9jLmhvc3QgKyB1cmk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEvXihodHRwcz98d3NzPyk6XFwvXFwvLy50ZXN0KHVyaSkpIHtcbiAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9PSB0eXBlb2YgbG9jKSB7XG4gICAgICAgICAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgXCIvL1wiICsgdXJpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXJpID0gXCJodHRwczovL1wiICsgdXJpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHBhcnNlXG4gICAgICAgIG9iaiA9IHBhcnNlKHVyaSk7XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSB3ZSB0cmVhdCBgbG9jYWxob3N0OjgwYCBhbmQgYGxvY2FsaG9zdGAgZXF1YWxseVxuICAgIGlmICghb2JqLnBvcnQpIHtcbiAgICAgICAgaWYgKC9eKGh0dHB8d3MpJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICAgICAgICBvYmoucG9ydCA9IFwiODBcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXihodHRwfHdzKXMkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgICAgICAgIG9iai5wb3J0ID0gXCI0NDNcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvYmoucGF0aCA9IG9iai5wYXRoIHx8IFwiL1wiO1xuICAgIGNvbnN0IGlwdjYgPSBvYmouaG9zdC5pbmRleE9mKFwiOlwiKSAhPT0gLTE7XG4gICAgY29uc3QgaG9zdCA9IGlwdjYgPyBcIltcIiArIG9iai5ob3N0ICsgXCJdXCIgOiBvYmouaG9zdDtcbiAgICAvLyBkZWZpbmUgdW5pcXVlIGlkXG4gICAgb2JqLmlkID0gb2JqLnByb3RvY29sICsgXCI6Ly9cIiArIGhvc3QgKyBcIjpcIiArIG9iai5wb3J0ICsgcGF0aDtcbiAgICAvLyBkZWZpbmUgaHJlZlxuICAgIG9iai5ocmVmID1cbiAgICAgICAgb2JqLnByb3RvY29sICtcbiAgICAgICAgICAgIFwiOi8vXCIgK1xuICAgICAgICAgICAgaG9zdCArXG4gICAgICAgICAgICAobG9jICYmIGxvYy5wb3J0ID09PSBvYmoucG9ydCA/IFwiXCIgOiBcIjpcIiArIG9iai5wb3J0KTtcbiAgICByZXR1cm4gb2JqO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/socket.io-client/build/esm/url.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/socket.io-parser/build/esm/binary.js":
/*!***********************************************************!*\
  !*** ./node_modules/socket.io-parser/build/esm/binary.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deconstructPacket: () => (/* binding */ deconstructPacket),\n/* harmony export */   reconstructPacket: () => (/* binding */ reconstructPacket)\n/* harmony export */ });\n/* harmony import */ var _is_binary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-binary.js */ \"(pages-dir-browser)/./node_modules/socket.io-parser/build/esm/is-binary.js\");\n\n/**\n * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @public\n */\nfunction deconstructPacket(packet) {\n    const buffers = [];\n    const packetData = packet.data;\n    const pack = packet;\n    pack.data = _deconstructPacket(packetData, buffers);\n    pack.attachments = buffers.length; // number of binary 'attachments'\n    return { packet: pack, buffers: buffers };\n}\nfunction _deconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if ((0,_is_binary_js__WEBPACK_IMPORTED_MODULE_0__.isBinary)(data)) {\n        const placeholder = { _placeholder: true, num: buffers.length };\n        buffers.push(data);\n        return placeholder;\n    }\n    else if (Array.isArray(data)) {\n        const newData = new Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n            newData[i] = _deconstructPacket(data[i], buffers);\n        }\n        return newData;\n    }\n    else if (typeof data === \"object\" && !(data instanceof Date)) {\n        const newData = {};\n        for (const key in data) {\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\n                newData[key] = _deconstructPacket(data[key], buffers);\n            }\n        }\n        return newData;\n    }\n    return data;\n}\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @public\n */\nfunction reconstructPacket(packet, buffers) {\n    packet.data = _reconstructPacket(packet.data, buffers);\n    delete packet.attachments; // no longer useful\n    return packet;\n}\nfunction _reconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (data && data._placeholder === true) {\n        const isIndexValid = typeof data.num === \"number\" &&\n            data.num >= 0 &&\n            data.num < buffers.length;\n        if (isIndexValid) {\n            return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n        }\n        else {\n            throw new Error(\"illegal attachments\");\n        }\n    }\n    else if (Array.isArray(data)) {\n        for (let i = 0; i < data.length; i++) {\n            data[i] = _reconstructPacket(data[i], buffers);\n        }\n    }\n    else if (typeof data === \"object\") {\n        for (const key in data) {\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\n                data[key] = _reconstructPacket(data[key], buffers);\n            }\n        }\n    }\n    return data;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2J1aWxkL2VzbS9iaW5hcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBUTtBQUNoQiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNPO0FBQ1A7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHNvY2tldC5pby1wYXJzZXJcXGJ1aWxkXFxlc21cXGJpbmFyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc0JpbmFyeSB9IGZyb20gXCIuL2lzLWJpbmFyeS5qc1wiO1xuLyoqXG4gKiBSZXBsYWNlcyBldmVyeSBCdWZmZXIgfCBBcnJheUJ1ZmZlciB8IEJsb2IgfCBGaWxlIGluIHBhY2tldCB3aXRoIGEgbnVtYmVyZWQgcGxhY2Vob2xkZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvbnN0cnVjdFBhY2tldChwYWNrZXQpIHtcbiAgICBjb25zdCBidWZmZXJzID0gW107XG4gICAgY29uc3QgcGFja2V0RGF0YSA9IHBhY2tldC5kYXRhO1xuICAgIGNvbnN0IHBhY2sgPSBwYWNrZXQ7XG4gICAgcGFjay5kYXRhID0gX2RlY29uc3RydWN0UGFja2V0KHBhY2tldERhdGEsIGJ1ZmZlcnMpO1xuICAgIHBhY2suYXR0YWNobWVudHMgPSBidWZmZXJzLmxlbmd0aDsgLy8gbnVtYmVyIG9mIGJpbmFyeSAnYXR0YWNobWVudHMnXG4gICAgcmV0dXJuIHsgcGFja2V0OiBwYWNrLCBidWZmZXJzOiBidWZmZXJzIH07XG59XG5mdW5jdGlvbiBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YSwgYnVmZmVycykge1xuICAgIGlmICghZGF0YSlcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgaWYgKGlzQmluYXJ5KGRhdGEpKSB7XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcbiAgICAgICAgYnVmZmVycy5wdXNoKGRhdGEpO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgY29uc3QgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3RGF0YVtpXSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldLCBidWZmZXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgY29uc3QgbmV3RGF0YSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkpIHtcbiAgICAgICAgICAgICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIFJlY29uc3RydWN0cyBhIGJpbmFyeSBwYWNrZXQgZnJvbSBpdHMgcGxhY2Vob2xkZXIgcGFja2V0IGFuZCBidWZmZXJzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIGV2ZW50IHBhY2tldCB3aXRoIHBsYWNlaG9sZGVyc1xuICogQHBhcmFtIHtBcnJheX0gYnVmZmVycyAtIGJpbmFyeSBidWZmZXJzIHRvIHB1dCBpbiBwbGFjZWhvbGRlciBwb3NpdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjb25zdHJ1Y3RlZCBwYWNrZXRcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlY29uc3RydWN0UGFja2V0KHBhY2tldCwgYnVmZmVycykge1xuICAgIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhLCBidWZmZXJzKTtcbiAgICBkZWxldGUgcGFja2V0LmF0dGFjaG1lbnRzOyAvLyBubyBsb25nZXIgdXNlZnVsXG4gICAgcmV0dXJuIHBhY2tldDtcbn1cbmZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG4gICAgaWYgKCFkYXRhKVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICBpZiAoZGF0YSAmJiBkYXRhLl9wbGFjZWhvbGRlciA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCBpc0luZGV4VmFsaWQgPSB0eXBlb2YgZGF0YS5udW0gPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgICAgIGRhdGEubnVtID49IDAgJiZcbiAgICAgICAgICAgIGRhdGEubnVtIDwgYnVmZmVycy5sZW5ndGg7XG4gICAgICAgIGlmIChpc0luZGV4VmFsaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBidWZmZXJzW2RhdGEubnVtXTsgLy8gYXBwcm9wcmlhdGUgYnVmZmVyIChzaG91bGQgYmUgbmF0dXJhbCBvcmRlciBhbnl3YXkpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGF0dGFjaG1lbnRzXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkYXRhW2ldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFbaV0sIGJ1ZmZlcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSkge1xuICAgICAgICAgICAgICAgIGRhdGFba2V5XSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0sIGJ1ZmZlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/socket.io-parser/build/esm/binary.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/socket.io-parser/build/esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/socket.io-parser/build/esm/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoder: () => (/* binding */ Decoder),\n/* harmony export */   Encoder: () => (/* binding */ Encoder),\n/* harmony export */   PacketType: () => (/* binding */ PacketType),\n/* harmony export */   protocol: () => (/* binding */ protocol)\n/* harmony export */ });\n/* harmony import */ var _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @socket.io/component-emitter */ \"(pages-dir-browser)/./node_modules/@socket.io/component-emitter/lib/esm/index.js\");\n/* harmony import */ var _binary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./binary.js */ \"(pages-dir-browser)/./node_modules/socket.io-parser/build/esm/binary.js\");\n/* harmony import */ var _is_binary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is-binary.js */ \"(pages-dir-browser)/./node_modules/socket.io-parser/build/esm/is-binary.js\");\n\n\n\n/**\n * These strings must not be used as event names, as they have a special meaning.\n */\nconst RESERVED_EVENTS = [\n    \"connect\",\n    \"connect_error\",\n    \"disconnect\",\n    \"disconnecting\",\n    \"newListener\",\n    \"removeListener\", // used by the Node.js EventEmitter\n];\n/**\n * Protocol version.\n *\n * @public\n */\nconst protocol = 5;\nvar PacketType;\n(function (PacketType) {\n    PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n    PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n    PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n    PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n    PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n    PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n    PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n})(PacketType || (PacketType = {}));\n/**\n * A socket.io Encoder instance\n */\nclass Encoder {\n    /**\n     * Encoder constructor\n     *\n     * @param {function} replacer - custom replacer to pass down to JSON.parse\n     */\n    constructor(replacer) {\n        this.replacer = replacer;\n    }\n    /**\n     * Encode a packet as a single string if non-binary, or as a\n     * buffer sequence, depending on packet type.\n     *\n     * @param {Object} obj - packet object\n     */\n    encode(obj) {\n        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n            if ((0,_is_binary_js__WEBPACK_IMPORTED_MODULE_2__.hasBinary)(obj)) {\n                return this.encodeAsBinary({\n                    type: obj.type === PacketType.EVENT\n                        ? PacketType.BINARY_EVENT\n                        : PacketType.BINARY_ACK,\n                    nsp: obj.nsp,\n                    data: obj.data,\n                    id: obj.id,\n                });\n            }\n        }\n        return [this.encodeAsString(obj)];\n    }\n    /**\n     * Encode packet as string.\n     */\n    encodeAsString(obj) {\n        // first is type\n        let str = \"\" + obj.type;\n        // attachments if we have them\n        if (obj.type === PacketType.BINARY_EVENT ||\n            obj.type === PacketType.BINARY_ACK) {\n            str += obj.attachments + \"-\";\n        }\n        // if we have a namespace other than `/`\n        // we append it followed by a comma `,`\n        if (obj.nsp && \"/\" !== obj.nsp) {\n            str += obj.nsp + \",\";\n        }\n        // immediately followed by the id\n        if (null != obj.id) {\n            str += obj.id;\n        }\n        // json data\n        if (null != obj.data) {\n            str += JSON.stringify(obj.data, this.replacer);\n        }\n        return str;\n    }\n    /**\n     * Encode packet as 'buffer sequence' by removing blobs, and\n     * deconstructing packet into object with placeholders and\n     * a list of buffers.\n     */\n    encodeAsBinary(obj) {\n        const deconstruction = (0,_binary_js__WEBPACK_IMPORTED_MODULE_1__.deconstructPacket)(obj);\n        const pack = this.encodeAsString(deconstruction.packet);\n        const buffers = deconstruction.buffers;\n        buffers.unshift(pack); // add packet info to beginning of data list\n        return buffers; // write all the buffers\n    }\n}\n// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript\nfunction isObject(value) {\n    return Object.prototype.toString.call(value) === \"[object Object]\";\n}\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n */\nclass Decoder extends _socket_io_component_emitter__WEBPACK_IMPORTED_MODULE_0__.Emitter {\n    /**\n     * Decoder constructor\n     *\n     * @param {function} reviver - custom reviver to pass down to JSON.stringify\n     */\n    constructor(reviver) {\n        super();\n        this.reviver = reviver;\n    }\n    /**\n     * Decodes an encoded packet string into packet JSON.\n     *\n     * @param {String} obj - encoded packet\n     */\n    add(obj) {\n        let packet;\n        if (typeof obj === \"string\") {\n            if (this.reconstructor) {\n                throw new Error(\"got plaintext data when reconstructing a packet\");\n            }\n            packet = this.decodeString(obj);\n            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;\n            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {\n                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;\n                // binary packet's json\n                this.reconstructor = new BinaryReconstructor(packet);\n                // no attachments, labeled binary but no binary data to follow\n                if (packet.attachments === 0) {\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n            else {\n                // non-binary full packet\n                super.emitReserved(\"decoded\", packet);\n            }\n        }\n        else if ((0,_is_binary_js__WEBPACK_IMPORTED_MODULE_2__.isBinary)(obj) || obj.base64) {\n            // raw binary data\n            if (!this.reconstructor) {\n                throw new Error(\"got binary data when not reconstructing a packet\");\n            }\n            else {\n                packet = this.reconstructor.takeBinaryData(obj);\n                if (packet) {\n                    // received final buffer\n                    this.reconstructor = null;\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Unknown type: \" + obj);\n        }\n    }\n    /**\n     * Decode a packet String (JSON data)\n     *\n     * @param {String} str\n     * @return {Object} packet\n     */\n    decodeString(str) {\n        let i = 0;\n        // look up type\n        const p = {\n            type: Number(str.charAt(0)),\n        };\n        if (PacketType[p.type] === undefined) {\n            throw new Error(\"unknown packet type \" + p.type);\n        }\n        // look up attachments if type binary\n        if (p.type === PacketType.BINARY_EVENT ||\n            p.type === PacketType.BINARY_ACK) {\n            const start = i + 1;\n            while (str.charAt(++i) !== \"-\" && i != str.length) { }\n            const buf = str.substring(start, i);\n            if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n                throw new Error(\"Illegal attachments\");\n            }\n            p.attachments = Number(buf);\n        }\n        // look up namespace (if any)\n        if (\"/\" === str.charAt(i + 1)) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (\",\" === c)\n                    break;\n                if (i === str.length)\n                    break;\n            }\n            p.nsp = str.substring(start, i);\n        }\n        else {\n            p.nsp = \"/\";\n        }\n        // look up id\n        const next = str.charAt(i + 1);\n        if (\"\" !== next && Number(next) == next) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (null == c || Number(c) != c) {\n                    --i;\n                    break;\n                }\n                if (i === str.length)\n                    break;\n            }\n            p.id = Number(str.substring(start, i + 1));\n        }\n        // look up json data\n        if (str.charAt(++i)) {\n            const payload = this.tryParse(str.substr(i));\n            if (Decoder.isPayloadValid(p.type, payload)) {\n                p.data = payload;\n            }\n            else {\n                throw new Error(\"invalid payload\");\n            }\n        }\n        return p;\n    }\n    tryParse(str) {\n        try {\n            return JSON.parse(str, this.reviver);\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    static isPayloadValid(type, payload) {\n        switch (type) {\n            case PacketType.CONNECT:\n                return isObject(payload);\n            case PacketType.DISCONNECT:\n                return payload === undefined;\n            case PacketType.CONNECT_ERROR:\n                return typeof payload === \"string\" || isObject(payload);\n            case PacketType.EVENT:\n            case PacketType.BINARY_EVENT:\n                return (Array.isArray(payload) &&\n                    (typeof payload[0] === \"number\" ||\n                        (typeof payload[0] === \"string\" &&\n                            RESERVED_EVENTS.indexOf(payload[0]) === -1)));\n            case PacketType.ACK:\n            case PacketType.BINARY_ACK:\n                return Array.isArray(payload);\n        }\n    }\n    /**\n     * Deallocates a parser's resources\n     */\n    destroy() {\n        if (this.reconstructor) {\n            this.reconstructor.finishedReconstruction();\n            this.reconstructor = null;\n        }\n    }\n}\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n */\nclass BinaryReconstructor {\n    constructor(packet) {\n        this.packet = packet;\n        this.buffers = [];\n        this.reconPack = packet;\n    }\n    /**\n     * Method to be called when binary data received from connection\n     * after a BINARY_EVENT packet.\n     *\n     * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n     * @return {null | Object} returns null if more binary data is expected or\n     *   a reconstructed packet object if all buffers have been received.\n     */\n    takeBinaryData(binData) {\n        this.buffers.push(binData);\n        if (this.buffers.length === this.reconPack.attachments) {\n            // done with buffer list\n            const packet = (0,_binary_js__WEBPACK_IMPORTED_MODULE_1__.reconstructPacket)(this.reconPack, this.buffers);\n            this.finishedReconstruction();\n            return packet;\n        }\n        return null;\n    }\n    /**\n     * Cleans up binary packet reconstruction variables.\n     */\n    finishedReconstruction() {\n        this.reconPack = null;\n        this.buffers = [];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2J1aWxkL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXVEO0FBQ1k7QUFDZDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7QUFDakM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0RBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZEQUFpQjtBQUNoRDtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDTyxzQkFBc0IsaUVBQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix1REFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckMsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDZEQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXHNob3BfaGFyZGhhdFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcc29ja2V0LmlvLXBhcnNlclxcYnVpbGRcXGVzbVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gXCJAc29ja2V0LmlvL2NvbXBvbmVudC1lbWl0dGVyXCI7XG5pbXBvcnQgeyBkZWNvbnN0cnVjdFBhY2tldCwgcmVjb25zdHJ1Y3RQYWNrZXQgfSBmcm9tIFwiLi9iaW5hcnkuanNcIjtcbmltcG9ydCB7IGlzQmluYXJ5LCBoYXNCaW5hcnkgfSBmcm9tIFwiLi9pcy1iaW5hcnkuanNcIjtcbi8qKlxuICogVGhlc2Ugc3RyaW5ncyBtdXN0IG5vdCBiZSB1c2VkIGFzIGV2ZW50IG5hbWVzLCBhcyB0aGV5IGhhdmUgYSBzcGVjaWFsIG1lYW5pbmcuXG4gKi9cbmNvbnN0IFJFU0VSVkVEX0VWRU5UUyA9IFtcbiAgICBcImNvbm5lY3RcIixcbiAgICBcImNvbm5lY3RfZXJyb3JcIixcbiAgICBcImRpc2Nvbm5lY3RcIixcbiAgICBcImRpc2Nvbm5lY3RpbmdcIixcbiAgICBcIm5ld0xpc3RlbmVyXCIsXG4gICAgXCJyZW1vdmVMaXN0ZW5lclwiLCAvLyB1c2VkIGJ5IHRoZSBOb2RlLmpzIEV2ZW50RW1pdHRlclxuXTtcbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBwcm90b2NvbCA9IDU7XG5leHBvcnQgdmFyIFBhY2tldFR5cGU7XG4oZnVuY3Rpb24gKFBhY2tldFR5cGUpIHtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJDT05ORUNUXCJdID0gMF0gPSBcIkNPTk5FQ1RcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJESVNDT05ORUNUXCJdID0gMV0gPSBcIkRJU0NPTk5FQ1RcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJFVkVOVFwiXSA9IDJdID0gXCJFVkVOVFwiO1xuICAgIFBhY2tldFR5cGVbUGFja2V0VHlwZVtcIkFDS1wiXSA9IDNdID0gXCJBQ0tcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJDT05ORUNUX0VSUk9SXCJdID0gNF0gPSBcIkNPTk5FQ1RfRVJST1JcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJCSU5BUllfRVZFTlRcIl0gPSA1XSA9IFwiQklOQVJZX0VWRU5UXCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiQklOQVJZX0FDS1wiXSA9IDZdID0gXCJCSU5BUllfQUNLXCI7XG59KShQYWNrZXRUeXBlIHx8IChQYWNrZXRUeXBlID0ge30pKTtcbi8qKlxuICogQSBzb2NrZXQuaW8gRW5jb2RlciBpbnN0YW5jZVxuICovXG5leHBvcnQgY2xhc3MgRW5jb2RlciB7XG4gICAgLyoqXG4gICAgICogRW5jb2RlciBjb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gcmVwbGFjZXIgLSBjdXN0b20gcmVwbGFjZXIgdG8gcGFzcyBkb3duIHRvIEpTT04ucGFyc2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXBsYWNlcikge1xuICAgICAgICB0aGlzLnJlcGxhY2VyID0gcmVwbGFjZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuICAgICAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3RcbiAgICAgKi9cbiAgICBlbmNvZGUob2JqKSB7XG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gUGFja2V0VHlwZS5FVkVOVCB8fCBvYmoudHlwZSA9PT0gUGFja2V0VHlwZS5BQ0spIHtcbiAgICAgICAgICAgIGlmIChoYXNCaW5hcnkob2JqKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZUFzQmluYXJ5KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogb2JqLnR5cGUgPT09IFBhY2tldFR5cGUuRVZFTlRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gUGFja2V0VHlwZS5CSU5BUllfRVZFTlRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogUGFja2V0VHlwZS5CSU5BUllfQUNLLFxuICAgICAgICAgICAgICAgICAgICBuc3A6IG9iai5uc3AsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG9iai5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBpZDogb2JqLmlkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdGhpcy5lbmNvZGVBc1N0cmluZyhvYmopXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlIHBhY2tldCBhcyBzdHJpbmcuXG4gICAgICovXG4gICAgZW5jb2RlQXNTdHJpbmcob2JqKSB7XG4gICAgICAgIC8vIGZpcnN0IGlzIHR5cGVcbiAgICAgICAgbGV0IHN0ciA9IFwiXCIgKyBvYmoudHlwZTtcbiAgICAgICAgLy8gYXR0YWNobWVudHMgaWYgd2UgaGF2ZSB0aGVtXG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gUGFja2V0VHlwZS5CSU5BUllfRVZFTlQgfHxcbiAgICAgICAgICAgIG9iai50eXBlID09PSBQYWNrZXRUeXBlLkJJTkFSWV9BQ0spIHtcbiAgICAgICAgICAgIHN0ciArPSBvYmouYXR0YWNobWVudHMgKyBcIi1cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbmFtZXNwYWNlIG90aGVyIHRoYW4gYC9gXG4gICAgICAgIC8vIHdlIGFwcGVuZCBpdCBmb2xsb3dlZCBieSBhIGNvbW1hIGAsYFxuICAgICAgICBpZiAob2JqLm5zcCAmJiBcIi9cIiAhPT0gb2JqLm5zcCkge1xuICAgICAgICAgICAgc3RyICs9IG9iai5uc3AgKyBcIixcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGUgaWRcbiAgICAgICAgaWYgKG51bGwgIT0gb2JqLmlkKSB7XG4gICAgICAgICAgICBzdHIgKz0gb2JqLmlkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGpzb24gZGF0YVxuICAgICAgICBpZiAobnVsbCAhPSBvYmouZGF0YSkge1xuICAgICAgICAgICAgc3RyICs9IEpTT04uc3RyaW5naWZ5KG9iai5kYXRhLCB0aGlzLnJlcGxhY2VyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGUgcGFja2V0IGFzICdidWZmZXIgc2VxdWVuY2UnIGJ5IHJlbW92aW5nIGJsb2JzLCBhbmRcbiAgICAgKiBkZWNvbnN0cnVjdGluZyBwYWNrZXQgaW50byBvYmplY3Qgd2l0aCBwbGFjZWhvbGRlcnMgYW5kXG4gICAgICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gICAgICovXG4gICAgZW5jb2RlQXNCaW5hcnkob2JqKSB7XG4gICAgICAgIGNvbnN0IGRlY29uc3RydWN0aW9uID0gZGVjb25zdHJ1Y3RQYWNrZXQob2JqKTtcbiAgICAgICAgY29uc3QgcGFjayA9IHRoaXMuZW5jb2RlQXNTdHJpbmcoZGVjb25zdHJ1Y3Rpb24ucGFja2V0KTtcbiAgICAgICAgY29uc3QgYnVmZmVycyA9IGRlY29uc3RydWN0aW9uLmJ1ZmZlcnM7XG4gICAgICAgIGJ1ZmZlcnMudW5zaGlmdChwYWNrKTsgLy8gYWRkIHBhY2tldCBpbmZvIHRvIGJlZ2lubmluZyBvZiBkYXRhIGxpc3RcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcnM7IC8vIHdyaXRlIGFsbCB0aGUgYnVmZmVyc1xuICAgIH1cbn1cbi8vIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NTExMjgxL2NoZWNrLWlmLWEtdmFsdWUtaXMtYW4tb2JqZWN0LWluLWphdmFzY3JpcHRcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59XG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqL1xuZXhwb3J0IGNsYXNzIERlY29kZXIgZXh0ZW5kcyBFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBEZWNvZGVyIGNvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSByZXZpdmVyIC0gY3VzdG9tIHJldml2ZXIgdG8gcGFzcyBkb3duIHRvIEpTT04uc3RyaW5naWZ5XG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmV2aXZlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJldml2ZXIgPSByZXZpdmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGVzIGFuIGVuY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG9iaiAtIGVuY29kZWQgcGFja2V0XG4gICAgICovXG4gICAgYWRkKG9iaikge1xuICAgICAgICBsZXQgcGFja2V0O1xuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImdvdCBwbGFpbnRleHQgZGF0YSB3aGVuIHJlY29uc3RydWN0aW5nIGEgcGFja2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFja2V0ID0gdGhpcy5kZWNvZGVTdHJpbmcob2JqKTtcbiAgICAgICAgICAgIGNvbnN0IGlzQmluYXJ5RXZlbnQgPSBwYWNrZXQudHlwZSA9PT0gUGFja2V0VHlwZS5CSU5BUllfRVZFTlQ7XG4gICAgICAgICAgICBpZiAoaXNCaW5hcnlFdmVudCB8fCBwYWNrZXQudHlwZSA9PT0gUGFja2V0VHlwZS5CSU5BUllfQUNLKSB7XG4gICAgICAgICAgICAgICAgcGFja2V0LnR5cGUgPSBpc0JpbmFyeUV2ZW50ID8gUGFja2V0VHlwZS5FVkVOVCA6IFBhY2tldFR5cGUuQUNLO1xuICAgICAgICAgICAgICAgIC8vIGJpbmFyeSBwYWNrZXQncyBqc29uXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcbiAgICAgICAgICAgICAgICAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuICAgICAgICAgICAgICAgIGlmIChwYWNrZXQuYXR0YWNobWVudHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuZW1pdFJlc2VydmVkKFwiZGVjb2RlZFwiLCBwYWNrZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG5vbi1iaW5hcnkgZnVsbCBwYWNrZXRcbiAgICAgICAgICAgICAgICBzdXBlci5lbWl0UmVzZXJ2ZWQoXCJkZWNvZGVkXCIsIHBhY2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCaW5hcnkob2JqKSB8fCBvYmouYmFzZTY0KSB7XG4gICAgICAgICAgICAvLyByYXcgYmluYXJ5IGRhdGFcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFja2V0ID0gdGhpcy5yZWNvbnN0cnVjdG9yLnRha2VCaW5hcnlEYXRhKG9iaik7XG4gICAgICAgICAgICAgICAgaWYgKHBhY2tldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuZW1pdFJlc2VydmVkKFwiZGVjb2RlZFwiLCBwYWNrZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZTogXCIgKyBvYmopO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICAgICAqL1xuICAgIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAvLyBsb29rIHVwIHR5cGVcbiAgICAgICAgY29uc3QgcCA9IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcihzdHIuY2hhckF0KDApKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFBhY2tldFR5cGVbcC50eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHBhY2tldCB0eXBlIFwiICsgcC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rIHVwIGF0dGFjaG1lbnRzIGlmIHR5cGUgYmluYXJ5XG4gICAgICAgIGlmIChwLnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0VWRU5UIHx8XG4gICAgICAgICAgICBwLnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0FDSykge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChzdHIuY2hhckF0KCsraSkgIT09IFwiLVwiICYmIGkgIT0gc3RyLmxlbmd0aCkgeyB9XG4gICAgICAgICAgICBjb25zdCBidWYgPSBzdHIuc3Vic3RyaW5nKHN0YXJ0LCBpKTtcbiAgICAgICAgICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGF0dGFjaG1lbnRzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG4gICAgICAgIGlmIChcIi9cIiA9PT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKFwiLFwiID09PSBjKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwLm5zcCA9IHN0ci5zdWJzdHJpbmcoc3RhcnQsIGkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcC5uc3AgPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rIHVwIGlkXG4gICAgICAgIGNvbnN0IG5leHQgPSBzdHIuY2hhckF0KGkgKyAxKTtcbiAgICAgICAgaWYgKFwiXCIgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwLmlkID0gTnVtYmVyKHN0ci5zdWJzdHJpbmcoc3RhcnQsIGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9vayB1cCBqc29uIGRhdGFcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRoaXMudHJ5UGFyc2Uoc3RyLnN1YnN0cihpKSk7XG4gICAgICAgICAgICBpZiAoRGVjb2Rlci5pc1BheWxvYWRWYWxpZChwLnR5cGUsIHBheWxvYWQpKSB7XG4gICAgICAgICAgICAgICAgcC5kYXRhID0gcGF5bG9hZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGF5bG9hZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgdHJ5UGFyc2Uoc3RyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdHIsIHRoaXMucmV2aXZlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgaXNQYXlsb2FkVmFsaWQodHlwZSwgcGF5bG9hZCkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgUGFja2V0VHlwZS5DT05ORUNUOlxuICAgICAgICAgICAgICAgIHJldHVybiBpc09iamVjdChwYXlsb2FkKTtcbiAgICAgICAgICAgIGNhc2UgUGFja2V0VHlwZS5ESVNDT05ORUNUOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuQ09OTkVDVF9FUlJPUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHBheWxvYWQgPT09IFwic3RyaW5nXCIgfHwgaXNPYmplY3QocGF5bG9hZCk7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuRVZFTlQ6XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuQklOQVJZX0VWRU5UOlxuICAgICAgICAgICAgICAgIHJldHVybiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJlxuICAgICAgICAgICAgICAgICAgICAodHlwZW9mIHBheWxvYWRbMF0gPT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgcGF5bG9hZFswXSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJFU0VSVkVEX0VWRU5UUy5pbmRleE9mKHBheWxvYWRbMF0pID09PSAtMSkpKTtcbiAgICAgICAgICAgIGNhc2UgUGFja2V0VHlwZS5BQ0s6XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuQklOQVJZX0FDSzpcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWFsbG9jYXRlcyBhIHBhcnNlcidzIHJlc291cmNlc1xuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIG1hbmFnZXIgb2YgYSBiaW5hcnkgZXZlbnQncyAnYnVmZmVyIHNlcXVlbmNlJy4gU2hvdWxkXG4gKiBiZSBjb25zdHJ1Y3RlZCB3aGVuZXZlciBhIHBhY2tldCBvZiB0eXBlIEJJTkFSWV9FVkVOVCBpc1xuICogZGVjb2RlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtCaW5hcnlSZWNvbnN0cnVjdG9yfSBpbml0aWFsaXplZCByZWNvbnN0cnVjdG9yXG4gKi9cbmNsYXNzIEJpbmFyeVJlY29uc3RydWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHBhY2tldCkge1xuICAgICAgICB0aGlzLnBhY2tldCA9IHBhY2tldDtcbiAgICAgICAgdGhpcy5idWZmZXJzID0gW107XG4gICAgICAgIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG4gICAgICogYWZ0ZXIgYSBCSU5BUllfRVZFTlQgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcbiAgICAgKiBAcmV0dXJuIHtudWxsIHwgT2JqZWN0fSByZXR1cm5zIG51bGwgaWYgbW9yZSBiaW5hcnkgZGF0YSBpcyBleHBlY3RlZCBvclxuICAgICAqICAgYSByZWNvbnN0cnVjdGVkIHBhY2tldCBvYmplY3QgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICAgICAqL1xuICAgIHRha2VCaW5hcnlEYXRhKGJpbkRhdGEpIHtcbiAgICAgICAgdGhpcy5idWZmZXJzLnB1c2goYmluRGF0YSk7XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoID09PSB0aGlzLnJlY29uUGFjay5hdHRhY2htZW50cykge1xuICAgICAgICAgICAgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG4gICAgICAgICAgICBjb25zdCBwYWNrZXQgPSByZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjaywgdGhpcy5idWZmZXJzKTtcbiAgICAgICAgICAgIHRoaXMuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHBhY2tldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIGJpbmFyeSBwYWNrZXQgcmVjb25zdHJ1Y3Rpb24gdmFyaWFibGVzLlxuICAgICAqL1xuICAgIGZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVjb25QYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5idWZmZXJzID0gW107XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/socket.io-parser/build/esm/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/socket.io-parser/build/esm/is-binary.js":
/*!**************************************************************!*\
  !*** ./node_modules/socket.io-parser/build/esm/is-binary.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hasBinary: () => (/* binding */ hasBinary),\n/* harmony export */   isBinary: () => (/* binding */ isBinary)\n/* harmony export */ });\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst isView = (obj) => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj.buffer instanceof ArrayBuffer;\n};\nconst toString = Object.prototype.toString;\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeFile = typeof File === \"function\" ||\n    (typeof File !== \"undefined\" &&\n        toString.call(File) === \"[object FileConstructor]\");\n/**\n * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\n *\n * @private\n */\nfunction isBinary(obj) {\n    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||\n        (withNativeBlob && obj instanceof Blob) ||\n        (withNativeFile && obj instanceof File));\n}\nfunction hasBinary(obj, toJSON) {\n    if (!obj || typeof obj !== \"object\") {\n        return false;\n    }\n    if (Array.isArray(obj)) {\n        for (let i = 0, l = obj.length; i < l; i++) {\n            if (hasBinary(obj[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (isBinary(obj)) {\n        return true;\n    }\n    if (obj.toJSON &&\n        typeof obj.toJSON === \"function\" &&\n        arguments.length === 1) {\n        return hasBinary(obj.toJSON(), true);\n    }\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n            return true;\n        }\n    }\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2J1aWxkL2VzbS9pcy1iaW5hcnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXHNob3BfaGFyZGhhdFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcc29ja2V0LmlvLXBhcnNlclxcYnVpbGRcXGVzbVxcaXMtYmluYXJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHdpdGhOYXRpdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgaXNWaWV3ID0gKG9iaikgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKVxuICAgICAgICA6IG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn07XG5jb25zdCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCB3aXRoTmF0aXZlQmxvYiA9IHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAodHlwZW9mIEJsb2IgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdG9TdHJpbmcuY2FsbChCbG9iKSA9PT0gXCJbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl1cIik7XG5jb25zdCB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBGaWxlID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAodHlwZW9mIEZpbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdG9TdHJpbmcuY2FsbChGaWxlKSA9PT0gXCJbb2JqZWN0IEZpbGVDb25zdHJ1Y3Rvcl1cIik7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYSBCdWZmZXIsIGFuIEFycmF5QnVmZmVyLCBhIEJsb2Igb3IgYSBGaWxlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0JpbmFyeShvYmopIHtcbiAgICByZXR1cm4gKCh3aXRoTmF0aXZlQXJyYXlCdWZmZXIgJiYgKG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IGlzVmlldyhvYmopKSkgfHxcbiAgICAgICAgKHdpdGhOYXRpdmVCbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICh3aXRoTmF0aXZlRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzQmluYXJ5KG9iaiwgdG9KU09OKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaGFzQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc0JpbmFyeShvYmopKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob2JqLnRvSlNPTiAmJlxuICAgICAgICB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGhhc0JpbmFyeShvYmoudG9KU09OKCksIHRydWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgaGFzQmluYXJ5KG9ialtrZXldKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/socket.io-parser/build/esm/is-binary.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NIL: () => (/* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]),\n/* harmony export */   parse: () => (/* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]),\n/* harmony export */   stringify: () => (/* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]),\n/* harmony export */   v1: () => (/* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]),\n/* harmony export */   v3: () => (/* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]),\n/* harmony export */   v4: () => (/* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]),\n/* harmony export */   v5: () => (/* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]),\n/* harmony export */   validate: () => (/* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]),\n/* harmony export */   version: () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])\n/* harmony export */ });\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/v1.js\");\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/v3.js\");\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/v5.js\");\n/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/nil.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/version.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/validate.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/parse.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDUTtBQUNFO0FBQ0UiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHV1aWRcXGRpc3RcXGVzbS1icm93c2VyXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IGFzIHYxIH0gZnJvbSAnLi92MS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHYzIH0gZnJvbSAnLi92My5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY0IH0gZnJvbSAnLi92NC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY1IH0gZnJvbSAnLi92NS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5JTCB9IGZyb20gJy4vbmlsLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZhbGlkYXRlIH0gZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFyc2UgfSBmcm9tICcuL3BhcnNlLmpzJzsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/index.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/md5.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/md5.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  var output = [];\n  var length32 = input.length * 32;\n  var hexTab = '0123456789abcdef';\n\n  for (var i = 0; i < length32; i += 8) {\n    var x = input[i >> 5] >>> i % 32 & 0xff;\n    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/**\n * Calculate output length with padding and bit length\n */\n\n\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  var a = 1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d = 271733878;\n\n  for (var i = 0; i < x.length; i += 16) {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n\n  var length8 = input.length * 8;\n  var output = new Uint32Array(getOutputLength(length8));\n\n  for (var i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  var lsw = (x & 0xffff) + (y & 0xffff);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (md5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbWQ1LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlFQUFlLEdBQUciLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHV1aWRcXGRpc3RcXGVzbS1icm93c2VyXFxtZDUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEJyb3dzZXItY29tcGF0aWJsZSBKYXZhU2NyaXB0IE1ENVxuICpcbiAqIE1vZGlmaWNhdGlvbiBvZiBKYXZhU2NyaXB0IE1ENVxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1NRDVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogQmFzZWQgb25cbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMiBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDlcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cbiAqL1xuZnVuY3Rpb24gbWQ1KGJ5dGVzKSB7XG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG1zZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChieXRlcykpOyAvLyBVVEY4IGVzY2FwZVxuXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShtc2cubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgKytpKSB7XG4gICAgICBieXRlc1tpXSA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZDVUb0hleEVuY29kZWRBcnJheSh3b3Jkc1RvTWQ1KGJ5dGVzVG9Xb3JkcyhieXRlcyksIGJ5dGVzLmxlbmd0aCAqIDgpKTtcbn1cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMgdG8gYW4gYXJyYXkgb2YgYnl0ZXNcbiAqL1xuXG5cbmZ1bmN0aW9uIG1kNVRvSGV4RW5jb2RlZEFycmF5KGlucHV0KSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgdmFyIGxlbmd0aDMyID0gaW5wdXQubGVuZ3RoICogMzI7XG4gIHZhciBoZXhUYWIgPSAnMDEyMzQ1Njc4OWFiY2RlZic7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgzMjsgaSArPSA4KSB7XG4gICAgdmFyIHggPSBpbnB1dFtpID4+IDVdID4+PiBpICUgMzIgJiAweGZmO1xuICAgIHZhciBoZXggPSBwYXJzZUludChoZXhUYWIuY2hhckF0KHggPj4+IDQgJiAweDBmKSArIGhleFRhYi5jaGFyQXQoeCAmIDB4MGYpLCAxNik7XG4gICAgb3V0cHV0LnB1c2goaGV4KTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBvdXRwdXQgbGVuZ3RoIHdpdGggcGFkZGluZyBhbmQgYml0IGxlbmd0aFxuICovXG5cblxuZnVuY3Rpb24gZ2V0T3V0cHV0TGVuZ3RoKGlucHV0TGVuZ3RoOCkge1xuICByZXR1cm4gKGlucHV0TGVuZ3RoOCArIDY0ID4+PiA5IDw8IDQpICsgMTQgKyAxO1xufVxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGguXG4gKi9cblxuXG5mdW5jdGlvbiB3b3Jkc1RvTWQ1KHgsIGxlbikge1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8IGxlbiAlIDMyO1xuICB4W2dldE91dHB1dExlbmd0aChsZW4pIC0gMV0gPSBsZW47XG4gIHZhciBhID0gMTczMjU4NDE5MztcbiAgdmFyIGIgPSAtMjcxNzMzODc5O1xuICB2YXIgYyA9IC0xNzMyNTg0MTk0O1xuICB2YXIgZCA9IDI3MTczMzg3ODtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgdmFyIG9sZGEgPSBhO1xuICAgIHZhciBvbGRiID0gYjtcbiAgICB2YXIgb2xkYyA9IGM7XG4gICAgdmFyIG9sZGQgPSBkO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2ldLCA3LCAtNjgwODc2OTM2KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMV0sIDEyLCAtMzg5NTY0NTg2KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE3LCA2MDYxMDU4MTkpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgNF0sIDcsIC0xNzY0MTg4OTcpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyA1XSwgMTIsIDEyMDAwODA0MjYpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyA2XSwgMTcsIC0xNDczMjMxMzQxKTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgN10sIDIyLCAtNDU3MDU5ODMpO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNywgMTc3MDAzNTQxNik7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDldLCAxMiwgLTE5NTg0MTQ0MTcpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAxMF0sIDE3LCAtNDIwNjMpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxMV0sIDIyLCAtMTk5MDQwNDE2Mik7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDEyXSwgNywgMTgwNDYwMzY4Mik7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDEzXSwgMTIsIC00MDM0MTEwMSk7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTcsIC0xNTAyMDAyMjkwKTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgMTVdLCAyMiwgMTIzNjUzNTMyOSk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDFdLCA1LCAtMTY1Nzk2NTEwKTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgNl0sIDksIC0xMDY5NTAxNjMyKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNCwgNjQzNzE3NzEzKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpXSwgMjAsIC0zNzM4OTczMDIpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNSwgLTcwMTU1ODY5MSk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDEwXSwgOSwgMzgwMTYwODMpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE0LCAtNjYwNDc4MzM1KTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgOV0sIDUsIDU2ODQ0NjQzOCk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDE0XSwgOSwgLTEwMTk4MDM2OTApO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAzXSwgMTQsIC0xODczNjM5NjEpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA4XSwgMjAsIDExNjM1MzE1MDEpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDUsIC0xNDQ0NjgxNDY3KTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMl0sIDksIC01MTQwMzc4NCk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDddLCAxNCwgMTczNTMyODQ3Myk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDEyXSwgMjAsIC0xOTI2NjA3NzM0KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgNV0sIDQsIC0zNzg1NTgpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNiwgMTgzOTAzMDU2Mik7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDFdLCA0LCAtMTUzMDk5MjA2MCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDRdLCAxMSwgMTI3Mjg5MzM1Myk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDddLCAxNiwgLTE1NTQ5NzYzMik7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMTNdLCA0LCA2ODEyNzkxNzQpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2ldLCAxMSwgLTM1ODUzNzIyMik7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNiwgLTcyMjUyMTk3OSk7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDZdLCAyMywgNzYwMjkxODkpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNCwgLTY0MDM2NDQ4Nyk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDEyXSwgMTEsIC00MjE4MTU4MzUpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE2LCA1MzA3NDI1MjApO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2ldLCA2LCAtMTk4NjMwODQ0KTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgN10sIDEwLCAxMTI2ODkxNDE1KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA1XSwgMjEsIC01NzQzNDA1NSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDEyXSwgNiwgMTcwMDQ4NTU3MSk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDNdLCAxMCwgLTE4OTQ5ODY2MDYpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxMF0sIDE1LCAtMTA1MTUyMyk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA4XSwgNiwgMTg3MzMxMzM1OSk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDE1XSwgMTAsIC0zMDYxMTc0NCk7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNSwgLTE1NjAxOTgzODApO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyAxM10sIDIxLCAxMzA5MTUxNjQ5KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgNF0sIDYsIC0xNDU1MjMwNzApO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAxMV0sIDEwLCAtMTEyMDIxMDM3OSk7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNSwgNzE4Nzg3MjU5KTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgOV0sIDIxLCAtMzQzNDg1NTUxKTtcbiAgICBhID0gc2FmZUFkZChhLCBvbGRhKTtcbiAgICBiID0gc2FmZUFkZChiLCBvbGRiKTtcbiAgICBjID0gc2FmZUFkZChjLCBvbGRjKTtcbiAgICBkID0gc2FmZUFkZChkLCBvbGRkKTtcbiAgfVxuXG4gIHJldHVybiBbYSwgYiwgYywgZF07XG59XG4vKlxuICogQ29udmVydCBhbiBhcnJheSBieXRlcyB0byBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzXG4gKiBDaGFyYWN0ZXJzID4yNTUgaGF2ZSB0aGVpciBoaWdoLWJ5dGUgc2lsZW50bHkgaWdub3JlZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJ5dGVzVG9Xb3JkcyhpbnB1dCkge1xuICBpZiAoaW5wdXQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIGxlbmd0aDggPSBpbnB1dC5sZW5ndGggKiA4O1xuICB2YXIgb3V0cHV0ID0gbmV3IFVpbnQzMkFycmF5KGdldE91dHB1dExlbmd0aChsZW5ndGg4KSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg4OyBpICs9IDgpIHtcbiAgICBvdXRwdXRbaSA+PiA1XSB8PSAoaW5wdXRbaSAvIDhdICYgMHhmZikgPDwgaSAlIDMyO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5cblxuZnVuY3Rpb24gc2FmZUFkZCh4LCB5KSB7XG4gIHZhciBsc3cgPSAoeCAmIDB4ZmZmZikgKyAoeSAmIDB4ZmZmZik7XG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIG1zdyA8PCAxNiB8IGxzdyAmIDB4ZmZmZjtcbn1cbi8qXG4gKiBCaXR3aXNlIHJvdGF0ZSBhIDMyLWJpdCBudW1iZXIgdG8gdGhlIGxlZnQuXG4gKi9cblxuXG5mdW5jdGlvbiBiaXRSb3RhdGVMZWZ0KG51bSwgY250KSB7XG4gIHJldHVybiBudW0gPDwgY250IHwgbnVtID4+PiAzMiAtIGNudDtcbn1cbi8qXG4gKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmb3VyIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxuICovXG5cblxuZnVuY3Rpb24gbWQ1Y21uKHEsIGEsIGIsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIHNhZmVBZGQoYml0Um90YXRlTGVmdChzYWZlQWRkKHNhZmVBZGQoYSwgcSksIHNhZmVBZGQoeCwgdCkpLCBzKSwgYik7XG59XG5cbmZ1bmN0aW9uIG1kNWZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihiICYgYyB8IH5iICYgZCwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIG1kNWdnKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihiICYgZCB8IGMgJiB+ZCwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIG1kNWhoKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihiIF4gYyBeIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVpaShhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYyBeIChiIHwgfmQpLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbWQ1OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/md5.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/nil.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/nil.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ('00000000-0000-0000-0000-000000000000');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbmlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxzQ0FBc0MiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHV1aWRcXGRpc3RcXGVzbS1icm93c2VyXFxuaWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCc7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/nil.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/parse.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/parse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/validate.js\");\n\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  var v;\n  var arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (parse);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcGFyc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7O0FBRXJDO0FBQ0EsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLEtBQUsiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHV1aWRcXGRpc3RcXGVzbS1icm93c2VyXFxwYXJzZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5cbmZ1bmN0aW9uIHBhcnNlKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICB2YXIgdjtcbiAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gUGFyc2UgIyMjIyMjIyMtLi4uLi0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDAsIDgpLCAxNikpID4+PiAyNDtcbiAgYXJyWzFdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMl0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzNdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLSMjIyMtLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls0XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSg5LCAxMyksIDE2KSkgPj4+IDg7XG4gIGFycls1XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLSMjIyMtLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNl0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTQsIDE4KSwgMTYpKSA+Pj4gODtcbiAgYXJyWzddID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0jIyMjLS4uLi4uLi4uLi4uLlxuXG4gIGFycls4XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxOSwgMjMpLCAxNikpID4+PiA4O1xuICBhcnJbOV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLS4uLi4tIyMjIyMjIyMjIyMjXG4gIC8vIChVc2UgXCIvXCIgdG8gYXZvaWQgMzItYml0IHRydW5jYXRpb24gd2hlbiBiaXQtc2hpZnRpbmcgaGlnaC1vcmRlciBieXRlcylcblxuICBhcnJbMTBdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDI0LCAzNiksIDE2KSkgLyAweDEwMDAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzExXSA9IHYgLyAweDEwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMl0gPSB2ID4+PiAyNCAmIDB4ZmY7XG4gIGFyclsxM10gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsxNF0gPSB2ID4+PiA4ICYgMHhmZjtcbiAgYXJyWzE1XSA9IHYgJiAweGZmO1xuICByZXR1cm4gYXJyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBwYXJzZTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/parse.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcmVnZXguanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyx5Q0FBeUMiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHV1aWRcXGRpc3RcXGVzbS1icm93c2VyXFxyZWdleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/regex.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHV1aWRcXGRpc3RcXGVzbS1icm93c2VyXFxybmcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVW5pcXVlIElEIGNyZWF0aW9uIHJlcXVpcmVzIGEgaGlnaCBxdWFsaXR5IHJhbmRvbSAjIGdlbmVyYXRvci4gSW4gdGhlIGJyb3dzZXIgd2UgdGhlcmVmb3JlXG4vLyByZXF1aXJlIHRoZSBjcnlwdG8gQVBJIGFuZCBkbyBub3Qgc3VwcG9ydCBidWlsdC1pbiBmYWxsYmFjayB0byBsb3dlciBxdWFsaXR5IHJhbmRvbSBudW1iZXJcbi8vIGdlbmVyYXRvcnMgKGxpa2UgTWF0aC5yYW5kb20oKSkuXG52YXIgZ2V0UmFuZG9tVmFsdWVzO1xudmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICAvLyBsYXp5IGxvYWQgc28gdGhhdCBlbnZpcm9ubWVudHMgdGhhdCBuZWVkIHRvIHBvbHlmaWxsIGhhdmUgYSBjaGFuY2UgdG8gZG8gc29cbiAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uIEFsc28sXG4gICAgLy8gZmluZCB0aGUgY29tcGxldGUgaW1wbGVtZW50YXRpb24gb2YgY3J5cHRvIChtc0NyeXB0bykgb24gSUUxMS5cbiAgICBnZXRSYW5kb21WYWx1ZXMgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pIHx8IHR5cGVvZiBtc0NyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJyAmJiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChtc0NyeXB0byk7XG5cbiAgICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCkgbm90IHN1cHBvcnRlZC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCNnZXRyYW5kb212YWx1ZXMtbm90LXN1cHBvcnRlZCcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBnZXRSYW5kb21WYWx1ZXMocm5kczgpO1xufSJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/rng.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/sha1.js":
/*!****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/sha1.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  var l = bytes.length / 4 + 2;\n  var N = Math.ceil(l / 16);\n  var M = new Array(N);\n\n  for (var _i = 0; _i < N; ++_i) {\n    var arr = new Uint32Array(16);\n\n    for (var j = 0; j < 16; ++j) {\n      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];\n    }\n\n    M[_i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (var _i2 = 0; _i2 < N; ++_i2) {\n    var W = new Uint32Array(80);\n\n    for (var t = 0; t < 16; ++t) {\n      W[t] = M[_i2][t];\n    }\n\n    for (var _t = 16; _t < 80; ++_t) {\n      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);\n    }\n\n    var a = H[0];\n    var b = H[1];\n    var c = H[2];\n    var d = H[3];\n    var e = H[4];\n\n    for (var _t2 = 0; _t2 < 80; ++_t2) {\n      var s = Math.floor(_t2 / 20);\n      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sha1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc2hhMS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EOztBQUVuRDs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUEsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxJQUFJIiwic291cmNlcyI6WyJDOlxcc2hvcF9oYXJkaGF0XFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFx1dWlkXFxkaXN0XFxlc20tYnJvd3Nlclxcc2hhMS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBZGFwdGVkIGZyb20gQ2hyaXMgVmVuZXNzJyBTSEExIGNvZGUgYXRcbi8vIGh0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvc2hhMS5odG1sXG5mdW5jdGlvbiBmKHMsIHgsIHksIHopIHtcbiAgc3dpdGNoIChzKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIHggJiB5IF4gfnggJiB6O1xuXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIHggXiB5IF4gejtcblxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiB4ICYgeSBeIHggJiB6IF4geSAmIHo7XG5cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4geCBeIHkgXiB6O1xuICB9XG59XG5cbmZ1bmN0aW9uIFJPVEwoeCwgbikge1xuICByZXR1cm4geCA8PCBuIHwgeCA+Pj4gMzIgLSBuO1xufVxuXG5mdW5jdGlvbiBzaGExKGJ5dGVzKSB7XG4gIHZhciBLID0gWzB4NWE4Mjc5OTksIDB4NmVkOWViYTEsIDB4OGYxYmJjZGMsIDB4Y2E2MmMxZDZdO1xuICB2YXIgSCA9IFsweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwXTtcblxuICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIHZhciBtc2cgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYnl0ZXMpKTsgLy8gVVRGOCBlc2NhcGVcblxuICAgIGJ5dGVzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7ICsraSkge1xuICAgICAgYnl0ZXMucHVzaChtc2cuY2hhckNvZGVBdChpKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIC8vIENvbnZlcnQgQXJyYXktbGlrZSB0byBBcnJheVxuICAgIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYnl0ZXMpO1xuICB9XG5cbiAgYnl0ZXMucHVzaCgweDgwKTtcbiAgdmFyIGwgPSBieXRlcy5sZW5ndGggLyA0ICsgMjtcbiAgdmFyIE4gPSBNYXRoLmNlaWwobCAvIDE2KTtcbiAgdmFyIE0gPSBuZXcgQXJyYXkoTik7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IE47ICsrX2kpIHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQzMkFycmF5KDE2KTtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgYXJyW2pdID0gYnl0ZXNbX2kgKiA2NCArIGogKiA0XSA8PCAyNCB8IGJ5dGVzW19pICogNjQgKyBqICogNCArIDFdIDw8IDE2IHwgYnl0ZXNbX2kgKiA2NCArIGogKiA0ICsgMl0gPDwgOCB8IGJ5dGVzW19pICogNjQgKyBqICogNCArIDNdO1xuICAgIH1cblxuICAgIE1bX2ldID0gYXJyO1xuICB9XG5cbiAgTVtOIC0gMV1bMTRdID0gKGJ5dGVzLmxlbmd0aCAtIDEpICogOCAvIE1hdGgucG93KDIsIDMyKTtcbiAgTVtOIC0gMV1bMTRdID0gTWF0aC5mbG9vcihNW04gLSAxXVsxNF0pO1xuICBNW04gLSAxXVsxNV0gPSAoYnl0ZXMubGVuZ3RoIC0gMSkgKiA4ICYgMHhmZmZmZmZmZjtcblxuICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBOOyArK19pMikge1xuICAgIHZhciBXID0gbmV3IFVpbnQzMkFycmF5KDgwKTtcblxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgMTY7ICsrdCkge1xuICAgICAgV1t0XSA9IE1bX2kyXVt0XTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBfdCA9IDE2OyBfdCA8IDgwOyArK190KSB7XG4gICAgICBXW190XSA9IFJPVEwoV1tfdCAtIDNdIF4gV1tfdCAtIDhdIF4gV1tfdCAtIDE0XSBeIFdbX3QgLSAxNl0sIDEpO1xuICAgIH1cblxuICAgIHZhciBhID0gSFswXTtcbiAgICB2YXIgYiA9IEhbMV07XG4gICAgdmFyIGMgPSBIWzJdO1xuICAgIHZhciBkID0gSFszXTtcbiAgICB2YXIgZSA9IEhbNF07XG5cbiAgICBmb3IgKHZhciBfdDIgPSAwOyBfdDIgPCA4MDsgKytfdDIpIHtcbiAgICAgIHZhciBzID0gTWF0aC5mbG9vcihfdDIgLyAyMCk7XG4gICAgICB2YXIgVCA9IFJPVEwoYSwgNSkgKyBmKHMsIGIsIGMsIGQpICsgZSArIEtbc10gKyBXW190Ml0gPj4+IDA7XG4gICAgICBlID0gZDtcbiAgICAgIGQgPSBjO1xuICAgICAgYyA9IFJPVEwoYiwgMzApID4+PiAwO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gVDtcbiAgICB9XG5cbiAgICBIWzBdID0gSFswXSArIGEgPj4+IDA7XG4gICAgSFsxXSA9IEhbMV0gKyBiID4+PiAwO1xuICAgIEhbMl0gPSBIWzJdICsgYyA+Pj4gMDtcbiAgICBIWzNdID0gSFszXSArIGQgPj4+IDA7XG4gICAgSFs0XSA9IEhbNF0gKyBlID4+PiAwO1xuICB9XG5cbiAgcmV0dXJuIFtIWzBdID4+IDI0ICYgMHhmZiwgSFswXSA+PiAxNiAmIDB4ZmYsIEhbMF0gPj4gOCAmIDB4ZmYsIEhbMF0gJiAweGZmLCBIWzFdID4+IDI0ICYgMHhmZiwgSFsxXSA+PiAxNiAmIDB4ZmYsIEhbMV0gPj4gOCAmIDB4ZmYsIEhbMV0gJiAweGZmLCBIWzJdID4+IDI0ICYgMHhmZiwgSFsyXSA+PiAxNiAmIDB4ZmYsIEhbMl0gPj4gOCAmIDB4ZmYsIEhbMl0gJiAweGZmLCBIWzNdID4+IDI0ICYgMHhmZiwgSFszXSA+PiAxNiAmIDB4ZmYsIEhbM10gPj4gOCAmIDB4ZmYsIEhbM10gJiAweGZmLCBIWzRdID4+IDI0ICYgMHhmZiwgSFs0XSA+PiAxNiAmIDB4ZmYsIEhbNF0gPj4gOCAmIDB4ZmYsIEhbNF0gJiAweGZmXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2hhMTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/sha1.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwZ0JBQTBnQjtBQUMxZ0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpRUFBZSxTQUFTIiwic291cmNlcyI6WyJDOlxcc2hvcF9oYXJkaGF0XFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFx1dWlkXFxkaXN0XFxlc20tYnJvd3Nlclxcc3RyaW5naWZ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbi8qKlxuICogQ29udmVydCBhcnJheSBvZiAxNiBieXRlIHZhbHVlcyB0byBVVUlEIHN0cmluZyBmb3JtYXQgb2YgdGhlIGZvcm06XG4gKiBYWFhYWFhYWC1YWFhYLVhYWFgtWFhYWC1YWFhYWFhYWFhYWFhcbiAqL1xuXG52YXIgYnl0ZVRvSGV4ID0gW107XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4LnB1c2goKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShhcnIpIHtcbiAgdmFyIG9mZnNldCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgLy8gTm90ZTogQmUgY2FyZWZ1bCBlZGl0aW5nIHRoaXMgY29kZSEgIEl0J3MgYmVlbiB0dW5lZCBmb3IgcGVyZm9ybWFuY2VcbiAgLy8gYW5kIHdvcmtzIGluIHdheXMgeW91IG1heSBub3QgZXhwZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkL3B1bGwvNDM0XG4gIHZhciB1dWlkID0gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpOyAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG5cbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gdXVpZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5naWZ5OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/stringify.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/v1.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v1.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/stringify.js\");\n\n // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\n\nvar _clockseq; // Previous uuid creation time\n\n\nvar _lastMSecs = 0;\nvar _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || new Array(16);\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    var seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(b);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ1ksQ0FBQztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZTs7O0FBR2Y7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCwrQ0FBRzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQSx3RUFBd0U7QUFDeEU7O0FBRUEsNEVBQTRFOztBQUU1RSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEIsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkIsb0NBQW9DOztBQUVwQyw4QkFBOEI7O0FBRTlCLGtDQUFrQzs7QUFFbEMsNEJBQTRCOztBQUU1QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBOztBQUVBLGdCQUFnQix5REFBUztBQUN6Qjs7QUFFQSxpRUFBZSxFQUFFIiwic291cmNlcyI6WyJDOlxcc2hvcF9oYXJkaGF0XFxmcm9udGVuZFxcbm9kZV9tb2R1bGVzXFx1dWlkXFxkaXN0XFxlc20tYnJvd3NlclxcdjEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJzsgLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuLy9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4vLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG52YXIgX25vZGVJZDtcblxudmFyIF9jbG9ja3NlcTsgLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG5cblxudmFyIF9sYXN0TVNlY3MgPSAwO1xudmFyIF9sYXN0TlNlY3MgPSAwOyAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkIGZvciBBUEkgZGV0YWlsc1xuXG5mdW5jdGlvbiB2MShvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICB2YXIgaSA9IGJ1ZiAmJiBvZmZzZXQgfHwgMDtcbiAgdmFyIGIgPSBidWYgfHwgbmV3IEFycmF5KDE2KTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBub2RlID0gb3B0aW9ucy5ub2RlIHx8IF9ub2RlSWQ7XG4gIHZhciBjbG9ja3NlcSA9IG9wdGlvbnMuY2xvY2tzZXEgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY2xvY2tzZXEgOiBfY2xvY2tzZXE7IC8vIG5vZGUgYW5kIGNsb2Nrc2VxIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gcmFuZG9tIHZhbHVlcyBpZiB0aGV5J3JlIG5vdFxuICAvLyBzcGVjaWZpZWQuICBXZSBkbyB0aGlzIGxhemlseSB0byBtaW5pbWl6ZSBpc3N1ZXMgcmVsYXRlZCB0byBpbnN1ZmZpY2llbnRcbiAgLy8gc3lzdGVtIGVudHJvcHkuICBTZWUgIzE4OVxuXG4gIGlmIChub2RlID09IG51bGwgfHwgY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgIHZhciBzZWVkQnl0ZXMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtzZWVkQnl0ZXNbMF0gfCAweDAxLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9IC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuXG5cbiAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7IC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcblxuICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7IC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcblxuICB2YXIgZHQgPSBtc2VjcyAtIF9sYXN0TVNlY3MgKyAobnNlY3MgLSBfbGFzdE5TZWNzKSAvIDEwMDAwOyAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG5cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfSAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG5cblxuICBpZiAoKGR0IDwgMCB8fCBtc2VjcyA+IF9sYXN0TVNlY3MpICYmIG9wdGlvbnMubnNlY3MgPT09IHVuZGVmaW5lZCkge1xuICAgIG5zZWNzID0gMDtcbiAgfSAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG5cblxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1dWlkLnYxKCk6IENhbid0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlY1wiKTtcbiAgfVxuXG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTsgLy8gUGVyIDQuMS40IC0gQ29udmVydCBmcm9tIHVuaXggZXBvY2ggdG8gR3JlZ29yaWFuIGVwb2NoXG5cbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7IC8vIGB0aW1lX2xvd2BcblxuICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmOyAvLyBgdGltZV9taWRgXG5cbiAgdmFyIHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjsgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcblxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG5cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7IC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDsgLy8gYGNsb2NrX3NlcV9sb3dgXG5cbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmOyAvLyBgbm9kZWBcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgfHwgc3RyaW5naWZ5KGIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2MTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/v1.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/v3.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v3.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/md5.js\");\n\n\nvar v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v3);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0E7QUFDM0IsU0FBUyxtREFBRyxhQUFhLCtDQUFHO0FBQzVCLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHV1aWRcXGRpc3RcXGVzbS1icm93c2VyXFx2My5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBtZDUgZnJvbSAnLi9tZDUuanMnO1xudmFyIHYzID0gdjM1KCd2MycsIDB4MzAsIG1kNSk7XG5leHBvcnQgZGVmYXVsdCB2MzsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/v3.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/v35.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v35.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: () => (/* binding */ DNS),\n/* harmony export */   URL: () => (/* binding */ URL),\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/parse.js\");\n\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  var bytes = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nvar DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nvar URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    var bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (var i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjM1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXVDO0FBQ1I7O0FBRS9CO0FBQ0EsMkNBQTJDOztBQUUzQzs7QUFFQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNBO0FBQ1AsNkJBQWUsb0NBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IscURBQUs7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyx5REFBUztBQUNwQixJQUFJOzs7QUFHSjtBQUNBLDhCQUE4QjtBQUM5QixJQUFJLGVBQWU7OztBQUduQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiQzpcXHNob3BfaGFyZGhhdFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcdXVpZFxcZGlzdFxcZXNtLWJyb3dzZXJcXHYzNS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmltcG9ydCBwYXJzZSBmcm9tICcuL3BhcnNlLmpzJztcblxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgc3RyID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpOyAvLyBVVEY4IGVzY2FwZVxuXG4gIHZhciBieXRlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZXMucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59XG5cbmV4cG9ydCB2YXIgRE5TID0gJzZiYTdiODEwLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgdmFyIFVSTCA9ICc2YmE3YjgxMS05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKG5hbWUsIHZlcnNpb24sIGhhc2hmdW5jKSB7XG4gIGZ1bmN0aW9uIGdlbmVyYXRlVVVJRCh2YWx1ZSwgbmFtZXNwYWNlLCBidWYsIG9mZnNldCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZXNwYWNlID0gcGFyc2UobmFtZXNwYWNlKTtcbiAgICB9XG5cbiAgICBpZiAobmFtZXNwYWNlLmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignTmFtZXNwYWNlIG11c3QgYmUgYXJyYXktbGlrZSAoMTYgaXRlcmFibGUgaW50ZWdlciB2YWx1ZXMsIDAtMjU1KScpO1xuICAgIH0gLy8gQ29tcHV0ZSBoYXNoIG9mIG5hbWVzcGFjZSBhbmQgdmFsdWUsIFBlciA0LjNcbiAgICAvLyBGdXR1cmU6IFVzZSBzcHJlYWQgc3ludGF4IHdoZW4gc3VwcG9ydGVkIG9uIGFsbCBwbGF0Zm9ybXMsIGUuZy4gYGJ5dGVzID1cbiAgICAvLyBoYXNoZnVuYyhbLi4ubmFtZXNwYWNlLCAuLi4gdmFsdWVdKWBcblxuXG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoMTYgKyB2YWx1ZS5sZW5ndGgpO1xuICAgIGJ5dGVzLnNldChuYW1lc3BhY2UpO1xuICAgIGJ5dGVzLnNldCh2YWx1ZSwgbmFtZXNwYWNlLmxlbmd0aCk7XG4gICAgYnl0ZXMgPSBoYXNoZnVuYyhieXRlcyk7XG4gICAgYnl0ZXNbNl0gPSBieXRlc1s2XSAmIDB4MGYgfCB2ZXJzaW9uO1xuICAgIGJ5dGVzWzhdID0gYnl0ZXNbOF0gJiAweDNmIHwgMHg4MDtcblxuICAgIGlmIChidWYpIHtcbiAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgICAgYnVmW29mZnNldCArIGldID0gYnl0ZXNbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ2lmeShieXRlcyk7XG4gIH0gLy8gRnVuY3Rpb24jbmFtZSBpcyBub3Qgc2V0dGFibGUgb24gc29tZSBwbGF0Zm9ybXMgKCMyNzApXG5cblxuICB0cnkge1xuICAgIGdlbmVyYXRlVVVJRC5uYW1lID0gbmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gIH0gY2F0Y2ggKGVycikge30gLy8gRm9yIENvbW1vbkpTIGRlZmF1bHQgZXhwb3J0IHN1cHBvcnRcblxuXG4gIGdlbmVyYXRlVVVJRC5ETlMgPSBETlM7XG4gIGdlbmVyYXRlVVVJRC5VUkwgPSBVUkw7XG4gIHJldHVybiBnZW5lcmF0ZVVVSUQ7XG59Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/v35.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(rnds);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ1k7O0FBRXZDO0FBQ0E7QUFDQSwrQ0FBK0MsK0NBQUcsS0FBSzs7QUFFdkQ7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUEsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVMseURBQVM7QUFDbEI7O0FBRUEsaUVBQWUsRUFBRSIsInNvdXJjZXMiOlsiQzpcXHNob3BfaGFyZGhhdFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcdXVpZFxcZGlzdFxcZXNtLWJyb3dzZXJcXHY0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgcm5kcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7IC8vIFBlciA0LjQsIHNldCBiaXRzIGZvciB2ZXJzaW9uIGFuZCBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGBcblxuICBybmRzWzZdID0gcm5kc1s2XSAmIDB4MGYgfCAweDQwO1xuICBybmRzWzhdID0gcm5kc1s4XSAmIDB4M2YgfCAweDgwOyAvLyBDb3B5IGJ5dGVzIHRvIGJ1ZmZlciwgaWYgcHJvdmlkZWRcblxuICBpZiAoYnVmKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHJuZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZjtcbiAgfVxuXG4gIHJldHVybiBzdHJpbmdpZnkocm5kcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHY0OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/v4.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/v5.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v5.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/sha1.js\");\n\n\nvar v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJCO0FBQ0U7QUFDN0IsU0FBUyxtREFBRyxhQUFhLGdEQUFJO0FBQzdCLGlFQUFlLEVBQUUiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHV1aWRcXGRpc3RcXGVzbS1icm93c2VyXFx2NS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBzaGExIGZyb20gJy4vc2hhMS5qcyc7XG52YXIgdjUgPSB2MzUoJ3Y1JywgMHg1MCwgc2hhMSk7XG5leHBvcnQgZGVmYXVsdCB2NTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/v5.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0I7O0FBRS9CO0FBQ0EscUNBQXFDLHNEQUFVO0FBQy9DOztBQUVBLGlFQUFlLFFBQVEiLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHV1aWRcXGRpc3RcXGVzbS1icm93c2VyXFx2YWxpZGF0ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUkVHRVggZnJvbSAnLi9yZWdleC5qcyc7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBSRUdFWC50ZXN0KHV1aWQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/validate.js\n"));

/***/ }),

/***/ "(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/version.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/version.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/validate.js\");\n\n\nfunction version(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (version);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHBhZ2VzLWRpci1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxQzs7QUFFckM7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlFQUFlLE9BQU8iLCJzb3VyY2VzIjpbIkM6XFxzaG9wX2hhcmRoYXRcXGZyb250ZW5kXFxub2RlX21vZHVsZXNcXHV1aWRcXGRpc3RcXGVzbS1icm93c2VyXFx2ZXJzaW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuZnVuY3Rpb24gdmVyc2lvbih1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlSW50KHV1aWQuc3Vic3RyKDE0LCAxKSwgMTYpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2ZXJzaW9uOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(pages-dir-browser)/./node_modules/uuid/dist/esm-browser/version.js\n"));

/***/ })

}]);